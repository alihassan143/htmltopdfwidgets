// Native PDF Engine - macOS WebKit bindings
// Generated by ffigen. Do not edit.
// ignore_for_file: type=lint

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: unused_import
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;

@ffi.Native<
  ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external bool _NativeLibrary_protocolTrampoline_e3qsqz(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_18v1jvf(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external void _NativeLibrary_protocolTrampoline_18v1jvf(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<
  instancetype Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external instancetype _NativeLibrary_protocolTrampoline_xr62hr(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_be1lg6(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_be1lg6(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCSelector>,
  )
>()
external void _NativeLibrary_protocolTrampoline_be1lg6(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCSelector> arg1,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCObjectImpl> Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
  )
>()
external ffi.Pointer<objc.ObjCObjectImpl>
_NativeLibrary_protocolTrampoline_1mbt9g9(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.UnsignedLong Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external int _NativeLibrary_protocolTrampoline_u1rw1h(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<
  ffi.Bool Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external bool _NativeLibrary_protocolTrampoline_3su7tt(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<
  objc.CGRect Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external objc.CGRect _NativeLibrary_protocolTrampoline_1c3uc0w(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_10lndml(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_10lndml(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Bool,
  )
>()
external void _NativeLibrary_protocolTrampoline_10lndml(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  bool arg1,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1e49sma(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1e49sma(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    objc.CGRect,
  )
>()
external void _NativeLibrary_protocolTrampoline_1e49sma(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGRect arg1,
);

@ffi.Native<
  objc.CGPoint Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external objc.CGPoint _NativeLibrary_protocolTrampoline_7ohnx8(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1bktu2(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1bktu2(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    objc.CGPoint,
  )
>()
external void _NativeLibrary_protocolTrampoline_1bktu2(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGPoint arg1,
);

@ffi.Native<
  ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external int _NativeLibrary_protocolTrampoline_ua0zt4(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_6qimxm(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_6qimxm(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Long,
  )
>()
external void _NativeLibrary_protocolTrampoline_6qimxm(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  int arg1,
);

@ffi.Native<
  ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external int _NativeLibrary_protocolTrampoline_1600k13(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_12prxo1(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_12prxo1(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Long,
  )
>()
external void _NativeLibrary_protocolTrampoline_12prxo1(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  int arg1,
);

@ffi.Native<
  objc.CGPoint Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    objc.CGPoint,
  )
>()
external objc.CGPoint _NativeLibrary_protocolTrampoline_loskaj(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGPoint arg1,
);

@ffi.Native<
  objc.CGSize Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    objc.CGSize,
  )
>()
external objc.CGSize _NativeLibrary_protocolTrampoline_zeon27(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGSize arg1,
);

@ffi.Native<
  ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external int _NativeLibrary_protocolTrampoline_fai2e9(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_unr2j3(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_unr2j3(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Long,
  )
>()
external void _NativeLibrary_protocolTrampoline_unr2j3(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  int arg1,
);

@ffi.Native<
  ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external int _NativeLibrary_protocolTrampoline_1sop3vw(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_w4u4pi(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_w4u4pi(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Long,
  )
>()
external void _NativeLibrary_protocolTrampoline_w4u4pi(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  int arg1,
);

@ffi.Native<
  ffi.Float Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external double _NativeLibrary_protocolTrampoline_66c10j(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1fcaigd(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1fcaigd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Float,
  )
>()
external void _NativeLibrary_protocolTrampoline_1fcaigd(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  double arg1,
);

@ffi.Native<
  ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external int _NativeLibrary_protocolTrampoline_1gh8zj5(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_141m1k3(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_141m1k3(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Long,
  )
>()
external void _NativeLibrary_protocolTrampoline_141m1k3(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  int arg1,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCObjectImpl> Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Long,
    ffi.Long,
  )
>()
external ffi.Pointer<objc.ObjCObjectImpl>
_NativeLibrary_protocolTrampoline_wrzr3t(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  int arg1,
  int arg2,
);

@ffi.Native<
  objc.NSRange Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external objc.NSRange _NativeLibrary_protocolTrampoline_1mh5vs9(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_xpqfd7(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_xpqfd7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    objc.NSRange,
  )
>()
external void _NativeLibrary_protocolTrampoline_xpqfd7(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.NSRange arg1,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCObjectImpl> Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    objc.NSRange,
  )
>()
external ffi.Pointer<objc.ObjCObjectImpl>
_NativeLibrary_protocolTrampoline_xzy3cf(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.NSRange arg1,
);

@ffi.Native<
  objc.NSRange Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Long,
  )
>()
external objc.NSRange _NativeLibrary_protocolTrampoline_8h6smj(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  int arg1,
);

@ffi.Native<
  objc.NSRange Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    objc.CGPoint,
  )
>()
external objc.NSRange _NativeLibrary_protocolTrampoline_1lg7chq(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGPoint arg1,
);

@ffi.Native<
  objc.CGRect Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    objc.NSRange,
  )
>()
external objc.CGRect _NativeLibrary_protocolTrampoline_ox7a80(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.NSRange arg1,
);

@ffi.Native<
  ffi.Long Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Long,
  )
>()
external int _NativeLibrary_protocolTrampoline_1p78ubn(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  int arg1,
);

@ffi.Native<
  ffi.Bool Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCSelector>,
  )
>()
external bool _NativeLibrary_protocolTrampoline_w1e3k0(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCSelector> arg1,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_108000h(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_108000h(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_bklti2(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_bklti2(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_pfv6jd(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
  )
>()
external void _NativeLibrary_protocolTrampoline_bklti2(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ffi.Pointer<objc.ObjCBlockImpl> arg3,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_d2nojr(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_d2nojr(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_xx612k(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_xx612k(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1pl9qdv(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1pl9qdv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
  )
>()
external void _NativeLibrary_protocolTrampoline_xx612k(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ffi.Pointer<objc.ObjCBlockImpl> arg4,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1a5qge(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1a5qge(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_fjrv01(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_fjrv01(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external void _NativeLibrary_protocolTrampoline_fjrv01(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1tz5yf(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1tz5yf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external void _NativeLibrary_protocolTrampoline_1tz5yf(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ffi.Pointer<objc.ObjCObjectImpl> arg3,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_n8yd09(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_n8yd09(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1s56lr9(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1s56lr9(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_axwdf6(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_axwdf6(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Bool,
    ffi.Pointer<objc.ObjCBlockImpl>,
  )
>()
external void _NativeLibrary_protocolTrampoline_axwdf6(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
  bool arg3,
  ffi.Pointer<objc.ObjCBlockImpl> arg4,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_19s8ne9(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_19s8ne9(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_xtuoz7(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCObjectImpl> Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.UnsignedLong,
    ffi.Pointer<objc.NSRange>,
    ffi.Pointer<ffi.Bool>,
  )
>()
external ffi.Pointer<objc.ObjCObjectImpl>
_NativeLibrary_protocolTrampoline_19qfjta(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  int arg1,
  ffi.Pointer<objc.NSRange> arg2,
  ffi.Pointer<ffi.Bool> arg3,
);

@ffi.Native<
  ffi.UnsignedLong Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
  )
>()
external int _NativeLibrary_protocolTrampoline_1ckyi24(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Bool Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external bool _NativeLibrary_protocolTrampoline_2n06mv(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1f6txb5(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1f6txb5(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    objc.NSRange,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external void _NativeLibrary_protocolTrampoline_1f6txb5(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.NSRange arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_ovsamd(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_ovsamd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external void _NativeLibrary_protocolTrampoline_ovsamd(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCObjectImpl> Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.UnsignedLong,
    ffi.Pointer<objc.NSRange>,
  )
>()
external ffi.Pointer<objc.ObjCObjectImpl>
_NativeLibrary_protocolTrampoline_vt1y0w(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  int arg1,
  ffi.Pointer<objc.NSRange> arg2,
);

final class CGAffineTransform extends ffi.Struct {
  @ffi.Double()
  external double a;

  @ffi.Double()
  external double b;

  @ffi.Double()
  external double c;

  @ffi.Double()
  external double d;

  @ffi.Double()
  external double tx;

  @ffi.Double()
  external double ty;
}

/// WARNING: NSProgressReporting is a stub. To generate bindings for this class, include
/// NSProgressReporting in your config's objc-protocols list.
///
/// NSProgressReporting
extension type NSProgressReporting._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [NSProgressReporting] that points to the same underlying object as [other].
  NSProgressReporting.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSProgressReporting] that wraps the given raw object pointer.
  NSProgressReporting.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

enum NSHTTPCookieAcceptPolicy {
  NSHTTPCookieAcceptPolicyAlways(0),
  NSHTTPCookieAcceptPolicyNever(1),
  NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain(2);

  final int value;
  const NSHTTPCookieAcceptPolicy(this.value);

  static NSHTTPCookieAcceptPolicy fromValue(int value) => switch (value) {
    0 => NSHTTPCookieAcceptPolicyAlways,
    1 => NSHTTPCookieAcceptPolicyNever,
    2 => NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain,
    _ => throw ArgumentError(
      'Unknown value for NSHTTPCookieAcceptPolicy: $value',
    ),
  };
}

final class __IOSurface extends ffi.Opaque {}

enum NSRectEdge {
  NSRectEdgeMinX(0),
  NSRectEdgeMinY(1),
  NSRectEdgeMaxX(2),
  NSRectEdgeMaxY(3);

  static const NSMinXEdge = NSRectEdgeMinX;
  static const NSMinYEdge = NSRectEdgeMinY;
  static const NSMaxXEdge = NSRectEdgeMaxX;
  static const NSMaxYEdge = NSRectEdgeMaxY;

  final int value;
  const NSRectEdge(this.value);

  static NSRectEdge fromValue(int value) => switch (value) {
    0 => NSRectEdgeMinX,
    1 => NSRectEdgeMinY,
    2 => NSRectEdgeMaxX,
    3 => NSRectEdgeMaxY,
    _ => throw ArgumentError('Unknown value for NSRectEdge: $value'),
  };

  @override
  String toString() {
    if (this == NSRectEdgeMinX)
      return "NSRectEdge.NSRectEdgeMinX, NSRectEdge.NSMinXEdge";
    if (this == NSRectEdgeMinY)
      return "NSRectEdge.NSRectEdgeMinY, NSRectEdge.NSMinYEdge";
    if (this == NSRectEdgeMaxX)
      return "NSRectEdge.NSRectEdgeMaxX, NSRectEdge.NSMaxXEdge";
    if (this == NSRectEdgeMaxY)
      return "NSRectEdge.NSRectEdgeMaxY, NSRectEdge.NSMaxYEdge";
    return super.toString();
  }
}

sealed class NSAlignmentOptions {
  static const NSAlignMinXInward = 1;
  static const NSAlignMinYInward = 2;
  static const NSAlignMaxXInward = 4;
  static const NSAlignMaxYInward = 8;
  static const NSAlignWidthInward = 16;
  static const NSAlignHeightInward = 32;
  static const NSAlignMinXOutward = 256;
  static const NSAlignMinYOutward = 512;
  static const NSAlignMaxXOutward = 1024;
  static const NSAlignMaxYOutward = 2048;
  static const NSAlignWidthOutward = 4096;
  static const NSAlignHeightOutward = 8192;
  static const NSAlignMinXNearest = 65536;
  static const NSAlignMinYNearest = 131072;
  static const NSAlignMaxXNearest = 262144;
  static const NSAlignMaxYNearest = 524288;
  static const NSAlignWidthNearest = 1048576;
  static const NSAlignHeightNearest = 2097152;
  static const NSAlignRectFlipped = -9223372036854775808;
  static const NSAlignAllEdgesInward = 15;
  static const NSAlignAllEdgesOutward = 3840;
  static const NSAlignAllEdgesNearest = 983040;
}

enum NSOperationQueuePriority {
  NSOperationQueuePriorityVeryLow(-8),
  NSOperationQueuePriorityLow(-4),
  NSOperationQueuePriorityNormal(0),
  NSOperationQueuePriorityHigh(4),
  NSOperationQueuePriorityVeryHigh(8);

  final int value;
  const NSOperationQueuePriority(this.value);

  static NSOperationQueuePriority fromValue(int value) => switch (value) {
    -8 => NSOperationQueuePriorityVeryLow,
    -4 => NSOperationQueuePriorityLow,
    0 => NSOperationQueuePriorityNormal,
    4 => NSOperationQueuePriorityHigh,
    8 => NSOperationQueuePriorityVeryHigh,
    _ => throw ArgumentError(
      'Unknown value for NSOperationQueuePriority: $value',
    ),
  };
}

/// WARNING: NSOperationQueue is a stub. To generate bindings for this class, include
/// NSOperationQueue in your config's objc-interfaces list.
///
/// NSOperationQueue
extension type NSOperationQueue._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, NSProgressReporting {
  /// Constructs a [NSOperationQueue] that points to the same underlying object as [other].
  NSOperationQueue.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSOperationQueue',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
  }

  /// Constructs a [NSOperationQueue] that wraps the given raw object pointer.
  NSOperationQueue.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSOperationQueue',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
  }
}

/// WARNING: NSURLAuthenticationChallenge is a stub. To generate bindings for this class, include
/// NSURLAuthenticationChallenge in your config's objc-interfaces list.
///
/// NSURLAuthenticationChallenge
extension type NSURLAuthenticationChallenge._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSSecureCoding {
  /// Constructs a [NSURLAuthenticationChallenge] that points to the same underlying object as [other].
  NSURLAuthenticationChallenge.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSURLAuthenticationChallenge',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
  }

  /// Constructs a [NSURLAuthenticationChallenge] that wraps the given raw object pointer.
  NSURLAuthenticationChallenge.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSURLAuthenticationChallenge',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
  }
}

enum NSURLCacheStoragePolicy {
  NSURLCacheStorageAllowed(0),
  NSURLCacheStorageAllowedInMemoryOnly(1),
  NSURLCacheStorageNotAllowed(2);

  final int value;
  const NSURLCacheStoragePolicy(this.value);

  static NSURLCacheStoragePolicy fromValue(int value) => switch (value) {
    0 => NSURLCacheStorageAllowed,
    1 => NSURLCacheStorageAllowedInMemoryOnly,
    2 => NSURLCacheStorageNotAllowed,
    _ => throw ArgumentError(
      'Unknown value for NSURLCacheStoragePolicy: $value',
    ),
  };
}

final class __SecIdentity extends ffi.Opaque {}

final class __SecTrust extends ffi.Opaque {}

enum tls_protocol_version_t {
  tls_protocol_version_TLSv10(769),
  tls_protocol_version_TLSv11(770),
  tls_protocol_version_TLSv12(771),
  tls_protocol_version_TLSv13(772),
  tls_protocol_version_DTLSv10(-257),
  tls_protocol_version_DTLSv12(-259);

  final int value;
  const tls_protocol_version_t(this.value);

  static tls_protocol_version_t fromValue(int value) => switch (value) {
    769 => tls_protocol_version_TLSv10,
    770 => tls_protocol_version_TLSv11,
    771 => tls_protocol_version_TLSv12,
    772 => tls_protocol_version_TLSv13,
    -257 => tls_protocol_version_DTLSv10,
    -259 => tls_protocol_version_DTLSv12,
    _ => throw ArgumentError(
      'Unknown value for tls_protocol_version_t: $value',
    ),
  };
}

enum SSLProtocol {
  kSSLProtocolUnknown(0),
  kTLSProtocol1(4),
  kTLSProtocol11(7),
  kTLSProtocol12(8),
  kDTLSProtocol1(9),
  kTLSProtocol13(10),
  kDTLSProtocol12(11),
  kTLSProtocolMaxSupported(999),
  kSSLProtocol2(1),
  kSSLProtocol3(2),
  kSSLProtocol3Only(3),
  kTLSProtocol1Only(5),
  kSSLProtocolAll(6);

  final int value;
  const SSLProtocol(this.value);

  static SSLProtocol fromValue(int value) => switch (value) {
    0 => kSSLProtocolUnknown,
    4 => kTLSProtocol1,
    7 => kTLSProtocol11,
    8 => kTLSProtocol12,
    9 => kDTLSProtocol1,
    10 => kTLSProtocol13,
    11 => kDTLSProtocol12,
    999 => kTLSProtocolMaxSupported,
    1 => kSSLProtocol2,
    2 => kSSLProtocol3,
    3 => kSSLProtocol3Only,
    5 => kTLSProtocol1Only,
    6 => kSSLProtocolAll,
    _ => throw ArgumentError('Unknown value for SSLProtocol: $value'),
  };
}

enum NSURLCredentialPersistence {
  NSURLCredentialPersistenceNone(0),
  NSURLCredentialPersistenceForSession(1),
  NSURLCredentialPersistencePermanent(2),
  NSURLCredentialPersistenceSynchronizable(3);

  final int value;
  const NSURLCredentialPersistence(this.value);

  static NSURLCredentialPersistence fromValue(int value) => switch (value) {
    0 => NSURLCredentialPersistenceNone,
    1 => NSURLCredentialPersistenceForSession,
    2 => NSURLCredentialPersistencePermanent,
    3 => NSURLCredentialPersistenceSynchronizable,
    _ => throw ArgumentError(
      'Unknown value for NSURLCredentialPersistence: $value',
    ),
  };
}

/// WARNING: NSURLCredential is a stub. To generate bindings for this class, include
/// NSURLCredential in your config's objc-interfaces list.
///
/// NSURLCredential
extension type NSURLCredential._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSSecureCoding,
        objc.NSCopying {
  /// Constructs a [NSURLCredential] that points to the same underlying object as [other].
  NSURLCredential.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSURLCredential',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
  }

  /// Constructs a [NSURLCredential] that wraps the given raw object pointer.
  NSURLCredential.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSURLCredential',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
  }
}

final class OpaqueIconRef extends ffi.Opaque {}

enum NSURLRequestCachePolicy {
  NSURLRequestUseProtocolCachePolicy(0),
  NSURLRequestReloadIgnoringLocalCacheData(1),
  NSURLRequestReloadIgnoringLocalAndRemoteCacheData(4),
  NSURLRequestReturnCacheDataElseLoad(2),
  NSURLRequestReturnCacheDataDontLoad(3),
  NSURLRequestReloadRevalidatingCacheData(5);

  static const NSURLRequestReloadIgnoringCacheData =
      NSURLRequestReloadIgnoringLocalCacheData;

  final int value;
  const NSURLRequestCachePolicy(this.value);

  static NSURLRequestCachePolicy fromValue(int value) => switch (value) {
    0 => NSURLRequestUseProtocolCachePolicy,
    1 => NSURLRequestReloadIgnoringLocalCacheData,
    4 => NSURLRequestReloadIgnoringLocalAndRemoteCacheData,
    2 => NSURLRequestReturnCacheDataElseLoad,
    3 => NSURLRequestReturnCacheDataDontLoad,
    5 => NSURLRequestReloadRevalidatingCacheData,
    _ => throw ArgumentError(
      'Unknown value for NSURLRequestCachePolicy: $value',
    ),
  };

  @override
  String toString() {
    if (this == NSURLRequestReloadIgnoringLocalCacheData)
      return "NSURLRequestCachePolicy.NSURLRequestReloadIgnoringLocalCacheData, NSURLRequestCachePolicy.NSURLRequestReloadIgnoringCacheData";
    return super.toString();
  }
}

enum NSURLRequestNetworkServiceType {
  NSURLNetworkServiceTypeDefault(0),
  NSURLNetworkServiceTypeVoIP(1),
  NSURLNetworkServiceTypeVideo(2),
  NSURLNetworkServiceTypeBackground(3),
  NSURLNetworkServiceTypeVoice(4),
  NSURLNetworkServiceTypeResponsiveData(6),
  NSURLNetworkServiceTypeAVStreaming(8),
  NSURLNetworkServiceTypeResponsiveAV(9),
  NSURLNetworkServiceTypeCallSignaling(11);

  final int value;
  const NSURLRequestNetworkServiceType(this.value);

  static NSURLRequestNetworkServiceType fromValue(int value) => switch (value) {
    0 => NSURLNetworkServiceTypeDefault,
    1 => NSURLNetworkServiceTypeVoIP,
    2 => NSURLNetworkServiceTypeVideo,
    3 => NSURLNetworkServiceTypeBackground,
    4 => NSURLNetworkServiceTypeVoice,
    6 => NSURLNetworkServiceTypeResponsiveData,
    8 => NSURLNetworkServiceTypeAVStreaming,
    9 => NSURLNetworkServiceTypeResponsiveAV,
    11 => NSURLNetworkServiceTypeCallSignaling,
    _ => throw ArgumentError(
      'Unknown value for NSURLRequestNetworkServiceType: $value',
    ),
  };
}

enum NSURLRequestAttribution {
  NSURLRequestAttributionDeveloper(0),
  NSURLRequestAttributionUser(1);

  final int value;
  const NSURLRequestAttribution(this.value);

  static NSURLRequestAttribution fromValue(int value) => switch (value) {
    0 => NSURLRequestAttributionDeveloper,
    1 => NSURLRequestAttributionUser,
    _ => throw ArgumentError(
      'Unknown value for NSURLRequestAttribution: $value',
    ),
  };
}

late final _class_NSURLRequest = objc.getClass("NSURLRequest");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
typedef instancetype = ffi.Pointer<objc.ObjCObjectImpl>;
typedef Dartinstancetype = objc.ObjCObject;
late final _sel_requestWithURL_ = objc.registerName("requestWithURL:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_supportsSecureCoding = objc.registerName(
  "supportsSecureCoding",
);
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_bool_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunction(
    bool Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<bool Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_bool_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> {
  bool call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
      >()(ref.pointer, arg0);
}

late final _sel_requestWithURL_cachePolicy_timeoutInterval_ = objc.registerName(
  "requestWithURL:cachePolicy:timeoutInterval:",
);
final _objc_msgSend_1ajs603 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.UnsignedLong,
          ffi.Double,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        double,
      )
    >();
late final _sel_initWithURL_ = objc.registerName("initWithURL:");
late final _sel_initWithURL_cachePolicy_timeoutInterval_ = objc.registerName(
  "initWithURL:cachePolicy:timeoutInterval:",
);
late final _sel_URL = objc.registerName("URL");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_cachePolicy = objc.registerName("cachePolicy");
final _objc_msgSend_8jm3uo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_timeoutInterval = objc.registerName("timeoutInterval");
final _objc_msgSend_1ukqyt8 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1ukqyt8Fpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_mainDocumentURL = objc.registerName("mainDocumentURL");
late final _sel_networkServiceType = objc.registerName("networkServiceType");
final _objc_msgSend_t4uaw1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_allowsCellularAccess = objc.registerName(
  "allowsCellularAccess",
);
late final _sel_allowsExpensiveNetworkAccess = objc.registerName(
  "allowsExpensiveNetworkAccess",
);
late final _sel_allowsConstrainedNetworkAccess = objc.registerName(
  "allowsConstrainedNetworkAccess",
);
late final _sel_allowsUltraConstrainedNetworkAccess = objc.registerName(
  "allowsUltraConstrainedNetworkAccess",
);
late final _sel_assumesHTTP3Capable = objc.registerName("assumesHTTP3Capable");
late final _sel_attribution = objc.registerName("attribution");
final _objc_msgSend_i3avs9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_requiresDNSSECValidation = objc.registerName(
  "requiresDNSSECValidation",
);
late final _sel_allowsPersistentDNS = objc.registerName("allowsPersistentDNS");
late final _sel_cookiePartitionIdentifier = objc.registerName(
  "cookiePartitionIdentifier",
);
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.NSZone>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.NSZone>,
      )
    >();
late final _sel_alloc = objc.registerName("alloc");
late final _sel_encodeWithCoder_ = objc.registerName("encodeWithCoder:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, objc.NSCoder.fromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSCoder.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSCoder.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSCoder.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSCoder$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_initWithCoder_ = objc.registerName("initWithCoder:");

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
      ffi.Pointer<ffi.Void>,
      objc.NSCoder,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSCoder,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
      ffi.Pointer<ffi.Void>,
      objc.NSCoder,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSCoder,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
      ffi.Pointer<ffi.Void>,
      objc.NSCoder,
    )
  >
  fromFunction(
    Dartinstancetype? Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSCoder,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                objc.NSCoder.fromPointer(arg1, retain: true, release: true),
              )?.ref.retainAndReturnPointer() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static instancetype _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          instancetype Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static instancetype _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as instancetype Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_instancetype_ffiVoid_NSCoder$CallExtension
    on
        objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
            ffi.Pointer<ffi.Void>,
            objc.NSCoder,
          )
        > {
  Dartinstancetype? call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer)
              .address ==
          0
      ? null
      : objc.ObjCObject(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer),
          retain: false,
          release: true,
        );
}

late final _sel_HTTPMethod = objc.registerName("HTTPMethod");
late final _sel_allHTTPHeaderFields = objc.registerName("allHTTPHeaderFields");
late final _sel_valueForHTTPHeaderField_ = objc.registerName(
  "valueForHTTPHeaderField:",
);
late final _sel_HTTPBody = objc.registerName("HTTPBody");
late final _sel_HTTPBodyStream = objc.registerName("HTTPBodyStream");
late final _sel_HTTPShouldHandleCookies = objc.registerName(
  "HTTPShouldHandleCookies",
);
late final _sel_HTTPShouldUsePipelining = objc.registerName(
  "HTTPShouldUsePipelining",
);

/// NSHTTPURLRequest
extension NSHTTPURLRequest on NSURLRequest {
  /// HTTPBody
  objc.NSData? get HTTPBody {
    objc.checkOsVersionInternal(
      'NSURLRequest.HTTPBody',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_HTTPBody);
    return $ret.address == 0
        ? null
        : objc.NSData.fromPointer($ret, retain: true, release: true);
  }

  /// HTTPBodyStream
  objc.NSInputStream? get HTTPBodyStream {
    objc.checkOsVersionInternal(
      'NSURLRequest.HTTPBodyStream',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_HTTPBodyStream,
    );
    return $ret.address == 0
        ? null
        : objc.NSInputStream.fromPointer($ret, retain: true, release: true);
  }

  /// HTTPMethod
  objc.NSString? get HTTPMethod {
    objc.checkOsVersionInternal(
      'NSURLRequest.HTTPMethod',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_HTTPMethod);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// HTTPShouldHandleCookies
  bool get HTTPShouldHandleCookies {
    objc.checkOsVersionInternal(
      'NSURLRequest.HTTPShouldHandleCookies',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_HTTPShouldHandleCookies,
    );
  }

  /// HTTPShouldUsePipelining
  bool get HTTPShouldUsePipelining {
    objc.checkOsVersionInternal(
      'NSURLRequest.HTTPShouldUsePipelining',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_HTTPShouldUsePipelining,
    );
  }

  /// allHTTPHeaderFields
  objc.NSDictionary? get allHTTPHeaderFields {
    objc.checkOsVersionInternal(
      'NSURLRequest.allHTTPHeaderFields',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_allHTTPHeaderFields,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// valueForHTTPHeaderField:
  objc.NSString? valueForHTTPHeaderField(objc.NSString field) {
    objc.checkOsVersionInternal(
      'NSURLRequest.valueForHTTPHeaderField:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_valueForHTTPHeaderField_,
      field.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }
}

/// NSURLRequest
extension type NSURLRequest._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSSecureCoding,
        objc.NSCopying,
        objc.NSMutableCopying {
  /// Constructs a [NSURLRequest] that points to the same underlying object as [other].
  NSURLRequest.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSURLRequest',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [NSURLRequest] that wraps the given raw object pointer.
  NSURLRequest.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSURLRequest',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NSURLRequest].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NSURLRequest,
  );

  /// alloc
  static NSURLRequest alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSURLRequest, _sel_alloc);
    return NSURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSURLRequest allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSURLRequest,
      _sel_allocWithZone_,
      zone,
    );
    return NSURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSURLRequest new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSURLRequest, _sel_new);
    return NSURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// requestWithURL:
  static NSURLRequest requestWithURL(objc.NSURL URL) {
    objc.checkOsVersionInternal(
      'NSURLRequest.requestWithURL:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSURLRequest,
      _sel_requestWithURL_,
      URL.ref.pointer,
    );
    return NSURLRequest.fromPointer($ret, retain: true, release: true);
  }

  /// requestWithURL:cachePolicy:timeoutInterval:
  static NSURLRequest requestWithURL$1(
    objc.NSURL URL, {
    required NSURLRequestCachePolicy cachePolicy,
    required double timeoutInterval,
  }) {
    objc.checkOsVersionInternal(
      'NSURLRequest.requestWithURL:cachePolicy:timeoutInterval:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_1ajs603(
      _class_NSURLRequest,
      _sel_requestWithURL_cachePolicy_timeoutInterval_,
      URL.ref.pointer,
      cachePolicy.value,
      timeoutInterval,
    );
    return NSURLRequest.fromPointer($ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSURLRequest, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of NSURLRequest constructed with the default `new` method.
  NSURLRequest() : this.as(new$().object$);
}

extension NSURLRequest$Methods on NSURLRequest {
  /// URL
  objc.NSURL? get URL {
    objc.checkOsVersionInternal(
      'NSURLRequest.URL',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_URL);
    return $ret.address == 0
        ? null
        : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }

  /// allowsCellularAccess
  bool get allowsCellularAccess {
    objc.checkOsVersionInternal(
      'NSURLRequest.allowsCellularAccess',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 8, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_allowsCellularAccess);
  }

  /// allowsConstrainedNetworkAccess
  bool get allowsConstrainedNetworkAccess {
    objc.checkOsVersionInternal(
      'NSURLRequest.allowsConstrainedNetworkAccess',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowsConstrainedNetworkAccess,
    );
  }

  /// allowsExpensiveNetworkAccess
  bool get allowsExpensiveNetworkAccess {
    objc.checkOsVersionInternal(
      'NSURLRequest.allowsExpensiveNetworkAccess',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowsExpensiveNetworkAccess,
    );
  }

  /// allowsPersistentDNS
  bool get allowsPersistentDNS {
    objc.checkOsVersionInternal(
      'NSURLRequest.allowsPersistentDNS',
      iOS: (false, (18, 0, 0)),
      macOS: (false, (15, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_allowsPersistentDNS);
  }

  /// allowsUltraConstrainedNetworkAccess
  bool get allowsUltraConstrainedNetworkAccess {
    objc.checkOsVersionInternal(
      'NSURLRequest.allowsUltraConstrainedNetworkAccess',
      iOS: (false, (26, 1, 0)),
      macOS: (false, (26, 1, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowsUltraConstrainedNetworkAccess,
    );
  }

  /// assumesHTTP3Capable
  bool get assumesHTTP3Capable {
    objc.checkOsVersionInternal(
      'NSURLRequest.assumesHTTP3Capable',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_assumesHTTP3Capable);
  }

  /// attribution
  NSURLRequestAttribution get attribution {
    objc.checkOsVersionInternal(
      'NSURLRequest.attribution',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_i3avs9(object$.ref.pointer, _sel_attribution);
    return NSURLRequestAttribution.fromValue($ret);
  }

  /// cachePolicy
  NSURLRequestCachePolicy get cachePolicy {
    objc.checkOsVersionInternal(
      'NSURLRequest.cachePolicy',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_8jm3uo(object$.ref.pointer, _sel_cachePolicy);
    return NSURLRequestCachePolicy.fromValue($ret);
  }

  /// cookiePartitionIdentifier
  objc.NSString? get cookiePartitionIdentifier {
    objc.checkOsVersionInternal(
      'NSURLRequest.cookiePartitionIdentifier',
      iOS: (false, (18, 2, 0)),
      macOS: (false, (15, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_cookiePartitionIdentifier,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// init
  NSURLRequest init() {
    objc.checkOsVersionInternal(
      'NSURLRequest.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSURLRequest? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// initWithURL:
  NSURLRequest initWithURL(objc.NSURL URL) {
    objc.checkOsVersionInternal(
      'NSURLRequest.initWithURL:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithURL_,
      URL.ref.pointer,
    );
    return NSURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// initWithURL:cachePolicy:timeoutInterval:
  NSURLRequest initWithURL$1(
    objc.NSURL URL, {
    required NSURLRequestCachePolicy cachePolicy,
    required double timeoutInterval,
  }) {
    objc.checkOsVersionInternal(
      'NSURLRequest.initWithURL:cachePolicy:timeoutInterval:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_1ajs603(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithURL_cachePolicy_timeoutInterval_,
      URL.ref.pointer,
      cachePolicy.value,
      timeoutInterval,
    );
    return NSURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// mainDocumentURL
  objc.NSURL? get mainDocumentURL {
    objc.checkOsVersionInternal(
      'NSURLRequest.mainDocumentURL',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_mainDocumentURL,
    );
    return $ret.address == 0
        ? null
        : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }

  /// networkServiceType
  NSURLRequestNetworkServiceType get networkServiceType {
    objc.checkOsVersionInternal(
      'NSURLRequest.networkServiceType',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_t4uaw1(
      object$.ref.pointer,
      _sel_networkServiceType,
    );
    return NSURLRequestNetworkServiceType.fromValue($ret);
  }

  /// requiresDNSSECValidation
  bool get requiresDNSSECValidation {
    objc.checkOsVersionInternal(
      'NSURLRequest.requiresDNSSECValidation',
      iOS: (false, (16, 1, 0)),
      macOS: (false, (13, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_requiresDNSSECValidation,
    );
  }

  /// timeoutInterval
  double get timeoutInterval {
    objc.checkOsVersionInternal(
      'NSURLRequest.timeoutInterval',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_timeoutInterval)
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_timeoutInterval);
  }
}

/// WARNING: NSURLResponse is a stub. To generate bindings for this class, include
/// NSURLResponse in your config's objc-interfaces list.
///
/// NSURLResponse
extension type NSURLResponse._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSSecureCoding,
        objc.NSCopying {
  /// Constructs a [NSURLResponse] that points to the same underlying object as [other].
  NSURLResponse.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSURLResponse',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
  }

  /// Constructs a [NSURLResponse] that wraps the given raw object pointer.
  NSURLResponse.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSURLResponse',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
  }
}

sealed class NSFileWrapperReadingOptions {
  static const NSFileWrapperReadingImmediate = 1;
  static const NSFileWrapperReadingWithoutMapping = 2;
}

sealed class NSFileWrapperWritingOptions {
  static const NSFileWrapperWritingAtomic = 1;
  static const NSFileWrapperWritingWithNameUpdating = 2;
}

sealed class NSNetServiceOptions {
  static const NSNetServiceNoAutoRename = 1;
  static const NSNetServiceListenForConnections = 2;
}

/// WARNING: NSUndoManager is a stub. To generate bindings for this class, include
/// NSUndoManager in your config's objc-interfaces list.
///
/// NSUndoManager
extension type NSUndoManager._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSUndoManager] that points to the same underlying object as [other].
  NSUndoManager.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSUndoManager',
      iOS: (false, (3, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
  }

  /// Constructs a [NSUndoManager] that wraps the given raw object pointer.
  NSUndoManager.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSUndoManager',
      iOS: (false, (3, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
  }
}

enum NSURLSessionTaskState {
  NSURLSessionTaskStateRunning(0),
  NSURLSessionTaskStateSuspended(1),
  NSURLSessionTaskStateCanceling(2),
  NSURLSessionTaskStateCompleted(3);

  final int value;
  const NSURLSessionTaskState(this.value);

  static NSURLSessionTaskState fromValue(int value) => switch (value) {
    0 => NSURLSessionTaskStateRunning,
    1 => NSURLSessionTaskStateSuspended,
    2 => NSURLSessionTaskStateCanceling,
    3 => NSURLSessionTaskStateCompleted,
    _ => throw ArgumentError('Unknown value for NSURLSessionTaskState: $value'),
  };
}

enum NSURLSessionWebSocketMessageType {
  NSURLSessionWebSocketMessageTypeData(0),
  NSURLSessionWebSocketMessageTypeString(1);

  final int value;
  const NSURLSessionWebSocketMessageType(this.value);

  static NSURLSessionWebSocketMessageType fromValue(int value) =>
      switch (value) {
        0 => NSURLSessionWebSocketMessageTypeData,
        1 => NSURLSessionWebSocketMessageTypeString,
        _ => throw ArgumentError(
          'Unknown value for NSURLSessionWebSocketMessageType: $value',
        ),
      };
}

enum NSURLSessionWebSocketCloseCode {
  NSURLSessionWebSocketCloseCodeInvalid(0),
  NSURLSessionWebSocketCloseCodeNormalClosure(1000),
  NSURLSessionWebSocketCloseCodeGoingAway(1001),
  NSURLSessionWebSocketCloseCodeProtocolError(1002),
  NSURLSessionWebSocketCloseCodeUnsupportedData(1003),
  NSURLSessionWebSocketCloseCodeNoStatusReceived(1005),
  NSURLSessionWebSocketCloseCodeAbnormalClosure(1006),
  NSURLSessionWebSocketCloseCodeInvalidFramePayloadData(1007),
  NSURLSessionWebSocketCloseCodePolicyViolation(1008),
  NSURLSessionWebSocketCloseCodeMessageTooBig(1009),
  NSURLSessionWebSocketCloseCodeMandatoryExtensionMissing(1010),
  NSURLSessionWebSocketCloseCodeInternalServerError(1011),
  NSURLSessionWebSocketCloseCodeTLSHandshakeFailure(1015);

  final int value;
  const NSURLSessionWebSocketCloseCode(this.value);

  static NSURLSessionWebSocketCloseCode fromValue(int value) => switch (value) {
    0 => NSURLSessionWebSocketCloseCodeInvalid,
    1000 => NSURLSessionWebSocketCloseCodeNormalClosure,
    1001 => NSURLSessionWebSocketCloseCodeGoingAway,
    1002 => NSURLSessionWebSocketCloseCodeProtocolError,
    1003 => NSURLSessionWebSocketCloseCodeUnsupportedData,
    1005 => NSURLSessionWebSocketCloseCodeNoStatusReceived,
    1006 => NSURLSessionWebSocketCloseCodeAbnormalClosure,
    1007 => NSURLSessionWebSocketCloseCodeInvalidFramePayloadData,
    1008 => NSURLSessionWebSocketCloseCodePolicyViolation,
    1009 => NSURLSessionWebSocketCloseCodeMessageTooBig,
    1010 => NSURLSessionWebSocketCloseCodeMandatoryExtensionMissing,
    1011 => NSURLSessionWebSocketCloseCodeInternalServerError,
    1015 => NSURLSessionWebSocketCloseCodeTLSHandshakeFailure,
    _ => throw ArgumentError(
      'Unknown value for NSURLSessionWebSocketCloseCode: $value',
    ),
  };
}

enum NSURLSessionMultipathServiceType {
  NSURLSessionMultipathServiceTypeNone(0),
  NSURLSessionMultipathServiceTypeHandover(1),
  NSURLSessionMultipathServiceTypeInteractive(2),
  NSURLSessionMultipathServiceTypeAggregate(3);

  final int value;
  const NSURLSessionMultipathServiceType(this.value);

  static NSURLSessionMultipathServiceType fromValue(int value) =>
      switch (value) {
        0 => NSURLSessionMultipathServiceTypeNone,
        1 => NSURLSessionMultipathServiceTypeHandover,
        2 => NSURLSessionMultipathServiceTypeInteractive,
        3 => NSURLSessionMultipathServiceTypeAggregate,
        _ => throw ArgumentError(
          'Unknown value for NSURLSessionMultipathServiceType: $value',
        ),
      };
}

enum NSURLSessionDelayedRequestDisposition {
  NSURLSessionDelayedRequestContinueLoading(0),
  NSURLSessionDelayedRequestUseNewRequest(1),
  NSURLSessionDelayedRequestCancel(2);

  final int value;
  const NSURLSessionDelayedRequestDisposition(this.value);

  static NSURLSessionDelayedRequestDisposition fromValue(int value) =>
      switch (value) {
        0 => NSURLSessionDelayedRequestContinueLoading,
        1 => NSURLSessionDelayedRequestUseNewRequest,
        2 => NSURLSessionDelayedRequestCancel,
        _ => throw ArgumentError(
          'Unknown value for NSURLSessionDelayedRequestDisposition: $value',
        ),
      };
}

enum NSURLSessionAuthChallengeDisposition {
  NSURLSessionAuthChallengeUseCredential(0),
  NSURLSessionAuthChallengePerformDefaultHandling(1),
  NSURLSessionAuthChallengeCancelAuthenticationChallenge(2),
  NSURLSessionAuthChallengeRejectProtectionSpace(3);

  final int value;
  const NSURLSessionAuthChallengeDisposition(this.value);

  static NSURLSessionAuthChallengeDisposition fromValue(int value) =>
      switch (value) {
        0 => NSURLSessionAuthChallengeUseCredential,
        1 => NSURLSessionAuthChallengePerformDefaultHandling,
        2 => NSURLSessionAuthChallengeCancelAuthenticationChallenge,
        3 => NSURLSessionAuthChallengeRejectProtectionSpace,
        _ => throw ArgumentError(
          'Unknown value for NSURLSessionAuthChallengeDisposition: $value',
        ),
      };
}

/// WARNING: NSUserActivity$1 is a stub. To generate bindings for this class, include
/// NSUserActivity in your config's objc-interfaces list.
///
/// NSUserActivity
extension type NSUserActivity$1._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSUserActivity$1] that points to the same underlying object as [other].
  NSUserActivity$1.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSUserActivity',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }

  /// Constructs a [NSUserActivity$1] that wraps the given raw object pointer.
  NSUserActivity$1.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSUserActivity',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }
}

final class NSAffineTransformStruct extends ffi.Struct {
  @ffi.Double()
  external double m11;

  @ffi.Double()
  external double m12;

  @ffi.Double()
  external double m21;

  @ffi.Double()
  external double m22;

  @ffi.Double()
  external double tX;

  @ffi.Double()
  external double tY;
}

enum NSSaveOptions {
  NSSaveOptionsYes(0),
  NSSaveOptionsNo(1),
  NSSaveOptionsAsk(2);

  final int value;
  const NSSaveOptions(this.value);

  static NSSaveOptions fromValue(int value) => switch (value) {
    0 => NSSaveOptionsYes,
    1 => NSSaveOptionsNo,
    2 => NSSaveOptionsAsk,
    _ => throw ArgumentError('Unknown value for NSSaveOptions: $value'),
  };
}

sealed class NSUnderlineStyle {
  static const NSUnderlineStyleNone = 0;
  static const NSUnderlineStyleSingle = 1;
  static const NSUnderlineStyleThick = 2;
  static const NSUnderlineStyleDouble = 9;
  static const NSUnderlineStylePatternSolid = 0;
  static const NSUnderlineStylePatternDot = 256;
  static const NSUnderlineStylePatternDash = 512;
  static const NSUnderlineStylePatternDashDot = 768;
  static const NSUnderlineStylePatternDashDotDot = 1024;
  static const NSUnderlineStyleByWord = 32768;
}

/// WARNING: NSUserInterfaceItemIdentification is a stub. To generate bindings for this class, include
/// NSUserInterfaceItemIdentification in your config's objc-protocols list.
///
/// NSUserInterfaceItemIdentification
extension type NSUserInterfaceItemIdentification._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol {
  /// Constructs a [NSUserInterfaceItemIdentification] that points to the same underlying object as [other].
  NSUserInterfaceItemIdentification.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSUserInterfaceItemIdentification] that wraps the given raw object pointer.
  NSUserInterfaceItemIdentification.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// WARNING: NSValidatedUserInterfaceItem is a stub. To generate bindings for this class, include
/// NSValidatedUserInterfaceItem in your config's objc-protocols list.
///
/// NSValidatedUserInterfaceItem
extension type NSValidatedUserInterfaceItem._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol {
  /// Constructs a [NSValidatedUserInterfaceItem] that points to the same underlying object as [other].
  NSValidatedUserInterfaceItem.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSValidatedUserInterfaceItem] that wraps the given raw object pointer.
  NSValidatedUserInterfaceItem.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// WARNING: NSUserInterfaceValidations is a stub. To generate bindings for this class, include
/// NSUserInterfaceValidations in your config's objc-protocols list.
///
/// NSUserInterfaceValidations
extension type NSUserInterfaceValidations._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol {
  /// Constructs a [NSUserInterfaceValidations] that points to the same underlying object as [other].
  NSUserInterfaceValidations.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSUserInterfaceValidations] that wraps the given raw object pointer.
  NSUserInterfaceValidations.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

enum NSAnimationCurve {
  NSAnimationEaseInOut(0),
  NSAnimationEaseIn(1),
  NSAnimationEaseOut(2),
  NSAnimationLinear(3);

  final int value;
  const NSAnimationCurve(this.value);

  static NSAnimationCurve fromValue(int value) => switch (value) {
    0 => NSAnimationEaseInOut,
    1 => NSAnimationEaseIn,
    2 => NSAnimationEaseOut,
    3 => NSAnimationLinear,
    _ => throw ArgumentError('Unknown value for NSAnimationCurve: $value'),
  };
}

enum NSAnimationBlockingMode {
  NSAnimationBlocking(0),
  NSAnimationNonblocking(1),
  NSAnimationNonblockingThreaded(2);

  final int value;
  const NSAnimationBlockingMode(this.value);

  static NSAnimationBlockingMode fromValue(int value) => switch (value) {
    0 => NSAnimationBlocking,
    1 => NSAnimationNonblocking,
    2 => NSAnimationNonblockingThreaded,
    _ => throw ArgumentError(
      'Unknown value for NSAnimationBlockingMode: $value',
    ),
  };
}

/// WARNING: NSAnimatablePropertyContainer is a stub. To generate bindings for this class, include
/// NSAnimatablePropertyContainer in your config's objc-protocols list.
///
/// NSAnimatablePropertyContainer
extension type NSAnimatablePropertyContainer._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol {
  /// Constructs a [NSAnimatablePropertyContainer] that points to the same underlying object as [other].
  NSAnimatablePropertyContainer.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSAnimatablePropertyContainer] that wraps the given raw object pointer.
  NSAnimatablePropertyContainer.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// WARNING: NSAppearance is a stub. To generate bindings for this class, include
/// NSAppearance in your config's objc-interfaces list.
///
/// NSAppearance
extension type NSAppearance._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSSecureCoding {
  /// Constructs a [NSAppearance] that points to the same underlying object as [other].
  NSAppearance.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSAppearance',
      iOS: (true, null),
      macOS: (false, (10, 9, 0)),
    );
  }

  /// Constructs a [NSAppearance] that wraps the given raw object pointer.
  NSAppearance.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSAppearance',
      iOS: (true, null),
      macOS: (false, (10, 9, 0)),
    );
  }
}

/// WARNING: NSAppearanceCustomization is a stub. To generate bindings for this class, include
/// NSAppearanceCustomization in your config's objc-protocols list.
///
/// NSAppearanceCustomization
extension type NSAppearanceCustomization._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [NSAppearanceCustomization] that points to the same underlying object as [other].
  NSAppearanceCustomization.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSAppearanceCustomization] that wraps the given raw object pointer.
  NSAppearanceCustomization.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

enum NSPasteboardAccessBehavior {
  NSPasteboardAccessBehaviorDefault(0),
  NSPasteboardAccessBehaviorAsk(1),
  NSPasteboardAccessBehaviorAlwaysAllow(2),
  NSPasteboardAccessBehaviorAlwaysDeny(3);

  final int value;
  const NSPasteboardAccessBehavior(this.value);

  static NSPasteboardAccessBehavior fromValue(int value) => switch (value) {
    0 => NSPasteboardAccessBehaviorDefault,
    1 => NSPasteboardAccessBehaviorAsk,
    2 => NSPasteboardAccessBehaviorAlwaysAllow,
    3 => NSPasteboardAccessBehaviorAlwaysDeny,
    _ => throw ArgumentError(
      'Unknown value for NSPasteboardAccessBehavior: $value',
    ),
  };
}

sealed class NSPasteboardContentsOptions {
  static const NSPasteboardContentsCurrentHostOnly = 1;
}

/// WARNING: NSPasteboard is a stub. To generate bindings for this class, include
/// NSPasteboard in your config's objc-interfaces list.
///
/// NSPasteboard
extension type NSPasteboard._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSPasteboard] that points to the same underlying object as [other].
  NSPasteboard.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSPasteboard', iOS: (true, null));
  }

  /// Constructs a [NSPasteboard] that wraps the given raw object pointer.
  NSPasteboard.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSPasteboard', iOS: (true, null));
  }
}

sealed class NSPasteboardWritingOptions {
  static const NSPasteboardWritingPromised = 512;
}

/// WARNING: NSPasteboardWriting is a stub. To generate bindings for this class, include
/// NSPasteboardWriting in your config's objc-protocols list.
///
/// NSPasteboardWriting
extension type NSPasteboardWriting._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [NSPasteboardWriting] that points to the same underlying object as [other].
  NSPasteboardWriting.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSPasteboardWriting] that wraps the given raw object pointer.
  NSPasteboardWriting.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

sealed class NSPasteboardReadingOptions {
  static const NSPasteboardReadingAsData = 0;
  static const NSPasteboardReadingAsString = 1;
  static const NSPasteboardReadingAsPropertyList = 2;
  static const NSPasteboardReadingAsKeyedArchive = 4;
}

/// WARNING: NSPasteboardReading is a stub. To generate bindings for this class, include
/// NSPasteboardReading in your config's objc-protocols list.
///
/// NSPasteboardReading
extension type NSPasteboardReading._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [NSPasteboardReading] that points to the same underlying object as [other].
  NSPasteboardReading.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSPasteboardReading] that wraps the given raw object pointer.
  NSPasteboardReading.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

sealed class NSDragOperation {
  static const NSDragOperationNone = 0;
  static const NSDragOperationCopy = 1;
  static const NSDragOperationLink = 2;
  static const NSDragOperationGeneric = 4;
  static const NSDragOperationPrivate = 8;
  static const NSDragOperationMove = 16;
  static const NSDragOperationDelete = 32;
  static const NSDragOperationEvery = -1;
  static const NSDragOperationAll_Obsolete = 15;
  static const NSDragOperationAll = 15;
}

enum NSDraggingFormation {
  NSDraggingFormationDefault(0),
  NSDraggingFormationNone(1),
  NSDraggingFormationPile(2),
  NSDraggingFormationList(3),
  NSDraggingFormationStack(4);

  final int value;
  const NSDraggingFormation(this.value);

  static NSDraggingFormation fromValue(int value) => switch (value) {
    0 => NSDraggingFormationDefault,
    1 => NSDraggingFormationNone,
    2 => NSDraggingFormationPile,
    3 => NSDraggingFormationList,
    4 => NSDraggingFormationStack,
    _ => throw ArgumentError('Unknown value for NSDraggingFormation: $value'),
  };
}

enum NSDraggingContext {
  NSDraggingContextOutsideApplication(0),
  NSDraggingContextWithinApplication(1);

  final int value;
  const NSDraggingContext(this.value);

  static NSDraggingContext fromValue(int value) => switch (value) {
    0 => NSDraggingContextOutsideApplication,
    1 => NSDraggingContextWithinApplication,
    _ => throw ArgumentError('Unknown value for NSDraggingContext: $value'),
  };
}

sealed class NSDraggingItemEnumerationOptions {
  static const NSDraggingItemEnumerationConcurrent = 1;
  static const NSDraggingItemEnumerationClearNonenumeratedImages = 65536;
}

enum NSSpringLoadingHighlight {
  NSSpringLoadingHighlightNone(0),
  NSSpringLoadingHighlightStandard(1),
  NSSpringLoadingHighlightEmphasized(2);

  final int value;
  const NSSpringLoadingHighlight(this.value);

  static NSSpringLoadingHighlight fromValue(int value) => switch (value) {
    0 => NSSpringLoadingHighlightNone,
    1 => NSSpringLoadingHighlightStandard,
    2 => NSSpringLoadingHighlightEmphasized,
    _ => throw ArgumentError(
      'Unknown value for NSSpringLoadingHighlight: $value',
    ),
  };
}

/// WARNING: NSDraggingInfo is a stub. To generate bindings for this class, include
/// NSDraggingInfo in your config's objc-protocols list.
///
/// NSDraggingInfo
extension type NSDraggingInfo._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [NSDraggingInfo] that points to the same underlying object as [other].
  NSDraggingInfo.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSDraggingInfo] that wraps the given raw object pointer.
  NSDraggingInfo.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// WARNING: NSDraggingDestination is a stub. To generate bindings for this class, include
/// NSDraggingDestination in your config's objc-protocols list.
///
/// NSDraggingDestination
extension type NSDraggingDestination._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [NSDraggingDestination] that points to the same underlying object as [other].
  NSDraggingDestination.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSDraggingDestination] that wraps the given raw object pointer.
  NSDraggingDestination.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// WARNING: NSDraggingSource is a stub. To generate bindings for this class, include
/// NSDraggingSource in your config's objc-protocols list.
///
/// NSDraggingSource
extension type NSDraggingSource._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [NSDraggingSource] that points to the same underlying object as [other].
  NSDraggingSource.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSDraggingSource] that wraps the given raw object pointer.
  NSDraggingSource.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

enum NSCompositingOperation {
  NSCompositingOperationClear(0),
  NSCompositingOperationCopy(1),
  NSCompositingOperationSourceOver(2),
  NSCompositingOperationSourceIn(3),
  NSCompositingOperationSourceOut(4),
  NSCompositingOperationSourceAtop(5),
  NSCompositingOperationDestinationOver(6),
  NSCompositingOperationDestinationIn(7),
  NSCompositingOperationDestinationOut(8),
  NSCompositingOperationDestinationAtop(9),
  NSCompositingOperationXOR(10),
  NSCompositingOperationPlusDarker(11),
  NSCompositingOperationHighlight(12),
  NSCompositingOperationPlusLighter(13),
  NSCompositingOperationMultiply(14),
  NSCompositingOperationScreen(15),
  NSCompositingOperationOverlay(16),
  NSCompositingOperationDarken(17),
  NSCompositingOperationLighten(18),
  NSCompositingOperationColorDodge(19),
  NSCompositingOperationColorBurn(20),
  NSCompositingOperationSoftLight(21),
  NSCompositingOperationHardLight(22),
  NSCompositingOperationDifference(23),
  NSCompositingOperationExclusion(24),
  NSCompositingOperationHue(25),
  NSCompositingOperationSaturation(26),
  NSCompositingOperationColor(27),
  NSCompositingOperationLuminosity(28);

  final int value;
  const NSCompositingOperation(this.value);

  static NSCompositingOperation fromValue(int value) => switch (value) {
    0 => NSCompositingOperationClear,
    1 => NSCompositingOperationCopy,
    2 => NSCompositingOperationSourceOver,
    3 => NSCompositingOperationSourceIn,
    4 => NSCompositingOperationSourceOut,
    5 => NSCompositingOperationSourceAtop,
    6 => NSCompositingOperationDestinationOver,
    7 => NSCompositingOperationDestinationIn,
    8 => NSCompositingOperationDestinationOut,
    9 => NSCompositingOperationDestinationAtop,
    10 => NSCompositingOperationXOR,
    11 => NSCompositingOperationPlusDarker,
    12 => NSCompositingOperationHighlight,
    13 => NSCompositingOperationPlusLighter,
    14 => NSCompositingOperationMultiply,
    15 => NSCompositingOperationScreen,
    16 => NSCompositingOperationOverlay,
    17 => NSCompositingOperationDarken,
    18 => NSCompositingOperationLighten,
    19 => NSCompositingOperationColorDodge,
    20 => NSCompositingOperationColorBurn,
    21 => NSCompositingOperationSoftLight,
    22 => NSCompositingOperationHardLight,
    23 => NSCompositingOperationDifference,
    24 => NSCompositingOperationExclusion,
    25 => NSCompositingOperationHue,
    26 => NSCompositingOperationSaturation,
    27 => NSCompositingOperationColor,
    28 => NSCompositingOperationLuminosity,
    _ => throw ArgumentError(
      'Unknown value for NSCompositingOperation: $value',
    ),
  };
}

enum NSBackingStoreType {
  NSBackingStoreRetained(0),
  NSBackingStoreNonretained(1),
  NSBackingStoreBuffered(2);

  final int value;
  const NSBackingStoreType(this.value);

  static NSBackingStoreType fromValue(int value) => switch (value) {
    0 => NSBackingStoreRetained,
    1 => NSBackingStoreNonretained,
    2 => NSBackingStoreBuffered,
    _ => throw ArgumentError('Unknown value for NSBackingStoreType: $value'),
  };
}

enum NSWindowOrderingMode {
  NSWindowAbove(1),
  NSWindowBelow(-1),
  NSWindowOut(0);

  final int value;
  const NSWindowOrderingMode(this.value);

  static NSWindowOrderingMode fromValue(int value) => switch (value) {
    1 => NSWindowAbove,
    -1 => NSWindowBelow,
    0 => NSWindowOut,
    _ => throw ArgumentError('Unknown value for NSWindowOrderingMode: $value'),
  };
}

enum NSFocusRingType {
  NSFocusRingTypeDefault(0),
  NSFocusRingTypeNone(1),
  NSFocusRingTypeExterior(2);

  final int value;
  const NSFocusRingType(this.value);

  static NSFocusRingType fromValue(int value) => switch (value) {
    0 => NSFocusRingTypeDefault,
    1 => NSFocusRingTypeNone,
    2 => NSFocusRingTypeExterior,
    _ => throw ArgumentError('Unknown value for NSFocusRingType: $value'),
  };
}

enum NSColorRenderingIntent {
  NSColorRenderingIntentDefault(0),
  NSColorRenderingIntentAbsoluteColorimetric(1),
  NSColorRenderingIntentRelativeColorimetric(2),
  NSColorRenderingIntentPerceptual(3),
  NSColorRenderingIntentSaturation(4);

  final int value;
  const NSColorRenderingIntent(this.value);

  static NSColorRenderingIntent fromValue(int value) => switch (value) {
    0 => NSColorRenderingIntentDefault,
    1 => NSColorRenderingIntentAbsoluteColorimetric,
    2 => NSColorRenderingIntentRelativeColorimetric,
    3 => NSColorRenderingIntentPerceptual,
    4 => NSColorRenderingIntentSaturation,
    _ => throw ArgumentError(
      'Unknown value for NSColorRenderingIntent: $value',
    ),
  };
}

enum NSWindowDepth {
  NSWindowDepthTwentyfourBitRGB(520),
  NSWindowDepthSixtyfourBitRGB(528),
  NSWindowDepthOnehundredtwentyeightBitRGB(544);

  final int value;
  const NSWindowDepth(this.value);

  static NSWindowDepth fromValue(int value) => switch (value) {
    520 => NSWindowDepthTwentyfourBitRGB,
    528 => NSWindowDepthSixtyfourBitRGB,
    544 => NSWindowDepthOnehundredtwentyeightBitRGB,
    _ => throw ArgumentError('Unknown value for NSWindowDepth: $value'),
  };
}

enum NSDisplayGamut {
  NSDisplayGamutSRGB(1),
  NSDisplayGamutP3(2);

  final int value;
  const NSDisplayGamut(this.value);

  static NSDisplayGamut fromValue(int value) => switch (value) {
    1 => NSDisplayGamutSRGB,
    2 => NSDisplayGamutP3,
    _ => throw ArgumentError('Unknown value for NSDisplayGamut: $value'),
  };
}

sealed class NSTouchPhase {
  static const NSTouchPhaseBegan = 1;
  static const NSTouchPhaseMoved = 2;
  static const NSTouchPhaseStationary = 4;
  static const NSTouchPhaseEnded = 8;
  static const NSTouchPhaseCancelled = 16;
  static const NSTouchPhaseTouching = 7;
  static const NSTouchPhaseAny = -1;
}

enum NSTouchType {
  NSTouchTypeDirect(0),
  NSTouchTypeIndirect(1);

  final int value;
  const NSTouchType(this.value);

  static NSTouchType fromValue(int value) => switch (value) {
    0 => NSTouchTypeDirect,
    1 => NSTouchTypeIndirect,
    _ => throw ArgumentError('Unknown value for NSTouchType: $value'),
  };
}

sealed class NSTouchTypeMask {
  static const NSTouchTypeMaskDirect = 1;
  static const NSTouchTypeMaskIndirect = 2;
}

final class CGContext extends ffi.Opaque {}

final class CGColor extends ffi.Opaque {}

final class CGColorSpace extends ffi.Opaque {}

final class CGImage extends ffi.Opaque {}

final class CGPath extends ffi.Opaque {}

final class CGLayer extends ffi.Opaque {}

final class __CGEvent extends ffi.Opaque {}

final class CGImageSource extends ffi.Opaque {}

enum CGImagePropertyOrientation {
  kCGImagePropertyOrientationUp(1),
  kCGImagePropertyOrientationUpMirrored(2),
  kCGImagePropertyOrientationDown(3),
  kCGImagePropertyOrientationDownMirrored(4),
  kCGImagePropertyOrientationLeftMirrored(5),
  kCGImagePropertyOrientationRight(6),
  kCGImagePropertyOrientationRightMirrored(7),
  kCGImagePropertyOrientationLeft(8);

  final int value;
  const CGImagePropertyOrientation(this.value);

  static CGImagePropertyOrientation fromValue(int value) => switch (value) {
    1 => kCGImagePropertyOrientationUp,
    2 => kCGImagePropertyOrientationUpMirrored,
    3 => kCGImagePropertyOrientationDown,
    4 => kCGImagePropertyOrientationDownMirrored,
    5 => kCGImagePropertyOrientationLeftMirrored,
    6 => kCGImagePropertyOrientationRight,
    7 => kCGImagePropertyOrientationRightMirrored,
    8 => kCGImagePropertyOrientationLeft,
    _ => throw ArgumentError(
      'Unknown value for CGImagePropertyOrientation: $value',
    ),
  };
}

enum NSEventType {
  NSEventTypeLeftMouseDown(1),
  NSEventTypeLeftMouseUp(2),
  NSEventTypeRightMouseDown(3),
  NSEventTypeRightMouseUp(4),
  NSEventTypeMouseMoved(5),
  NSEventTypeLeftMouseDragged(6),
  NSEventTypeRightMouseDragged(7),
  NSEventTypeMouseEntered(8),
  NSEventTypeMouseExited(9),
  NSEventTypeKeyDown(10),
  NSEventTypeKeyUp(11),
  NSEventTypeFlagsChanged(12),
  NSEventTypeAppKitDefined(13),
  NSEventTypeSystemDefined(14),
  NSEventTypeApplicationDefined(15),
  NSEventTypePeriodic(16),
  NSEventTypeCursorUpdate(17),
  NSEventTypeScrollWheel(22),
  NSEventTypeTabletPoint(23),
  NSEventTypeTabletProximity(24),
  NSEventTypeOtherMouseDown(25),
  NSEventTypeOtherMouseUp(26),
  NSEventTypeOtherMouseDragged(27),
  NSEventTypeGesture(29),
  NSEventTypeMagnify(30),
  NSEventTypeSwipe(31),
  NSEventTypeRotate(18),
  NSEventTypeBeginGesture(19),
  NSEventTypeEndGesture(20),
  NSEventTypeSmartMagnify(32),
  NSEventTypeQuickLook(33),
  NSEventTypePressure(34),
  NSEventTypeDirectTouch(37),
  NSEventTypeChangeMode(38),
  NSEventTypeMouseCancelled(40);

  final int value;
  const NSEventType(this.value);

  static NSEventType fromValue(int value) => switch (value) {
    1 => NSEventTypeLeftMouseDown,
    2 => NSEventTypeLeftMouseUp,
    3 => NSEventTypeRightMouseDown,
    4 => NSEventTypeRightMouseUp,
    5 => NSEventTypeMouseMoved,
    6 => NSEventTypeLeftMouseDragged,
    7 => NSEventTypeRightMouseDragged,
    8 => NSEventTypeMouseEntered,
    9 => NSEventTypeMouseExited,
    10 => NSEventTypeKeyDown,
    11 => NSEventTypeKeyUp,
    12 => NSEventTypeFlagsChanged,
    13 => NSEventTypeAppKitDefined,
    14 => NSEventTypeSystemDefined,
    15 => NSEventTypeApplicationDefined,
    16 => NSEventTypePeriodic,
    17 => NSEventTypeCursorUpdate,
    22 => NSEventTypeScrollWheel,
    23 => NSEventTypeTabletPoint,
    24 => NSEventTypeTabletProximity,
    25 => NSEventTypeOtherMouseDown,
    26 => NSEventTypeOtherMouseUp,
    27 => NSEventTypeOtherMouseDragged,
    29 => NSEventTypeGesture,
    30 => NSEventTypeMagnify,
    31 => NSEventTypeSwipe,
    18 => NSEventTypeRotate,
    19 => NSEventTypeBeginGesture,
    20 => NSEventTypeEndGesture,
    32 => NSEventTypeSmartMagnify,
    33 => NSEventTypeQuickLook,
    34 => NSEventTypePressure,
    37 => NSEventTypeDirectTouch,
    38 => NSEventTypeChangeMode,
    40 => NSEventTypeMouseCancelled,
    _ => throw ArgumentError('Unknown value for NSEventType: $value'),
  };
}

sealed class NSEventMask {
  static const NSEventMaskLeftMouseDown = 2;
  static const NSEventMaskLeftMouseUp = 4;
  static const NSEventMaskRightMouseDown = 8;
  static const NSEventMaskRightMouseUp = 16;
  static const NSEventMaskMouseMoved = 32;
  static const NSEventMaskLeftMouseDragged = 64;
  static const NSEventMaskRightMouseDragged = 128;
  static const NSEventMaskMouseEntered = 256;
  static const NSEventMaskMouseExited = 512;
  static const NSEventMaskKeyDown = 1024;
  static const NSEventMaskKeyUp = 2048;
  static const NSEventMaskFlagsChanged = 4096;
  static const NSEventMaskAppKitDefined = 8192;
  static const NSEventMaskSystemDefined = 16384;
  static const NSEventMaskApplicationDefined = 32768;
  static const NSEventMaskPeriodic = 65536;
  static const NSEventMaskCursorUpdate = 131072;
  static const NSEventMaskScrollWheel = 4194304;
  static const NSEventMaskTabletPoint = 8388608;
  static const NSEventMaskTabletProximity = 16777216;
  static const NSEventMaskOtherMouseDown = 33554432;
  static const NSEventMaskOtherMouseUp = 67108864;
  static const NSEventMaskOtherMouseDragged = 134217728;
  static const NSEventMaskGesture = 536870912;
  static const NSEventMaskMagnify = 1073741824;
  static const NSEventMaskSwipe = 2147483648;
  static const NSEventMaskRotate = 262144;
  static const NSEventMaskBeginGesture = 524288;
  static const NSEventMaskEndGesture = 1048576;
  static const NSEventMaskSmartMagnify = 4294967296;
  static const NSEventMaskPressure = 17179869184;
  static const NSEventMaskDirectTouch = 137438953472;
  static const NSEventMaskChangeMode = 274877906944;
  static const NSEventMaskMouseCancelled = 1099511627776;
  static const NSEventMaskAny = -1;
}

sealed class NSEventModifierFlags {
  static const NSEventModifierFlagCapsLock = 65536;
  static const NSEventModifierFlagShift = 131072;
  static const NSEventModifierFlagControl = 262144;
  static const NSEventModifierFlagOption = 524288;
  static const NSEventModifierFlagCommand = 1048576;
  static const NSEventModifierFlagNumericPad = 2097152;
  static const NSEventModifierFlagHelp = 4194304;
  static const NSEventModifierFlagFunction = 8388608;
  static const NSEventModifierFlagDeviceIndependentFlagsMask = 4294901760;
}

enum NSPointingDeviceType {
  NSPointingDeviceTypeUnknown(0),
  NSPointingDeviceTypePen(1),
  NSPointingDeviceTypeCursor(2),
  NSPointingDeviceTypeEraser(3);

  final int value;
  const NSPointingDeviceType(this.value);

  static NSPointingDeviceType fromValue(int value) => switch (value) {
    0 => NSPointingDeviceTypeUnknown,
    1 => NSPointingDeviceTypePen,
    2 => NSPointingDeviceTypeCursor,
    3 => NSPointingDeviceTypeEraser,
    _ => throw ArgumentError('Unknown value for NSPointingDeviceType: $value'),
  };
}

sealed class NSEventButtonMask {
  static const NSEventButtonMaskPenTip = 1;
  static const NSEventButtonMaskPenLowerSide = 2;
  static const NSEventButtonMaskPenUpperSide = 4;
}

sealed class NSEventPhase {
  static const NSEventPhaseNone = 0;
  static const NSEventPhaseBegan = 1;
  static const NSEventPhaseStationary = 2;
  static const NSEventPhaseChanged = 4;
  static const NSEventPhaseEnded = 8;
  static const NSEventPhaseCancelled = 16;
  static const NSEventPhaseMayBegin = 32;
}

enum NSEventGestureAxis {
  NSEventGestureAxisNone(0),
  NSEventGestureAxisHorizontal(1),
  NSEventGestureAxisVertical(2);

  final int value;
  const NSEventGestureAxis(this.value);

  static NSEventGestureAxis fromValue(int value) => switch (value) {
    0 => NSEventGestureAxisNone,
    1 => NSEventGestureAxisHorizontal,
    2 => NSEventGestureAxisVertical,
    _ => throw ArgumentError('Unknown value for NSEventGestureAxis: $value'),
  };
}

sealed class NSEventSwipeTrackingOptions {
  static const NSEventSwipeTrackingLockDirection = 1;
  static const NSEventSwipeTrackingClampGestureAmount = 2;
}

enum NSEventSubtype {
  NSEventSubtypeWindowExposed(0),
  NSEventSubtypeApplicationActivated(1),
  NSEventSubtypeApplicationDeactivated(2),
  NSEventSubtypeWindowMoved(4),
  NSEventSubtypeScreenChanged(8),
  NSEventSubtypeTouch(3);

  static const NSEventSubtypePowerOff = NSEventSubtypeApplicationActivated;
  static const NSEventSubtypeMouseEvent = NSEventSubtypeWindowExposed;
  static const NSEventSubtypeTabletPoint = NSEventSubtypeApplicationActivated;
  static const NSEventSubtypeTabletProximity =
      NSEventSubtypeApplicationDeactivated;

  final int value;
  const NSEventSubtype(this.value);

  static NSEventSubtype fromValue(int value) => switch (value) {
    0 => NSEventSubtypeWindowExposed,
    1 => NSEventSubtypeApplicationActivated,
    2 => NSEventSubtypeApplicationDeactivated,
    4 => NSEventSubtypeWindowMoved,
    8 => NSEventSubtypeScreenChanged,
    3 => NSEventSubtypeTouch,
    _ => throw ArgumentError('Unknown value for NSEventSubtype: $value'),
  };

  @override
  String toString() {
    if (this == NSEventSubtypeWindowExposed)
      return "NSEventSubtype.NSEventSubtypeWindowExposed, NSEventSubtype.NSEventSubtypeMouseEvent";
    if (this == NSEventSubtypeApplicationActivated)
      return "NSEventSubtype.NSEventSubtypeApplicationActivated, NSEventSubtype.NSEventSubtypePowerOff, NSEventSubtype.NSEventSubtypeTabletPoint";
    if (this == NSEventSubtypeApplicationDeactivated)
      return "NSEventSubtype.NSEventSubtypeApplicationDeactivated, NSEventSubtype.NSEventSubtypeTabletProximity";
    return super.toString();
  }
}

enum NSPressureBehavior {
  NSPressureBehaviorUnknown(-1),
  NSPressureBehaviorPrimaryDefault(0),
  NSPressureBehaviorPrimaryClick(1),
  NSPressureBehaviorPrimaryGeneric(2),
  NSPressureBehaviorPrimaryAccelerator(3),
  NSPressureBehaviorPrimaryDeepClick(5),
  NSPressureBehaviorPrimaryDeepDrag(6);

  final int value;
  const NSPressureBehavior(this.value);

  static NSPressureBehavior fromValue(int value) => switch (value) {
    -1 => NSPressureBehaviorUnknown,
    0 => NSPressureBehaviorPrimaryDefault,
    1 => NSPressureBehaviorPrimaryClick,
    2 => NSPressureBehaviorPrimaryGeneric,
    3 => NSPressureBehaviorPrimaryAccelerator,
    5 => NSPressureBehaviorPrimaryDeepClick,
    6 => NSPressureBehaviorPrimaryDeepDrag,
    _ => throw ArgumentError('Unknown value for NSPressureBehavior: $value'),
  };
}

/// WARNING: NSEvent is a stub. To generate bindings for this class, include
/// NSEvent in your config's objc-interfaces list.
///
/// NSEvent
extension type NSEvent._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying, objc.NSCoding {
  /// Constructs a [NSEvent] that points to the same underlying object as [other].
  NSEvent.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSEvent', iOS: (true, null));
  }

  /// Constructs a [NSEvent] that wraps the given raw object pointer.
  NSEvent.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSEvent', iOS: (true, null));
  }
}

enum NSAccessibilityOrientation {
  NSAccessibilityOrientationUnknown(0),
  NSAccessibilityOrientationVertical(1),
  NSAccessibilityOrientationHorizontal(2);

  final int value;
  const NSAccessibilityOrientation(this.value);

  static NSAccessibilityOrientation fromValue(int value) => switch (value) {
    0 => NSAccessibilityOrientationUnknown,
    1 => NSAccessibilityOrientationVertical,
    2 => NSAccessibilityOrientationHorizontal,
    _ => throw ArgumentError(
      'Unknown value for NSAccessibilityOrientation: $value',
    ),
  };
}

enum NSAccessibilitySortDirection {
  NSAccessibilitySortDirectionUnknown(0),
  NSAccessibilitySortDirectionAscending(1),
  NSAccessibilitySortDirectionDescending(2);

  final int value;
  const NSAccessibilitySortDirection(this.value);

  static NSAccessibilitySortDirection fromValue(int value) => switch (value) {
    0 => NSAccessibilitySortDirectionUnknown,
    1 => NSAccessibilitySortDirectionAscending,
    2 => NSAccessibilitySortDirectionDescending,
    _ => throw ArgumentError(
      'Unknown value for NSAccessibilitySortDirection: $value',
    ),
  };
}

enum NSAccessibilityRulerMarkerType {
  NSAccessibilityRulerMarkerTypeUnknown(0),
  NSAccessibilityRulerMarkerTypeTabStopLeft(1),
  NSAccessibilityRulerMarkerTypeTabStopRight(2),
  NSAccessibilityRulerMarkerTypeTabStopCenter(3),
  NSAccessibilityRulerMarkerTypeTabStopDecimal(4),
  NSAccessibilityRulerMarkerTypeIndentHead(5),
  NSAccessibilityRulerMarkerTypeIndentTail(6),
  NSAccessibilityRulerMarkerTypeIndentFirstLine(7);

  final int value;
  const NSAccessibilityRulerMarkerType(this.value);

  static NSAccessibilityRulerMarkerType fromValue(int value) => switch (value) {
    0 => NSAccessibilityRulerMarkerTypeUnknown,
    1 => NSAccessibilityRulerMarkerTypeTabStopLeft,
    2 => NSAccessibilityRulerMarkerTypeTabStopRight,
    3 => NSAccessibilityRulerMarkerTypeTabStopCenter,
    4 => NSAccessibilityRulerMarkerTypeTabStopDecimal,
    5 => NSAccessibilityRulerMarkerTypeIndentHead,
    6 => NSAccessibilityRulerMarkerTypeIndentTail,
    7 => NSAccessibilityRulerMarkerTypeIndentFirstLine,
    _ => throw ArgumentError(
      'Unknown value for NSAccessibilityRulerMarkerType: $value',
    ),
  };
}

enum NSAccessibilityUnits {
  NSAccessibilityUnitsUnknown(0),
  NSAccessibilityUnitsInches(1),
  NSAccessibilityUnitsCentimeters(2),
  NSAccessibilityUnitsPoints(3),
  NSAccessibilityUnitsPicas(4);

  final int value;
  const NSAccessibilityUnits(this.value);

  static NSAccessibilityUnits fromValue(int value) => switch (value) {
    0 => NSAccessibilityUnitsUnknown,
    1 => NSAccessibilityUnitsInches,
    2 => NSAccessibilityUnitsCentimeters,
    3 => NSAccessibilityUnitsPoints,
    4 => NSAccessibilityUnitsPicas,
    _ => throw ArgumentError('Unknown value for NSAccessibilityUnits: $value'),
  };
}

/// WARNING: NSAccessibilityElement is a stub. To generate bindings for this class, include
/// NSAccessibilityElement in your config's objc-protocols list.
///
/// NSAccessibilityElement
extension type NSAccessibilityElement._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [NSAccessibilityElement] that points to the same underlying object as [other].
  NSAccessibilityElement.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSAccessibilityElement] that wraps the given raw object pointer.
  NSAccessibilityElement.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// WARNING: NSAccessibility is a stub. To generate bindings for this class, include
/// NSAccessibility in your config's objc-protocols list.
///
/// NSAccessibility
extension type NSAccessibility._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [NSAccessibility] that points to the same underlying object as [other].
  NSAccessibility.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSAccessibility] that wraps the given raw object pointer.
  NSAccessibility.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _class_NSResponder = objc.getClass("NSResponder");
late final _sel_nextResponder = objc.registerName("nextResponder");
late final _sel_setNextResponder_ = objc.registerName("setNextResponder:");
late final _sel_tryToPerform_with_ = objc.registerName("tryToPerform:with:");
final _objc_msgSend_1f04296 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_performKeyEquivalent_ = objc.registerName(
  "performKeyEquivalent:",
);
late final _sel_validRequestorForSendType_returnType_ = objc.registerName(
  "validRequestorForSendType:returnType:",
);
final _objc_msgSend_15qeuct = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_mouseDown_ = objc.registerName("mouseDown:");
late final _sel_rightMouseDown_ = objc.registerName("rightMouseDown:");
late final _sel_otherMouseDown_ = objc.registerName("otherMouseDown:");
late final _sel_mouseUp_ = objc.registerName("mouseUp:");
late final _sel_rightMouseUp_ = objc.registerName("rightMouseUp:");
late final _sel_otherMouseUp_ = objc.registerName("otherMouseUp:");
late final _sel_mouseMoved_ = objc.registerName("mouseMoved:");
late final _sel_mouseDragged_ = objc.registerName("mouseDragged:");
late final _sel_mouseCancelled_ = objc.registerName("mouseCancelled:");
late final _sel_scrollWheel_ = objc.registerName("scrollWheel:");
late final _sel_rightMouseDragged_ = objc.registerName("rightMouseDragged:");
late final _sel_otherMouseDragged_ = objc.registerName("otherMouseDragged:");
late final _sel_mouseEntered_ = objc.registerName("mouseEntered:");
late final _sel_mouseExited_ = objc.registerName("mouseExited:");
late final _sel_keyDown_ = objc.registerName("keyDown:");
late final _sel_keyUp_ = objc.registerName("keyUp:");
late final _sel_flagsChanged_ = objc.registerName("flagsChanged:");
late final _sel_tabletPoint_ = objc.registerName("tabletPoint:");
late final _sel_tabletProximity_ = objc.registerName("tabletProximity:");
late final _sel_cursorUpdate_ = objc.registerName("cursorUpdate:");
late final _sel_magnifyWithEvent_ = objc.registerName("magnifyWithEvent:");
late final _sel_rotateWithEvent_ = objc.registerName("rotateWithEvent:");
late final _sel_swipeWithEvent_ = objc.registerName("swipeWithEvent:");
late final _sel_beginGestureWithEvent_ = objc.registerName(
  "beginGestureWithEvent:",
);
late final _sel_endGestureWithEvent_ = objc.registerName(
  "endGestureWithEvent:",
);
late final _sel_smartMagnifyWithEvent_ = objc.registerName(
  "smartMagnifyWithEvent:",
);
late final _sel_changeModeWithEvent_ = objc.registerName(
  "changeModeWithEvent:",
);
late final _sel_touchesBeganWithEvent_ = objc.registerName(
  "touchesBeganWithEvent:",
);
late final _sel_touchesMovedWithEvent_ = objc.registerName(
  "touchesMovedWithEvent:",
);
late final _sel_touchesEndedWithEvent_ = objc.registerName(
  "touchesEndedWithEvent:",
);
late final _sel_touchesCancelledWithEvent_ = objc.registerName(
  "touchesCancelledWithEvent:",
);
late final _sel_quickLookWithEvent_ = objc.registerName("quickLookWithEvent:");
late final _sel_pressureChangeWithEvent_ = objc.registerName(
  "pressureChangeWithEvent:",
);
late final _sel_contextMenuKeyDown_ = objc.registerName("contextMenuKeyDown:");
late final _sel_noResponderFor_ = objc.registerName("noResponderFor:");
final _objc_msgSend_1d9e4oe = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_acceptsFirstResponder = objc.registerName(
  "acceptsFirstResponder",
);
late final _sel_becomeFirstResponder = objc.registerName(
  "becomeFirstResponder",
);
late final _sel_resignFirstResponder = objc.registerName(
  "resignFirstResponder",
);
late final _sel_interpretKeyEvents_ = objc.registerName("interpretKeyEvents:");
late final _sel_flushBufferedKeyEvents = objc.registerName(
  "flushBufferedKeyEvents",
);
final _objc_msgSend_1pl9qdv = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// WARNING: NSMenu is a stub. To generate bindings for this class, include
/// NSMenu in your config's objc-interfaces list.
///
/// NSMenu
extension type NSMenu._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSCopying,
        objc.NSCoding,
        NSUserInterfaceItemIdentification,
        NSAppearanceCustomization,
        NSAccessibilityElement,
        NSAccessibility {
  /// Constructs a [NSMenu] that points to the same underlying object as [other].
  NSMenu.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSMenu', iOS: (true, null));
  }

  /// Constructs a [NSMenu] that wraps the given raw object pointer.
  NSMenu.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSMenu', iOS: (true, null));
  }
}

late final _sel_menu = objc.registerName("menu");
late final _sel_setMenu_ = objc.registerName("setMenu:");
late final _sel_showContextHelp_ = objc.registerName("showContextHelp:");
late final _sel_helpRequested_ = objc.registerName("helpRequested:");
late final _sel_shouldBeTreatedAsInkEvent_ = objc.registerName(
  "shouldBeTreatedAsInkEvent:",
);
late final _sel_wantsScrollEventsForSwipeTrackingOnAxis_ = objc.registerName(
  "wantsScrollEventsForSwipeTrackingOnAxis:",
);
final _objc_msgSend_s1vka0 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_wantsForwardedScrollEventsForAxis_ = objc.registerName(
  "wantsForwardedScrollEventsForAxis:",
);
late final _sel_supplementalTargetForAction_sender_ = objc.registerName(
  "supplementalTargetForAction:sender:",
);
final _objc_msgSend_gx50so = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_insertText_ = objc.registerName("insertText:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObject) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(arg0, objc.ObjCObject(arg1, retain: true, release: true)),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObject) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, objc.ObjCObject(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObject) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, objc.ObjCObject(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, objc.ObjCObject(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl$1$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        > {
  void call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObject arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_doCommandBySelector_ = objc.registerName(
  "doCommandBySelector:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_objcObjCSelector {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCSelector> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCSelector> arg1) =>
              fn(arg0, arg1),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCSelector> arg1) =>
          fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_be1lg6(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCSelector> arg1) =>
          fn(arg0, arg1),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCSelector> arg1) =>
          fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_be1lg6(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCSelector> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCSelector>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCSelector>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCSelector>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCSelector> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCSelector>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCSelector>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCSelector>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCSelector>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCSelector>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCSelector> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCSelector> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCSelector>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCSelector> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCSelector>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCSelector>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_objcObjCSelector$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCSelector>,
          )
        > {
  void call(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCSelector> arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCSelector> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCSelector>,
            )
          >()(ref.pointer, arg0, arg1);
}

late final _sel_moveForward_ = objc.registerName("moveForward:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>?,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>?,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObject?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>?,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                arg1.address == 0
                    ? null
                    : objc.ObjCObject(arg1, retain: true, release: true),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObject?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.ObjCObject(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObjectImpl>?,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObject?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.ObjCObject(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.ObjCObject(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObjectImpl>?,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>?,
          )
        > {
  void call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObject? arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_moveRight_ = objc.registerName("moveRight:");
late final _sel_moveBackward_ = objc.registerName("moveBackward:");
late final _sel_moveLeft_ = objc.registerName("moveLeft:");
late final _sel_moveUp_ = objc.registerName("moveUp:");
late final _sel_moveDown_ = objc.registerName("moveDown:");
late final _sel_moveWordForward_ = objc.registerName("moveWordForward:");
late final _sel_moveWordBackward_ = objc.registerName("moveWordBackward:");
late final _sel_moveToBeginningOfLine_ = objc.registerName(
  "moveToBeginningOfLine:",
);
late final _sel_moveToEndOfLine_ = objc.registerName("moveToEndOfLine:");
late final _sel_moveToBeginningOfParagraph_ = objc.registerName(
  "moveToBeginningOfParagraph:",
);
late final _sel_moveToEndOfParagraph_ = objc.registerName(
  "moveToEndOfParagraph:",
);
late final _sel_moveToEndOfDocument_ = objc.registerName(
  "moveToEndOfDocument:",
);
late final _sel_moveToBeginningOfDocument_ = objc.registerName(
  "moveToBeginningOfDocument:",
);
late final _sel_pageDown_ = objc.registerName("pageDown:");
late final _sel_pageUp_ = objc.registerName("pageUp:");
late final _sel_centerSelectionInVisibleArea_ = objc.registerName(
  "centerSelectionInVisibleArea:",
);
late final _sel_moveBackwardAndModifySelection_ = objc.registerName(
  "moveBackwardAndModifySelection:",
);
late final _sel_moveForwardAndModifySelection_ = objc.registerName(
  "moveForwardAndModifySelection:",
);
late final _sel_moveWordForwardAndModifySelection_ = objc.registerName(
  "moveWordForwardAndModifySelection:",
);
late final _sel_moveWordBackwardAndModifySelection_ = objc.registerName(
  "moveWordBackwardAndModifySelection:",
);
late final _sel_moveUpAndModifySelection_ = objc.registerName(
  "moveUpAndModifySelection:",
);
late final _sel_moveDownAndModifySelection_ = objc.registerName(
  "moveDownAndModifySelection:",
);
late final _sel_moveToBeginningOfLineAndModifySelection_ = objc.registerName(
  "moveToBeginningOfLineAndModifySelection:",
);
late final _sel_moveToEndOfLineAndModifySelection_ = objc.registerName(
  "moveToEndOfLineAndModifySelection:",
);
late final _sel_moveToBeginningOfParagraphAndModifySelection_ = objc
    .registerName("moveToBeginningOfParagraphAndModifySelection:");
late final _sel_moveToEndOfParagraphAndModifySelection_ = objc.registerName(
  "moveToEndOfParagraphAndModifySelection:",
);
late final _sel_moveToEndOfDocumentAndModifySelection_ = objc.registerName(
  "moveToEndOfDocumentAndModifySelection:",
);
late final _sel_moveToBeginningOfDocumentAndModifySelection_ = objc
    .registerName("moveToBeginningOfDocumentAndModifySelection:");
late final _sel_pageDownAndModifySelection_ = objc.registerName(
  "pageDownAndModifySelection:",
);
late final _sel_pageUpAndModifySelection_ = objc.registerName(
  "pageUpAndModifySelection:",
);
late final _sel_moveParagraphForwardAndModifySelection_ = objc.registerName(
  "moveParagraphForwardAndModifySelection:",
);
late final _sel_moveParagraphBackwardAndModifySelection_ = objc.registerName(
  "moveParagraphBackwardAndModifySelection:",
);
late final _sel_moveWordRight_ = objc.registerName("moveWordRight:");
late final _sel_moveWordLeft_ = objc.registerName("moveWordLeft:");
late final _sel_moveRightAndModifySelection_ = objc.registerName(
  "moveRightAndModifySelection:",
);
late final _sel_moveLeftAndModifySelection_ = objc.registerName(
  "moveLeftAndModifySelection:",
);
late final _sel_moveWordRightAndModifySelection_ = objc.registerName(
  "moveWordRightAndModifySelection:",
);
late final _sel_moveWordLeftAndModifySelection_ = objc.registerName(
  "moveWordLeftAndModifySelection:",
);
late final _sel_moveToLeftEndOfLine_ = objc.registerName(
  "moveToLeftEndOfLine:",
);
late final _sel_moveToRightEndOfLine_ = objc.registerName(
  "moveToRightEndOfLine:",
);
late final _sel_moveToLeftEndOfLineAndModifySelection_ = objc.registerName(
  "moveToLeftEndOfLineAndModifySelection:",
);
late final _sel_moveToRightEndOfLineAndModifySelection_ = objc.registerName(
  "moveToRightEndOfLineAndModifySelection:",
);
late final _sel_scrollPageUp_ = objc.registerName("scrollPageUp:");
late final _sel_scrollPageDown_ = objc.registerName("scrollPageDown:");
late final _sel_scrollLineUp_ = objc.registerName("scrollLineUp:");
late final _sel_scrollLineDown_ = objc.registerName("scrollLineDown:");
late final _sel_scrollToBeginningOfDocument_ = objc.registerName(
  "scrollToBeginningOfDocument:",
);
late final _sel_scrollToEndOfDocument_ = objc.registerName(
  "scrollToEndOfDocument:",
);
late final _sel_transpose_ = objc.registerName("transpose:");
late final _sel_transposeWords_ = objc.registerName("transposeWords:");
late final _sel_selectAll_ = objc.registerName("selectAll:");
late final _sel_selectParagraph_ = objc.registerName("selectParagraph:");
late final _sel_selectLine_ = objc.registerName("selectLine:");
late final _sel_selectWord_ = objc.registerName("selectWord:");
late final _sel_indent_ = objc.registerName("indent:");
late final _sel_insertTab_ = objc.registerName("insertTab:");
late final _sel_insertBacktab_ = objc.registerName("insertBacktab:");
late final _sel_insertNewline_ = objc.registerName("insertNewline:");
late final _sel_insertParagraphSeparator_ = objc.registerName(
  "insertParagraphSeparator:",
);
late final _sel_insertNewlineIgnoringFieldEditor_ = objc.registerName(
  "insertNewlineIgnoringFieldEditor:",
);
late final _sel_insertTabIgnoringFieldEditor_ = objc.registerName(
  "insertTabIgnoringFieldEditor:",
);
late final _sel_insertLineBreak_ = objc.registerName("insertLineBreak:");
late final _sel_insertContainerBreak_ = objc.registerName(
  "insertContainerBreak:",
);
late final _sel_insertSingleQuoteIgnoringSubstitution_ = objc.registerName(
  "insertSingleQuoteIgnoringSubstitution:",
);
late final _sel_insertDoubleQuoteIgnoringSubstitution_ = objc.registerName(
  "insertDoubleQuoteIgnoringSubstitution:",
);
late final _sel_changeCaseOfLetter_ = objc.registerName("changeCaseOfLetter:");
late final _sel_uppercaseWord_ = objc.registerName("uppercaseWord:");
late final _sel_lowercaseWord_ = objc.registerName("lowercaseWord:");
late final _sel_capitalizeWord_ = objc.registerName("capitalizeWord:");
late final _sel_deleteForward_ = objc.registerName("deleteForward:");
late final _sel_deleteBackward_ = objc.registerName("deleteBackward:");
late final _sel_deleteBackwardByDecomposingPreviousCharacter_ = objc
    .registerName("deleteBackwardByDecomposingPreviousCharacter:");
late final _sel_deleteWordForward_ = objc.registerName("deleteWordForward:");
late final _sel_deleteWordBackward_ = objc.registerName("deleteWordBackward:");
late final _sel_deleteToBeginningOfLine_ = objc.registerName(
  "deleteToBeginningOfLine:",
);
late final _sel_deleteToEndOfLine_ = objc.registerName("deleteToEndOfLine:");
late final _sel_deleteToBeginningOfParagraph_ = objc.registerName(
  "deleteToBeginningOfParagraph:",
);
late final _sel_deleteToEndOfParagraph_ = objc.registerName(
  "deleteToEndOfParagraph:",
);
late final _sel_yank_ = objc.registerName("yank:");
late final _sel_complete_ = objc.registerName("complete:");
late final _sel_setMark_ = objc.registerName("setMark:");
late final _sel_deleteToMark_ = objc.registerName("deleteToMark:");
late final _sel_selectToMark_ = objc.registerName("selectToMark:");
late final _sel_swapWithMark_ = objc.registerName("swapWithMark:");
late final _sel_cancelOperation_ = objc.registerName("cancelOperation:");
late final _sel_makeBaseWritingDirectionNatural_ = objc.registerName(
  "makeBaseWritingDirectionNatural:",
);
late final _sel_makeBaseWritingDirectionLeftToRight_ = objc.registerName(
  "makeBaseWritingDirectionLeftToRight:",
);
late final _sel_makeBaseWritingDirectionRightToLeft_ = objc.registerName(
  "makeBaseWritingDirectionRightToLeft:",
);
late final _sel_makeTextWritingDirectionNatural_ = objc.registerName(
  "makeTextWritingDirectionNatural:",
);
late final _sel_makeTextWritingDirectionLeftToRight_ = objc.registerName(
  "makeTextWritingDirectionLeftToRight:",
);
late final _sel_makeTextWritingDirectionRightToLeft_ = objc.registerName(
  "makeTextWritingDirectionRightToLeft:",
);
late final _sel_quickLookPreviewItems_ = objc.registerName(
  "quickLookPreviewItems:",
);
late final _sel_showContextMenuForSelection_ = objc.registerName(
  "showContextMenuForSelection:",
);

/// WARNING: NSStandardKeyBindingResponding is a stub. To generate bindings for this class, include
/// NSStandardKeyBindingResponding in your config's objc-protocols list.
///
/// NSStandardKeyBindingResponding
extension type NSStandardKeyBindingResponding._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [NSStandardKeyBindingResponding] that points to the same underlying object as [other].
  NSStandardKeyBindingResponding.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSStandardKeyBindingResponding] that wraps the given raw object pointer.
  NSStandardKeyBindingResponding.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// NSStandardKeyBindingMethods
extension NSStandardKeyBindingMethods on NSResponder {
  /// cancelOperation:
  void cancelOperation(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.cancelOperation:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_cancelOperation_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'cancelOperation:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_cancelOperation_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// capitalizeWord:
  void capitalizeWord(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.capitalizeWord:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_capitalizeWord_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'capitalizeWord:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_capitalizeWord_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// centerSelectionInVisibleArea:
  void centerSelectionInVisibleArea(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.centerSelectionInVisibleArea:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_centerSelectionInVisibleArea_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'centerSelectionInVisibleArea:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_centerSelectionInVisibleArea_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// changeCaseOfLetter:
  void changeCaseOfLetter(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.changeCaseOfLetter:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_changeCaseOfLetter_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'changeCaseOfLetter:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_changeCaseOfLetter_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// complete:
  void complete(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.complete:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_complete_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'complete:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_complete_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// deleteBackward:
  void deleteBackward(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.deleteBackward:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_deleteBackward_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'deleteBackward:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_deleteBackward_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// deleteBackwardByDecomposingPreviousCharacter:
  void deleteBackwardByDecomposingPreviousCharacter(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.deleteBackwardByDecomposingPreviousCharacter:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_deleteBackwardByDecomposingPreviousCharacter_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'deleteBackwardByDecomposingPreviousCharacter:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_deleteBackwardByDecomposingPreviousCharacter_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// deleteForward:
  void deleteForward(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.deleteForward:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_deleteForward_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'deleteForward:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_deleteForward_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// deleteToBeginningOfLine:
  void deleteToBeginningOfLine(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.deleteToBeginningOfLine:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_deleteToBeginningOfLine_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'deleteToBeginningOfLine:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_deleteToBeginningOfLine_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// deleteToBeginningOfParagraph:
  void deleteToBeginningOfParagraph(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.deleteToBeginningOfParagraph:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_deleteToBeginningOfParagraph_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'deleteToBeginningOfParagraph:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_deleteToBeginningOfParagraph_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// deleteToEndOfLine:
  void deleteToEndOfLine(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.deleteToEndOfLine:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_deleteToEndOfLine_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'deleteToEndOfLine:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_deleteToEndOfLine_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// deleteToEndOfParagraph:
  void deleteToEndOfParagraph(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.deleteToEndOfParagraph:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_deleteToEndOfParagraph_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'deleteToEndOfParagraph:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_deleteToEndOfParagraph_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// deleteToMark:
  void deleteToMark(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.deleteToMark:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_deleteToMark_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'deleteToMark:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_deleteToMark_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// deleteWordBackward:
  void deleteWordBackward(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.deleteWordBackward:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_deleteWordBackward_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'deleteWordBackward:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_deleteWordBackward_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// deleteWordForward:
  void deleteWordForward(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.deleteWordForward:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_deleteWordForward_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'deleteWordForward:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_deleteWordForward_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// doCommandBySelector:
  void doCommandBySelector(ffi.Pointer<objc.ObjCSelector> selector) {
    objc.checkOsVersionInternal(
      'NSResponder.doCommandBySelector:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_doCommandBySelector_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'doCommandBySelector:',
      );
    }
    _objc_msgSend_1d9e4oe(
      object$.ref.pointer,
      _sel_doCommandBySelector_,
      selector,
    );
  }

  /// indent:
  void indent(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.indent:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_indent_)) {
      throw objc.UnimplementedOptionalMethodException('NSResponder', 'indent:');
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_indent_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// insertBacktab:
  void insertBacktab(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.insertBacktab:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_insertBacktab_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'insertBacktab:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_insertBacktab_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// insertContainerBreak:
  void insertContainerBreak(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.insertContainerBreak:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_insertContainerBreak_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'insertContainerBreak:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_insertContainerBreak_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// insertDoubleQuoteIgnoringSubstitution:
  void insertDoubleQuoteIgnoringSubstitution(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.insertDoubleQuoteIgnoringSubstitution:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_insertDoubleQuoteIgnoringSubstitution_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'insertDoubleQuoteIgnoringSubstitution:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_insertDoubleQuoteIgnoringSubstitution_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// insertLineBreak:
  void insertLineBreak(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.insertLineBreak:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_insertLineBreak_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'insertLineBreak:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_insertLineBreak_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// insertNewline:
  void insertNewline(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.insertNewline:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_insertNewline_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'insertNewline:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_insertNewline_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// insertNewlineIgnoringFieldEditor:
  void insertNewlineIgnoringFieldEditor(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.insertNewlineIgnoringFieldEditor:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_insertNewlineIgnoringFieldEditor_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'insertNewlineIgnoringFieldEditor:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_insertNewlineIgnoringFieldEditor_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// insertParagraphSeparator:
  void insertParagraphSeparator(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.insertParagraphSeparator:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_insertParagraphSeparator_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'insertParagraphSeparator:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_insertParagraphSeparator_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// insertSingleQuoteIgnoringSubstitution:
  void insertSingleQuoteIgnoringSubstitution(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.insertSingleQuoteIgnoringSubstitution:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_insertSingleQuoteIgnoringSubstitution_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'insertSingleQuoteIgnoringSubstitution:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_insertSingleQuoteIgnoringSubstitution_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// insertTab:
  void insertTab(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.insertTab:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_insertTab_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'insertTab:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_insertTab_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// insertTabIgnoringFieldEditor:
  void insertTabIgnoringFieldEditor(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.insertTabIgnoringFieldEditor:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_insertTabIgnoringFieldEditor_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'insertTabIgnoringFieldEditor:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_insertTabIgnoringFieldEditor_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// insertText:
  void insertText(objc.ObjCObject insertString) {
    objc.checkOsVersionInternal('NSResponder.insertText:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_insertText_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'insertText:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_insertText_,
      insertString.ref.pointer,
    );
  }

  /// lowercaseWord:
  void lowercaseWord(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.lowercaseWord:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_lowercaseWord_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'lowercaseWord:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_lowercaseWord_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// makeBaseWritingDirectionLeftToRight:
  void makeBaseWritingDirectionLeftToRight(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.makeBaseWritingDirectionLeftToRight:',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_makeBaseWritingDirectionLeftToRight_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'makeBaseWritingDirectionLeftToRight:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_makeBaseWritingDirectionLeftToRight_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// makeBaseWritingDirectionNatural:
  void makeBaseWritingDirectionNatural(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.makeBaseWritingDirectionNatural:',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_makeBaseWritingDirectionNatural_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'makeBaseWritingDirectionNatural:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_makeBaseWritingDirectionNatural_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// makeBaseWritingDirectionRightToLeft:
  void makeBaseWritingDirectionRightToLeft(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.makeBaseWritingDirectionRightToLeft:',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_makeBaseWritingDirectionRightToLeft_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'makeBaseWritingDirectionRightToLeft:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_makeBaseWritingDirectionRightToLeft_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// makeTextWritingDirectionLeftToRight:
  void makeTextWritingDirectionLeftToRight(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.makeTextWritingDirectionLeftToRight:',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_makeTextWritingDirectionLeftToRight_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'makeTextWritingDirectionLeftToRight:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_makeTextWritingDirectionLeftToRight_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// makeTextWritingDirectionNatural:
  void makeTextWritingDirectionNatural(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.makeTextWritingDirectionNatural:',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_makeTextWritingDirectionNatural_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'makeTextWritingDirectionNatural:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_makeTextWritingDirectionNatural_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// makeTextWritingDirectionRightToLeft:
  void makeTextWritingDirectionRightToLeft(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.makeTextWritingDirectionRightToLeft:',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_makeTextWritingDirectionRightToLeft_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'makeTextWritingDirectionRightToLeft:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_makeTextWritingDirectionRightToLeft_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveBackward:
  void moveBackward(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.moveBackward:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_moveBackward_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveBackward:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveBackward_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveBackwardAndModifySelection:
  void moveBackwardAndModifySelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveBackwardAndModifySelection:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveBackwardAndModifySelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveBackwardAndModifySelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveBackwardAndModifySelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveDown:
  void moveDown(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.moveDown:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_moveDown_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveDown:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveDown_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveDownAndModifySelection:
  void moveDownAndModifySelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveDownAndModifySelection:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveDownAndModifySelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveDownAndModifySelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveDownAndModifySelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveForward:
  void moveForward(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.moveForward:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_moveForward_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveForward:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveForward_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveForwardAndModifySelection:
  void moveForwardAndModifySelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveForwardAndModifySelection:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveForwardAndModifySelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveForwardAndModifySelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveForwardAndModifySelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveLeft:
  void moveLeft(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.moveLeft:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_moveLeft_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveLeft:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveLeft_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveLeftAndModifySelection:
  void moveLeftAndModifySelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveLeftAndModifySelection:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveLeftAndModifySelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveLeftAndModifySelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveLeftAndModifySelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveParagraphBackwardAndModifySelection:
  void moveParagraphBackwardAndModifySelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveParagraphBackwardAndModifySelection:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveParagraphBackwardAndModifySelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveParagraphBackwardAndModifySelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveParagraphBackwardAndModifySelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveParagraphForwardAndModifySelection:
  void moveParagraphForwardAndModifySelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveParagraphForwardAndModifySelection:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveParagraphForwardAndModifySelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveParagraphForwardAndModifySelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveParagraphForwardAndModifySelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveRight:
  void moveRight(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.moveRight:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_moveRight_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveRight:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveRight_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveRightAndModifySelection:
  void moveRightAndModifySelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveRightAndModifySelection:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveRightAndModifySelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveRightAndModifySelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveRightAndModifySelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveToBeginningOfDocument:
  void moveToBeginningOfDocument(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveToBeginningOfDocument:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveToBeginningOfDocument_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveToBeginningOfDocument:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveToBeginningOfDocument_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveToBeginningOfDocumentAndModifySelection:
  void moveToBeginningOfDocumentAndModifySelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveToBeginningOfDocumentAndModifySelection:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveToBeginningOfDocumentAndModifySelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveToBeginningOfDocumentAndModifySelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveToBeginningOfDocumentAndModifySelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveToBeginningOfLine:
  void moveToBeginningOfLine(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveToBeginningOfLine:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveToBeginningOfLine_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveToBeginningOfLine:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveToBeginningOfLine_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveToBeginningOfLineAndModifySelection:
  void moveToBeginningOfLineAndModifySelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveToBeginningOfLineAndModifySelection:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveToBeginningOfLineAndModifySelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveToBeginningOfLineAndModifySelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveToBeginningOfLineAndModifySelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveToBeginningOfParagraph:
  void moveToBeginningOfParagraph(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveToBeginningOfParagraph:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveToBeginningOfParagraph_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveToBeginningOfParagraph:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveToBeginningOfParagraph_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveToBeginningOfParagraphAndModifySelection:
  void moveToBeginningOfParagraphAndModifySelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveToBeginningOfParagraphAndModifySelection:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveToBeginningOfParagraphAndModifySelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveToBeginningOfParagraphAndModifySelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveToBeginningOfParagraphAndModifySelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveToEndOfDocument:
  void moveToEndOfDocument(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveToEndOfDocument:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveToEndOfDocument_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveToEndOfDocument:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveToEndOfDocument_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveToEndOfDocumentAndModifySelection:
  void moveToEndOfDocumentAndModifySelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveToEndOfDocumentAndModifySelection:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveToEndOfDocumentAndModifySelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveToEndOfDocumentAndModifySelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveToEndOfDocumentAndModifySelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveToEndOfLine:
  void moveToEndOfLine(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveToEndOfLine:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_moveToEndOfLine_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveToEndOfLine:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveToEndOfLine_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveToEndOfLineAndModifySelection:
  void moveToEndOfLineAndModifySelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveToEndOfLineAndModifySelection:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveToEndOfLineAndModifySelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveToEndOfLineAndModifySelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveToEndOfLineAndModifySelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveToEndOfParagraph:
  void moveToEndOfParagraph(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveToEndOfParagraph:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveToEndOfParagraph_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveToEndOfParagraph:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveToEndOfParagraph_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveToEndOfParagraphAndModifySelection:
  void moveToEndOfParagraphAndModifySelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveToEndOfParagraphAndModifySelection:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveToEndOfParagraphAndModifySelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveToEndOfParagraphAndModifySelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveToEndOfParagraphAndModifySelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveToLeftEndOfLine:
  void moveToLeftEndOfLine(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveToLeftEndOfLine:',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveToLeftEndOfLine_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveToLeftEndOfLine:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveToLeftEndOfLine_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveToLeftEndOfLineAndModifySelection:
  void moveToLeftEndOfLineAndModifySelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveToLeftEndOfLineAndModifySelection:',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveToLeftEndOfLineAndModifySelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveToLeftEndOfLineAndModifySelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveToLeftEndOfLineAndModifySelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveToRightEndOfLine:
  void moveToRightEndOfLine(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveToRightEndOfLine:',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveToRightEndOfLine_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveToRightEndOfLine:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveToRightEndOfLine_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveToRightEndOfLineAndModifySelection:
  void moveToRightEndOfLineAndModifySelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveToRightEndOfLineAndModifySelection:',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveToRightEndOfLineAndModifySelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveToRightEndOfLineAndModifySelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveToRightEndOfLineAndModifySelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveUp:
  void moveUp(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.moveUp:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_moveUp_)) {
      throw objc.UnimplementedOptionalMethodException('NSResponder', 'moveUp:');
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveUp_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveUpAndModifySelection:
  void moveUpAndModifySelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveUpAndModifySelection:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveUpAndModifySelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveUpAndModifySelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveUpAndModifySelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveWordBackward:
  void moveWordBackward(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveWordBackward:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_moveWordBackward_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveWordBackward:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveWordBackward_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveWordBackwardAndModifySelection:
  void moveWordBackwardAndModifySelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveWordBackwardAndModifySelection:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveWordBackwardAndModifySelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveWordBackwardAndModifySelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveWordBackwardAndModifySelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveWordForward:
  void moveWordForward(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveWordForward:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_moveWordForward_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveWordForward:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveWordForward_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveWordForwardAndModifySelection:
  void moveWordForwardAndModifySelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveWordForwardAndModifySelection:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveWordForwardAndModifySelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveWordForwardAndModifySelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveWordForwardAndModifySelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveWordLeft:
  void moveWordLeft(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.moveWordLeft:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_moveWordLeft_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveWordLeft:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveWordLeft_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveWordLeftAndModifySelection:
  void moveWordLeftAndModifySelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveWordLeftAndModifySelection:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveWordLeftAndModifySelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveWordLeftAndModifySelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveWordLeftAndModifySelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveWordRight:
  void moveWordRight(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveWordRight:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_moveWordRight_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveWordRight:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveWordRight_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// moveWordRightAndModifySelection:
  void moveWordRightAndModifySelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.moveWordRightAndModifySelection:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_moveWordRightAndModifySelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'moveWordRightAndModifySelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_moveWordRightAndModifySelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// pageDown:
  void pageDown(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.pageDown:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_pageDown_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'pageDown:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_pageDown_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// pageDownAndModifySelection:
  void pageDownAndModifySelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.pageDownAndModifySelection:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_pageDownAndModifySelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'pageDownAndModifySelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_pageDownAndModifySelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// pageUp:
  void pageUp(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.pageUp:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_pageUp_)) {
      throw objc.UnimplementedOptionalMethodException('NSResponder', 'pageUp:');
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_pageUp_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// pageUpAndModifySelection:
  void pageUpAndModifySelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.pageUpAndModifySelection:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_pageUpAndModifySelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'pageUpAndModifySelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_pageUpAndModifySelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// quickLookPreviewItems:
  void quickLookPreviewItems(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.quickLookPreviewItems:',
      iOS: (true, null),
      macOS: (false, (10, 8, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_quickLookPreviewItems_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'quickLookPreviewItems:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_quickLookPreviewItems_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// scrollLineDown:
  void scrollLineDown(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.scrollLineDown:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_scrollLineDown_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'scrollLineDown:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_scrollLineDown_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// scrollLineUp:
  void scrollLineUp(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.scrollLineUp:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_scrollLineUp_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'scrollLineUp:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_scrollLineUp_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// scrollPageDown:
  void scrollPageDown(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.scrollPageDown:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_scrollPageDown_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'scrollPageDown:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_scrollPageDown_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// scrollPageUp:
  void scrollPageUp(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.scrollPageUp:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_scrollPageUp_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'scrollPageUp:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_scrollPageUp_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// scrollToBeginningOfDocument:
  void scrollToBeginningOfDocument(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.scrollToBeginningOfDocument:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_scrollToBeginningOfDocument_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'scrollToBeginningOfDocument:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_scrollToBeginningOfDocument_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// scrollToEndOfDocument:
  void scrollToEndOfDocument(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.scrollToEndOfDocument:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_scrollToEndOfDocument_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'scrollToEndOfDocument:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_scrollToEndOfDocument_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// selectAll:
  void selectAll(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.selectAll:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_selectAll_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'selectAll:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_selectAll_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// selectLine:
  void selectLine(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.selectLine:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_selectLine_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'selectLine:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_selectLine_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// selectParagraph:
  void selectParagraph(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.selectParagraph:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_selectParagraph_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'selectParagraph:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_selectParagraph_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// selectToMark:
  void selectToMark(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.selectToMark:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_selectToMark_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'selectToMark:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_selectToMark_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// selectWord:
  void selectWord(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.selectWord:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_selectWord_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'selectWord:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_selectWord_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setMark:
  void setMark(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.setMark:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_setMark_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'setMark:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMark_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// showContextMenuForSelection:
  void showContextMenuForSelection(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.showContextMenuForSelection:',
      iOS: (true, null),
      macOS: (false, (15, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_showContextMenuForSelection_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'showContextMenuForSelection:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_showContextMenuForSelection_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// swapWithMark:
  void swapWithMark(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.swapWithMark:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_swapWithMark_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'swapWithMark:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_swapWithMark_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// transpose:
  void transpose(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.transpose:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_transpose_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'transpose:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_transpose_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// transposeWords:
  void transposeWords(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.transposeWords:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_transposeWords_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'transposeWords:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_transposeWords_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// uppercaseWord:
  void uppercaseWord(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.uppercaseWord:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_uppercaseWord_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSResponder',
        'uppercaseWord:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_uppercaseWord_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// yank:
  void yank(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSResponder.yank:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_yank_)) {
      throw objc.UnimplementedOptionalMethodException('NSResponder', 'yank:');
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_yank_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }
}

late final _sel_undoManager = objc.registerName("undoManager");

/// NSUndoSupport
extension NSUndoSupport on NSResponder {
  /// undoManager
  NSUndoManager? get undoManager {
    objc.checkOsVersionInternal('NSResponder.undoManager', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_undoManager);
    return $ret.address == 0
        ? null
        : NSUndoManager.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_validateProposedFirstResponder_forEvent_ = objc.registerName(
  "validateProposedFirstResponder:forEvent:",
);
final _objc_msgSend_1lsax7n = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// NSControlEditingSupport
extension NSControlEditingSupport on NSResponder {
  /// validateProposedFirstResponder:forEvent:
  bool validateProposedFirstResponder(
    NSResponder responder, {
    NSEvent? forEvent,
  }) {
    objc.checkOsVersionInternal(
      'NSResponder.validateProposedFirstResponder:forEvent:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_1lsax7n(
      object$.ref.pointer,
      _sel_validateProposedFirstResponder_forEvent_,
      responder.ref.pointer,
      forEvent?.ref.pointer ?? ffi.nullptr,
    );
  }
}

/// WARNING: NSWindow is a stub. To generate bindings for this class, include
/// NSWindow in your config's objc-interfaces list.
///
/// NSWindow
extension type NSWindow._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        NSResponder,
        NSAnimatablePropertyContainer,
        NSMenuItemValidation,
        NSUserInterfaceValidations,
        NSUserInterfaceItemIdentification,
        NSAppearanceCustomization,
        NSAccessibilityElement,
        NSAccessibility {
  /// Constructs a [NSWindow] that points to the same underlying object as [other].
  NSWindow.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSWindow', iOS: (true, null));
  }

  /// Constructs a [NSWindow] that wraps the given raw object pointer.
  NSWindow.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSWindow', iOS: (true, null));
  }
}

late final _sel_presentError_modalForWindow_delegate_didPresentSelector_contextInfo_ =
    objc.registerName(
      "presentError:modalForWindow:delegate:didPresentSelector:contextInfo:",
    );
final _objc_msgSend_1k1rf1w = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Void>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Void>,
      )
    >();
late final _sel_presentError_ = objc.registerName("presentError:");
late final _sel_willPresentError_ = objc.registerName("willPresentError:");

/// NSErrorPresentation
extension NSErrorPresentation on NSResponder {
  /// presentError:
  bool presentError(objc.NSError error) {
    objc.checkOsVersionInternal('NSResponder.presentError:', iOS: (true, null));
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_presentError_,
      error.ref.pointer,
    );
  }

  /// presentError:modalForWindow:delegate:didPresentSelector:contextInfo:
  void presentError$1(
    objc.NSError error, {
    required NSWindow modalForWindow,
    objc.ObjCObject? delegate,
    required ffi.Pointer<objc.ObjCSelector> didPresentSelector,
    required ffi.Pointer<ffi.Void> contextInfo,
  }) {
    objc.checkOsVersionInternal(
      'NSResponder.presentError:modalForWindow:delegate:didPresentSelector:contextInfo:',
      iOS: (true, null),
    );
    _objc_msgSend_1k1rf1w(
      object$.ref.pointer,
      _sel_presentError_modalForWindow_delegate_didPresentSelector_contextInfo_,
      error.ref.pointer,
      modalForWindow.ref.pointer,
      delegate?.ref.pointer ?? ffi.nullptr,
      didPresentSelector,
      contextInfo,
    );
  }

  /// willPresentError:
  objc.NSError willPresentError(objc.NSError error) {
    objc.checkOsVersionInternal(
      'NSResponder.willPresentError:',
      iOS: (true, null),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_willPresentError_,
      error.ref.pointer,
    );
    return objc.NSError.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_performTextFinderAction_ = objc.registerName(
  "performTextFinderAction:",
);

/// NSTextFinderSupport
extension NSTextFinderSupport on NSResponder {
  /// performTextFinderAction:
  void performTextFinderAction(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.performTextFinderAction:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_performTextFinderAction_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }
}

late final _sel_newWindowForTab_ = objc.registerName("newWindowForTab:");

/// NSWindowTabbing
extension NSWindowTabbing on NSResponder {
  /// newWindowForTab:
  void newWindowForTab(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.newWindowForTab:',
      iOS: (true, null),
      macOS: (false, (10, 12, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_newWindowForTab_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }
}

late final _sel_showWritingTools_ = objc.registerName("showWritingTools:");

/// NSWritingToolsSupport
extension NSWritingToolsSupport on NSResponder {
  /// showWritingTools:
  void showWritingTools(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.showWritingTools:',
      iOS: (true, null),
      macOS: (false, (15, 2, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_showWritingTools_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }
}

late final _sel_performMnemonic_ = objc.registerName("performMnemonic:");

/// NSDeprecated
extension NSDeprecated on NSResponder {
  /// performMnemonic:
  bool performMnemonic(objc.NSString string) {
    objc.checkOsVersionInternal(
      'NSResponder.performMnemonic:',
      iOS: (true, null),
      macOS: (false, (10, 0, 0)),
    );
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_performMnemonic_,
      string.ref.pointer,
    );
  }
}

late final _sel_userActivity = objc.registerName("userActivity");
late final _sel_setUserActivity_ = objc.registerName("setUserActivity:");
late final _sel_updateUserActivityState_ = objc.registerName(
  "updateUserActivityState:",
);
late final _sel_restoreUserActivityState_ = objc.registerName(
  "restoreUserActivityState:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity$1)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSUserActivity {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity$1)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity$1)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity$1)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity$1)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity$1)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, NSUserActivity$1) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity$1)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                NSUserActivity$1.fromPointer(arg1, retain: true, release: true),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity$1)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, NSUserActivity$1) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        NSUserActivity$1.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity$1)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity$1)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, NSUserActivity$1) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        NSUserActivity$1.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        NSUserActivity$1.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity$1)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity$1)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSUserActivity$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity$1)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, NSUserActivity$1 arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// WARNING: NSUserActivityRestoring is a stub. To generate bindings for this class, include
/// NSUserActivityRestoring in your config's objc-protocols list.
///
/// NSUserActivityRestoring
extension type NSUserActivityRestoring._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [NSUserActivityRestoring] that points to the same underlying object as [other].
  NSUserActivityRestoring.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSUserActivityRestoring] that wraps the given raw object pointer.
  NSUserActivityRestoring.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// NSUserActivity
extension NSUserActivity on NSResponder {
  /// restoreUserActivityState:
  void restoreUserActivityState(NSUserActivity$1 userActivity) {
    objc.checkOsVersionInternal(
      'NSResponder.restoreUserActivityState:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_restoreUserActivityState_,
      userActivity.ref.pointer,
    );
  }

  /// setUserActivity:
  set userActivity(NSUserActivity$1? value) {
    objc.checkOsVersionInternal(
      'NSResponder.setUserActivity:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setUserActivity_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// updateUserActivityState:
  void updateUserActivityState(NSUserActivity$1 userActivity) {
    objc.checkOsVersionInternal(
      'NSResponder.updateUserActivityState:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_updateUserActivityState_,
      userActivity.ref.pointer,
    );
  }

  /// userActivity
  NSUserActivity$1? get userActivity {
    objc.checkOsVersionInternal(
      'NSResponder.userActivity',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_userActivity);
    return $ret.address == 0
        ? null
        : NSUserActivity$1.fromPointer($ret, retain: true, release: true);
  }
}

/// WARNING: NSTouchBar is a stub. To generate bindings for this class, include
/// NSTouchBar in your config's objc-interfaces list.
///
/// NSTouchBar
extension type NSTouchBar._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCoding {
  /// Constructs a [NSTouchBar] that points to the same underlying object as [other].
  NSTouchBar.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSTouchBar',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 12, 2)),
    );
  }

  /// Constructs a [NSTouchBar] that wraps the given raw object pointer.
  NSTouchBar.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSTouchBar',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 12, 2)),
    );
  }
}

late final _sel_touchBar = objc.registerName("touchBar");

/// Construction methods for `objc.ObjCBlock<NSTouchBar? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSTouchBar_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<NSTouchBar? Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<NSTouchBar? Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<NSTouchBar? Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<NSTouchBar? Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<NSTouchBar? Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    NSTouchBar? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<NSTouchBar? Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) =>
          fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<NSTouchBar? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSTouchBar_ffiVoid$CallExtension
    on objc.ObjCBlock<NSTouchBar? Function(ffi.Pointer<ffi.Void>)> {
  NSTouchBar? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : NSTouchBar.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_setTouchBar_ = objc.registerName("setTouchBar:");
late final _sel_makeTouchBar = objc.registerName("makeTouchBar");

/// WARNING: NSTouchBarProvider$1 is a stub. To generate bindings for this class, include
/// NSTouchBarProvider in your config's objc-protocols list.
///
/// NSTouchBarProvider
extension type NSTouchBarProvider$1._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [NSTouchBarProvider$1] that points to the same underlying object as [other].
  NSTouchBarProvider$1.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSTouchBarProvider$1] that wraps the given raw object pointer.
  NSTouchBarProvider$1.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// NSTouchBarProvider
extension NSTouchBarProvider on NSResponder {
  /// makeTouchBar
  NSTouchBar? makeTouchBar() {
    objc.checkOsVersionInternal(
      'NSResponder.makeTouchBar',
      macOS: (false, (10, 12, 2)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_makeTouchBar);
    return $ret.address == 0
        ? null
        : NSTouchBar.fromPointer($ret, retain: true, release: true);
  }

  /// setTouchBar:
  set touchBar(NSTouchBar? value) {
    objc.checkOsVersionInternal(
      'NSResponder.setTouchBar:',
      macOS: (false, (10, 12, 2)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setTouchBar_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// touchBar
  NSTouchBar? get touchBar$1 {
    objc.checkOsVersionInternal(
      'NSResponder.touchBar',
      macOS: (false, (10, 12, 2)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_touchBar);
    return $ret.address == 0
        ? null
        : NSTouchBar.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_interfaceStyle = objc.registerName("interfaceStyle");
final _objc_msgSend_xw2lbc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setInterfaceStyle_ = objc.registerName("setInterfaceStyle:");
final _objc_msgSend_1i9r4xy = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// NSInterfaceStyle
extension NSInterfaceStyle on NSResponder {
  /// interfaceStyle
  int interfaceStyle() {
    objc.checkOsVersionInternal(
      'NSResponder.interfaceStyle',
      iOS: (true, null),
      macOS: (false, (10, 0, 0)),
    );
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_interfaceStyle);
  }

  /// setInterfaceStyle:
  void setInterfaceStyle(int interfaceStyle) {
    objc.checkOsVersionInternal(
      'NSResponder.setInterfaceStyle:',
      iOS: (true, null),
      macOS: (false, (10, 0, 0)),
    );
    _objc_msgSend_1i9r4xy(
      object$.ref.pointer,
      _sel_setInterfaceStyle_,
      interfaceStyle,
    );
  }
}

late final _sel_encodeRestorableStateWithCoder_ = objc.registerName(
  "encodeRestorableStateWithCoder:",
);
late final _sel_encodeRestorableStateWithCoder_backgroundQueue_ = objc
    .registerName("encodeRestorableStateWithCoder:backgroundQueue:");
final _objc_msgSend_pfv6jd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_restoreStateWithCoder_ = objc.registerName(
  "restoreStateWithCoder:",
);
late final _sel_invalidateRestorableState = objc.registerName(
  "invalidateRestorableState",
);
late final _sel_restorableStateKeyPaths = objc.registerName(
  "restorableStateKeyPaths",
);
late final _sel_allowedClassesForRestorableStateKeyPath_ = objc.registerName(
  "allowedClassesForRestorableStateKeyPath:",
);

/// NSRestorableState
extension NSRestorableState on NSResponder {
  /// encodeRestorableStateWithCoder:
  void encodeRestorableStateWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal(
      'NSResponder.encodeRestorableStateWithCoder:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_encodeRestorableStateWithCoder_,
      coder.ref.pointer,
    );
  }

  /// encodeRestorableStateWithCoder:backgroundQueue:
  void encodeRestorableStateWithCoder$1(
    objc.NSCoder coder, {
    required NSOperationQueue backgroundQueue,
  }) {
    objc.checkOsVersionInternal(
      'NSResponder.encodeRestorableStateWithCoder:backgroundQueue:',
      iOS: (true, null),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_encodeRestorableStateWithCoder_backgroundQueue_,
      coder.ref.pointer,
      backgroundQueue.ref.pointer,
    );
  }

  /// invalidateRestorableState
  void invalidateRestorableState() {
    objc.checkOsVersionInternal(
      'NSResponder.invalidateRestorableState',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_invalidateRestorableState);
  }

  /// restoreStateWithCoder:
  void restoreStateWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal(
      'NSResponder.restoreStateWithCoder:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_restoreStateWithCoder_,
      coder.ref.pointer,
    );
  }

  /// allowedClassesForRestorableStateKeyPath:
  static objc.NSArray allowedClassesForRestorableStateKeyPath(
    objc.NSString keyPath,
  ) {
    objc.checkOsVersionInternal(
      'NSResponder.allowedClassesForRestorableStateKeyPath:',
      iOS: (true, null),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSResponder,
      _sel_allowedClassesForRestorableStateKeyPath_,
      keyPath.ref.pointer,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// restorableStateKeyPaths
  static objc.NSArray getRestorableStateKeyPaths() {
    objc.checkOsVersionInternal(
      'NSResponder.restorableStateKeyPaths',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _class_NSResponder,
      _sel_restorableStateKeyPaths,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
}

/// NSResponder
extension type NSResponder._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCoding {
  /// Constructs a [NSResponder] that points to the same underlying object as [other].
  NSResponder.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSResponder', iOS: (true, null));
    assert(isA(object$));
  }

  /// Constructs a [NSResponder] that wraps the given raw object pointer.
  NSResponder.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSResponder', iOS: (true, null));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NSResponder].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NSResponder,
  );

  /// alloc
  static NSResponder alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSResponder, _sel_alloc);
    return NSResponder.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSResponder allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSResponder,
      _sel_allocWithZone_,
      zone,
    );
    return NSResponder.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSResponder new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSResponder, _sel_new);
    return NSResponder.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of NSResponder constructed with the default `new` method.
  NSResponder() : this.as(new$().object$);
}

extension NSResponder$Methods on NSResponder {
  /// acceptsFirstResponder
  bool get acceptsFirstResponder {
    objc.checkOsVersionInternal(
      'NSResponder.acceptsFirstResponder',
      iOS: (true, null),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_acceptsFirstResponder,
    );
  }

  /// becomeFirstResponder
  bool becomeFirstResponder() {
    objc.checkOsVersionInternal(
      'NSResponder.becomeFirstResponder',
      iOS: (true, null),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_becomeFirstResponder);
  }

  /// beginGestureWithEvent:
  void beginGestureWithEvent(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.beginGestureWithEvent:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_beginGestureWithEvent_,
      event.ref.pointer,
    );
  }

  /// changeModeWithEvent:
  void changeModeWithEvent(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.changeModeWithEvent:',
      iOS: (true, null),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_changeModeWithEvent_,
      event.ref.pointer,
    );
  }

  /// contextMenuKeyDown:
  void contextMenuKeyDown(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.contextMenuKeyDown:',
      iOS: (true, null),
      macOS: (false, (15, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_contextMenuKeyDown_,
      event.ref.pointer,
    );
  }

  /// cursorUpdate:
  void cursorUpdate(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.cursorUpdate:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_cursorUpdate_,
      event.ref.pointer,
    );
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// endGestureWithEvent:
  void endGestureWithEvent(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.endGestureWithEvent:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_endGestureWithEvent_,
      event.ref.pointer,
    );
  }

  /// flagsChanged:
  void flagsChanged(NSEvent event) {
    objc.checkOsVersionInternal('NSResponder.flagsChanged:', iOS: (true, null));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_flagsChanged_,
      event.ref.pointer,
    );
  }

  /// flushBufferedKeyEvents
  void flushBufferedKeyEvents() {
    objc.checkOsVersionInternal(
      'NSResponder.flushBufferedKeyEvents',
      iOS: (true, null),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_flushBufferedKeyEvents);
  }

  /// helpRequested:
  void helpRequested(NSEvent eventPtr) {
    objc.checkOsVersionInternal(
      'NSResponder.helpRequested:',
      iOS: (true, null),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_helpRequested_,
      eventPtr.ref.pointer,
    );
  }

  /// init
  NSResponder init() {
    objc.checkOsVersionInternal(
      'NSResponder.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSResponder.fromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSResponder? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSResponder.fromPointer($ret, retain: false, release: true);
  }

  /// interpretKeyEvents:
  void interpretKeyEvents(objc.NSArray eventArray) {
    objc.checkOsVersionInternal(
      'NSResponder.interpretKeyEvents:',
      iOS: (true, null),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_interpretKeyEvents_,
      eventArray.ref.pointer,
    );
  }

  /// keyDown:
  void keyDown(NSEvent event) {
    objc.checkOsVersionInternal('NSResponder.keyDown:', iOS: (true, null));
    _objc_msgSend_xtuoz7(object$.ref.pointer, _sel_keyDown_, event.ref.pointer);
  }

  /// keyUp:
  void keyUp(NSEvent event) {
    objc.checkOsVersionInternal('NSResponder.keyUp:', iOS: (true, null));
    _objc_msgSend_xtuoz7(object$.ref.pointer, _sel_keyUp_, event.ref.pointer);
  }

  /// magnifyWithEvent:
  void magnifyWithEvent(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.magnifyWithEvent:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_magnifyWithEvent_,
      event.ref.pointer,
    );
  }

  /// menu
  NSMenu? get menu {
    objc.checkOsVersionInternal('NSResponder.menu', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_menu);
    return $ret.address == 0
        ? null
        : NSMenu.fromPointer($ret, retain: true, release: true);
  }

  /// mouseCancelled:
  void mouseCancelled(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.mouseCancelled:',
      iOS: (true, null),
      macOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_mouseCancelled_,
      event.ref.pointer,
    );
  }

  /// mouseDown:
  void mouseDown(NSEvent event) {
    objc.checkOsVersionInternal('NSResponder.mouseDown:', iOS: (true, null));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_mouseDown_,
      event.ref.pointer,
    );
  }

  /// mouseDragged:
  void mouseDragged(NSEvent event) {
    objc.checkOsVersionInternal('NSResponder.mouseDragged:', iOS: (true, null));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_mouseDragged_,
      event.ref.pointer,
    );
  }

  /// mouseEntered:
  void mouseEntered(NSEvent event) {
    objc.checkOsVersionInternal('NSResponder.mouseEntered:', iOS: (true, null));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_mouseEntered_,
      event.ref.pointer,
    );
  }

  /// mouseExited:
  void mouseExited(NSEvent event) {
    objc.checkOsVersionInternal('NSResponder.mouseExited:', iOS: (true, null));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_mouseExited_,
      event.ref.pointer,
    );
  }

  /// mouseMoved:
  void mouseMoved(NSEvent event) {
    objc.checkOsVersionInternal('NSResponder.mouseMoved:', iOS: (true, null));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_mouseMoved_,
      event.ref.pointer,
    );
  }

  /// mouseUp:
  void mouseUp(NSEvent event) {
    objc.checkOsVersionInternal('NSResponder.mouseUp:', iOS: (true, null));
    _objc_msgSend_xtuoz7(object$.ref.pointer, _sel_mouseUp_, event.ref.pointer);
  }

  /// nextResponder
  NSResponder? get nextResponder {
    objc.checkOsVersionInternal('NSResponder.nextResponder', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_nextResponder);
    return $ret.address == 0
        ? null
        : NSResponder.fromPointer($ret, retain: true, release: true);
  }

  /// noResponderFor:
  void noResponderFor(ffi.Pointer<objc.ObjCSelector> eventSelector) {
    objc.checkOsVersionInternal(
      'NSResponder.noResponderFor:',
      iOS: (true, null),
    );
    _objc_msgSend_1d9e4oe(
      object$.ref.pointer,
      _sel_noResponderFor_,
      eventSelector,
    );
  }

  /// otherMouseDown:
  void otherMouseDown(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.otherMouseDown:',
      iOS: (true, null),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_otherMouseDown_,
      event.ref.pointer,
    );
  }

  /// otherMouseDragged:
  void otherMouseDragged(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.otherMouseDragged:',
      iOS: (true, null),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_otherMouseDragged_,
      event.ref.pointer,
    );
  }

  /// otherMouseUp:
  void otherMouseUp(NSEvent event) {
    objc.checkOsVersionInternal('NSResponder.otherMouseUp:', iOS: (true, null));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_otherMouseUp_,
      event.ref.pointer,
    );
  }

  /// performKeyEquivalent:
  bool performKeyEquivalent(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.performKeyEquivalent:',
      iOS: (true, null),
    );
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_performKeyEquivalent_,
      event.ref.pointer,
    );
  }

  /// pressureChangeWithEvent:
  void pressureChangeWithEvent(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.pressureChangeWithEvent:',
      iOS: (true, null),
      macOS: (false, (10, 10, 3)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_pressureChangeWithEvent_,
      event.ref.pointer,
    );
  }

  /// quickLookWithEvent:
  void quickLookWithEvent(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.quickLookWithEvent:',
      iOS: (true, null),
      macOS: (false, (10, 8, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_quickLookWithEvent_,
      event.ref.pointer,
    );
  }

  /// resignFirstResponder
  bool resignFirstResponder() {
    objc.checkOsVersionInternal(
      'NSResponder.resignFirstResponder',
      iOS: (true, null),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_resignFirstResponder);
  }

  /// rightMouseDown:
  void rightMouseDown(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.rightMouseDown:',
      iOS: (true, null),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_rightMouseDown_,
      event.ref.pointer,
    );
  }

  /// rightMouseDragged:
  void rightMouseDragged(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.rightMouseDragged:',
      iOS: (true, null),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_rightMouseDragged_,
      event.ref.pointer,
    );
  }

  /// rightMouseUp:
  void rightMouseUp(NSEvent event) {
    objc.checkOsVersionInternal('NSResponder.rightMouseUp:', iOS: (true, null));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_rightMouseUp_,
      event.ref.pointer,
    );
  }

  /// rotateWithEvent:
  void rotateWithEvent(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.rotateWithEvent:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_rotateWithEvent_,
      event.ref.pointer,
    );
  }

  /// scrollWheel:
  void scrollWheel(NSEvent event) {
    objc.checkOsVersionInternal('NSResponder.scrollWheel:', iOS: (true, null));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_scrollWheel_,
      event.ref.pointer,
    );
  }

  /// setMenu:
  set menu(NSMenu? value) {
    objc.checkOsVersionInternal('NSResponder.setMenu:', iOS: (true, null));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMenu_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setNextResponder:
  set nextResponder(NSResponder? value) {
    objc.checkOsVersionInternal(
      'NSResponder.setNextResponder:',
      iOS: (true, null),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setNextResponder_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// shouldBeTreatedAsInkEvent:
  bool shouldBeTreatedAsInkEvent(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.shouldBeTreatedAsInkEvent:',
      iOS: (true, null),
    );
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_shouldBeTreatedAsInkEvent_,
      event.ref.pointer,
    );
  }

  /// showContextHelp:
  void showContextHelp(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'NSResponder.showContextHelp:',
      iOS: (true, null),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_showContextHelp_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// smartMagnifyWithEvent:
  void smartMagnifyWithEvent(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.smartMagnifyWithEvent:',
      iOS: (true, null),
      macOS: (false, (10, 8, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_smartMagnifyWithEvent_,
      event.ref.pointer,
    );
  }

  /// supplementalTargetForAction:sender:
  objc.ObjCObject? supplementalTargetForAction(
    ffi.Pointer<objc.ObjCSelector> action, {
    objc.ObjCObject? sender,
  }) {
    objc.checkOsVersionInternal(
      'NSResponder.supplementalTargetForAction:sender:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_gx50so(
      object$.ref.pointer,
      _sel_supplementalTargetForAction_sender_,
      action,
      sender?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// swipeWithEvent:
  void swipeWithEvent(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.swipeWithEvent:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_swipeWithEvent_,
      event.ref.pointer,
    );
  }

  /// tabletPoint:
  void tabletPoint(NSEvent event) {
    objc.checkOsVersionInternal('NSResponder.tabletPoint:', iOS: (true, null));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_tabletPoint_,
      event.ref.pointer,
    );
  }

  /// tabletProximity:
  void tabletProximity(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.tabletProximity:',
      iOS: (true, null),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_tabletProximity_,
      event.ref.pointer,
    );
  }

  /// touchesBeganWithEvent:
  void touchesBeganWithEvent(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.touchesBeganWithEvent:',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_touchesBeganWithEvent_,
      event.ref.pointer,
    );
  }

  /// touchesCancelledWithEvent:
  void touchesCancelledWithEvent(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.touchesCancelledWithEvent:',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_touchesCancelledWithEvent_,
      event.ref.pointer,
    );
  }

  /// touchesEndedWithEvent:
  void touchesEndedWithEvent(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.touchesEndedWithEvent:',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_touchesEndedWithEvent_,
      event.ref.pointer,
    );
  }

  /// touchesMovedWithEvent:
  void touchesMovedWithEvent(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSResponder.touchesMovedWithEvent:',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_touchesMovedWithEvent_,
      event.ref.pointer,
    );
  }

  /// tryToPerform:with:
  bool tryToPerform(
    ffi.Pointer<objc.ObjCSelector> action, {
    objc.ObjCObject? with$,
  }) {
    objc.checkOsVersionInternal(
      'NSResponder.tryToPerform:with:',
      iOS: (true, null),
    );
    return _objc_msgSend_1f04296(
      object$.ref.pointer,
      _sel_tryToPerform_with_,
      action,
      with$?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// validRequestorForSendType:returnType:
  objc.ObjCObject? validRequestorForSendType(
    objc.NSString? sendType, {
    objc.NSString? returnType,
  }) {
    objc.checkOsVersionInternal(
      'NSResponder.validRequestorForSendType:returnType:',
      iOS: (true, null),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_validRequestorForSendType_returnType_,
      sendType?.ref.pointer ?? ffi.nullptr,
      returnType?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// wantsForwardedScrollEventsForAxis:
  bool wantsForwardedScrollEventsForAxis(NSEventGestureAxis axis) {
    objc.checkOsVersionInternal(
      'NSResponder.wantsForwardedScrollEventsForAxis:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_s1vka0(
      object$.ref.pointer,
      _sel_wantsForwardedScrollEventsForAxis_,
      axis.value,
    );
  }

  /// wantsScrollEventsForSwipeTrackingOnAxis:
  bool wantsScrollEventsForSwipeTrackingOnAxis(NSEventGestureAxis axis) {
    objc.checkOsVersionInternal(
      'NSResponder.wantsScrollEventsForSwipeTrackingOnAxis:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_s1vka0(
      object$.ref.pointer,
      _sel_wantsScrollEventsForSwipeTrackingOnAxis_,
      axis.value,
    );
  }
}

enum NSUserInterfaceLayoutDirection {
  NSUserInterfaceLayoutDirectionLeftToRight(0),
  NSUserInterfaceLayoutDirectionRightToLeft(1);

  final int value;
  const NSUserInterfaceLayoutDirection(this.value);

  static NSUserInterfaceLayoutDirection fromValue(int value) => switch (value) {
    0 => NSUserInterfaceLayoutDirectionLeftToRight,
    1 => NSUserInterfaceLayoutDirectionRightToLeft,
    _ => throw ArgumentError(
      'Unknown value for NSUserInterfaceLayoutDirection: $value',
    ),
  };
}

sealed class NSAutoresizingMaskOptions {
  static const NSViewNotSizable = 0;
  static const NSViewMinXMargin = 1;
  static const NSViewWidthSizable = 2;
  static const NSViewMaxXMargin = 4;
  static const NSViewMinYMargin = 8;
  static const NSViewHeightSizable = 16;
  static const NSViewMaxYMargin = 32;
}

enum NSBorderType {
  NSNoBorder(0),
  NSLineBorder(1),
  NSBezelBorder(2),
  NSGrooveBorder(3);

  final int value;
  const NSBorderType(this.value);

  static NSBorderType fromValue(int value) => switch (value) {
    0 => NSNoBorder,
    1 => NSLineBorder,
    2 => NSBezelBorder,
    3 => NSGrooveBorder,
    _ => throw ArgumentError('Unknown value for NSBorderType: $value'),
  };
}

enum NSViewLayerContentsRedrawPolicy {
  NSViewLayerContentsRedrawNever(0),
  NSViewLayerContentsRedrawOnSetNeedsDisplay(1),
  NSViewLayerContentsRedrawDuringViewResize(2),
  NSViewLayerContentsRedrawBeforeViewResize(3),
  NSViewLayerContentsRedrawCrossfade(4);

  final int value;
  const NSViewLayerContentsRedrawPolicy(this.value);

  static NSViewLayerContentsRedrawPolicy fromValue(int value) =>
      switch (value) {
        0 => NSViewLayerContentsRedrawNever,
        1 => NSViewLayerContentsRedrawOnSetNeedsDisplay,
        2 => NSViewLayerContentsRedrawDuringViewResize,
        3 => NSViewLayerContentsRedrawBeforeViewResize,
        4 => NSViewLayerContentsRedrawCrossfade,
        _ => throw ArgumentError(
          'Unknown value for NSViewLayerContentsRedrawPolicy: $value',
        ),
      };
}

enum NSViewLayerContentsPlacement {
  NSViewLayerContentsPlacementScaleAxesIndependently(0),
  NSViewLayerContentsPlacementScaleProportionallyToFit(1),
  NSViewLayerContentsPlacementScaleProportionallyToFill(2),
  NSViewLayerContentsPlacementCenter(3),
  NSViewLayerContentsPlacementTop(4),
  NSViewLayerContentsPlacementTopRight(5),
  NSViewLayerContentsPlacementRight(6),
  NSViewLayerContentsPlacementBottomRight(7),
  NSViewLayerContentsPlacementBottom(8),
  NSViewLayerContentsPlacementBottomLeft(9),
  NSViewLayerContentsPlacementLeft(10),
  NSViewLayerContentsPlacementTopLeft(11);

  final int value;
  const NSViewLayerContentsPlacement(this.value);

  static NSViewLayerContentsPlacement fromValue(int value) => switch (value) {
    0 => NSViewLayerContentsPlacementScaleAxesIndependently,
    1 => NSViewLayerContentsPlacementScaleProportionallyToFit,
    2 => NSViewLayerContentsPlacementScaleProportionallyToFill,
    3 => NSViewLayerContentsPlacementCenter,
    4 => NSViewLayerContentsPlacementTop,
    5 => NSViewLayerContentsPlacementTopRight,
    6 => NSViewLayerContentsPlacementRight,
    7 => NSViewLayerContentsPlacementBottomRight,
    8 => NSViewLayerContentsPlacementBottom,
    9 => NSViewLayerContentsPlacementBottomLeft,
    10 => NSViewLayerContentsPlacementLeft,
    11 => NSViewLayerContentsPlacementTopLeft,
    _ => throw ArgumentError(
      'Unknown value for NSViewLayerContentsPlacement: $value',
    ),
  };
}

late final _class_NSView = objc.getClass("NSView");
late final _sel_initWithFrame_ = objc.registerName("initWithFrame:");
final _objc_msgSend_15yz4e6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
      )
    >();
late final _sel_window = objc.registerName("window");
late final _sel_superview = objc.registerName("superview");
late final _sel_subviews = objc.registerName("subviews");
late final _sel_setSubviews_ = objc.registerName("setSubviews:");
late final _sel_isDescendantOf_ = objc.registerName("isDescendantOf:");
late final _sel_ancestorSharedWithView_ = objc.registerName(
  "ancestorSharedWithView:",
);
late final _sel_opaqueAncestor = objc.registerName("opaqueAncestor");
late final _sel_isHidden = objc.registerName("isHidden");
late final _sel_setHidden_ = objc.registerName("setHidden:");
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
      )
    >();
late final _sel_isHiddenOrHasHiddenAncestor = objc.registerName(
  "isHiddenOrHasHiddenAncestor",
);
late final _sel_getRectsBeingDrawn_count_ = objc.registerName(
  "getRectsBeingDrawn:count:",
);
final _objc_msgSend_1e6ypoe = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Pointer<objc.CGRect>>,
          ffi.Pointer<ffi.Long>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Pointer<objc.CGRect>>,
        ffi.Pointer<ffi.Long>,
      )
    >();
late final _sel_needsToDrawRect_ = objc.registerName("needsToDrawRect:");
final _objc_msgSend_fcioro = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
      )
    >();
late final _sel_wantsDefaultClipping = objc.registerName(
  "wantsDefaultClipping",
);
late final _sel_viewDidHide = objc.registerName("viewDidHide");
late final _sel_viewDidUnhide = objc.registerName("viewDidUnhide");
late final _sel_addSubview_ = objc.registerName("addSubview:");
late final _sel_addSubview_positioned_relativeTo_ = objc.registerName(
  "addSubview:positioned:relativeTo:",
);
final _objc_msgSend_2y3j65 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_sortSubviewsUsingFunction_context_ = objc.registerName(
  "sortSubviewsUsingFunction:context:",
);
final _objc_msgSend_11nb6m0 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<
            ffi.NativeFunction<
              ffi.Long Function(
                ffi.Pointer<objc.ObjCObjectImpl>,
                ffi.Pointer<objc.ObjCObjectImpl>,
                ffi.Pointer<ffi.Void>,
              )
            >
          >,
          ffi.Pointer<ffi.Void>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<
          ffi.NativeFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >
        >,
        ffi.Pointer<ffi.Void>,
      )
    >();
late final _sel_viewWillMoveToWindow_ = objc.registerName(
  "viewWillMoveToWindow:",
);
late final _sel_viewDidMoveToWindow = objc.registerName("viewDidMoveToWindow");
late final _sel_viewWillMoveToSuperview_ = objc.registerName(
  "viewWillMoveToSuperview:",
);
late final _sel_viewDidMoveToSuperview = objc.registerName(
  "viewDidMoveToSuperview",
);
late final _sel_didAddSubview_ = objc.registerName("didAddSubview:");
late final _sel_willRemoveSubview_ = objc.registerName("willRemoveSubview:");
late final _sel_removeFromSuperview = objc.registerName("removeFromSuperview");
late final _sel_replaceSubview_with_ = objc.registerName(
  "replaceSubview:with:",
);
late final _sel_removeFromSuperviewWithoutNeedingDisplay = objc.registerName(
  "removeFromSuperviewWithoutNeedingDisplay",
);
late final _sel_viewDidChangeBackingProperties = objc.registerName(
  "viewDidChangeBackingProperties",
);
late final _sel_postsFrameChangedNotifications = objc.registerName(
  "postsFrameChangedNotifications",
);
late final _sel_setPostsFrameChangedNotifications_ = objc.registerName(
  "setPostsFrameChangedNotifications:",
);
late final _sel_resizeSubviewsWithOldSize_ = objc.registerName(
  "resizeSubviewsWithOldSize:",
);
final _objc_msgSend_13lgpwz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGSize,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGSize,
      )
    >();
late final _sel_resizeWithOldSuperviewSize_ = objc.registerName(
  "resizeWithOldSuperviewSize:",
);
late final _sel_autoresizesSubviews = objc.registerName("autoresizesSubviews");
late final _sel_setAutoresizesSubviews_ = objc.registerName(
  "setAutoresizesSubviews:",
);
late final _sel_autoresizingMask = objc.registerName("autoresizingMask");
final _objc_msgSend_1stg510 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setAutoresizingMask_ = objc.registerName(
  "setAutoresizingMask:",
);
final _objc_msgSend_1scx73y = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_setFrameOrigin_ = objc.registerName("setFrameOrigin:");
final _objc_msgSend_iy8iz6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
      )
    >();
late final _sel_setFrameSize_ = objc.registerName("setFrameSize:");
late final _sel_frame = objc.registerName("frame");
final _objc_msgSend_bu1hbw = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_bu1hbwStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setFrame_ = objc.registerName("setFrame:");
final _objc_msgSend_1okkq16 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
      )
    >();
late final _sel_frameRotation = objc.registerName("frameRotation");
late final _sel_setFrameRotation_ = objc.registerName("setFrameRotation:");
final _objc_msgSend_hwm8nu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
      )
    >();
late final _sel_frameCenterRotation = objc.registerName("frameCenterRotation");
late final _sel_setFrameCenterRotation_ = objc.registerName(
  "setFrameCenterRotation:",
);
late final _sel_setBoundsOrigin_ = objc.registerName("setBoundsOrigin:");
late final _sel_setBoundsSize_ = objc.registerName("setBoundsSize:");
late final _sel_boundsRotation = objc.registerName("boundsRotation");
late final _sel_setBoundsRotation_ = objc.registerName("setBoundsRotation:");
late final _sel_translateOriginToPoint_ = objc.registerName(
  "translateOriginToPoint:",
);
late final _sel_scaleUnitSquareToSize_ = objc.registerName(
  "scaleUnitSquareToSize:",
);
late final _sel_rotateByAngle_ = objc.registerName("rotateByAngle:");
late final _sel_bounds = objc.registerName("bounds");
late final _sel_setBounds_ = objc.registerName("setBounds:");
late final _sel_isFlipped = objc.registerName("isFlipped");
late final _sel_isRotatedFromBase = objc.registerName("isRotatedFromBase");
late final _sel_isRotatedOrScaledFromBase = objc.registerName(
  "isRotatedOrScaledFromBase",
);
late final _sel_isOpaque = objc.registerName("isOpaque");
late final _sel_convertPoint_fromView_ = objc.registerName(
  "convertPoint:fromView:",
);
final _objc_msgSend_3l1tu1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGPoint Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      objc.CGPoint Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
final _objc_msgSend_3l1tu1Stret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGPoint>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGPoint>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_convertPoint_toView_ = objc.registerName(
  "convertPoint:toView:",
);
late final _sel_convertSize_fromView_ = objc.registerName(
  "convertSize:fromView:",
);
final _objc_msgSend_4fmiil = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGSize Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGSize,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      objc.CGSize Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGSize,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
final _objc_msgSend_4fmiilStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGSize>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGSize,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGSize>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGSize,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_convertSize_toView_ = objc.registerName("convertSize:toView:");
late final _sel_convertRect_fromView_ = objc.registerName(
  "convertRect:fromView:",
);
final _objc_msgSend_2olghr = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
final _objc_msgSend_2olghrStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_convertRect_toView_ = objc.registerName("convertRect:toView:");
late final _sel_backingAlignedRect_options_ = objc.registerName(
  "backingAlignedRect:options:",
);
final _objc_msgSend_qmdcb3 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.LongLong,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        int,
      )
    >();
final _objc_msgSend_qmdcb3Stret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.LongLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        int,
      )
    >();
late final _sel_centerScanRect_ = objc.registerName("centerScanRect:");
final _objc_msgSend_1gn1s3d = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
      )
    >();
final _objc_msgSend_1gn1s3dStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
      )
    >();
late final _sel_convertPointToBacking_ = objc.registerName(
  "convertPointToBacking:",
);
final _objc_msgSend_1w4qqqr = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGPoint Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
        )
      >
    >()
    .asFunction<
      objc.CGPoint Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
      )
    >();
final _objc_msgSend_1w4qqqrStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGPoint>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGPoint>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
      )
    >();
late final _sel_convertPointFromBacking_ = objc.registerName(
  "convertPointFromBacking:",
);
late final _sel_convertSizeToBacking_ = objc.registerName(
  "convertSizeToBacking:",
);
final _objc_msgSend_1owrp3b = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGSize Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGSize,
        )
      >
    >()
    .asFunction<
      objc.CGSize Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGSize,
      )
    >();
final _objc_msgSend_1owrp3bStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGSize>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGSize,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGSize>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGSize,
      )
    >();
late final _sel_convertSizeFromBacking_ = objc.registerName(
  "convertSizeFromBacking:",
);
late final _sel_convertRectToBacking_ = objc.registerName(
  "convertRectToBacking:",
);
late final _sel_convertRectFromBacking_ = objc.registerName(
  "convertRectFromBacking:",
);
late final _sel_convertPointToLayer_ = objc.registerName(
  "convertPointToLayer:",
);
late final _sel_convertPointFromLayer_ = objc.registerName(
  "convertPointFromLayer:",
);
late final _sel_convertSizeToLayer_ = objc.registerName("convertSizeToLayer:");
late final _sel_convertSizeFromLayer_ = objc.registerName(
  "convertSizeFromLayer:",
);
late final _sel_convertRectToLayer_ = objc.registerName("convertRectToLayer:");
late final _sel_convertRectFromLayer_ = objc.registerName(
  "convertRectFromLayer:",
);
late final _sel_canDrawConcurrently = objc.registerName("canDrawConcurrently");
late final _sel_setCanDrawConcurrently_ = objc.registerName(
  "setCanDrawConcurrently:",
);
late final _sel_canDraw = objc.registerName("canDraw");
late final _sel_setNeedsDisplayInRect_ = objc.registerName(
  "setNeedsDisplayInRect:",
);
late final _sel_needsDisplay = objc.registerName("needsDisplay");
late final _sel_setNeedsDisplay_ = objc.registerName("setNeedsDisplay:");
late final _sel_lockFocus = objc.registerName("lockFocus");
late final _sel_unlockFocus = objc.registerName("unlockFocus");
late final _sel_lockFocusIfCanDraw = objc.registerName("lockFocusIfCanDraw");

/// WARNING: NSGraphicsContext is a stub. To generate bindings for this class, include
/// NSGraphicsContext in your config's objc-interfaces list.
///
/// NSGraphicsContext
extension type NSGraphicsContext._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSGraphicsContext] that points to the same underlying object as [other].
  NSGraphicsContext.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSGraphicsContext', iOS: (true, null));
  }

  /// Constructs a [NSGraphicsContext] that wraps the given raw object pointer.
  NSGraphicsContext.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSGraphicsContext', iOS: (true, null));
  }
}

late final _sel_lockFocusIfCanDrawInContext_ = objc.registerName(
  "lockFocusIfCanDrawInContext:",
);
late final _sel_focusView = objc.registerName("focusView");
late final _sel_visibleRect = objc.registerName("visibleRect");
late final _sel_display = objc.registerName("display");
late final _sel_displayIfNeeded = objc.registerName("displayIfNeeded");
late final _sel_displayIfNeededIgnoringOpacity = objc.registerName(
  "displayIfNeededIgnoringOpacity",
);
late final _sel_displayRect_ = objc.registerName("displayRect:");
late final _sel_displayIfNeededInRect_ = objc.registerName(
  "displayIfNeededInRect:",
);
late final _sel_displayRectIgnoringOpacity_ = objc.registerName(
  "displayRectIgnoringOpacity:",
);
late final _sel_displayIfNeededInRectIgnoringOpacity_ = objc.registerName(
  "displayIfNeededInRectIgnoringOpacity:",
);
late final _sel_drawRect_ = objc.registerName("drawRect:");
late final _sel_displayRectIgnoringOpacity_inContext_ = objc.registerName(
  "displayRectIgnoringOpacity:inContext:",
);
final _objc_msgSend_f227js = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// WARNING: NSBitmapImageRep is a stub. To generate bindings for this class, include
/// NSBitmapImageRep in your config's objc-interfaces list.
///
/// NSBitmapImageRep
extension type NSBitmapImageRep._(objc.ObjCObject object$)
    implements objc.ObjCObject, NSImageRep, objc.NSSecureCoding {
  /// Constructs a [NSBitmapImageRep] that points to the same underlying object as [other].
  NSBitmapImageRep.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSBitmapImageRep', iOS: (true, null));
  }

  /// Constructs a [NSBitmapImageRep] that wraps the given raw object pointer.
  NSBitmapImageRep.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSBitmapImageRep', iOS: (true, null));
  }
}

late final _sel_bitmapImageRepForCachingDisplayInRect_ = objc.registerName(
  "bitmapImageRepForCachingDisplayInRect:",
);
late final _sel_cacheDisplayInRect_toBitmapImageRep_ = objc.registerName(
  "cacheDisplayInRect:toBitmapImageRep:",
);
late final _sel_viewWillDraw = objc.registerName("viewWillDraw");
late final _sel_scrollPoint_ = objc.registerName("scrollPoint:");
late final _sel_scrollRectToVisible_ = objc.registerName(
  "scrollRectToVisible:",
);
late final _sel_autoscroll_ = objc.registerName("autoscroll:");
late final _sel_adjustScroll_ = objc.registerName("adjustScroll:");
late final _sel_scrollRect_by_ = objc.registerName("scrollRect:by:");
final _objc_msgSend_7turk2 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          objc.CGSize,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        objc.CGSize,
      )
    >();
late final _sel_translateRectsNeedingDisplayInRect_by_ = objc.registerName(
  "translateRectsNeedingDisplayInRect:by:",
);
late final _sel_hitTest_ = objc.registerName("hitTest:");
final _objc_msgSend_wgkxx2 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
      )
    >();
late final _sel_mouse_inRect_ = objc.registerName("mouse:inRect:");
final _objc_msgSend_1dxtbtd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
        objc.CGRect,
      )
    >();
late final _sel_viewWithTag_ = objc.registerName("viewWithTag:");
final _objc_msgSend_qugqlf = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_tag = objc.registerName("tag");
final _objc_msgSend_1hz7y9r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_acceptsFirstMouse_ = objc.registerName("acceptsFirstMouse:");
late final _sel_shouldDelayWindowOrderingForEvent_ = objc.registerName(
  "shouldDelayWindowOrderingForEvent:",
);
late final _sel_needsPanelToBecomeKey = objc.registerName(
  "needsPanelToBecomeKey",
);
late final _sel_mouseDownCanMoveWindow = objc.registerName(
  "mouseDownCanMoveWindow",
);
late final _sel_acceptsTouchEvents = objc.registerName("acceptsTouchEvents");
late final _sel_setAcceptsTouchEvents_ = objc.registerName(
  "setAcceptsTouchEvents:",
);
late final _sel_wantsRestingTouches = objc.registerName("wantsRestingTouches");
late final _sel_setWantsRestingTouches_ = objc.registerName(
  "setWantsRestingTouches:",
);

/// WARNING: CALayer is a stub. To generate bindings for this class, include
/// CALayer in your config's objc-interfaces list.
///
/// CALayer
extension type CALayer._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSSecureCoding,
        CAMediaTiming {
  /// Constructs a [CALayer] that points to the same underlying object as [other].
  CALayer.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'CALayer',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
  }

  /// Constructs a [CALayer] that wraps the given raw object pointer.
  CALayer.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'CALayer',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
  }
}

late final _sel_makeBackingLayer = objc.registerName("makeBackingLayer");
late final _sel_layerContentsRedrawPolicy = objc.registerName(
  "layerContentsRedrawPolicy",
);
final _objc_msgSend_13txbxf = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setLayerContentsRedrawPolicy_ = objc.registerName(
  "setLayerContentsRedrawPolicy:",
);
final _objc_msgSend_1skjrc7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_layerContentsPlacement = objc.registerName(
  "layerContentsPlacement",
);
final _objc_msgSend_1eacaxd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setLayerContentsPlacement_ = objc.registerName(
  "setLayerContentsPlacement:",
);
final _objc_msgSend_3dohm9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_wantsLayer = objc.registerName("wantsLayer");
late final _sel_setWantsLayer_ = objc.registerName("setWantsLayer:");
late final _sel_layer = objc.registerName("layer");
late final _sel_setLayer_ = objc.registerName("setLayer:");
late final _sel_wantsUpdateLayer = objc.registerName("wantsUpdateLayer");
late final _sel_updateLayer = objc.registerName("updateLayer");
late final _sel_canDrawSubviewsIntoLayer = objc.registerName(
  "canDrawSubviewsIntoLayer",
);
late final _sel_setCanDrawSubviewsIntoLayer_ = objc.registerName(
  "setCanDrawSubviewsIntoLayer:",
);
late final _sel_layoutSubtreeIfNeeded = objc.registerName(
  "layoutSubtreeIfNeeded",
);
late final _sel_layout = objc.registerName("layout");
late final _sel_needsLayout = objc.registerName("needsLayout");
late final _sel_setNeedsLayout_ = objc.registerName("setNeedsLayout:");
late final _sel_alphaValue = objc.registerName("alphaValue");
late final _sel_setAlphaValue_ = objc.registerName("setAlphaValue:");
late final _sel_layerUsesCoreImageFilters = objc.registerName(
  "layerUsesCoreImageFilters",
);
late final _sel_setLayerUsesCoreImageFilters_ = objc.registerName(
  "setLayerUsesCoreImageFilters:",
);
late final _sel_backgroundFilters = objc.registerName("backgroundFilters");
late final _sel_setBackgroundFilters_ = objc.registerName(
  "setBackgroundFilters:",
);

/// WARNING: CIFilter is a stub. To generate bindings for this class, include
/// CIFilter in your config's objc-interfaces list.
///
/// CIFilter
extension type CIFilter._(objc.ObjCObject object$) implements objc.ObjCObject {
  /// Constructs a [CIFilter] that points to the same underlying object as [other].
  CIFilter.as(objc.ObjCObject other) : object$ = other {}

  /// Constructs a [CIFilter] that wraps the given raw object pointer.
  CIFilter.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {}
}

late final _sel_compositingFilter = objc.registerName("compositingFilter");
late final _sel_setCompositingFilter_ = objc.registerName(
  "setCompositingFilter:",
);
late final _sel_contentFilters = objc.registerName("contentFilters");
late final _sel_setContentFilters_ = objc.registerName("setContentFilters:");

/// WARNING: NSShadow is a stub. To generate bindings for this class, include
/// NSShadow in your config's objc-interfaces list.
///
/// NSShadow
extension type NSShadow._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSCopying,
        objc.NSSecureCoding {
  /// Constructs a [NSShadow] that points to the same underlying object as [other].
  NSShadow.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSShadow',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
  }

  /// Constructs a [NSShadow] that wraps the given raw object pointer.
  NSShadow.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSShadow',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
  }
}

late final _sel_shadow = objc.registerName("shadow");
late final _sel_setShadow_ = objc.registerName("setShadow:");
late final _sel_clipsToBounds = objc.registerName("clipsToBounds");
late final _sel_setClipsToBounds_ = objc.registerName("setClipsToBounds:");
late final _sel_postsBoundsChangedNotifications = objc.registerName(
  "postsBoundsChangedNotifications",
);
late final _sel_setPostsBoundsChangedNotifications_ = objc.registerName(
  "setPostsBoundsChangedNotifications:",
);

/// WARNING: NSScrollView is a stub. To generate bindings for this class, include
/// NSScrollView in your config's objc-interfaces list.
///
/// NSScrollView
extension type NSScrollView._(objc.ObjCObject object$)
    implements objc.ObjCObject, NSView, NSTextFinderBarContainer {
  /// Constructs a [NSScrollView] that points to the same underlying object as [other].
  NSScrollView.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSScrollView', iOS: (true, null));
  }

  /// Constructs a [NSScrollView] that wraps the given raw object pointer.
  NSScrollView.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSScrollView', iOS: (true, null));
  }
}

late final _sel_enclosingScrollView = objc.registerName("enclosingScrollView");
late final _sel_menuForEvent_ = objc.registerName("menuForEvent:");
late final _sel_defaultMenu = objc.registerName("defaultMenu");
late final _sel_willOpenMenu_withEvent_ = objc.registerName(
  "willOpenMenu:withEvent:",
);
late final _sel_didCloseMenu_withEvent_ = objc.registerName(
  "didCloseMenu:withEvent:",
);
late final _sel_toolTip = objc.registerName("toolTip");
late final _sel_setToolTip_ = objc.registerName("setToolTip:");
late final _sel_addToolTipRect_owner_userData_ = objc.registerName(
  "addToolTipRect:owner:userData:",
);
final _objc_msgSend_n11w24 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<ffi.Void>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<ffi.Void>,
      )
    >();
late final _sel_removeToolTip_ = objc.registerName("removeToolTip:");
final _objc_msgSend_4sp4xj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_removeAllToolTips = objc.registerName("removeAllToolTips");
late final _sel_viewWillStartLiveResize = objc.registerName(
  "viewWillStartLiveResize",
);
late final _sel_viewDidEndLiveResize = objc.registerName(
  "viewDidEndLiveResize",
);
late final _sel_inLiveResize = objc.registerName("inLiveResize");
late final _sel_preservesContentDuringLiveResize = objc.registerName(
  "preservesContentDuringLiveResize",
);
late final _sel_rectPreservedDuringLiveResize = objc.registerName(
  "rectPreservedDuringLiveResize",
);
late final _sel_getRectsExposedDuringLiveResize_count_ = objc.registerName(
  "getRectsExposedDuringLiveResize:count:",
);
final _objc_msgSend_145wlaw = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<ffi.Long>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<ffi.Long>,
      )
    >();

/// WARNING: NSTextInputContext is a stub. To generate bindings for this class, include
/// NSTextInputContext in your config's objc-interfaces list.
///
/// NSTextInputContext
extension type NSTextInputContext._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSTextInputContext] that points to the same underlying object as [other].
  NSTextInputContext.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSTextInputContext',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
  }

  /// Constructs a [NSTextInputContext] that wraps the given raw object pointer.
  NSTextInputContext.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSTextInputContext',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
  }
}

late final _sel_inputContext = objc.registerName("inputContext");
late final _sel_rectForSmartMagnificationAtPoint_inRect_ = objc.registerName(
  "rectForSmartMagnificationAtPoint:inRect:",
);
final _objc_msgSend_mtf8w4 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
        objc.CGRect,
      )
    >();
final _objc_msgSend_mtf8w4Stret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
        objc.CGRect,
      )
    >();
late final _sel_userInterfaceLayoutDirection = objc.registerName(
  "userInterfaceLayoutDirection",
);
final _objc_msgSend_1spww5v = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setUserInterfaceLayoutDirection_ = objc.registerName(
  "setUserInterfaceLayoutDirection:",
);
final _objc_msgSend_9se2j = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_prepareForReuse = objc.registerName("prepareForReuse");
late final _sel_isCompatibleWithResponsiveScrolling = objc.registerName(
  "isCompatibleWithResponsiveScrolling",
);
late final _sel_prepareContentInRect_ = objc.registerName(
  "prepareContentInRect:",
);
late final _sel_preparedContentRect = objc.registerName("preparedContentRect");
late final _sel_setPreparedContentRect_ = objc.registerName(
  "setPreparedContentRect:",
);
late final _sel_allowsVibrancy = objc.registerName("allowsVibrancy");
late final _sel_viewDidChangeEffectiveAppearance = objc.registerName(
  "viewDidChangeEffectiveAppearance",
);
late final _sel_animator = objc.registerName("animator");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_objcObjCObjectImpl_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
  >
  fromFunction(
    objc.ObjCObject Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_objcObjCObjectImpl_ffiVoid$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
        > {
  objc.ObjCObject call(ffi.Pointer<ffi.Void> arg0) => objc.ObjCObject(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >()(ref.pointer, arg0),
    retain: true,
    release: true,
  );
}

late final _sel_animations = objc.registerName("animations");

/// Construction methods for `objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSDictionary_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    objc.NSDictionary Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSDictionary_ffiVoid$CallExtension
    on objc.ObjCBlock<objc.NSDictionary Function(ffi.Pointer<ffi.Void>)> {
  objc.NSDictionary call(ffi.Pointer<ffi.Void> arg0) =>
      objc.NSDictionary.fromPointer(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0,
                )
              >
            >()
            .asFunction<
              ffi.Pointer<objc.ObjCObjectImpl> Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
              )
            >()(ref.pointer, arg0),
        retain: true,
        release: true,
      );
}

late final _sel_setAnimations_ = objc.registerName("setAnimations:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSDictionary {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                objc.NSDictionary.fromPointer(
                  arg1,
                  retain: true,
                  release: true,
                ),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSDictionary.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSDictionary.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSDictionary.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSDictionary$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSDictionary)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSDictionary arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_animationForKey_ = objc.registerName("animationForKey:");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
abstract final class ObjCBlock_objcObjCObjectImpl_ffiVoid_NSPasteboardType {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSString,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSString,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSString,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSString,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSString,
    )
  >
  fromFunction(
    objc.ObjCObject? Function(ffi.Pointer<ffi.Void>, objc.NSString) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSString,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                objc.NSString.fromPointer(arg1, retain: true, release: true),
              )?.ref.retainAndAutorelease() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
extension ObjCBlock_objcObjCObjectImpl_ffiVoid_NSPasteboardType$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObjectImpl>? Function(
            ffi.Pointer<ffi.Void>,
            objc.NSString,
          )
        > {
  objc.ObjCObject? call(ffi.Pointer<ffi.Void> arg0, objc.NSString arg1) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer)
              .address ==
          0
      ? null
      : objc.ObjCObject(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer),
          retain: true,
          release: true,
        );
}

late final _sel_defaultAnimationForKey_ = objc.registerName(
  "defaultAnimationForKey:",
);
late final _sel_identifier = objc.registerName("identifier");

/// Construction methods for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSUserInterfaceItemIdentifier_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    objc.NSString? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) =>
          fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSUserInterfaceItemIdentifier_ffiVoid$CallExtension
    on objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)> {
  objc.NSString? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : objc.NSString.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_setIdentifier_ = objc.registerName("setIdentifier:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSUserInterfaceItemIdentifier {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.NSString?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                arg1.address == 0
                    ? null
                    : objc.NSString.fromPointer(
                        arg1,
                        retain: true,
                        release: true,
                      ),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.NSString?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSString.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.NSString?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSString.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSString.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSUserInterfaceItemIdentifier$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSString? arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_draggingEntered_ = objc.registerName("draggingEntered:");
final _objc_msgSend_us60nl = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)>`.
abstract final class ObjCBlock_NSDragOperation_ffiVoid_idNSDraggingInfo {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.UnsignedLong Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.UnsignedLong Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.UnsignedLong Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.UnsignedLong Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.UnsignedLong Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  fromFunction(
    int Function(ffi.Pointer<ffi.Void>, NSDraggingInfo) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.UnsignedLong Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                NSDraggingInfo.fromPointer(arg1, retain: true, release: true),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static int _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.UnsignedLong Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.UnsignedLong Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline, 0)
          .cast();
  static int _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as int Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.UnsignedLong Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline, 0)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)>`.
extension ObjCBlock_NSDragOperation_ffiVoid_idNSDraggingInfo$CallExtension
    on
        objc.ObjCBlock<
          ffi.UnsignedLong Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        > {
  int call(ffi.Pointer<ffi.Void> arg0, NSDraggingInfo arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.UnsignedLong Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        int Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_draggingUpdated_ = objc.registerName("draggingUpdated:");
late final _sel_draggingExited_ = objc.registerName("draggingExited:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>?,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>?,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, NSDraggingInfo?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>?,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                arg1.address == 0
                    ? null
                    : NSDraggingInfo.fromPointer(
                        arg1,
                        retain: true,
                        release: true,
                      ),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, NSDraggingInfo?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : NSDraggingInfo.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObjectImpl>?,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, NSDraggingInfo?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : NSDraggingInfo.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : NSDraggingInfo.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObjectImpl>?,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>?,
          )
        > {
  void call(ffi.Pointer<ffi.Void> arg0, NSDraggingInfo? arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_prepareForDragOperation_ = objc.registerName(
  "prepareForDragOperation:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)>`.
abstract final class ObjCBlock_bool_ffiVoid_idNSDraggingInfo {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
  >
  fromFunction(
    bool Function(ffi.Pointer<ffi.Void>, NSDraggingInfo) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                NSDraggingInfo.fromPointer(arg1, retain: true, release: true),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as bool Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)>`.
extension ObjCBlock_bool_ffiVoid_idNSDraggingInfo$CallExtension
    on
        objc.ObjCBlock<
          ffi.Bool Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        > {
  bool call(ffi.Pointer<ffi.Void> arg0, NSDraggingInfo arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_performDragOperation_ = objc.registerName(
  "performDragOperation:",
);
late final _sel_concludeDragOperation_ = objc.registerName(
  "concludeDragOperation:",
);
late final _sel_draggingEnded_ = objc.registerName("draggingEnded:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, NSDraggingInfo) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                NSDraggingInfo.fromPointer(arg1, retain: true, release: true),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, NSDraggingInfo) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        NSDraggingInfo.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, NSDraggingInfo) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        NSDraggingInfo.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        NSDraggingInfo.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_idNSDraggingInfo$1$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        > {
  void call(ffi.Pointer<ffi.Void> arg0, NSDraggingInfo arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_wantsPeriodicDraggingUpdates = objc.registerName(
  "wantsPeriodicDraggingUpdates",
);
late final _sel_updateDraggingItemsForDrag_ = objc.registerName(
  "updateDraggingItemsForDrag:",
);
late final _sel_appearance = objc.registerName("appearance");

/// Construction methods for `objc.ObjCBlock<NSAppearance? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSAppearance_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<NSAppearance? Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<NSAppearance? Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<NSAppearance? Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<NSAppearance? Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<NSAppearance? Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    NSAppearance? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<NSAppearance? Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) =>
          fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<NSAppearance? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSAppearance_ffiVoid$CallExtension
    on objc.ObjCBlock<NSAppearance? Function(ffi.Pointer<ffi.Void>)> {
  NSAppearance? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : NSAppearance.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_setAppearance_ = objc.registerName("setAppearance:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSAppearance {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, NSAppearance?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : NSAppearance.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, NSAppearance?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : NSAppearance.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, NSAppearance?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : NSAppearance.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : NSAppearance.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSAppearance$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSAppearance?)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSAppearance? arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_effectiveAppearance = objc.registerName("effectiveAppearance");

/// Construction methods for `objc.ObjCBlock<NSAppearance Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSAppearance_ffiVoid$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<NSAppearance Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<NSAppearance Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<NSAppearance Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<NSAppearance Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<NSAppearance Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    NSAppearance Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<NSAppearance Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<NSAppearance Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSAppearance_ffiVoid$1$CallExtension
    on objc.ObjCBlock<NSAppearance Function(ffi.Pointer<ffi.Void>)> {
  NSAppearance call(ffi.Pointer<ffi.Void> arg0) => NSAppearance.fromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >()(ref.pointer, arg0),
    retain: true,
    release: true,
  );
}

late final _sel_accessibilityFrame = objc.registerName("accessibilityFrame");

/// Construction methods for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSRect_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    objc.CGRect Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static objc.CGRect _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<ffi.Void> arg0)>
      >()
      .asFunction<objc.CGRect Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            objc.CGRect Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static objc.CGRect _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as objc.CGRect Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            objc.CGRect Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSRect_ffiVoid$CallExtension
    on objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)> {
  objc.CGRect call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          objc.CGRect Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
        )
      >()(ref.pointer, arg0);
}

late final _sel_accessibilityParent = objc.registerName("accessibilityParent");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_objcObjCObjectImpl_ffiVoid$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
  >
  fromFunction(
    objc.ObjCObject? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0) =>
              fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_objcObjCObjectImpl_ffiVoid$1$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
        > {
  objc.ObjCObject? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : objc.ObjCObject(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_isAccessibilityFocused = objc.registerName(
  "isAccessibilityFocused",
);
late final _sel_accessibilityIdentifier = objc.registerName(
  "accessibilityIdentifier",
);
late final _sel_isAccessibilityElement = objc.registerName(
  "isAccessibilityElement",
);
late final _sel_setAccessibilityElement_ = objc.registerName(
  "setAccessibilityElement:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Bool arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, bool) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, bool arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, bool) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, bool arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_10lndml(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, bool) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, bool arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, bool arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_10lndml(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    bool arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, bool))(
      arg0,
      arg1,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Bool,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Bool,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    bool arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, bool))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Bool,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Bool,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Bool,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Bool,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    bool arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Bool arg1)
        >
      >()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, bool)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Bool,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    bool arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, bool))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Bool,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>`.
extension ObjCBlock_ffiVoid_ffiVoid_bool$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)> {
  void call(ffi.Pointer<ffi.Void> arg0, bool arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Bool arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          bool,
        )
      >()(ref.pointer, arg0, arg1);
}

late final _sel_setAccessibilityFrame_ = objc.registerName(
  "setAccessibilityFrame:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGRect)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSRect {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGRect)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGRect)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGRect)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGRect)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGRect)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.CGRect) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGRect)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGRect)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.CGRect) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1e49sma(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGRect)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGRect)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.CGRect) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1e49sma(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGRect)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGRect arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.Void>, objc.CGRect))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      objc.CGRect,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            objc.CGRect,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGRect arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, objc.CGRect))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      objc.CGRect,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            objc.CGRect,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      objc.CGRect,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            objc.CGRect,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGRect arg1,
  ) =>
      block.ref.target
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1)
            >
          >()
          .asFunction<void Function(ffi.Pointer<ffi.Void>, objc.CGRect)>()(
        arg0,
        arg1,
      );
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGRect,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGRect arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, objc.CGRect))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGRect,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGRect)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSRect$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGRect)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.CGRect arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          objc.CGRect,
        )
      >()(ref.pointer, arg0, arg1);
}

late final _sel_setAccessibilityFocused_ = objc.registerName(
  "setAccessibilityFocused:",
);
late final _sel_accessibilityActivationPoint = objc.registerName(
  "accessibilityActivationPoint",
);
final _objc_msgSend_1uwdhlk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGPoint Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      objc.CGPoint Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1uwdhlkStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGPoint>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGPoint>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSPoint_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    objc.CGPoint Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static objc.CGPoint _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<ffi.Void> arg0)>
      >()
      .asFunction<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            objc.CGPoint Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static objc.CGPoint _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as objc.CGPoint Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            objc.CGPoint Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSPoint_ffiVoid$CallExtension
    on objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)> {
  objc.CGPoint call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          objc.CGPoint Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        objc.CGPoint Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
        )
      >()(ref.pointer, arg0);
}

late final _sel_setAccessibilityActivationPoint_ = objc.registerName(
  "setAccessibilityActivationPoint:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSPoint {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.CGPoint) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.CGPoint) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1bktu2(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.CGPoint) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1bktu2(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGPoint arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.Void>, objc.CGPoint))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      objc.CGPoint,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            objc.CGPoint,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGPoint arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, objc.CGPoint))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      objc.CGPoint,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            objc.CGPoint,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      objc.CGPoint,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            objc.CGPoint,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGPoint arg1,
  ) =>
      block.ref.target
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1)
            >
          >()
          .asFunction<void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>()(
        arg0,
        arg1,
      );
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGPoint,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGPoint arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, objc.CGPoint))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGPoint,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSPoint$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.CGPoint arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          objc.CGPoint,
        )
      >()(ref.pointer, arg0, arg1);
}

late final _sel_accessibilityTopLevelUIElement = objc.registerName(
  "accessibilityTopLevelUIElement",
);
late final _sel_setAccessibilityTopLevelUIElement_ = objc.registerName(
  "setAccessibilityTopLevelUIElement:",
);
late final _sel_accessibilityURL = objc.registerName("accessibilityURL");

/// Construction methods for `objc.ObjCBlock<objc.NSURL? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSURL_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSURL? Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSURL? Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSURL? Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.NSURL? Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSURL? Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    objc.NSURL? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSURL? Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) =>
          fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSURL? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSURL_ffiVoid$CallExtension
    on objc.ObjCBlock<objc.NSURL? Function(ffi.Pointer<ffi.Void>)> {
  objc.NSURL? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : objc.NSURL.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_setAccessibilityURL_ = objc.registerName(
  "setAccessibilityURL:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSURL?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURL {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSURL?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSURL?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSURL?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSURL?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSURL?)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.NSURL?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSURL?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSURL.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSURL?)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.NSURL?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSURL.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSURL?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSURL?)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.NSURL?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSURL.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSURL.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSURL?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSURL?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURL$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSURL?)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSURL? arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_accessibilityValue = objc.registerName("accessibilityValue");
late final _sel_setAccessibilityValue_ = objc.registerName(
  "setAccessibilityValue:",
);
late final _sel_accessibilityValueDescription = objc.registerName(
  "accessibilityValueDescription",
);
late final _sel_setAccessibilityValueDescription_ = objc.registerName(
  "setAccessibilityValueDescription:",
);
late final _sel_accessibilityVisibleChildren = objc.registerName(
  "accessibilityVisibleChildren",
);

/// Construction methods for `objc.ObjCBlock<objc.NSArray? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSArray_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSArray? Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSArray? Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSArray? Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.NSArray? Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSArray? Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    objc.NSArray? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSArray? Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) =>
          fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSArray? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSArray_ffiVoid$CallExtension
    on objc.ObjCBlock<objc.NSArray? Function(ffi.Pointer<ffi.Void>)> {
  objc.NSArray? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : objc.NSArray.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_setAccessibilityVisibleChildren_ = objc.registerName(
  "setAccessibilityVisibleChildren:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray?)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.NSArray?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSArray.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray?)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.NSArray?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSArray.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray?)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.NSArray?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSArray.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSArray.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSArray$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray?)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSArray? arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_accessibilitySubrole = objc.registerName(
  "accessibilitySubrole",
);
late final _sel_setAccessibilitySubrole_ = objc.registerName(
  "setAccessibilitySubrole:",
);
late final _sel_accessibilityTitle = objc.registerName("accessibilityTitle");
late final _sel_setAccessibilityTitle_ = objc.registerName(
  "setAccessibilityTitle:",
);
late final _sel_accessibilityTitleUIElement = objc.registerName(
  "accessibilityTitleUIElement",
);
late final _sel_setAccessibilityTitleUIElement_ = objc.registerName(
  "setAccessibilityTitleUIElement:",
);
late final _sel_accessibilityNextContents = objc.registerName(
  "accessibilityNextContents",
);
late final _sel_setAccessibilityNextContents_ = objc.registerName(
  "setAccessibilityNextContents:",
);
late final _sel_accessibilityOrientation = objc.registerName(
  "accessibilityOrientation",
);
final _objc_msgSend_hnn3gk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSAccessibilityOrientation_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromFunction(
    NSAccessibilityOrientation Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).value,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static int _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline, 0)
          .cast();
  static int _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline, 0)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSAccessibilityOrientation_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> {
  NSAccessibilityOrientation call(ffi.Pointer<ffi.Void> arg0) =>
      NSAccessibilityOrientation.fromValue(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                ffi.Long Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0,
                )
              >
            >()
            .asFunction<
              int Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
              )
            >()(ref.pointer, arg0),
      );
}

late final _sel_setAccessibilityOrientation_ = objc.registerName(
  "setAccessibilityOrientation:",
);
final _objc_msgSend_1jcoroy = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSAccessibilityOrientation {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, NSAccessibilityOrientation) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, NSAccessibilityOrientation.fromValue(arg1)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, NSAccessibilityOrientation) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, NSAccessibilityOrientation.fromValue(arg1)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_6qimxm(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, NSAccessibilityOrientation) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, NSAccessibilityOrientation.fromValue(arg1)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, NSAccessibilityOrientation.fromValue(arg1)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_6qimxm(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, int))(
      arg0,
      arg1,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, int))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)
        >
      >()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Long,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, int))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Long,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSAccessibilityOrientation$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSAccessibilityOrientation arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Long arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          int,
        )
      >()(ref.pointer, arg0, arg1.value);
}

late final _sel_accessibilityOverflowButton = objc.registerName(
  "accessibilityOverflowButton",
);
late final _sel_setAccessibilityOverflowButton_ = objc.registerName(
  "setAccessibilityOverflowButton:",
);
late final _sel_setAccessibilityParent_ = objc.registerName(
  "setAccessibilityParent:",
);
late final _sel_accessibilityPlaceholderValue = objc.registerName(
  "accessibilityPlaceholderValue",
);
late final _sel_setAccessibilityPlaceholderValue_ = objc.registerName(
  "setAccessibilityPlaceholderValue:",
);
late final _sel_accessibilityPreviousContents = objc.registerName(
  "accessibilityPreviousContents",
);
late final _sel_setAccessibilityPreviousContents_ = objc.registerName(
  "setAccessibilityPreviousContents:",
);
late final _sel_accessibilityRole = objc.registerName("accessibilityRole");
late final _sel_setAccessibilityRole_ = objc.registerName(
  "setAccessibilityRole:",
);
late final _sel_accessibilityRoleDescription = objc.registerName(
  "accessibilityRoleDescription",
);
late final _sel_setAccessibilityRoleDescription_ = objc.registerName(
  "setAccessibilityRoleDescription:",
);
late final _sel_accessibilitySearchButton = objc.registerName(
  "accessibilitySearchButton",
);
late final _sel_setAccessibilitySearchButton_ = objc.registerName(
  "setAccessibilitySearchButton:",
);
late final _sel_accessibilitySearchMenu = objc.registerName(
  "accessibilitySearchMenu",
);
late final _sel_setAccessibilitySearchMenu_ = objc.registerName(
  "setAccessibilitySearchMenu:",
);
late final _sel_isAccessibilitySelected = objc.registerName(
  "isAccessibilitySelected",
);
late final _sel_setAccessibilitySelected_ = objc.registerName(
  "setAccessibilitySelected:",
);
late final _sel_accessibilitySelectedChildren = objc.registerName(
  "accessibilitySelectedChildren",
);
late final _sel_setAccessibilitySelectedChildren_ = objc.registerName(
  "setAccessibilitySelectedChildren:",
);
late final _sel_accessibilityServesAsTitleForUIElements = objc.registerName(
  "accessibilityServesAsTitleForUIElements",
);
late final _sel_setAccessibilityServesAsTitleForUIElements_ = objc.registerName(
  "setAccessibilityServesAsTitleForUIElements:",
);
late final _sel_accessibilityShownMenu = objc.registerName(
  "accessibilityShownMenu",
);
late final _sel_setAccessibilityShownMenu_ = objc.registerName(
  "setAccessibilityShownMenu:",
);
late final _sel_accessibilityMinValue = objc.registerName(
  "accessibilityMinValue",
);
late final _sel_setAccessibilityMinValue_ = objc.registerName(
  "setAccessibilityMinValue:",
);
late final _sel_accessibilityMaxValue = objc.registerName(
  "accessibilityMaxValue",
);
late final _sel_setAccessibilityMaxValue_ = objc.registerName(
  "setAccessibilityMaxValue:",
);
late final _sel_accessibilityLinkedUIElements = objc.registerName(
  "accessibilityLinkedUIElements",
);
late final _sel_setAccessibilityLinkedUIElements_ = objc.registerName(
  "setAccessibilityLinkedUIElements:",
);
late final _sel_accessibilityWindow = objc.registerName("accessibilityWindow");
late final _sel_setAccessibilityWindow_ = objc.registerName(
  "setAccessibilityWindow:",
);
late final _sel_setAccessibilityIdentifier_ = objc.registerName(
  "setAccessibilityIdentifier:",
);
late final _sel_accessibilityHelp = objc.registerName("accessibilityHelp");
late final _sel_setAccessibilityHelp_ = objc.registerName(
  "setAccessibilityHelp:",
);
late final _sel_accessibilityFilename = objc.registerName(
  "accessibilityFilename",
);
late final _sel_setAccessibilityFilename_ = objc.registerName(
  "setAccessibilityFilename:",
);
late final _sel_isAccessibilityExpanded = objc.registerName(
  "isAccessibilityExpanded",
);
late final _sel_setAccessibilityExpanded_ = objc.registerName(
  "setAccessibilityExpanded:",
);
late final _sel_isAccessibilityEdited = objc.registerName(
  "isAccessibilityEdited",
);
late final _sel_setAccessibilityEdited_ = objc.registerName(
  "setAccessibilityEdited:",
);
late final _sel_isAccessibilityEnabled = objc.registerName(
  "isAccessibilityEnabled",
);
late final _sel_setAccessibilityEnabled_ = objc.registerName(
  "setAccessibilityEnabled:",
);
late final _sel_accessibilityChildren = objc.registerName(
  "accessibilityChildren",
);
late final _sel_setAccessibilityChildren_ = objc.registerName(
  "setAccessibilityChildren:",
);
late final _sel_accessibilityChildrenInNavigationOrder = objc.registerName(
  "accessibilityChildrenInNavigationOrder",
);
late final _sel_setAccessibilityChildrenInNavigationOrder_ = objc.registerName(
  "setAccessibilityChildrenInNavigationOrder:",
);
late final _sel_accessibilityClearButton = objc.registerName(
  "accessibilityClearButton",
);
late final _sel_setAccessibilityClearButton_ = objc.registerName(
  "setAccessibilityClearButton:",
);
late final _sel_accessibilityCancelButton = objc.registerName(
  "accessibilityCancelButton",
);
late final _sel_setAccessibilityCancelButton_ = objc.registerName(
  "setAccessibilityCancelButton:",
);
late final _sel_isAccessibilityProtectedContent = objc.registerName(
  "isAccessibilityProtectedContent",
);
late final _sel_setAccessibilityProtectedContent_ = objc.registerName(
  "setAccessibilityProtectedContent:",
);
late final _sel_accessibilityContents = objc.registerName(
  "accessibilityContents",
);
late final _sel_setAccessibilityContents_ = objc.registerName(
  "setAccessibilityContents:",
);
late final _sel_accessibilityLabel = objc.registerName("accessibilityLabel");
late final _sel_setAccessibilityLabel_ = objc.registerName(
  "setAccessibilityLabel:",
);
late final _sel_isAccessibilityAlternateUIVisible = objc.registerName(
  "isAccessibilityAlternateUIVisible",
);
late final _sel_setAccessibilityAlternateUIVisible_ = objc.registerName(
  "setAccessibilityAlternateUIVisible:",
);
late final _sel_accessibilitySharedFocusElements = objc.registerName(
  "accessibilitySharedFocusElements",
);
late final _sel_setAccessibilitySharedFocusElements_ = objc.registerName(
  "setAccessibilitySharedFocusElements:",
);
late final _sel_isAccessibilityRequired = objc.registerName(
  "isAccessibilityRequired",
);
late final _sel_setAccessibilityRequired_ = objc.registerName(
  "setAccessibilityRequired:",
);
late final _sel_accessibilityCustomRotors = objc.registerName(
  "accessibilityCustomRotors",
);

/// Construction methods for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSArray_ffiVoid$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    objc.NSArray Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSArray_ffiVoid$1$CallExtension
    on objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> {
  objc.NSArray call(ffi.Pointer<ffi.Void> arg0) => objc.NSArray.fromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >()(ref.pointer, arg0),
    retain: true,
    release: true,
  );
}

late final _sel_setAccessibilityCustomRotors_ = objc.registerName(
  "setAccessibilityCustomRotors:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSArray$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, objc.NSArray.fromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSArray.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSArray.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSArray.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSArray$1$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSArray arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_accessibilityUserInputLabels = objc.registerName(
  "accessibilityUserInputLabels",
);
late final _sel_setAccessibilityUserInputLabels_ = objc.registerName(
  "setAccessibilityUserInputLabels:",
);
late final _sel_accessibilityAttributedUserInputLabels = objc.registerName(
  "accessibilityAttributedUserInputLabels",
);
late final _sel_setAccessibilityAttributedUserInputLabels_ = objc.registerName(
  "setAccessibilityAttributedUserInputLabels:",
);
late final _sel_accessibilityApplicationFocusedUIElement = objc.registerName(
  "accessibilityApplicationFocusedUIElement",
);
late final _sel_setAccessibilityApplicationFocusedUIElement_ = objc
    .registerName("setAccessibilityApplicationFocusedUIElement:");
late final _sel_accessibilityMainWindow = objc.registerName(
  "accessibilityMainWindow",
);
late final _sel_setAccessibilityMainWindow_ = objc.registerName(
  "setAccessibilityMainWindow:",
);
late final _sel_isAccessibilityHidden = objc.registerName(
  "isAccessibilityHidden",
);
late final _sel_setAccessibilityHidden_ = objc.registerName(
  "setAccessibilityHidden:",
);
late final _sel_isAccessibilityFrontmost = objc.registerName(
  "isAccessibilityFrontmost",
);
late final _sel_setAccessibilityFrontmost_ = objc.registerName(
  "setAccessibilityFrontmost:",
);
late final _sel_accessibilityFocusedWindow = objc.registerName(
  "accessibilityFocusedWindow",
);
late final _sel_setAccessibilityFocusedWindow_ = objc.registerName(
  "setAccessibilityFocusedWindow:",
);
late final _sel_accessibilityWindows = objc.registerName(
  "accessibilityWindows",
);
late final _sel_setAccessibilityWindows_ = objc.registerName(
  "setAccessibilityWindows:",
);
late final _sel_accessibilityExtrasMenuBar = objc.registerName(
  "accessibilityExtrasMenuBar",
);
late final _sel_setAccessibilityExtrasMenuBar_ = objc.registerName(
  "setAccessibilityExtrasMenuBar:",
);
late final _sel_accessibilityMenuBar = objc.registerName(
  "accessibilityMenuBar",
);
late final _sel_setAccessibilityMenuBar_ = objc.registerName(
  "setAccessibilityMenuBar:",
);
late final _sel_accessibilityColumnTitles = objc.registerName(
  "accessibilityColumnTitles",
);
late final _sel_setAccessibilityColumnTitles_ = objc.registerName(
  "setAccessibilityColumnTitles:",
);
late final _sel_isAccessibilityOrderedByRow = objc.registerName(
  "isAccessibilityOrderedByRow",
);
late final _sel_setAccessibilityOrderedByRow_ = objc.registerName(
  "setAccessibilityOrderedByRow:",
);
late final _sel_accessibilityHorizontalUnits = objc.registerName(
  "accessibilityHorizontalUnits",
);
final _objc_msgSend_k2hzvx = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSAccessibilityUnits_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromFunction(
    NSAccessibilityUnits Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).value,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static int _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline, 0)
          .cast();
  static int _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline, 0)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSAccessibilityUnits_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> {
  NSAccessibilityUnits call(ffi.Pointer<ffi.Void> arg0) =>
      NSAccessibilityUnits.fromValue(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                ffi.Long Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0,
                )
              >
            >()
            .asFunction<
              int Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
              )
            >()(ref.pointer, arg0),
      );
}

late final _sel_setAccessibilityHorizontalUnits_ = objc.registerName(
  "setAccessibilityHorizontalUnits:",
);
final _objc_msgSend_kr9ig9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSAccessibilityUnits {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, NSAccessibilityUnits) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, NSAccessibilityUnits.fromValue(arg1)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, NSAccessibilityUnits) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, NSAccessibilityUnits.fromValue(arg1)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_12prxo1(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, NSAccessibilityUnits) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, NSAccessibilityUnits.fromValue(arg1)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, NSAccessibilityUnits.fromValue(arg1)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_12prxo1(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, int))(
      arg0,
      arg1,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, int))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)
        >
      >()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Long,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, int))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Long,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSAccessibilityUnits$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSAccessibilityUnits arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Long arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          int,
        )
      >()(ref.pointer, arg0, arg1.value);
}

late final _sel_accessibilityVerticalUnits = objc.registerName(
  "accessibilityVerticalUnits",
);
late final _sel_setAccessibilityVerticalUnits_ = objc.registerName(
  "setAccessibilityVerticalUnits:",
);
late final _sel_accessibilityHorizontalUnitDescription = objc.registerName(
  "accessibilityHorizontalUnitDescription",
);
late final _sel_setAccessibilityHorizontalUnitDescription_ = objc.registerName(
  "setAccessibilityHorizontalUnitDescription:",
);
late final _sel_accessibilityVerticalUnitDescription = objc.registerName(
  "accessibilityVerticalUnitDescription",
);
late final _sel_setAccessibilityVerticalUnitDescription_ = objc.registerName(
  "setAccessibilityVerticalUnitDescription:",
);
late final _sel_accessibilityLayoutPointForScreenPoint_ = objc.registerName(
  "accessibilityLayoutPointForScreenPoint:",
);

/// Construction methods for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>`.
abstract final class ObjCBlock_NSPoint_ffiVoid_NSPoint {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        objc.CGPoint Function(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint)
  >
  fromFunction(
    objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static objc.CGPoint _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGPoint arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          objc.CGPoint Function(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1)
        >
      >()
      .asFunction<
        objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            objc.CGPoint Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGPoint,
            )
          >(_fnPtrTrampoline)
          .cast();
  static objc.CGPoint _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGPoint arg1,
  ) =>
      (objc.getBlockClosure(block)
          as objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint))(
        arg0,
        arg1,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            objc.CGPoint Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGPoint,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>`.
extension ObjCBlock_NSPoint_ffiVoid_NSPoint$CallExtension
    on
        objc.ObjCBlock<
          objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint)
        > {
  objc.CGPoint call(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          objc.CGPoint Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.CGPoint arg1,
          )
        >
      >()
      .asFunction<
        objc.CGPoint Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          objc.CGPoint,
        )
      >()(ref.pointer, arg0, arg1);
}

late final _sel_accessibilityLayoutSizeForScreenSize_ = objc.registerName(
  "accessibilityLayoutSizeForScreenSize:",
);

/// Construction methods for `objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, objc.CGSize)>`.
abstract final class ObjCBlock_NSSize_ffiVoid_NSSize {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.CGSize Function(ffi.Pointer<ffi.Void>, objc.CGSize)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, objc.CGSize)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.CGSize Function(ffi.Pointer<ffi.Void>, objc.CGSize)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        objc.CGSize Function(ffi.Pointer<ffi.Void> arg0, objc.CGSize arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, objc.CGSize)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.CGSize Function(ffi.Pointer<ffi.Void>, objc.CGSize)
  >
  fromFunction(
    objc.CGSize Function(ffi.Pointer<ffi.Void>, objc.CGSize) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, objc.CGSize)>(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, objc.CGSize arg1) => fn(arg0, arg1),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static objc.CGSize _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGSize arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          objc.CGSize Function(ffi.Pointer<ffi.Void> arg0, objc.CGSize arg1)
        >
      >()
      .asFunction<
        objc.CGSize Function(ffi.Pointer<ffi.Void>, objc.CGSize)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            objc.CGSize Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGSize,
            )
          >(_fnPtrTrampoline)
          .cast();
  static objc.CGSize _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGSize arg1,
  ) =>
      (objc.getBlockClosure(block)
          as objc.CGSize Function(ffi.Pointer<ffi.Void>, objc.CGSize))(
        arg0,
        arg1,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            objc.CGSize Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGSize,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, objc.CGSize)>`.
extension ObjCBlock_NSSize_ffiVoid_NSSize$CallExtension
    on
        objc.ObjCBlock<
          objc.CGSize Function(ffi.Pointer<ffi.Void>, objc.CGSize)
        > {
  objc.CGSize call(ffi.Pointer<ffi.Void> arg0, objc.CGSize arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          objc.CGSize Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.CGSize arg1,
          )
        >
      >()
      .asFunction<
        objc.CGSize Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          objc.CGSize,
        )
      >()(ref.pointer, arg0, arg1);
}

late final _sel_accessibilityScreenPointForLayoutPoint_ = objc.registerName(
  "accessibilityScreenPointForLayoutPoint:",
);
late final _sel_accessibilityScreenSizeForLayoutSize_ = objc.registerName(
  "accessibilityScreenSizeForLayoutSize:",
);
late final _sel_accessibilityHandles = objc.registerName(
  "accessibilityHandles",
);
late final _sel_setAccessibilityHandles_ = objc.registerName(
  "setAccessibilityHandles:",
);
late final _sel_accessibilityWarningValue = objc.registerName(
  "accessibilityWarningValue",
);
late final _sel_setAccessibilityWarningValue_ = objc.registerName(
  "setAccessibilityWarningValue:",
);
late final _sel_accessibilityCriticalValue = objc.registerName(
  "accessibilityCriticalValue",
);
late final _sel_setAccessibilityCriticalValue_ = objc.registerName(
  "setAccessibilityCriticalValue:",
);
late final _sel_isAccessibilityDisclosed = objc.registerName(
  "isAccessibilityDisclosed",
);
late final _sel_setAccessibilityDisclosed_ = objc.registerName(
  "setAccessibilityDisclosed:",
);
late final _sel_accessibilityDisclosedByRow = objc.registerName(
  "accessibilityDisclosedByRow",
);
late final _sel_setAccessibilityDisclosedByRow_ = objc.registerName(
  "setAccessibilityDisclosedByRow:",
);
late final _sel_accessibilityDisclosedRows = objc.registerName(
  "accessibilityDisclosedRows",
);
late final _sel_setAccessibilityDisclosedRows_ = objc.registerName(
  "setAccessibilityDisclosedRows:",
);
late final _sel_accessibilityDisclosureLevel = objc.registerName(
  "accessibilityDisclosureLevel",
);

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSInteger_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromFunction(
    int Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static int _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline, 0)
          .cast();
  static int _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline, 0)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSInteger_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> {
  int call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Long Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        int Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
      >()(ref.pointer, arg0);
}

late final _sel_setAccessibilityDisclosureLevel_ = objc.registerName(
  "setAccessibilityDisclosureLevel:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSInteger {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, int) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, int) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_unr2j3(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, int) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_unr2j3(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, int))(
      arg0,
      arg1,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, int))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)
        >
      >()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Long,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, int))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Long,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSInteger$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)> {
  void call(ffi.Pointer<ffi.Void> arg0, int arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Long arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          int,
        )
      >()(ref.pointer, arg0, arg1);
}

late final _sel_accessibilityMarkerUIElements = objc.registerName(
  "accessibilityMarkerUIElements",
);
late final _sel_setAccessibilityMarkerUIElements_ = objc.registerName(
  "setAccessibilityMarkerUIElements:",
);
late final _sel_accessibilityMarkerValues = objc.registerName(
  "accessibilityMarkerValues",
);
late final _sel_setAccessibilityMarkerValues_ = objc.registerName(
  "setAccessibilityMarkerValues:",
);
late final _sel_accessibilityMarkerGroupUIElement = objc.registerName(
  "accessibilityMarkerGroupUIElement",
);
late final _sel_setAccessibilityMarkerGroupUIElement_ = objc.registerName(
  "setAccessibilityMarkerGroupUIElement:",
);
late final _sel_accessibilityUnits = objc.registerName("accessibilityUnits");
late final _sel_setAccessibilityUnits_ = objc.registerName(
  "setAccessibilityUnits:",
);
late final _sel_accessibilityUnitDescription = objc.registerName(
  "accessibilityUnitDescription",
);
late final _sel_setAccessibilityUnitDescription_ = objc.registerName(
  "setAccessibilityUnitDescription:",
);
late final _sel_accessibilityRulerMarkerType = objc.registerName(
  "accessibilityRulerMarkerType",
);
final _objc_msgSend_w95izs = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSAccessibilityRulerMarkerType_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromFunction(
    NSAccessibilityRulerMarkerType Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).value,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static int _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline, 0)
          .cast();
  static int _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline, 0)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSAccessibilityRulerMarkerType_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> {
  NSAccessibilityRulerMarkerType call(ffi.Pointer<ffi.Void> arg0) =>
      NSAccessibilityRulerMarkerType.fromValue(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                ffi.Long Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0,
                )
              >
            >()
            .asFunction<
              int Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
              )
            >()(ref.pointer, arg0),
      );
}

late final _sel_setAccessibilityRulerMarkerType_ = objc.registerName(
  "setAccessibilityRulerMarkerType:",
);
final _objc_msgSend_1y0966 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSAccessibilityRulerMarkerType {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, NSAccessibilityRulerMarkerType) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, NSAccessibilityRulerMarkerType.fromValue(arg1)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, NSAccessibilityRulerMarkerType) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, NSAccessibilityRulerMarkerType.fromValue(arg1)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_w4u4pi(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, NSAccessibilityRulerMarkerType) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, NSAccessibilityRulerMarkerType.fromValue(arg1)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, NSAccessibilityRulerMarkerType.fromValue(arg1)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_w4u4pi(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, int))(
      arg0,
      arg1,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, int))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)
        >
      >()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Long,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, int))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Long,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSAccessibilityRulerMarkerType$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSAccessibilityRulerMarkerType arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Long arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              int,
            )
          >()(ref.pointer, arg0, arg1.value);
}

late final _sel_accessibilityMarkerTypeDescription = objc.registerName(
  "accessibilityMarkerTypeDescription",
);
late final _sel_setAccessibilityMarkerTypeDescription_ = objc.registerName(
  "setAccessibilityMarkerTypeDescription:",
);
late final _sel_accessibilityHorizontalScrollBar = objc.registerName(
  "accessibilityHorizontalScrollBar",
);
late final _sel_setAccessibilityHorizontalScrollBar_ = objc.registerName(
  "setAccessibilityHorizontalScrollBar:",
);
late final _sel_accessibilityVerticalScrollBar = objc.registerName(
  "accessibilityVerticalScrollBar",
);
late final _sel_setAccessibilityVerticalScrollBar_ = objc.registerName(
  "setAccessibilityVerticalScrollBar:",
);
late final _sel_accessibilityAllowedValues = objc.registerName(
  "accessibilityAllowedValues",
);
late final _sel_setAccessibilityAllowedValues_ = objc.registerName(
  "setAccessibilityAllowedValues:",
);
late final _sel_accessibilityLabelUIElements = objc.registerName(
  "accessibilityLabelUIElements",
);
late final _sel_setAccessibilityLabelUIElements_ = objc.registerName(
  "setAccessibilityLabelUIElements:",
);
late final _sel_accessibilityLabelValue = objc.registerName(
  "accessibilityLabelValue",
);
final _objc_msgSend_2cgrxl = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Float Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_2cgrxlFpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Float Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Float Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_ffiFloat_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Float Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Float Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Float Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Float Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Float Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Float Function(ffi.Pointer<ffi.Void>)> fromFunction(
    double Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Float Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static double _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<ffi.Float Function(ffi.Pointer<ffi.Void> arg0)>
      >()
      .asFunction<double Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Float Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline, 0.0)
          .cast();
  static double _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as double Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Float Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline, 0.0)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Float Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_ffiFloat_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Float Function(ffi.Pointer<ffi.Void>)> {
  double call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Float Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        double Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
      >()(ref.pointer, arg0);
}

late final _sel_setAccessibilityLabelValue_ = objc.registerName(
  "setAccessibilityLabelValue:",
);
final _objc_msgSend_v5hmet = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Float,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_ffiFloat {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Float arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, double) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, double arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, double) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, double arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1fcaigd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, double) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, double arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, double arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1fcaigd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    double arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.Void>, double))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Float,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Float,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    double arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, double))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Float,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Float,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Float,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Float,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    double arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Float arg1)
        >
      >()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, double)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Float,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    double arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, double))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Float,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)>`.
extension ObjCBlock_ffiVoid_ffiVoid_ffiFloat$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Float)> {
  void call(ffi.Pointer<ffi.Void> arg0, double arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Float arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          double,
        )
      >()(ref.pointer, arg0, arg1);
}

late final _sel_accessibilitySplitters = objc.registerName(
  "accessibilitySplitters",
);
late final _sel_setAccessibilitySplitters_ = objc.registerName(
  "setAccessibilitySplitters:",
);
late final _sel_accessibilityDecrementButton = objc.registerName(
  "accessibilityDecrementButton",
);
late final _sel_setAccessibilityDecrementButton_ = objc.registerName(
  "setAccessibilityDecrementButton:",
);
late final _sel_accessibilityIncrementButton = objc.registerName(
  "accessibilityIncrementButton",
);
late final _sel_setAccessibilityIncrementButton_ = objc.registerName(
  "setAccessibilityIncrementButton:",
);
late final _sel_accessibilityTabs = objc.registerName("accessibilityTabs");
late final _sel_setAccessibilityTabs_ = objc.registerName(
  "setAccessibilityTabs:",
);
late final _sel_accessibilityHeader = objc.registerName("accessibilityHeader");
late final _sel_setAccessibilityHeader_ = objc.registerName(
  "setAccessibilityHeader:",
);
late final _sel_accessibilityColumnCount = objc.registerName(
  "accessibilityColumnCount",
);
late final _sel_setAccessibilityColumnCount_ = objc.registerName(
  "setAccessibilityColumnCount:",
);
late final _sel_accessibilityRowCount = objc.registerName(
  "accessibilityRowCount",
);
late final _sel_setAccessibilityRowCount_ = objc.registerName(
  "setAccessibilityRowCount:",
);
late final _sel_accessibilityIndex = objc.registerName("accessibilityIndex");
late final _sel_setAccessibilityIndex_ = objc.registerName(
  "setAccessibilityIndex:",
);
late final _sel_accessibilityColumns = objc.registerName(
  "accessibilityColumns",
);
late final _sel_setAccessibilityColumns_ = objc.registerName(
  "setAccessibilityColumns:",
);
late final _sel_accessibilityRows = objc.registerName("accessibilityRows");
late final _sel_setAccessibilityRows_ = objc.registerName(
  "setAccessibilityRows:",
);
late final _sel_accessibilityVisibleRows = objc.registerName(
  "accessibilityVisibleRows",
);
late final _sel_setAccessibilityVisibleRows_ = objc.registerName(
  "setAccessibilityVisibleRows:",
);
late final _sel_accessibilitySelectedRows = objc.registerName(
  "accessibilitySelectedRows",
);
late final _sel_setAccessibilitySelectedRows_ = objc.registerName(
  "setAccessibilitySelectedRows:",
);
late final _sel_accessibilityVisibleColumns = objc.registerName(
  "accessibilityVisibleColumns",
);
late final _sel_setAccessibilityVisibleColumns_ = objc.registerName(
  "setAccessibilityVisibleColumns:",
);
late final _sel_accessibilitySelectedColumns = objc.registerName(
  "accessibilitySelectedColumns",
);
late final _sel_setAccessibilitySelectedColumns_ = objc.registerName(
  "setAccessibilitySelectedColumns:",
);
late final _sel_accessibilitySortDirection = objc.registerName(
  "accessibilitySortDirection",
);
final _objc_msgSend_16y6cxr = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSAccessibilitySortDirection_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromFunction(
    NSAccessibilitySortDirection Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).value,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static int _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline, 0)
          .cast();
  static int _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline, 0)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSAccessibilitySortDirection_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> {
  NSAccessibilitySortDirection call(ffi.Pointer<ffi.Void> arg0) =>
      NSAccessibilitySortDirection.fromValue(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                ffi.Long Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0,
                )
              >
            >()
            .asFunction<
              int Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
              )
            >()(ref.pointer, arg0),
      );
}

late final _sel_setAccessibilitySortDirection_ = objc.registerName(
  "setAccessibilitySortDirection:",
);
final _objc_msgSend_5reanf = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSAccessibilitySortDirection {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, NSAccessibilitySortDirection) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, NSAccessibilitySortDirection.fromValue(arg1)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, NSAccessibilitySortDirection) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, NSAccessibilitySortDirection.fromValue(arg1)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_141m1k3(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, NSAccessibilitySortDirection) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, NSAccessibilitySortDirection.fromValue(arg1)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, NSAccessibilitySortDirection.fromValue(arg1)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_141m1k3(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, int))(
      arg0,
      arg1,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, int))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)
        >
      >()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Long,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, int))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Long,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSAccessibilitySortDirection$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSAccessibilitySortDirection arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Long arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              int,
            )
          >()(ref.pointer, arg0, arg1.value);
}

late final _sel_accessibilityRowHeaderUIElements = objc.registerName(
  "accessibilityRowHeaderUIElements",
);
late final _sel_setAccessibilityRowHeaderUIElements_ = objc.registerName(
  "setAccessibilityRowHeaderUIElements:",
);
late final _sel_accessibilitySelectedCells = objc.registerName(
  "accessibilitySelectedCells",
);
late final _sel_setAccessibilitySelectedCells_ = objc.registerName(
  "setAccessibilitySelectedCells:",
);
late final _sel_accessibilityVisibleCells = objc.registerName(
  "accessibilityVisibleCells",
);
late final _sel_setAccessibilityVisibleCells_ = objc.registerName(
  "setAccessibilityVisibleCells:",
);
late final _sel_accessibilityColumnHeaderUIElements = objc.registerName(
  "accessibilityColumnHeaderUIElements",
);
late final _sel_setAccessibilityColumnHeaderUIElements_ = objc.registerName(
  "setAccessibilityColumnHeaderUIElements:",
);
late final _sel_accessibilityCellForColumn_row_ = objc.registerName(
  "accessibilityCellForColumn:row:",
);
final _objc_msgSend_1nzyvs1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        int,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, ffi.Long, ffi.Long)>`.
abstract final class ObjCBlock_objcObjCObjectImpl_ffiVoid_NSInteger_NSInteger {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(
      ffi.Pointer<ffi.Void>,
      ffi.Long,
      ffi.Long,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(
          ffi.Pointer<ffi.Void>,
          ffi.Long,
          ffi.Long,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(
      ffi.Pointer<ffi.Void>,
      ffi.Long,
      ffi.Long,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Long arg1,
          ffi.Long arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(
          ffi.Pointer<ffi.Void>,
          ffi.Long,
          ffi.Long,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(
      ffi.Pointer<ffi.Void>,
      ffi.Long,
      ffi.Long,
    )
  >
  fromFunction(
    objc.ObjCObject? Function(ffi.Pointer<ffi.Void>, int, int) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(
          ffi.Pointer<ffi.Void>,
          ffi.Long,
          ffi.Long,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, int arg1, int arg2) =>
              fn(arg0, arg1, arg2)?.ref.retainAndAutorelease() ?? ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
    int arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Long arg1,
            ffi.Long arg2,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Long,
              ffi.Long,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
    int arg2,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void>,
            int,
            int,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Long,
              ffi.Long,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, ffi.Long, ffi.Long)>`.
extension ObjCBlock_objcObjCObjectImpl_ffiVoid_NSInteger_NSInteger$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObjectImpl>? Function(
            ffi.Pointer<ffi.Void>,
            ffi.Long,
            ffi.Long,
          )
        > {
  objc.ObjCObject? call(ffi.Pointer<ffi.Void> arg0, int arg1, int arg2) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Long arg1,
                    ffi.Long arg2,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  int,
                  int,
                )
              >()(ref.pointer, arg0, arg1, arg2)
              .address ==
          0
      ? null
      : objc.ObjCObject(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Long arg1,
                    ffi.Long arg2,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  int,
                  int,
                )
              >()(ref.pointer, arg0, arg1, arg2),
          retain: true,
          release: true,
        );
}

late final _sel_accessibilityRowIndexRange = objc.registerName(
  "accessibilityRowIndexRange",
);
final _objc_msgSend_1u11dbb = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.NSRange Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      objc.NSRange Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1u11dbbStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.NSRange>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.NSRange>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<objc.NSRange Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSRange_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSRange Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSRange Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSRange Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<objc.NSRange Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<objc.NSRange Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSRange Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    objc.NSRange Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSRange Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static objc.NSRange _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<objc.NSRange Function(ffi.Pointer<ffi.Void> arg0)>
      >()
      .asFunction<objc.NSRange Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            objc.NSRange Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static objc.NSRange _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as objc.NSRange Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            objc.NSRange Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSRange Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSRange_ffiVoid$CallExtension
    on objc.ObjCBlock<objc.NSRange Function(ffi.Pointer<ffi.Void>)> {
  objc.NSRange call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          objc.NSRange Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        objc.NSRange Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
        )
      >()(ref.pointer, arg0);
}

late final _sel_setAccessibilityRowIndexRange_ = objc.registerName(
  "setAccessibilityRowIndexRange:",
);
final _objc_msgSend_1e3pm0z = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.NSRange,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.NSRange,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSRange {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> arg0, objc.NSRange arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.NSRange) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, objc.NSRange arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.NSRange) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.NSRange arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_xpqfd7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.NSRange) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.NSRange arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.NSRange arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_xpqfd7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.Void>, objc.NSRange))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      objc.NSRange,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            objc.NSRange,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, objc.NSRange))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      objc.NSRange,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            objc.NSRange,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      objc.NSRange,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            objc.NSRange,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
  ) =>
      block.ref.target
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void> arg0, objc.NSRange arg1)
            >
          >()
          .asFunction<void Function(ffi.Pointer<ffi.Void>, objc.NSRange)>()(
        arg0,
        arg1,
      );
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.NSRange,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, objc.NSRange))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.NSRange,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSRange$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSRange arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.NSRange arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          objc.NSRange,
        )
      >()(ref.pointer, arg0, arg1);
}

late final _sel_accessibilityColumnIndexRange = objc.registerName(
  "accessibilityColumnIndexRange",
);
late final _sel_setAccessibilityColumnIndexRange_ = objc.registerName(
  "setAccessibilityColumnIndexRange:",
);
late final _sel_accessibilityInsertionPointLineNumber = objc.registerName(
  "accessibilityInsertionPointLineNumber",
);
late final _sel_setAccessibilityInsertionPointLineNumber_ = objc.registerName(
  "setAccessibilityInsertionPointLineNumber:",
);
late final _sel_accessibilitySharedCharacterRange = objc.registerName(
  "accessibilitySharedCharacterRange",
);
late final _sel_setAccessibilitySharedCharacterRange_ = objc.registerName(
  "setAccessibilitySharedCharacterRange:",
);
late final _sel_accessibilitySharedTextUIElements = objc.registerName(
  "accessibilitySharedTextUIElements",
);
late final _sel_setAccessibilitySharedTextUIElements_ = objc.registerName(
  "setAccessibilitySharedTextUIElements:",
);
late final _sel_accessibilityVisibleCharacterRange = objc.registerName(
  "accessibilityVisibleCharacterRange",
);
late final _sel_setAccessibilityVisibleCharacterRange_ = objc.registerName(
  "setAccessibilityVisibleCharacterRange:",
);
late final _sel_accessibilityNumberOfCharacters = objc.registerName(
  "accessibilityNumberOfCharacters",
);
late final _sel_setAccessibilityNumberOfCharacters_ = objc.registerName(
  "setAccessibilityNumberOfCharacters:",
);
late final _sel_accessibilitySelectedText = objc.registerName(
  "accessibilitySelectedText",
);
late final _sel_setAccessibilitySelectedText_ = objc.registerName(
  "setAccessibilitySelectedText:",
);
late final _sel_accessibilitySelectedTextRange = objc.registerName(
  "accessibilitySelectedTextRange",
);
late final _sel_setAccessibilitySelectedTextRange_ = objc.registerName(
  "setAccessibilitySelectedTextRange:",
);
late final _sel_accessibilitySelectedTextRanges = objc.registerName(
  "accessibilitySelectedTextRanges",
);
late final _sel_setAccessibilitySelectedTextRanges_ = objc.registerName(
  "setAccessibilitySelectedTextRanges:",
);
late final _sel_accessibilityAttributedStringForRange_ = objc.registerName(
  "accessibilityAttributedStringForRange:",
);
final _objc_msgSend_1k1o1s7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.NSRange,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.NSRange,
      )
    >();

/// Construction methods for `objc.ObjCBlock<objc.NSAttributedString? Function(ffi.Pointer<ffi.Void>, objc.NSRange)>`.
abstract final class ObjCBlock_NSAttributedString_ffiVoid_NSRange {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.NSAttributedString? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        objc.NSAttributedString? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.NSAttributedString? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void> arg0,
          objc.NSRange arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.NSAttributedString? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.NSAttributedString? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
  >
  fromFunction(
    objc.NSAttributedString? Function(ffi.Pointer<ffi.Void>, objc.NSRange) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.NSAttributedString? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, objc.NSRange arg1) =>
              fn(arg0, arg1)?.ref.retainAndAutorelease() ?? ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void> arg0,
            objc.NSRange arg1,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSRange,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.NSRange,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void>,
            objc.NSRange,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.NSRange,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSAttributedString? Function(ffi.Pointer<ffi.Void>, objc.NSRange)>`.
extension ObjCBlock_NSAttributedString_ffiVoid_NSRange$CallExtension
    on
        objc.ObjCBlock<
          objc.NSAttributedString? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
        > {
  objc.NSAttributedString? call(
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
  ) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    objc.NSRange arg1,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  objc.NSRange,
                )
              >()(ref.pointer, arg0, arg1)
              .address ==
          0
      ? null
      : objc.NSAttributedString.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    objc.NSRange arg1,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  objc.NSRange,
                )
              >()(ref.pointer, arg0, arg1),
          retain: true,
          release: true,
        );
}

late final _sel_accessibilityRangeForLine_ = objc.registerName(
  "accessibilityRangeForLine:",
);
final _objc_msgSend_118andf = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.NSRange Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      objc.NSRange Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_118andfStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.NSRange>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.NSRange>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// Construction methods for `objc.ObjCBlock<objc.NSRange Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
abstract final class ObjCBlock_NSRange_ffiVoid_NSInteger {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSRange Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSRange Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSRange Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        objc.NSRange Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.NSRange Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSRange Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromFunction(
    objc.NSRange Function(ffi.Pointer<ffi.Void>, int) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSRange Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static objc.NSRange _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) =>
      block.ref.target
          .cast<
            ffi.NativeFunction<
              objc.NSRange Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)
            >
          >()
          .asFunction<objc.NSRange Function(ffi.Pointer<ffi.Void>, int)>()(
        arg0,
        arg1,
      );
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            objc.NSRange Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Long,
            )
          >(_fnPtrTrampoline)
          .cast();
  static objc.NSRange _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) =>
      (objc.getBlockClosure(block)
          as objc.NSRange Function(ffi.Pointer<ffi.Void>, int))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            objc.NSRange Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Long,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSRange Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
extension ObjCBlock_NSRange_ffiVoid_NSInteger$CallExtension
    on objc.ObjCBlock<objc.NSRange Function(ffi.Pointer<ffi.Void>, ffi.Long)> {
  objc.NSRange call(ffi.Pointer<ffi.Void> arg0, int arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          objc.NSRange Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Long arg1,
          )
        >
      >()
      .asFunction<
        objc.NSRange Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          int,
        )
      >()(ref.pointer, arg0, arg1);
}

late final _sel_accessibilityStringForRange_ = objc.registerName(
  "accessibilityStringForRange:",
);

/// Construction methods for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, objc.NSRange)>`.
abstract final class ObjCBlock_NSString_ffiVoid_NSRange {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.NSString? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        objc.NSString? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.NSString? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void> arg0,
          objc.NSRange arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.NSString? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.NSString? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
  >
  fromFunction(
    objc.NSString? Function(ffi.Pointer<ffi.Void>, objc.NSRange) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.NSString? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, objc.NSRange arg1) =>
              fn(arg0, arg1)?.ref.retainAndAutorelease() ?? ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void> arg0,
            objc.NSRange arg1,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSRange,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.NSRange,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void>,
            objc.NSRange,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.NSRange,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, objc.NSRange)>`.
extension ObjCBlock_NSString_ffiVoid_NSRange$CallExtension
    on
        objc.ObjCBlock<
          objc.NSString? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
        > {
  objc.NSString? call(ffi.Pointer<ffi.Void> arg0, objc.NSRange arg1) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    objc.NSRange arg1,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  objc.NSRange,
                )
              >()(ref.pointer, arg0, arg1)
              .address ==
          0
      ? null
      : objc.NSString.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    objc.NSRange arg1,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  objc.NSRange,
                )
              >()(ref.pointer, arg0, arg1),
          retain: true,
          release: true,
        );
}

late final _sel_accessibilityRangeForPosition_ = objc.registerName(
  "accessibilityRangeForPosition:",
);
final _objc_msgSend_d3jy2u = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.NSRange Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
        )
      >
    >()
    .asFunction<
      objc.NSRange Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
      )
    >();
final _objc_msgSend_d3jy2uStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.NSRange>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.NSRange>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
      )
    >();

/// Construction methods for `objc.ObjCBlock<objc.NSRange Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>`.
abstract final class ObjCBlock_NSRange_ffiVoid_NSPoint {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.NSRange Function(ffi.Pointer<ffi.Void>, objc.CGPoint)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        objc.NSRange Function(ffi.Pointer<ffi.Void>, objc.CGPoint)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.NSRange Function(ffi.Pointer<ffi.Void>, objc.CGPoint)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        objc.NSRange Function(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.NSRange Function(ffi.Pointer<ffi.Void>, objc.CGPoint)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.NSRange Function(ffi.Pointer<ffi.Void>, objc.CGPoint)
  >
  fromFunction(
    objc.NSRange Function(ffi.Pointer<ffi.Void>, objc.CGPoint) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.NSRange Function(ffi.Pointer<ffi.Void>, objc.CGPoint)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static objc.NSRange _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGPoint arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          objc.NSRange Function(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1)
        >
      >()
      .asFunction<
        objc.NSRange Function(ffi.Pointer<ffi.Void>, objc.CGPoint)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            objc.NSRange Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGPoint,
            )
          >(_fnPtrTrampoline)
          .cast();
  static objc.NSRange _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGPoint arg1,
  ) =>
      (objc.getBlockClosure(block)
          as objc.NSRange Function(ffi.Pointer<ffi.Void>, objc.CGPoint))(
        arg0,
        arg1,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            objc.NSRange Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGPoint,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSRange Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>`.
extension ObjCBlock_NSRange_ffiVoid_NSPoint$CallExtension
    on
        objc.ObjCBlock<
          objc.NSRange Function(ffi.Pointer<ffi.Void>, objc.CGPoint)
        > {
  objc.NSRange call(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          objc.NSRange Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.CGPoint arg1,
          )
        >
      >()
      .asFunction<
        objc.NSRange Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          objc.CGPoint,
        )
      >()(ref.pointer, arg0, arg1);
}

late final _sel_accessibilityRangeForIndex_ = objc.registerName(
  "accessibilityRangeForIndex:",
);
late final _sel_accessibilityFrameForRange_ = objc.registerName(
  "accessibilityFrameForRange:",
);
final _objc_msgSend_1c8xwaw = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.NSRange,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.NSRange,
      )
    >();
final _objc_msgSend_1c8xwawStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.NSRange,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.NSRange,
      )
    >();

/// Construction methods for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.NSRange)>`.
abstract final class ObjCBlock_NSRect_ffiVoid_NSRange {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.NSRange)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.NSRange)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.NSRange)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        objc.CGRect Function(ffi.Pointer<ffi.Void> arg0, objc.NSRange arg1)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.NSRange)>(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.NSRange)
  >
  fromFunction(
    objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.NSRange) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.NSRange)>(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, objc.NSRange arg1) => fn(arg0, arg1),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static objc.CGRect _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          objc.CGRect Function(ffi.Pointer<ffi.Void> arg0, objc.NSRange arg1)
        >
      >()
      .asFunction<
        objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.NSRange)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            objc.CGRect Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.NSRange,
            )
          >(_fnPtrTrampoline)
          .cast();
  static objc.CGRect _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
  ) =>
      (objc.getBlockClosure(block)
          as objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.NSRange))(
        arg0,
        arg1,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            objc.CGRect Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.NSRange,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.NSRange)>`.
extension ObjCBlock_NSRect_ffiVoid_NSRange$CallExtension
    on
        objc.ObjCBlock<
          objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.NSRange)
        > {
  objc.CGRect call(ffi.Pointer<ffi.Void> arg0, objc.NSRange arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          objc.CGRect Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.NSRange arg1,
          )
        >
      >()
      .asFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          objc.NSRange,
        )
      >()(ref.pointer, arg0, arg1);
}

late final _sel_accessibilityRTFForRange_ = objc.registerName(
  "accessibilityRTFForRange:",
);

/// Construction methods for `objc.ObjCBlock<objc.NSData? Function(ffi.Pointer<ffi.Void>, objc.NSRange)>`.
abstract final class ObjCBlock_NSData_ffiVoid_NSRange {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.NSData? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        objc.NSData? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.NSData? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void> arg0,
          objc.NSRange arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.NSData? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.NSData? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
  >
  fromFunction(
    objc.NSData? Function(ffi.Pointer<ffi.Void>, objc.NSRange) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.NSData? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, objc.NSRange arg1) =>
              fn(arg0, arg1)?.ref.retainAndAutorelease() ?? ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void> arg0,
            objc.NSRange arg1,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSRange,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.NSRange,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void>,
            objc.NSRange,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.NSRange,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSData? Function(ffi.Pointer<ffi.Void>, objc.NSRange)>`.
extension ObjCBlock_NSData_ffiVoid_NSRange$CallExtension
    on
        objc.ObjCBlock<
          objc.NSData? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
        > {
  objc.NSData? call(ffi.Pointer<ffi.Void> arg0, objc.NSRange arg1) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    objc.NSRange arg1,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  objc.NSRange,
                )
              >()(ref.pointer, arg0, arg1)
              .address ==
          0
      ? null
      : objc.NSData.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    objc.NSRange arg1,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  objc.NSRange,
                )
              >()(ref.pointer, arg0, arg1),
          retain: true,
          release: true,
        );
}

late final _sel_accessibilityStyleRangeForIndex_ = objc.registerName(
  "accessibilityStyleRangeForIndex:",
);
late final _sel_accessibilityLineForIndex_ = objc.registerName(
  "accessibilityLineForIndex:",
);
final _objc_msgSend_12hwf9n = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
abstract final class ObjCBlock_NSInteger_ffiVoid_NSInteger {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Long Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromFunction(
    int Function(ffi.Pointer<ffi.Void>, int) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static int _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)
        >
      >()
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Long,
            )
          >(_fnPtrTrampoline, 0)
          .cast();
  static int _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) =>
      (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>, int))(
        arg0,
        arg1,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Long,
            )
          >(_closureTrampoline, 0)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
extension ObjCBlock_NSInteger_ffiVoid_NSInteger$CallExtension
    on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, ffi.Long)> {
  int call(ffi.Pointer<ffi.Void> arg0, int arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Long Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Long arg1,
          )
        >
      >()
      .asFunction<
        int Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          int,
        )
      >()(ref.pointer, arg0, arg1);
}

late final _sel_accessibilityToolbarButton = objc.registerName(
  "accessibilityToolbarButton",
);
late final _sel_setAccessibilityToolbarButton_ = objc.registerName(
  "setAccessibilityToolbarButton:",
);
late final _sel_isAccessibilityModal = objc.registerName(
  "isAccessibilityModal",
);
late final _sel_setAccessibilityModal_ = objc.registerName(
  "setAccessibilityModal:",
);
late final _sel_accessibilityProxy = objc.registerName("accessibilityProxy");
late final _sel_setAccessibilityProxy_ = objc.registerName(
  "setAccessibilityProxy:",
);
late final _sel_isAccessibilityMain = objc.registerName("isAccessibilityMain");
late final _sel_setAccessibilityMain_ = objc.registerName(
  "setAccessibilityMain:",
);
late final _sel_accessibilityFullScreenButton = objc.registerName(
  "accessibilityFullScreenButton",
);
late final _sel_setAccessibilityFullScreenButton_ = objc.registerName(
  "setAccessibilityFullScreenButton:",
);
late final _sel_accessibilityGrowArea = objc.registerName(
  "accessibilityGrowArea",
);
late final _sel_setAccessibilityGrowArea_ = objc.registerName(
  "setAccessibilityGrowArea:",
);
late final _sel_accessibilityDocument = objc.registerName(
  "accessibilityDocument",
);
late final _sel_setAccessibilityDocument_ = objc.registerName(
  "setAccessibilityDocument:",
);
late final _sel_accessibilityDefaultButton = objc.registerName(
  "accessibilityDefaultButton",
);
late final _sel_setAccessibilityDefaultButton_ = objc.registerName(
  "setAccessibilityDefaultButton:",
);
late final _sel_accessibilityCloseButton = objc.registerName(
  "accessibilityCloseButton",
);
late final _sel_setAccessibilityCloseButton_ = objc.registerName(
  "setAccessibilityCloseButton:",
);
late final _sel_accessibilityZoomButton = objc.registerName(
  "accessibilityZoomButton",
);
late final _sel_setAccessibilityZoomButton_ = objc.registerName(
  "setAccessibilityZoomButton:",
);
late final _sel_accessibilityMinimizeButton = objc.registerName(
  "accessibilityMinimizeButton",
);
late final _sel_setAccessibilityMinimizeButton_ = objc.registerName(
  "setAccessibilityMinimizeButton:",
);
late final _sel_isAccessibilityMinimized = objc.registerName(
  "isAccessibilityMinimized",
);
late final _sel_setAccessibilityMinimized_ = objc.registerName(
  "setAccessibilityMinimized:",
);
late final _sel_accessibilityCustomActions = objc.registerName(
  "accessibilityCustomActions",
);
late final _sel_setAccessibilityCustomActions_ = objc.registerName(
  "setAccessibilityCustomActions:",
);
late final _sel_accessibilityPerformCancel = objc.registerName(
  "accessibilityPerformCancel",
);
late final _sel_accessibilityPerformConfirm = objc.registerName(
  "accessibilityPerformConfirm",
);
late final _sel_accessibilityPerformDecrement = objc.registerName(
  "accessibilityPerformDecrement",
);
late final _sel_accessibilityPerformDelete = objc.registerName(
  "accessibilityPerformDelete",
);
late final _sel_accessibilityPerformIncrement = objc.registerName(
  "accessibilityPerformIncrement",
);
late final _sel_accessibilityPerformPick = objc.registerName(
  "accessibilityPerformPick",
);
late final _sel_accessibilityPerformPress = objc.registerName(
  "accessibilityPerformPress",
);
late final _sel_accessibilityPerformRaise = objc.registerName(
  "accessibilityPerformRaise",
);
late final _sel_accessibilityPerformShowAlternateUI = objc.registerName(
  "accessibilityPerformShowAlternateUI",
);
late final _sel_accessibilityPerformShowDefaultUI = objc.registerName(
  "accessibilityPerformShowDefaultUI",
);
late final _sel_accessibilityPerformShowMenu = objc.registerName(
  "accessibilityPerformShowMenu",
);
late final _sel_isAccessibilitySelectorAllowed_ = objc.registerName(
  "isAccessibilitySelectorAllowed:",
);
final _objc_msgSend_1srf6wk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)>`.
abstract final class ObjCBlock_bool_ffiVoid_objcObjCSelector {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCSelector> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
  >
  fromFunction(
    bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCSelector> arg1) =>
              fn(arg0, arg1),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCSelector> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCSelector> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCSelector>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCSelector> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as bool Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCSelector>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCSelector>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCSelector>)>`.
extension ObjCBlock_bool_ffiVoid_objcObjCSelector$CallExtension
    on
        objc.ObjCBlock<
          ffi.Bool Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCSelector>,
          )
        > {
  bool call(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCSelector> arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Bool Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCSelector> arg1,
              )
            >
          >()
          .asFunction<
            bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCSelector>,
            )
          >()(ref.pointer, arg0, arg1);
}

late final _sel_nextKeyView = objc.registerName("nextKeyView");
late final _sel_setNextKeyView_ = objc.registerName("setNextKeyView:");
late final _sel_previousKeyView = objc.registerName("previousKeyView");
late final _sel_nextValidKeyView = objc.registerName("nextValidKeyView");
late final _sel_previousValidKeyView = objc.registerName(
  "previousValidKeyView",
);
late final _sel_canBecomeKeyView = objc.registerName("canBecomeKeyView");
late final _sel_setKeyboardFocusRingNeedsDisplayInRect_ = objc.registerName(
  "setKeyboardFocusRingNeedsDisplayInRect:",
);
late final _sel_focusRingType = objc.registerName("focusRingType");
final _objc_msgSend_1izjlh8 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setFocusRingType_ = objc.registerName("setFocusRingType:");
final _objc_msgSend_234agq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_defaultFocusRingType = objc.registerName(
  "defaultFocusRingType",
);
late final _sel_drawFocusRingMask = objc.registerName("drawFocusRingMask");
late final _sel_focusRingMaskBounds = objc.registerName("focusRingMaskBounds");
late final _sel_noteFocusRingMaskChanged = objc.registerName(
  "noteFocusRingMaskChanged",
);

/// NSKeyboardUI
extension NSKeyboardUI on NSView {
  /// canBecomeKeyView
  bool get canBecomeKeyView {
    objc.checkOsVersionInternal('NSView.canBecomeKeyView', iOS: (true, null));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_canBecomeKeyView);
  }

  /// drawFocusRingMask
  void drawFocusRingMask() {
    objc.checkOsVersionInternal(
      'NSView.drawFocusRingMask',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_drawFocusRingMask);
  }

  /// focusRingMaskBounds
  objc.CGRect get focusRingMaskBounds {
    objc.checkOsVersionInternal(
      'NSView.focusRingMaskBounds',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(
            $ptr,
            object$.ref.pointer,
            _sel_focusRingMaskBounds,
          )
        : $ptr.ref = _objc_msgSend_bu1hbw(
            object$.ref.pointer,
            _sel_focusRingMaskBounds,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// focusRingType
  NSFocusRingType get focusRingType {
    objc.checkOsVersionInternal('NSView.focusRingType', iOS: (true, null));
    final $ret = _objc_msgSend_1izjlh8(object$.ref.pointer, _sel_focusRingType);
    return NSFocusRingType.fromValue($ret);
  }

  /// nextKeyView
  NSView? get nextKeyView {
    objc.checkOsVersionInternal('NSView.nextKeyView', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_nextKeyView);
    return $ret.address == 0
        ? null
        : NSView.fromPointer($ret, retain: true, release: true);
  }

  /// nextValidKeyView
  NSView? get nextValidKeyView {
    objc.checkOsVersionInternal('NSView.nextValidKeyView', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_nextValidKeyView,
    );
    return $ret.address == 0
        ? null
        : NSView.fromPointer($ret, retain: true, release: true);
  }

  /// noteFocusRingMaskChanged
  void noteFocusRingMaskChanged() {
    objc.checkOsVersionInternal(
      'NSView.noteFocusRingMaskChanged',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_noteFocusRingMaskChanged);
  }

  /// previousKeyView
  NSView? get previousKeyView {
    objc.checkOsVersionInternal('NSView.previousKeyView', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_previousKeyView,
    );
    return $ret.address == 0
        ? null
        : NSView.fromPointer($ret, retain: true, release: true);
  }

  /// previousValidKeyView
  NSView? get previousValidKeyView {
    objc.checkOsVersionInternal(
      'NSView.previousValidKeyView',
      iOS: (true, null),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_previousValidKeyView,
    );
    return $ret.address == 0
        ? null
        : NSView.fromPointer($ret, retain: true, release: true);
  }

  /// setFocusRingType:
  set focusRingType(NSFocusRingType value) {
    objc.checkOsVersionInternal('NSView.setFocusRingType:', iOS: (true, null));
    _objc_msgSend_234agq(
      object$.ref.pointer,
      _sel_setFocusRingType_,
      value.value,
    );
  }

  /// setKeyboardFocusRingNeedsDisplayInRect:
  void setKeyboardFocusRingNeedsDisplayInRect(objc.CGRect rect) {
    objc.checkOsVersionInternal(
      'NSView.setKeyboardFocusRingNeedsDisplayInRect:',
      iOS: (true, null),
    );
    _objc_msgSend_1okkq16(
      object$.ref.pointer,
      _sel_setKeyboardFocusRingNeedsDisplayInRect_,
      rect,
    );
  }

  /// setNextKeyView:
  set nextKeyView(NSView? value) {
    objc.checkOsVersionInternal('NSView.setNextKeyView:', iOS: (true, null));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setNextKeyView_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// defaultFocusRingType
  static NSFocusRingType getDefaultFocusRingType() {
    objc.checkOsVersionInternal(
      'NSView.defaultFocusRingType',
      iOS: (true, null),
    );
    final $ret = _objc_msgSend_1izjlh8(
      _class_NSView,
      _sel_defaultFocusRingType,
    );
    return NSFocusRingType.fromValue($ret);
  }
}

late final _sel_writeEPSInsideRect_toPasteboard_ = objc.registerName(
  "writeEPSInsideRect:toPasteboard:",
);
late final _sel_dataWithEPSInsideRect_ = objc.registerName(
  "dataWithEPSInsideRect:",
);
late final _sel_writePDFInsideRect_toPasteboard_ = objc.registerName(
  "writePDFInsideRect:toPasteboard:",
);
late final _sel_dataWithPDFInsideRect_ = objc.registerName(
  "dataWithPDFInsideRect:",
);
late final _sel_print_ = objc.registerName("print:");
late final _sel_knowsPageRange_ = objc.registerName("knowsPageRange:");
final _objc_msgSend_d8qq73 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.NSRange>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.NSRange>,
      )
    >();
late final _sel_heightAdjustLimit = objc.registerName("heightAdjustLimit");
late final _sel_widthAdjustLimit = objc.registerName("widthAdjustLimit");
late final _sel_adjustPageWidthNew_left_right_limit_ = objc.registerName(
  "adjustPageWidthNew:left:right:limit:",
);
final _objc_msgSend_1x1jj8j = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Double>,
          ffi.Double,
          ffi.Double,
          ffi.Double,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Double>,
        double,
        double,
        double,
      )
    >();
late final _sel_adjustPageHeightNew_top_bottom_limit_ = objc.registerName(
  "adjustPageHeightNew:top:bottom:limit:",
);
late final _sel_rectForPage_ = objc.registerName("rectForPage:");
final _objc_msgSend_18zln4e = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_18zln4eStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_locationOfPrintRect_ = objc.registerName(
  "locationOfPrintRect:",
);
final _objc_msgSend_txl7s5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGPoint Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      objc.CGPoint Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
      )
    >();
final _objc_msgSend_txl7s5Stret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGPoint>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGPoint>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
      )
    >();
late final _sel_drawPageBorderWithSize_ = objc.registerName(
  "drawPageBorderWithSize:",
);
late final _sel_pageHeader = objc.registerName("pageHeader");
late final _sel_pageFooter = objc.registerName("pageFooter");
late final _sel_drawSheetBorderWithSize_ = objc.registerName(
  "drawSheetBorderWithSize:",
);
late final _sel_printJobTitle = objc.registerName("printJobTitle");
late final _sel_beginDocument = objc.registerName("beginDocument");
late final _sel_endDocument = objc.registerName("endDocument");
late final _sel_beginPageInRect_atPlacement_ = objc.registerName(
  "beginPageInRect:atPlacement:",
);
final _objc_msgSend_ysm2mt = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          objc.CGPoint,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        objc.CGPoint,
      )
    >();
late final _sel_endPage = objc.registerName("endPage");

/// NSPrinting
extension NSPrinting on NSView {
  /// adjustPageHeightNew:top:bottom:limit:
  void adjustPageHeightNew(
    ffi.Pointer<ffi.Double> newBottom, {
    required double top,
    required double bottom,
    required double limit,
  }) {
    objc.checkOsVersionInternal(
      'NSView.adjustPageHeightNew:top:bottom:limit:',
      iOS: (true, null),
    );
    _objc_msgSend_1x1jj8j(
      object$.ref.pointer,
      _sel_adjustPageHeightNew_top_bottom_limit_,
      newBottom,
      top,
      bottom,
      limit,
    );
  }

  /// adjustPageWidthNew:left:right:limit:
  void adjustPageWidthNew(
    ffi.Pointer<ffi.Double> newRight, {
    required double left,
    required double right,
    required double limit,
  }) {
    objc.checkOsVersionInternal(
      'NSView.adjustPageWidthNew:left:right:limit:',
      iOS: (true, null),
    );
    _objc_msgSend_1x1jj8j(
      object$.ref.pointer,
      _sel_adjustPageWidthNew_left_right_limit_,
      newRight,
      left,
      right,
      limit,
    );
  }

  /// beginDocument
  void beginDocument() {
    objc.checkOsVersionInternal('NSView.beginDocument', iOS: (true, null));
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_beginDocument);
  }

  /// beginPageInRect:atPlacement:
  void beginPageInRect(objc.CGRect rect, {required objc.CGPoint atPlacement}) {
    objc.checkOsVersionInternal(
      'NSView.beginPageInRect:atPlacement:',
      iOS: (true, null),
    );
    _objc_msgSend_ysm2mt(
      object$.ref.pointer,
      _sel_beginPageInRect_atPlacement_,
      rect,
      atPlacement,
    );
  }

  /// dataWithEPSInsideRect:
  objc.NSData dataWithEPSInsideRect(objc.CGRect rect) {
    objc.checkOsVersionInternal(
      'NSView.dataWithEPSInsideRect:',
      iOS: (true, null),
    );
    final $ret = _objc_msgSend_15yz4e6(
      object$.ref.pointer,
      _sel_dataWithEPSInsideRect_,
      rect,
    );
    return objc.NSData.fromPointer($ret, retain: true, release: true);
  }

  /// dataWithPDFInsideRect:
  objc.NSData dataWithPDFInsideRect(objc.CGRect rect) {
    objc.checkOsVersionInternal(
      'NSView.dataWithPDFInsideRect:',
      iOS: (true, null),
    );
    final $ret = _objc_msgSend_15yz4e6(
      object$.ref.pointer,
      _sel_dataWithPDFInsideRect_,
      rect,
    );
    return objc.NSData.fromPointer($ret, retain: true, release: true);
  }

  /// drawPageBorderWithSize:
  void drawPageBorderWithSize(objc.CGSize borderSize) {
    objc.checkOsVersionInternal(
      'NSView.drawPageBorderWithSize:',
      iOS: (true, null),
    );
    _objc_msgSend_13lgpwz(
      object$.ref.pointer,
      _sel_drawPageBorderWithSize_,
      borderSize,
    );
  }

  /// drawSheetBorderWithSize:
  void drawSheetBorderWithSize(objc.CGSize borderSize) {
    objc.checkOsVersionInternal(
      'NSView.drawSheetBorderWithSize:',
      iOS: (true, null),
      macOS: (false, (10, 0, 0)),
    );
    _objc_msgSend_13lgpwz(
      object$.ref.pointer,
      _sel_drawSheetBorderWithSize_,
      borderSize,
    );
  }

  /// endDocument
  void endDocument() {
    objc.checkOsVersionInternal('NSView.endDocument', iOS: (true, null));
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_endDocument);
  }

  /// endPage
  void endPage() {
    objc.checkOsVersionInternal('NSView.endPage', iOS: (true, null));
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_endPage);
  }

  /// heightAdjustLimit
  double get heightAdjustLimit {
    objc.checkOsVersionInternal('NSView.heightAdjustLimit', iOS: (true, null));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            object$.ref.pointer,
            _sel_heightAdjustLimit,
          )
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_heightAdjustLimit);
  }

  /// knowsPageRange:
  bool knowsPageRange(ffi.Pointer<objc.NSRange> range) {
    objc.checkOsVersionInternal('NSView.knowsPageRange:', iOS: (true, null));
    return _objc_msgSend_d8qq73(
      object$.ref.pointer,
      _sel_knowsPageRange_,
      range,
    );
  }

  /// locationOfPrintRect:
  objc.CGPoint locationOfPrintRect(objc.CGRect rect) {
    objc.checkOsVersionInternal(
      'NSView.locationOfPrintRect:',
      iOS: (true, null),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_txl7s5Stret(
            $ptr,
            object$.ref.pointer,
            _sel_locationOfPrintRect_,
            rect,
          )
        : $ptr.ref = _objc_msgSend_txl7s5(
            object$.ref.pointer,
            _sel_locationOfPrintRect_,
            rect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// pageFooter
  objc.NSAttributedString get pageFooter {
    objc.checkOsVersionInternal('NSView.pageFooter', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_pageFooter);
    return objc.NSAttributedString.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// pageHeader
  objc.NSAttributedString get pageHeader {
    objc.checkOsVersionInternal('NSView.pageHeader', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_pageHeader);
    return objc.NSAttributedString.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// print:
  void print(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('NSView.print:', iOS: (true, null));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_print_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// printJobTitle
  objc.NSString get printJobTitle {
    objc.checkOsVersionInternal('NSView.printJobTitle', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_printJobTitle);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// rectForPage:
  objc.CGRect rectForPage(int page) {
    objc.checkOsVersionInternal('NSView.rectForPage:', iOS: (true, null));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18zln4eStret(
            $ptr,
            object$.ref.pointer,
            _sel_rectForPage_,
            page,
          )
        : $ptr.ref = _objc_msgSend_18zln4e(
            object$.ref.pointer,
            _sel_rectForPage_,
            page,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// widthAdjustLimit
  double get widthAdjustLimit {
    objc.checkOsVersionInternal('NSView.widthAdjustLimit', iOS: (true, null));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_widthAdjustLimit)
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_widthAdjustLimit);
  }

  /// writeEPSInsideRect:toPasteboard:
  void writeEPSInsideRect(
    objc.CGRect rect, {
    required NSPasteboard toPasteboard,
  }) {
    objc.checkOsVersionInternal(
      'NSView.writeEPSInsideRect:toPasteboard:',
      iOS: (true, null),
    );
    _objc_msgSend_f227js(
      object$.ref.pointer,
      _sel_writeEPSInsideRect_toPasteboard_,
      rect,
      toPasteboard.ref.pointer,
    );
  }

  /// writePDFInsideRect:toPasteboard:
  void writePDFInsideRect(
    objc.CGRect rect, {
    required NSPasteboard toPasteboard,
  }) {
    objc.checkOsVersionInternal(
      'NSView.writePDFInsideRect:toPasteboard:',
      iOS: (true, null),
    );
    _objc_msgSend_f227js(
      object$.ref.pointer,
      _sel_writePDFInsideRect_toPasteboard_,
      rect,
      toPasteboard.ref.pointer,
    );
  }
}

/// WARNING: NSDraggingSession is a stub. To generate bindings for this class, include
/// NSDraggingSession in your config's objc-interfaces list.
///
/// NSDraggingSession
extension type NSDraggingSession._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSDraggingSession] that points to the same underlying object as [other].
  NSDraggingSession.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSDraggingSession',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
  }

  /// Constructs a [NSDraggingSession] that wraps the given raw object pointer.
  NSDraggingSession.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSDraggingSession',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
  }
}

late final _sel_beginDraggingSessionWithItems_event_source_ = objc.registerName(
  "beginDraggingSessionWithItems:event:source:",
);
final _objc_msgSend_11spmsz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_registeredDraggedTypes = objc.registerName(
  "registeredDraggedTypes",
);
late final _sel_registerForDraggedTypes_ = objc.registerName(
  "registerForDraggedTypes:",
);
late final _sel_unregisterDraggedTypes = objc.registerName(
  "unregisterDraggedTypes",
);

/// NSDrag
extension NSDrag on NSView {
  /// beginDraggingSessionWithItems:event:source:
  NSDraggingSession beginDraggingSessionWithItems(
    objc.NSArray items, {
    required NSEvent event,
    required NSDraggingSource source,
  }) {
    objc.checkOsVersionInternal(
      'NSView.beginDraggingSessionWithItems:event:source:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      object$.ref.pointer,
      _sel_beginDraggingSessionWithItems_event_source_,
      items.ref.pointer,
      event.ref.pointer,
      source.ref.pointer,
    );
    return NSDraggingSession.fromPointer($ret, retain: true, release: true);
  }

  /// registerForDraggedTypes:
  void registerForDraggedTypes(objc.NSArray newTypes) {
    objc.checkOsVersionInternal(
      'NSView.registerForDraggedTypes:',
      iOS: (true, null),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_registerForDraggedTypes_,
      newTypes.ref.pointer,
    );
  }

  /// registeredDraggedTypes
  objc.NSArray get registeredDraggedTypes {
    objc.checkOsVersionInternal(
      'NSView.registeredDraggedTypes',
      iOS: (true, null),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_registeredDraggedTypes,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// unregisterDraggedTypes
  void unregisterDraggedTypes() {
    objc.checkOsVersionInternal(
      'NSView.unregisterDraggedTypes',
      iOS: (true, null),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_unregisterDraggedTypes);
  }
}

/// WARNING: NSScreen is a stub. To generate bindings for this class, include
/// NSScreen in your config's objc-interfaces list.
///
/// NSScreen
extension type NSScreen._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSScreen] that points to the same underlying object as [other].
  NSScreen.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSScreen', iOS: (true, null));
  }

  /// Constructs a [NSScreen] that wraps the given raw object pointer.
  NSScreen.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSScreen', iOS: (true, null));
  }
}

late final _sel_enterFullScreenMode_withOptions_ = objc.registerName(
  "enterFullScreenMode:withOptions:",
);
late final _sel_exitFullScreenModeWithOptions_ = objc.registerName(
  "exitFullScreenModeWithOptions:",
);
late final _sel_isInFullScreenMode = objc.registerName("isInFullScreenMode");

/// NSFullScreenMode
extension NSFullScreenMode on NSView {
  /// enterFullScreenMode:withOptions:
  bool enterFullScreenMode(NSScreen screen, {objc.NSDictionary? withOptions}) {
    objc.checkOsVersionInternal(
      'NSView.enterFullScreenMode:withOptions:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    return _objc_msgSend_1lsax7n(
      object$.ref.pointer,
      _sel_enterFullScreenMode_withOptions_,
      screen.ref.pointer,
      withOptions?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// exitFullScreenModeWithOptions:
  void exitFullScreenModeWithOptions(objc.NSDictionary? options) {
    objc.checkOsVersionInternal(
      'NSView.exitFullScreenModeWithOptions:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_exitFullScreenModeWithOptions_,
      options?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// isInFullScreenMode
  bool get isInFullScreenMode {
    objc.checkOsVersionInternal(
      'NSView.isInFullScreenMode',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isInFullScreenMode);
  }
}

late final _sel_showDefinitionForAttributedString_atPoint_ = objc.registerName(
  "showDefinitionForAttributedString:atPoint:",
);
final _objc_msgSend_1h7qyzw = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          objc.CGPoint,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        objc.CGPoint,
      )
    >();

/// Construction methods for `objc.ObjCBlock<objc.CGPoint Function(objc.NSRange)>`.
abstract final class ObjCBlock_NSPoint_NSRange {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGPoint Function(objc.NSRange)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.CGPoint Function(objc.NSRange)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGPoint Function(objc.NSRange)>
  fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<objc.CGPoint Function(objc.NSRange arg0)>>
    ptr,
  ) => objc.ObjCBlock<objc.CGPoint Function(objc.NSRange)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGPoint Function(objc.NSRange)> fromFunction(
    objc.CGPoint Function(objc.NSRange) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.CGPoint Function(objc.NSRange)>(
    objc.newClosureBlock(
      _closureCallable,
      (objc.NSRange arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static objc.CGPoint _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    objc.NSRange arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<objc.CGPoint Function(objc.NSRange arg0)>>()
      .asFunction<objc.CGPoint Function(objc.NSRange)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            objc.CGPoint Function(ffi.Pointer<objc.ObjCBlockImpl>, objc.NSRange)
          >(_fnPtrTrampoline)
          .cast();
  static objc.CGPoint _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    objc.NSRange arg0,
  ) => (objc.getBlockClosure(block) as objc.CGPoint Function(objc.NSRange))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            objc.CGPoint Function(ffi.Pointer<objc.ObjCBlockImpl>, objc.NSRange)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGPoint Function(objc.NSRange)>`.
extension ObjCBlock_NSPoint_NSRange$CallExtension
    on objc.ObjCBlock<objc.CGPoint Function(objc.NSRange)> {
  objc.CGPoint call(objc.NSRange arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          objc.CGPoint Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            objc.NSRange arg0,
          )
        >
      >()
      .asFunction<
        objc.CGPoint Function(ffi.Pointer<objc.ObjCBlockImpl>, objc.NSRange)
      >()(ref.pointer, arg0);
}

late final _sel_showDefinitionForAttributedString_range_options_baselineOriginProvider_ =
    objc.registerName(
      "showDefinitionForAttributedString:range:options:baselineOriginProvider:",
    );
final _objc_msgSend_jf3t5g = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          objc.NSRange,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        objc.NSRange,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// NSDefinition
extension NSDefinition on NSView {
  /// showDefinitionForAttributedString:atPoint:
  void showDefinitionForAttributedString(
    objc.NSAttributedString? attrString, {
    required objc.CGPoint atPoint,
  }) {
    objc.checkOsVersionInternal(
      'NSView.showDefinitionForAttributedString:atPoint:',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_1h7qyzw(
      object$.ref.pointer,
      _sel_showDefinitionForAttributedString_atPoint_,
      attrString?.ref.pointer ?? ffi.nullptr,
      atPoint,
    );
  }

  /// showDefinitionForAttributedString:range:options:baselineOriginProvider:
  void showDefinitionForAttributedString$1(
    objc.NSAttributedString? attrString, {
    required objc.NSRange range,
    objc.NSDictionary? options,
    objc.ObjCBlock<objc.CGPoint Function(objc.NSRange)>? baselineOriginProvider,
  }) {
    objc.checkOsVersionInternal(
      'NSView.showDefinitionForAttributedString:range:options:baselineOriginProvider:',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_jf3t5g(
      object$.ref.pointer,
      _sel_showDefinitionForAttributedString_range_options_baselineOriginProvider_,
      attrString?.ref.pointer ?? ffi.nullptr,
      range,
      options?.ref.pointer ?? ffi.nullptr,
      baselineOriginProvider?.ref.pointer ?? ffi.nullptr,
    );
  }
}

late final _sel_isDrawingFindIndicator = objc.registerName(
  "isDrawingFindIndicator",
);

/// NSFindIndicator
extension NSFindIndicator on NSView {
  /// isDrawingFindIndicator
  bool get isDrawingFindIndicator {
    objc.checkOsVersionInternal(
      'NSView.isDrawingFindIndicator',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isDrawingFindIndicator,
    );
  }
}

late final _sel_gestureRecognizers = objc.registerName("gestureRecognizers");
late final _sel_setGestureRecognizers_ = objc.registerName(
  "setGestureRecognizers:",
);

/// WARNING: NSGestureRecognizer$1 is a stub. To generate bindings for this class, include
/// NSGestureRecognizer in your config's objc-interfaces list.
///
/// NSGestureRecognizer
extension type NSGestureRecognizer$1._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCoding {
  /// Constructs a [NSGestureRecognizer$1] that points to the same underlying object as [other].
  NSGestureRecognizer$1.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSGestureRecognizer',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
  }

  /// Constructs a [NSGestureRecognizer$1] that wraps the given raw object pointer.
  NSGestureRecognizer$1.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSGestureRecognizer',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
  }
}

late final _sel_addGestureRecognizer_ = objc.registerName(
  "addGestureRecognizer:",
);
late final _sel_removeGestureRecognizer_ = objc.registerName(
  "removeGestureRecognizer:",
);

/// NSGestureRecognizer
extension NSGestureRecognizer on NSView {
  /// addGestureRecognizer:
  void addGestureRecognizer(NSGestureRecognizer$1 gestureRecognizer) {
    objc.checkOsVersionInternal(
      'NSView.addGestureRecognizer:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_addGestureRecognizer_,
      gestureRecognizer.ref.pointer,
    );
  }

  /// gestureRecognizers
  objc.NSArray get gestureRecognizers {
    objc.checkOsVersionInternal(
      'NSView.gestureRecognizers',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_gestureRecognizers,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// removeGestureRecognizer:
  void removeGestureRecognizer(NSGestureRecognizer$1 gestureRecognizer) {
    objc.checkOsVersionInternal(
      'NSView.removeGestureRecognizer:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_removeGestureRecognizer_,
      gestureRecognizer.ref.pointer,
    );
  }

  /// setGestureRecognizers:
  set gestureRecognizers(objc.NSArray value) {
    objc.checkOsVersionInternal(
      'NSView.setGestureRecognizers:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setGestureRecognizers_,
      value.ref.pointer,
    );
  }
}

late final _sel_allowedTouchTypes = objc.registerName("allowedTouchTypes");
final _objc_msgSend_2aezwh = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setAllowedTouchTypes_ = objc.registerName(
  "setAllowedTouchTypes:",
);
final _objc_msgSend_h8icn1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// NSTouchBar
extension NSTouchBar$1 on NSView {
  /// allowedTouchTypes
  int get allowedTouchTypes {
    objc.checkOsVersionInternal(
      'NSView.allowedTouchTypes',
      iOS: (true, null),
      macOS: (false, (10, 12, 2)),
    );
    return _objc_msgSend_2aezwh(object$.ref.pointer, _sel_allowedTouchTypes);
  }

  /// setAllowedTouchTypes:
  set allowedTouchTypes(int value) {
    objc.checkOsVersionInternal(
      'NSView.setAllowedTouchTypes:',
      iOS: (true, null),
      macOS: (false, (10, 12, 2)),
    );
    _objc_msgSend_h8icn1(
      object$.ref.pointer,
      _sel_setAllowedTouchTypes_,
      value,
    );
  }
}

late final _sel_safeAreaInsets = objc.registerName("safeAreaInsets");
final _objc_msgSend_sl0cgw = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.NSEdgeInsets Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      objc.NSEdgeInsets Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_sl0cgwStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.NSEdgeInsets>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.NSEdgeInsets>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_additionalSafeAreaInsets = objc.registerName(
  "additionalSafeAreaInsets",
);
late final _sel_setAdditionalSafeAreaInsets_ = objc.registerName(
  "setAdditionalSafeAreaInsets:",
);
final _objc_msgSend_1ug163q = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.NSEdgeInsets,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.NSEdgeInsets,
      )
    >();

/// WARNING: NSLayoutGuide is a stub. To generate bindings for this class, include
/// NSLayoutGuide in your config's objc-interfaces list.
///
/// NSLayoutGuide
extension type NSLayoutGuide._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSCoding,
        NSUserInterfaceItemIdentification {
  /// Constructs a [NSLayoutGuide] that points to the same underlying object as [other].
  NSLayoutGuide.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSLayoutGuide',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
  }

  /// Constructs a [NSLayoutGuide] that wraps the given raw object pointer.
  NSLayoutGuide.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSLayoutGuide',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
  }
}

late final _sel_safeAreaLayoutGuide = objc.registerName("safeAreaLayoutGuide");
late final _sel_safeAreaRect = objc.registerName("safeAreaRect");
late final _sel_layoutMarginsGuide = objc.registerName("layoutMarginsGuide");

/// NSSafeAreas
extension NSSafeAreas on NSView {
  /// additionalSafeAreaInsets
  objc.NSEdgeInsets get additionalSafeAreaInsets {
    objc.checkOsVersionInternal(
      'NSView.additionalSafeAreaInsets',
      iOS: (true, null),
      macOS: (false, (11, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.NSEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_sl0cgwStret(
            $ptr,
            object$.ref.pointer,
            _sel_additionalSafeAreaInsets,
          )
        : $ptr.ref = _objc_msgSend_sl0cgw(
            object$.ref.pointer,
            _sel_additionalSafeAreaInsets,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.NSEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.NSEdgeInsets>($finalizable);
  }

  /// layoutMarginsGuide
  NSLayoutGuide get layoutMarginsGuide {
    objc.checkOsVersionInternal(
      'NSView.layoutMarginsGuide',
      iOS: (true, null),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_layoutMarginsGuide,
    );
    return NSLayoutGuide.fromPointer($ret, retain: true, release: true);
  }

  /// safeAreaInsets
  objc.NSEdgeInsets get safeAreaInsets {
    objc.checkOsVersionInternal(
      'NSView.safeAreaInsets',
      iOS: (true, null),
      macOS: (false, (11, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.NSEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_sl0cgwStret(
            $ptr,
            object$.ref.pointer,
            _sel_safeAreaInsets,
          )
        : $ptr.ref = _objc_msgSend_sl0cgw(
            object$.ref.pointer,
            _sel_safeAreaInsets,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.NSEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.NSEdgeInsets>($finalizable);
  }

  /// safeAreaLayoutGuide
  NSLayoutGuide get safeAreaLayoutGuide {
    objc.checkOsVersionInternal(
      'NSView.safeAreaLayoutGuide',
      iOS: (true, null),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_safeAreaLayoutGuide,
    );
    return NSLayoutGuide.fromPointer($ret, retain: true, release: true);
  }

  /// safeAreaRect
  objc.CGRect get safeAreaRect {
    objc.checkOsVersionInternal(
      'NSView.safeAreaRect',
      iOS: (true, null),
      macOS: (false, (11, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(
            $ptr,
            object$.ref.pointer,
            _sel_safeAreaRect,
          )
        : $ptr.ref = _objc_msgSend_bu1hbw(
            object$.ref.pointer,
            _sel_safeAreaRect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// setAdditionalSafeAreaInsets:
  set additionalSafeAreaInsets(objc.NSEdgeInsets value) {
    objc.checkOsVersionInternal(
      'NSView.setAdditionalSafeAreaInsets:',
      iOS: (true, null),
      macOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_1ug163q(
      object$.ref.pointer,
      _sel_setAdditionalSafeAreaInsets_,
      value,
    );
  }
}

late final _sel_prefersCompactControlSizeMetrics = objc.registerName(
  "prefersCompactControlSizeMetrics",
);
late final _sel_setPrefersCompactControlSizeMetrics_ = objc.registerName(
  "setPrefersCompactControlSizeMetrics:",
);

/// NSCompactControlSizeMetrics
extension NSCompactControlSizeMetrics on NSView {
  /// prefersCompactControlSizeMetrics
  bool get prefersCompactControlSizeMetrics {
    objc.checkOsVersionInternal(
      'NSView.prefersCompactControlSizeMetrics',
      iOS: (true, null),
      macOS: (false, (26, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_prefersCompactControlSizeMetrics,
    );
  }

  /// setPrefersCompactControlSizeMetrics:
  set prefersCompactControlSizeMetrics(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setPrefersCompactControlSizeMetrics:',
      iOS: (true, null),
      macOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setPrefersCompactControlSizeMetrics_,
      value,
    );
  }
}

/// WARNING: NSTrackingArea$1 is a stub. To generate bindings for this class, include
/// NSTrackingArea in your config's objc-interfaces list.
///
/// NSTrackingArea
extension type NSTrackingArea$1._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying, objc.NSCoding {
  /// Constructs a [NSTrackingArea$1] that points to the same underlying object as [other].
  NSTrackingArea$1.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSTrackingArea',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
  }

  /// Constructs a [NSTrackingArea$1] that wraps the given raw object pointer.
  NSTrackingArea$1.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSTrackingArea',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
  }
}

late final _sel_addTrackingArea_ = objc.registerName("addTrackingArea:");
late final _sel_removeTrackingArea_ = objc.registerName("removeTrackingArea:");
late final _sel_trackingAreas = objc.registerName("trackingAreas");
late final _sel_updateTrackingAreas = objc.registerName("updateTrackingAreas");

/// WARNING: NSCursor is a stub. To generate bindings for this class, include
/// NSCursor in your config's objc-interfaces list.
///
/// NSCursor
extension type NSCursor._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSSecureCoding {
  /// Constructs a [NSCursor] that points to the same underlying object as [other].
  NSCursor.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSCursor',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
  }

  /// Constructs a [NSCursor] that wraps the given raw object pointer.
  NSCursor.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSCursor',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
  }
}

late final _sel_addCursorRect_cursor_ = objc.registerName(
  "addCursorRect:cursor:",
);
late final _sel_removeCursorRect_cursor_ = objc.registerName(
  "removeCursorRect:cursor:",
);
late final _sel_discardCursorRects = objc.registerName("discardCursorRects");
late final _sel_resetCursorRects = objc.registerName("resetCursorRects");
late final _sel_addTrackingRect_owner_userData_assumeInside_ = objc
    .registerName("addTrackingRect:owner:userData:assumeInside:");
final _objc_msgSend_jlvx1c = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<ffi.Void>,
        bool,
      )
    >();
late final _sel_removeTrackingRect_ = objc.registerName("removeTrackingRect:");

/// NSTrackingArea
extension NSTrackingArea on NSView {
  /// addCursorRect:cursor:
  void addCursorRect(objc.CGRect rect, {required NSCursor cursor}) {
    objc.checkOsVersionInternal(
      'NSView.addCursorRect:cursor:',
      iOS: (true, null),
    );
    _objc_msgSend_f227js(
      object$.ref.pointer,
      _sel_addCursorRect_cursor_,
      rect,
      cursor.ref.pointer,
    );
  }

  /// addTrackingArea:
  void addTrackingArea(NSTrackingArea$1 trackingArea) {
    objc.checkOsVersionInternal(
      'NSView.addTrackingArea:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_addTrackingArea_,
      trackingArea.ref.pointer,
    );
  }

  /// addTrackingRect:owner:userData:assumeInside:
  int addTrackingRect(
    objc.CGRect rect, {
    required objc.ObjCObject owner,
    required ffi.Pointer<ffi.Void> userData,
    required bool assumeInside,
  }) {
    objc.checkOsVersionInternal(
      'NSView.addTrackingRect:owner:userData:assumeInside:',
      iOS: (true, null),
    );
    return _objc_msgSend_jlvx1c(
      object$.ref.pointer,
      _sel_addTrackingRect_owner_userData_assumeInside_,
      rect,
      owner.ref.pointer,
      userData,
      assumeInside,
    );
  }

  /// discardCursorRects
  void discardCursorRects() {
    objc.checkOsVersionInternal('NSView.discardCursorRects', iOS: (true, null));
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_discardCursorRects);
  }

  /// removeCursorRect:cursor:
  void removeCursorRect(objc.CGRect rect, {required NSCursor cursor}) {
    objc.checkOsVersionInternal(
      'NSView.removeCursorRect:cursor:',
      iOS: (true, null),
    );
    _objc_msgSend_f227js(
      object$.ref.pointer,
      _sel_removeCursorRect_cursor_,
      rect,
      cursor.ref.pointer,
    );
  }

  /// removeTrackingArea:
  void removeTrackingArea(NSTrackingArea$1 trackingArea) {
    objc.checkOsVersionInternal(
      'NSView.removeTrackingArea:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_removeTrackingArea_,
      trackingArea.ref.pointer,
    );
  }

  /// removeTrackingRect:
  void removeTrackingRect(int tag) {
    objc.checkOsVersionInternal(
      'NSView.removeTrackingRect:',
      iOS: (true, null),
    );
    _objc_msgSend_4sp4xj(object$.ref.pointer, _sel_removeTrackingRect_, tag);
  }

  /// resetCursorRects
  void resetCursorRects() {
    objc.checkOsVersionInternal('NSView.resetCursorRects', iOS: (true, null));
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_resetCursorRects);
  }

  /// trackingAreas
  objc.NSArray get trackingAreas {
    objc.checkOsVersionInternal(
      'NSView.trackingAreas',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_trackingAreas);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// updateTrackingAreas
  void updateTrackingAreas() {
    objc.checkOsVersionInternal(
      'NSView.updateTrackingAreas',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_updateTrackingAreas);
  }
}

/// WARNING: CADisplayLink is a stub. To generate bindings for this class, include
/// CADisplayLink in your config's objc-interfaces list.
///
/// CADisplayLink
extension type CADisplayLink._(objc.ObjCObject object$)
    implements objc.ObjCObject {
  /// Constructs a [CADisplayLink] that points to the same underlying object as [other].
  CADisplayLink.as(objc.ObjCObject other) : object$ = other {}

  /// Constructs a [CADisplayLink] that wraps the given raw object pointer.
  CADisplayLink.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {}
}

late final _sel_displayLinkWithTarget_selector_ = objc.registerName(
  "displayLinkWithTarget:selector:",
);
final _objc_msgSend_836y90 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// NSDisplayLink
extension NSDisplayLink on NSView {
  /// displayLinkWithTarget:selector:
  CADisplayLink displayLinkWithTarget(
    objc.ObjCObject target, {
    required ffi.Pointer<objc.ObjCSelector> selector,
  }) {
    objc.checkOsVersionInternal(
      'NSView.displayLinkWithTarget:selector:',
      iOS: (true, null),
    );
    final $ret = _objc_msgSend_836y90(
      object$.ref.pointer,
      _sel_displayLinkWithTarget_selector_,
      target.ref.pointer,
      selector,
    );
    return CADisplayLink.fromPointer($ret, retain: true, release: true);
  }
}

/// WARNING: NSImage is a stub. To generate bindings for this class, include
/// NSImage in your config's objc-interfaces list.
///
/// NSImage
extension type NSImage._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSImage] that points to the same underlying object as [other].
  NSImage.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSImage', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [NSImage] that wraps the given raw object pointer.
  NSImage.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSImage', iOS: (false, (13, 0, 0)));
  }
}

late final _sel_dragImage_at_offset_event_pasteboard_source_slideBack_ = objc
    .registerName("dragImage:at:offset:event:pasteboard:source:slideBack:");
final _objc_msgSend_1t2qvli = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          objc.CGPoint,
          objc.CGSize,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        objc.CGPoint,
        objc.CGSize,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        bool,
      )
    >();
late final _sel_dragFile_fromRect_slideBack_event_ = objc.registerName(
  "dragFile:fromRect:slideBack:event:",
);
final _objc_msgSend_17y4jh4 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          objc.CGRect,
          ffi.Bool,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        objc.CGRect,
        bool,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_dragPromisedFilesOfTypes_fromRect_source_slideBack_event_ = objc
    .registerName("dragPromisedFilesOfTypes:fromRect:source:slideBack:event:");
final _objc_msgSend_phi3he = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Bool,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObjectImpl>,
        bool,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_convertPointToBase_ = objc.registerName("convertPointToBase:");
late final _sel_convertPointFromBase_ = objc.registerName(
  "convertPointFromBase:",
);
late final _sel_convertSizeToBase_ = objc.registerName("convertSizeToBase:");
late final _sel_convertSizeFromBase_ = objc.registerName(
  "convertSizeFromBase:",
);
late final _sel_convertRectToBase_ = objc.registerName("convertRectToBase:");
late final _sel_convertRectFromBase_ = objc.registerName(
  "convertRectFromBase:",
);
late final _sel_shouldDrawColor = objc.registerName("shouldDrawColor");
late final _sel_gState = objc.registerName("gState");
late final _sel_allocateGState = objc.registerName("allocateGState");
late final _sel_releaseGState = objc.registerName("releaseGState");
late final _sel_setUpGState = objc.registerName("setUpGState");
late final _sel_renewGState = objc.registerName("renewGState");

/// NSDeprecated
extension NSDeprecated$1 on NSView {
  /// allocateGState
  void allocateGState() {
    objc.checkOsVersionInternal(
      'NSView.allocateGState',
      iOS: (true, null),
      macOS: (false, (10, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_allocateGState);
  }

  /// convertPointFromBase:
  objc.CGPoint convertPointFromBase(objc.CGPoint point) {
    objc.checkOsVersionInternal(
      'NSView.convertPointFromBase:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1w4qqqrStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertPointFromBase_,
            point,
          )
        : $ptr.ref = _objc_msgSend_1w4qqqr(
            object$.ref.pointer,
            _sel_convertPointFromBase_,
            point,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// convertPointToBase:
  objc.CGPoint convertPointToBase(objc.CGPoint point) {
    objc.checkOsVersionInternal(
      'NSView.convertPointToBase:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1w4qqqrStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertPointToBase_,
            point,
          )
        : $ptr.ref = _objc_msgSend_1w4qqqr(
            object$.ref.pointer,
            _sel_convertPointToBase_,
            point,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// convertRectFromBase:
  objc.CGRect convertRectFromBase(objc.CGRect rect) {
    objc.checkOsVersionInternal(
      'NSView.convertRectFromBase:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1gn1s3dStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertRectFromBase_,
            rect,
          )
        : $ptr.ref = _objc_msgSend_1gn1s3d(
            object$.ref.pointer,
            _sel_convertRectFromBase_,
            rect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// convertRectToBase:
  objc.CGRect convertRectToBase(objc.CGRect rect) {
    objc.checkOsVersionInternal(
      'NSView.convertRectToBase:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1gn1s3dStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertRectToBase_,
            rect,
          )
        : $ptr.ref = _objc_msgSend_1gn1s3d(
            object$.ref.pointer,
            _sel_convertRectToBase_,
            rect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// convertSizeFromBase:
  objc.CGSize convertSizeFromBase(objc.CGSize size) {
    objc.checkOsVersionInternal(
      'NSView.convertSizeFromBase:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1owrp3bStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertSizeFromBase_,
            size,
          )
        : $ptr.ref = _objc_msgSend_1owrp3b(
            object$.ref.pointer,
            _sel_convertSizeFromBase_,
            size,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// convertSizeToBase:
  objc.CGSize convertSizeToBase(objc.CGSize size) {
    objc.checkOsVersionInternal(
      'NSView.convertSizeToBase:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1owrp3bStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertSizeToBase_,
            size,
          )
        : $ptr.ref = _objc_msgSend_1owrp3b(
            object$.ref.pointer,
            _sel_convertSizeToBase_,
            size,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// dragFile:fromRect:slideBack:event:
  bool dragFile(
    objc.NSString filename, {
    required objc.CGRect fromRect,
    required bool slideBack,
    required NSEvent event,
  }) {
    objc.checkOsVersionInternal(
      'NSView.dragFile:fromRect:slideBack:event:',
      iOS: (true, null),
      macOS: (false, (10, 0, 0)),
    );
    return _objc_msgSend_17y4jh4(
      object$.ref.pointer,
      _sel_dragFile_fromRect_slideBack_event_,
      filename.ref.pointer,
      fromRect,
      slideBack,
      event.ref.pointer,
    );
  }

  /// dragImage:at:offset:event:pasteboard:source:slideBack:
  void dragImage(
    NSImage image, {
    required objc.CGPoint at,
    required objc.CGSize offset,
    required NSEvent event,
    required NSPasteboard pasteboard,
    required objc.ObjCObject source,
    required bool slideBack,
  }) {
    objc.checkOsVersionInternal(
      'NSView.dragImage:at:offset:event:pasteboard:source:slideBack:',
      iOS: (true, null),
      macOS: (false, (10, 0, 0)),
    );
    _objc_msgSend_1t2qvli(
      object$.ref.pointer,
      _sel_dragImage_at_offset_event_pasteboard_source_slideBack_,
      image.ref.pointer,
      at,
      offset,
      event.ref.pointer,
      pasteboard.ref.pointer,
      source.ref.pointer,
      slideBack,
    );
  }

  /// dragPromisedFilesOfTypes:fromRect:source:slideBack:event:
  bool dragPromisedFilesOfTypes(
    objc.NSArray typeArray, {
    required objc.CGRect fromRect,
    required objc.ObjCObject source,
    required bool slideBack,
    required NSEvent event,
  }) {
    objc.checkOsVersionInternal(
      'NSView.dragPromisedFilesOfTypes:fromRect:source:slideBack:event:',
      iOS: (true, null),
      macOS: (false, (10, 0, 0)),
    );
    return _objc_msgSend_phi3he(
      object$.ref.pointer,
      _sel_dragPromisedFilesOfTypes_fromRect_source_slideBack_event_,
      typeArray.ref.pointer,
      fromRect,
      source.ref.pointer,
      slideBack,
      event.ref.pointer,
    );
  }

  /// gState
  int gState() {
    objc.checkOsVersionInternal(
      'NSView.gState',
      iOS: (true, null),
      macOS: (false, (10, 0, 0)),
    );
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_gState);
  }

  /// performMnemonic:
  bool performMnemonic(objc.NSString string) {
    objc.checkOsVersionInternal(
      'NSView.performMnemonic:',
      iOS: (true, null),
      macOS: (false, (10, 0, 0)),
    );
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_performMnemonic_,
      string.ref.pointer,
    );
  }

  /// releaseGState
  void releaseGState() {
    objc.checkOsVersionInternal(
      'NSView.releaseGState',
      iOS: (true, null),
      macOS: (false, (10, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_releaseGState);
  }

  /// renewGState
  void renewGState() {
    objc.checkOsVersionInternal(
      'NSView.renewGState',
      iOS: (true, null),
      macOS: (false, (10, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_renewGState);
  }

  /// setUpGState
  void setUpGState() {
    objc.checkOsVersionInternal(
      'NSView.setUpGState',
      iOS: (true, null),
      macOS: (false, (10, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_setUpGState);
  }

  /// shouldDrawColor
  bool shouldDrawColor() {
    objc.checkOsVersionInternal(
      'NSView.shouldDrawColor',
      iOS: (true, null),
      macOS: (false, (10, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_shouldDrawColor);
  }
}

/// WARNING: NSWritingToolsCoordinator$1 is a stub. To generate bindings for this class, include
/// NSWritingToolsCoordinator in your config's objc-interfaces list.
///
/// NSWritingToolsCoordinator
extension type NSWritingToolsCoordinator$1._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSWritingToolsCoordinator$1] that points to the same underlying object as [other].
  NSWritingToolsCoordinator$1.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSWritingToolsCoordinator',
      iOS: (true, null),
      macOS: (false, (15, 2, 0)),
    );
  }

  /// Constructs a [NSWritingToolsCoordinator$1] that wraps the given raw object pointer.
  NSWritingToolsCoordinator$1.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSWritingToolsCoordinator',
      iOS: (true, null),
      macOS: (false, (15, 2, 0)),
    );
  }
}

late final _sel_writingToolsCoordinator = objc.registerName(
  "writingToolsCoordinator",
);
late final _sel_setWritingToolsCoordinator_ = objc.registerName(
  "setWritingToolsCoordinator:",
);

/// NSWritingToolsCoordinator
extension NSWritingToolsCoordinator on NSView {
  /// setWritingToolsCoordinator:
  set writingToolsCoordinator(NSWritingToolsCoordinator$1? value) {
    objc.checkOsVersionInternal(
      'NSView.setWritingToolsCoordinator:',
      iOS: (true, null),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setWritingToolsCoordinator_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// writingToolsCoordinator
  NSWritingToolsCoordinator$1? get writingToolsCoordinator {
    objc.checkOsVersionInternal(
      'NSView.writingToolsCoordinator',
      iOS: (true, null),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_writingToolsCoordinator,
    );
    return $ret.address == 0
        ? null
        : NSWritingToolsCoordinator$1.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }
}

/// WARNING: NSMenuItem is a stub. To generate bindings for this class, include
/// NSMenuItem in your config's objc-interfaces list.
///
/// NSMenuItem
extension type NSMenuItem._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSCopying,
        objc.NSCoding,
        NSValidatedUserInterfaceItem,
        NSUserInterfaceItemIdentification,
        NSAccessibilityElement,
        NSAccessibility {
  /// Constructs a [NSMenuItem] that points to the same underlying object as [other].
  NSMenuItem.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSMenuItem', iOS: (true, null));
  }

  /// Constructs a [NSMenuItem] that wraps the given raw object pointer.
  NSMenuItem.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSMenuItem', iOS: (true, null));
  }
}

late final _sel_enclosingMenuItem = objc.registerName("enclosingMenuItem");

/// NSViewEnclosingMenuItem
extension NSViewEnclosingMenuItem on NSView {
  /// enclosingMenuItem
  NSMenuItem? get enclosingMenuItem {
    objc.checkOsVersionInternal(
      'NSView.enclosingMenuItem',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_enclosingMenuItem,
    );
    return $ret.address == 0
        ? null
        : NSMenuItem.fromPointer($ret, retain: true, release: true);
  }
}

/// WARNING: NSCandidateListTouchBarItem$1 is a stub. To generate bindings for this class, include
/// NSCandidateListTouchBarItem in your config's objc-interfaces list.
///
/// NSCandidateListTouchBarItem
extension type NSCandidateListTouchBarItem$1._(objc.ObjCObject object$)
    implements objc.ObjCObject, NSTouchBarItem {
  /// Constructs a [NSCandidateListTouchBarItem$1] that points to the same underlying object as [other].
  NSCandidateListTouchBarItem$1.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSCandidateListTouchBarItem',
      iOS: (true, null),
      macOS: (false, (10, 12, 2)),
    );
  }

  /// Constructs a [NSCandidateListTouchBarItem$1] that wraps the given raw object pointer.
  NSCandidateListTouchBarItem$1.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSCandidateListTouchBarItem',
      iOS: (true, null),
      macOS: (false, (10, 12, 2)),
    );
  }
}

late final _sel_candidateListTouchBarItem = objc.registerName(
  "candidateListTouchBarItem",
);

/// NSCandidateListTouchBarItem
extension NSCandidateListTouchBarItem on NSView {
  /// candidateListTouchBarItem
  NSCandidateListTouchBarItem$1? get candidateListTouchBarItem {
    objc.checkOsVersionInternal(
      'NSView.candidateListTouchBarItem',
      iOS: (true, null),
      macOS: (false, (10, 12, 2)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_candidateListTouchBarItem,
    );
    return $ret.address == 0
        ? null
        : NSCandidateListTouchBarItem$1.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }
}

/// WARNING: NSClipView is a stub. To generate bindings for this class, include
/// NSClipView in your config's objc-interfaces list.
///
/// NSClipView
extension type NSClipView._(objc.ObjCObject object$)
    implements objc.ObjCObject, NSView {
  /// Constructs a [NSClipView] that points to the same underlying object as [other].
  NSClipView.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSClipView', iOS: (true, null));
  }

  /// Constructs a [NSClipView] that wraps the given raw object pointer.
  NSClipView.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSClipView', iOS: (true, null));
  }
}

late final _sel_reflectScrolledClipView_ = objc.registerName(
  "reflectScrolledClipView:",
);
late final _sel_scrollClipView_toPoint_ = objc.registerName(
  "scrollClipView:toPoint:",
);

/// NSClipViewSuperview
extension NSClipViewSuperview on NSView {
  /// reflectScrolledClipView:
  void reflectScrolledClipView(NSClipView clipView) {
    objc.checkOsVersionInternal(
      'NSView.reflectScrolledClipView:',
      iOS: (true, null),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_reflectScrolledClipView_,
      clipView.ref.pointer,
    );
  }

  /// scrollClipView:toPoint:
  void scrollClipView(NSClipView clipView, {required objc.CGPoint toPoint}) {
    objc.checkOsVersionInternal(
      'NSView.scrollClipView:toPoint:',
      iOS: (true, null),
    );
    _objc_msgSend_1h7qyzw(
      object$.ref.pointer,
      _sel_scrollClipView_toPoint_,
      clipView.ref.pointer,
      toPoint,
    );
  }
}

/// WARNING: NSLayoutXAxisAnchor is a stub. To generate bindings for this class, include
/// NSLayoutXAxisAnchor in your config's objc-interfaces list.
///
/// NSLayoutXAxisAnchor
extension type NSLayoutXAxisAnchor._(objc.ObjCObject object$)
    implements objc.ObjCObject, NSLayoutAnchor {
  /// Constructs a [NSLayoutXAxisAnchor] that points to the same underlying object as [other].
  NSLayoutXAxisAnchor.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSLayoutXAxisAnchor',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }

  /// Constructs a [NSLayoutXAxisAnchor] that wraps the given raw object pointer.
  NSLayoutXAxisAnchor.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSLayoutXAxisAnchor',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }
}

late final _sel_leadingAnchor = objc.registerName("leadingAnchor");
late final _sel_trailingAnchor = objc.registerName("trailingAnchor");
late final _sel_leftAnchor = objc.registerName("leftAnchor");
late final _sel_rightAnchor = objc.registerName("rightAnchor");

/// WARNING: NSLayoutYAxisAnchor is a stub. To generate bindings for this class, include
/// NSLayoutYAxisAnchor in your config's objc-interfaces list.
///
/// NSLayoutYAxisAnchor
extension type NSLayoutYAxisAnchor._(objc.ObjCObject object$)
    implements objc.ObjCObject, NSLayoutAnchor {
  /// Constructs a [NSLayoutYAxisAnchor] that points to the same underlying object as [other].
  NSLayoutYAxisAnchor.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSLayoutYAxisAnchor',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }

  /// Constructs a [NSLayoutYAxisAnchor] that wraps the given raw object pointer.
  NSLayoutYAxisAnchor.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSLayoutYAxisAnchor',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }
}

late final _sel_topAnchor = objc.registerName("topAnchor");
late final _sel_bottomAnchor = objc.registerName("bottomAnchor");

/// WARNING: NSLayoutDimension is a stub. To generate bindings for this class, include
/// NSLayoutDimension in your config's objc-interfaces list.
///
/// NSLayoutDimension
extension type NSLayoutDimension._(objc.ObjCObject object$)
    implements objc.ObjCObject, NSLayoutAnchor {
  /// Constructs a [NSLayoutDimension] that points to the same underlying object as [other].
  NSLayoutDimension.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSLayoutDimension',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }

  /// Constructs a [NSLayoutDimension] that wraps the given raw object pointer.
  NSLayoutDimension.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSLayoutDimension',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }
}

late final _sel_widthAnchor = objc.registerName("widthAnchor");
late final _sel_heightAnchor = objc.registerName("heightAnchor");
late final _sel_centerXAnchor = objc.registerName("centerXAnchor");
late final _sel_centerYAnchor = objc.registerName("centerYAnchor");
late final _sel_firstBaselineAnchor = objc.registerName("firstBaselineAnchor");
late final _sel_lastBaselineAnchor = objc.registerName("lastBaselineAnchor");
late final _sel_constraints = objc.registerName("constraints");

/// WARNING: NSLayoutConstraint is a stub. To generate bindings for this class, include
/// NSLayoutConstraint in your config's objc-interfaces list.
///
/// NSLayoutConstraint
extension type NSLayoutConstraint._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSLayoutConstraint] that points to the same underlying object as [other].
  NSLayoutConstraint.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSLayoutConstraint',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
  }

  /// Constructs a [NSLayoutConstraint] that wraps the given raw object pointer.
  NSLayoutConstraint.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSLayoutConstraint',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
  }
}

late final _sel_addConstraint_ = objc.registerName("addConstraint:");
late final _sel_addConstraints_ = objc.registerName("addConstraints:");
late final _sel_removeConstraint_ = objc.registerName("removeConstraint:");
late final _sel_removeConstraints_ = objc.registerName("removeConstraints:");

/// NSConstraintBasedLayoutInstallingConstraints
extension NSConstraintBasedLayoutInstallingConstraints on NSView {
  /// addConstraint:
  void addConstraint(NSLayoutConstraint constraint) {
    objc.checkOsVersionInternal(
      'NSView.addConstraint:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_addConstraint_,
      constraint.ref.pointer,
    );
  }

  /// addConstraints:
  void addConstraints(objc.NSArray constraints) {
    objc.checkOsVersionInternal(
      'NSView.addConstraints:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_addConstraints_,
      constraints.ref.pointer,
    );
  }

  /// bottomAnchor
  NSLayoutYAxisAnchor get bottomAnchor {
    objc.checkOsVersionInternal(
      'NSView.bottomAnchor',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_bottomAnchor);
    return NSLayoutYAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// centerXAnchor
  NSLayoutXAxisAnchor get centerXAnchor {
    objc.checkOsVersionInternal(
      'NSView.centerXAnchor',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_centerXAnchor);
    return NSLayoutXAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// centerYAnchor
  NSLayoutYAxisAnchor get centerYAnchor {
    objc.checkOsVersionInternal(
      'NSView.centerYAnchor',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_centerYAnchor);
    return NSLayoutYAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// constraints
  objc.NSArray get constraints {
    objc.checkOsVersionInternal(
      'NSView.constraints',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_constraints);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// firstBaselineAnchor
  NSLayoutYAxisAnchor get firstBaselineAnchor {
    objc.checkOsVersionInternal(
      'NSView.firstBaselineAnchor',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_firstBaselineAnchor,
    );
    return NSLayoutYAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// heightAnchor
  NSLayoutDimension get heightAnchor {
    objc.checkOsVersionInternal(
      'NSView.heightAnchor',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_heightAnchor);
    return NSLayoutDimension.fromPointer($ret, retain: true, release: true);
  }

  /// lastBaselineAnchor
  NSLayoutYAxisAnchor get lastBaselineAnchor {
    objc.checkOsVersionInternal(
      'NSView.lastBaselineAnchor',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_lastBaselineAnchor,
    );
    return NSLayoutYAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// leadingAnchor
  NSLayoutXAxisAnchor get leadingAnchor {
    objc.checkOsVersionInternal(
      'NSView.leadingAnchor',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_leadingAnchor);
    return NSLayoutXAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// leftAnchor
  NSLayoutXAxisAnchor get leftAnchor {
    objc.checkOsVersionInternal(
      'NSView.leftAnchor',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_leftAnchor);
    return NSLayoutXAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// removeConstraint:
  void removeConstraint(NSLayoutConstraint constraint) {
    objc.checkOsVersionInternal(
      'NSView.removeConstraint:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_removeConstraint_,
      constraint.ref.pointer,
    );
  }

  /// removeConstraints:
  void removeConstraints(objc.NSArray constraints) {
    objc.checkOsVersionInternal(
      'NSView.removeConstraints:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_removeConstraints_,
      constraints.ref.pointer,
    );
  }

  /// rightAnchor
  NSLayoutXAxisAnchor get rightAnchor {
    objc.checkOsVersionInternal(
      'NSView.rightAnchor',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_rightAnchor);
    return NSLayoutXAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// topAnchor
  NSLayoutYAxisAnchor get topAnchor {
    objc.checkOsVersionInternal(
      'NSView.topAnchor',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_topAnchor);
    return NSLayoutYAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// trailingAnchor
  NSLayoutXAxisAnchor get trailingAnchor {
    objc.checkOsVersionInternal(
      'NSView.trailingAnchor',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_trailingAnchor,
    );
    return NSLayoutXAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// widthAnchor
  NSLayoutDimension get widthAnchor {
    objc.checkOsVersionInternal(
      'NSView.widthAnchor',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_widthAnchor);
    return NSLayoutDimension.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_updateConstraintsForSubtreeIfNeeded = objc.registerName(
  "updateConstraintsForSubtreeIfNeeded",
);
late final _sel_updateConstraints = objc.registerName("updateConstraints");
late final _sel_needsUpdateConstraints = objc.registerName(
  "needsUpdateConstraints",
);
late final _sel_setNeedsUpdateConstraints_ = objc.registerName(
  "setNeedsUpdateConstraints:",
);

/// NSConstraintBasedLayoutCoreMethods
extension NSConstraintBasedLayoutCoreMethods on NSView {
  /// needsUpdateConstraints
  bool get needsUpdateConstraints {
    objc.checkOsVersionInternal(
      'NSView.needsUpdateConstraints',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_needsUpdateConstraints,
    );
  }

  /// setNeedsUpdateConstraints:
  set needsUpdateConstraints(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setNeedsUpdateConstraints:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setNeedsUpdateConstraints_,
      value,
    );
  }

  /// updateConstraints
  void updateConstraints() {
    objc.checkOsVersionInternal(
      'NSView.updateConstraints',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_updateConstraints);
  }

  /// updateConstraintsForSubtreeIfNeeded
  void updateConstraintsForSubtreeIfNeeded() {
    objc.checkOsVersionInternal(
      'NSView.updateConstraintsForSubtreeIfNeeded',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1pl9qdv(
      object$.ref.pointer,
      _sel_updateConstraintsForSubtreeIfNeeded,
    );
  }
}

late final _sel_translatesAutoresizingMaskIntoConstraints = objc.registerName(
  "translatesAutoresizingMaskIntoConstraints",
);
late final _sel_setTranslatesAutoresizingMaskIntoConstraints_ = objc
    .registerName("setTranslatesAutoresizingMaskIntoConstraints:");
late final _sel_requiresConstraintBasedLayout = objc.registerName(
  "requiresConstraintBasedLayout",
);

/// NSConstraintBasedCompatibility
extension NSConstraintBasedCompatibility on NSView {
  /// setTranslatesAutoresizingMaskIntoConstraints:
  set translatesAutoresizingMaskIntoConstraints(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setTranslatesAutoresizingMaskIntoConstraints:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setTranslatesAutoresizingMaskIntoConstraints_,
      value,
    );
  }

  /// translatesAutoresizingMaskIntoConstraints
  bool get translatesAutoresizingMaskIntoConstraints {
    objc.checkOsVersionInternal(
      'NSView.translatesAutoresizingMaskIntoConstraints',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_translatesAutoresizingMaskIntoConstraints,
    );
  }

  /// requiresConstraintBasedLayout
  static bool getRequiresConstraintBasedLayout() {
    objc.checkOsVersionInternal(
      'NSView.requiresConstraintBasedLayout',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_91o635(
      _class_NSView,
      _sel_requiresConstraintBasedLayout,
    );
  }
}

late final _sel_alignmentRectForFrame_ = objc.registerName(
  "alignmentRectForFrame:",
);
late final _sel_frameForAlignmentRect_ = objc.registerName(
  "frameForAlignmentRect:",
);
late final _sel_alignmentRectInsets = objc.registerName("alignmentRectInsets");
late final _sel_firstBaselineOffsetFromTop = objc.registerName(
  "firstBaselineOffsetFromTop",
);
late final _sel_lastBaselineOffsetFromBottom = objc.registerName(
  "lastBaselineOffsetFromBottom",
);
late final _sel_baselineOffsetFromBottom = objc.registerName(
  "baselineOffsetFromBottom",
);
late final _sel_intrinsicContentSize = objc.registerName(
  "intrinsicContentSize",
);
final _objc_msgSend_1vdfken = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGSize Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      objc.CGSize Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1vdfkenStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGSize>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGSize>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_invalidateIntrinsicContentSize = objc.registerName(
  "invalidateIntrinsicContentSize",
);

enum NSLayoutConstraintOrientation {
  NSLayoutConstraintOrientationHorizontal(0),
  NSLayoutConstraintOrientationVertical(1);

  final int value;
  const NSLayoutConstraintOrientation(this.value);

  static NSLayoutConstraintOrientation fromValue(int value) => switch (value) {
    0 => NSLayoutConstraintOrientationHorizontal,
    1 => NSLayoutConstraintOrientationVertical,
    _ => throw ArgumentError(
      'Unknown value for NSLayoutConstraintOrientation: $value',
    ),
  };
}

late final _sel_contentHuggingPriorityForOrientation_ = objc.registerName(
  "contentHuggingPriorityForOrientation:",
);
final _objc_msgSend_1whr4fh = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Float Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_1whr4fhFpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Float Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_setContentHuggingPriority_forOrientation_ = objc.registerName(
  "setContentHuggingPriority:forOrientation:",
);
final _objc_msgSend_t6rg3z = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Float,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        int,
      )
    >();
late final _sel_contentCompressionResistancePriorityForOrientation_ = objc
    .registerName("contentCompressionResistancePriorityForOrientation:");
late final _sel_setContentCompressionResistancePriority_forOrientation_ = objc
    .registerName("setContentCompressionResistancePriority:forOrientation:");
late final _sel_isHorizontalContentSizeConstraintActive = objc.registerName(
  "isHorizontalContentSizeConstraintActive",
);
late final _sel_setHorizontalContentSizeConstraintActive_ = objc.registerName(
  "setHorizontalContentSizeConstraintActive:",
);
late final _sel_isVerticalContentSizeConstraintActive = objc.registerName(
  "isVerticalContentSizeConstraintActive",
);
late final _sel_setVerticalContentSizeConstraintActive_ = objc.registerName(
  "setVerticalContentSizeConstraintActive:",
);

/// NSConstraintBasedLayoutLayering
extension NSConstraintBasedLayoutLayering on NSView {
  /// alignmentRectForFrame:
  objc.CGRect alignmentRectForFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal(
      'NSView.alignmentRectForFrame:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1gn1s3dStret(
            $ptr,
            object$.ref.pointer,
            _sel_alignmentRectForFrame_,
            frame,
          )
        : $ptr.ref = _objc_msgSend_1gn1s3d(
            object$.ref.pointer,
            _sel_alignmentRectForFrame_,
            frame,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// alignmentRectInsets
  objc.NSEdgeInsets get alignmentRectInsets {
    objc.checkOsVersionInternal(
      'NSView.alignmentRectInsets',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.NSEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_sl0cgwStret(
            $ptr,
            object$.ref.pointer,
            _sel_alignmentRectInsets,
          )
        : $ptr.ref = _objc_msgSend_sl0cgw(
            object$.ref.pointer,
            _sel_alignmentRectInsets,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.NSEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.NSEdgeInsets>($finalizable);
  }

  /// baselineOffsetFromBottom
  double get baselineOffsetFromBottom {
    objc.checkOsVersionInternal(
      'NSView.baselineOffsetFromBottom',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            object$.ref.pointer,
            _sel_baselineOffsetFromBottom,
          )
        : _objc_msgSend_1ukqyt8(
            object$.ref.pointer,
            _sel_baselineOffsetFromBottom,
          );
  }

  /// contentCompressionResistancePriorityForOrientation:
  double contentCompressionResistancePriorityForOrientation(
    NSLayoutConstraintOrientation orientation,
  ) {
    objc.checkOsVersionInternal(
      'NSView.contentCompressionResistancePriorityForOrientation:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1whr4fhFpret(
            object$.ref.pointer,
            _sel_contentCompressionResistancePriorityForOrientation_,
            orientation.value,
          )
        : _objc_msgSend_1whr4fh(
            object$.ref.pointer,
            _sel_contentCompressionResistancePriorityForOrientation_,
            orientation.value,
          );
  }

  /// contentHuggingPriorityForOrientation:
  double contentHuggingPriorityForOrientation(
    NSLayoutConstraintOrientation orientation,
  ) {
    objc.checkOsVersionInternal(
      'NSView.contentHuggingPriorityForOrientation:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1whr4fhFpret(
            object$.ref.pointer,
            _sel_contentHuggingPriorityForOrientation_,
            orientation.value,
          )
        : _objc_msgSend_1whr4fh(
            object$.ref.pointer,
            _sel_contentHuggingPriorityForOrientation_,
            orientation.value,
          );
  }

  /// firstBaselineOffsetFromTop
  double get firstBaselineOffsetFromTop {
    objc.checkOsVersionInternal(
      'NSView.firstBaselineOffsetFromTop',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            object$.ref.pointer,
            _sel_firstBaselineOffsetFromTop,
          )
        : _objc_msgSend_1ukqyt8(
            object$.ref.pointer,
            _sel_firstBaselineOffsetFromTop,
          );
  }

  /// frameForAlignmentRect:
  objc.CGRect frameForAlignmentRect(objc.CGRect alignmentRect) {
    objc.checkOsVersionInternal(
      'NSView.frameForAlignmentRect:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1gn1s3dStret(
            $ptr,
            object$.ref.pointer,
            _sel_frameForAlignmentRect_,
            alignmentRect,
          )
        : $ptr.ref = _objc_msgSend_1gn1s3d(
            object$.ref.pointer,
            _sel_frameForAlignmentRect_,
            alignmentRect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// intrinsicContentSize
  objc.CGSize get intrinsicContentSize {
    objc.checkOsVersionInternal(
      'NSView.intrinsicContentSize',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1vdfkenStret(
            $ptr,
            object$.ref.pointer,
            _sel_intrinsicContentSize,
          )
        : $ptr.ref = _objc_msgSend_1vdfken(
            object$.ref.pointer,
            _sel_intrinsicContentSize,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// invalidateIntrinsicContentSize
  void invalidateIntrinsicContentSize() {
    objc.checkOsVersionInternal(
      'NSView.invalidateIntrinsicContentSize',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1pl9qdv(
      object$.ref.pointer,
      _sel_invalidateIntrinsicContentSize,
    );
  }

  /// isHorizontalContentSizeConstraintActive
  bool get isHorizontalContentSizeConstraintActive {
    objc.checkOsVersionInternal(
      'NSView.isHorizontalContentSizeConstraintActive',
      iOS: (true, null),
      macOS: (false, (10, 15, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isHorizontalContentSizeConstraintActive,
    );
  }

  /// isVerticalContentSizeConstraintActive
  bool get isVerticalContentSizeConstraintActive {
    objc.checkOsVersionInternal(
      'NSView.isVerticalContentSizeConstraintActive',
      iOS: (true, null),
      macOS: (false, (10, 15, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isVerticalContentSizeConstraintActive,
    );
  }

  /// lastBaselineOffsetFromBottom
  double get lastBaselineOffsetFromBottom {
    objc.checkOsVersionInternal(
      'NSView.lastBaselineOffsetFromBottom',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            object$.ref.pointer,
            _sel_lastBaselineOffsetFromBottom,
          )
        : _objc_msgSend_1ukqyt8(
            object$.ref.pointer,
            _sel_lastBaselineOffsetFromBottom,
          );
  }

  /// setContentCompressionResistancePriority:forOrientation:
  void setContentCompressionResistancePriority(
    double priority, {
    required NSLayoutConstraintOrientation forOrientation,
  }) {
    objc.checkOsVersionInternal(
      'NSView.setContentCompressionResistancePriority:forOrientation:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_t6rg3z(
      object$.ref.pointer,
      _sel_setContentCompressionResistancePriority_forOrientation_,
      priority,
      forOrientation.value,
    );
  }

  /// setContentHuggingPriority:forOrientation:
  void setContentHuggingPriority(
    double priority, {
    required NSLayoutConstraintOrientation forOrientation,
  }) {
    objc.checkOsVersionInternal(
      'NSView.setContentHuggingPriority:forOrientation:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_t6rg3z(
      object$.ref.pointer,
      _sel_setContentHuggingPriority_forOrientation_,
      priority,
      forOrientation.value,
    );
  }

  /// setHorizontalContentSizeConstraintActive:
  set isHorizontalContentSizeConstraintActive(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setHorizontalContentSizeConstraintActive:',
      iOS: (true, null),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setHorizontalContentSizeConstraintActive_,
      value,
    );
  }

  /// setVerticalContentSizeConstraintActive:
  set isVerticalContentSizeConstraintActive(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setVerticalContentSizeConstraintActive:',
      iOS: (true, null),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setVerticalContentSizeConstraintActive_,
      value,
    );
  }
}

late final _sel_fittingSize = objc.registerName("fittingSize");

/// NSConstraintBasedLayoutFittingSize
extension NSConstraintBasedLayoutFittingSize on NSView {
  /// fittingSize
  objc.CGSize get fittingSize {
    objc.checkOsVersionInternal(
      'NSView.fittingSize',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1vdfkenStret(
            $ptr,
            object$.ref.pointer,
            _sel_fittingSize,
          )
        : $ptr.ref = _objc_msgSend_1vdfken(
            object$.ref.pointer,
            _sel_fittingSize,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }
}

late final _sel_constraintsAffectingLayoutForOrientation_ = objc.registerName(
  "constraintsAffectingLayoutForOrientation:",
);
final _objc_msgSend_1r01ixf = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_hasAmbiguousLayout = objc.registerName("hasAmbiguousLayout");
late final _sel_exerciseAmbiguityInLayout = objc.registerName(
  "exerciseAmbiguityInLayout",
);

/// NSConstraintBasedLayoutDebugging
extension NSConstraintBasedLayoutDebugging on NSView {
  /// constraintsAffectingLayoutForOrientation:
  objc.NSArray constraintsAffectingLayoutForOrientation(
    NSLayoutConstraintOrientation orientation,
  ) {
    objc.checkOsVersionInternal(
      'NSView.constraintsAffectingLayoutForOrientation:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1r01ixf(
      object$.ref.pointer,
      _sel_constraintsAffectingLayoutForOrientation_,
      orientation.value,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// exerciseAmbiguityInLayout
  void exerciseAmbiguityInLayout() {
    objc.checkOsVersionInternal(
      'NSView.exerciseAmbiguityInLayout',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_exerciseAmbiguityInLayout);
  }

  /// hasAmbiguousLayout
  bool get hasAmbiguousLayout {
    objc.checkOsVersionInternal(
      'NSView.hasAmbiguousLayout',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_hasAmbiguousLayout);
  }
}

late final _sel_addLayoutGuide_ = objc.registerName("addLayoutGuide:");
late final _sel_removeLayoutGuide_ = objc.registerName("removeLayoutGuide:");
late final _sel_layoutGuides = objc.registerName("layoutGuides");

/// NSLayoutGuideSupport
extension NSLayoutGuideSupport on NSView {
  /// addLayoutGuide:
  void addLayoutGuide(NSLayoutGuide guide) {
    objc.checkOsVersionInternal(
      'NSView.addLayoutGuide:',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_addLayoutGuide_,
      guide.ref.pointer,
    );
  }

  /// layoutGuides
  objc.NSArray get layoutGuides {
    objc.checkOsVersionInternal(
      'NSView.layoutGuides',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_layoutGuides);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// removeLayoutGuide:
  void removeLayoutGuide(NSLayoutGuide guide) {
    objc.checkOsVersionInternal(
      'NSView.removeLayoutGuide:',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_removeLayoutGuide_,
      guide.ref.pointer,
    );
  }
}

/// WARNING: NSViewLayoutRegion is a stub. To generate bindings for this class, include
/// NSViewLayoutRegion in your config's objc-interfaces list.
///
/// NSViewLayoutRegion
extension type NSViewLayoutRegion._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSViewLayoutRegion] that points to the same underlying object as [other].
  NSViewLayoutRegion.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSViewLayoutRegion',
      iOS: (true, null),
      macOS: (false, (26, 0, 0)),
    );
  }

  /// Constructs a [NSViewLayoutRegion] that wraps the given raw object pointer.
  NSViewLayoutRegion.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSViewLayoutRegion',
      iOS: (true, null),
      macOS: (false, (26, 0, 0)),
    );
  }
}

late final _sel_layoutGuideForLayoutRegion_ = objc.registerName(
  "layoutGuideForLayoutRegion:",
);
late final _sel_edgeInsetsForLayoutRegion_ = objc.registerName(
  "edgeInsetsForLayoutRegion:",
);
final _objc_msgSend_d3dd4i = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.NSEdgeInsets Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      objc.NSEdgeInsets Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
final _objc_msgSend_d3dd4iStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.NSEdgeInsets>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.NSEdgeInsets>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_rectForLayoutRegion_ = objc.registerName(
  "rectForLayoutRegion:",
);
final _objc_msgSend_qrtfce = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
final _objc_msgSend_qrtfceStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// LayoutRegions
extension LayoutRegions on NSView {
  /// edgeInsetsForLayoutRegion:
  objc.NSEdgeInsets edgeInsetsForLayoutRegion(NSViewLayoutRegion layoutRegion) {
    objc.checkOsVersionInternal(
      'NSView.edgeInsetsForLayoutRegion:',
      iOS: (true, null),
      macOS: (false, (26, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.NSEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_d3dd4iStret(
            $ptr,
            object$.ref.pointer,
            _sel_edgeInsetsForLayoutRegion_,
            layoutRegion.ref.pointer,
          )
        : $ptr.ref = _objc_msgSend_d3dd4i(
            object$.ref.pointer,
            _sel_edgeInsetsForLayoutRegion_,
            layoutRegion.ref.pointer,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.NSEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.NSEdgeInsets>($finalizable);
  }

  /// layoutGuideForLayoutRegion:
  NSLayoutGuide layoutGuideForLayoutRegion(NSViewLayoutRegion layoutRegion) {
    objc.checkOsVersionInternal(
      'NSView.layoutGuideForLayoutRegion:',
      iOS: (true, null),
      macOS: (false, (26, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_layoutGuideForLayoutRegion_,
      layoutRegion.ref.pointer,
    );
    return NSLayoutGuide.fromPointer($ret, retain: true, release: true);
  }

  /// rectForLayoutRegion:
  objc.CGRect rectForLayoutRegion(NSViewLayoutRegion layoutRegion) {
    objc.checkOsVersionInternal(
      'NSView.rectForLayoutRegion:',
      iOS: (true, null),
      macOS: (false, (26, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_qrtfceStret(
            $ptr,
            object$.ref.pointer,
            _sel_rectForLayoutRegion_,
            layoutRegion.ref.pointer,
          )
        : $ptr.ref = _objc_msgSend_qrtfce(
            object$.ref.pointer,
            _sel_rectForLayoutRegion_,
            layoutRegion.ref.pointer,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }
}

/// WARNING: NSRulerView is a stub. To generate bindings for this class, include
/// NSRulerView in your config's objc-interfaces list.
///
/// NSRulerView
extension type NSRulerView._(objc.ObjCObject object$)
    implements objc.ObjCObject, NSView {
  /// Constructs a [NSRulerView] that points to the same underlying object as [other].
  NSRulerView.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSRulerView', iOS: (true, null));
  }

  /// Constructs a [NSRulerView] that wraps the given raw object pointer.
  NSRulerView.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSRulerView', iOS: (true, null));
  }
}

/// WARNING: NSRulerMarker is a stub. To generate bindings for this class, include
/// NSRulerMarker in your config's objc-interfaces list.
///
/// NSRulerMarker
extension type NSRulerMarker._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying, objc.NSCoding {
  /// Constructs a [NSRulerMarker] that points to the same underlying object as [other].
  NSRulerMarker.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSRulerMarker', iOS: (true, null));
  }

  /// Constructs a [NSRulerMarker] that wraps the given raw object pointer.
  NSRulerMarker.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSRulerMarker', iOS: (true, null));
  }
}

late final _sel_rulerView_shouldMoveMarker_ = objc.registerName(
  "rulerView:shouldMoveMarker:",
);
late final _sel_rulerView_willMoveMarker_toLocation_ = objc.registerName(
  "rulerView:willMoveMarker:toLocation:",
);
final _objc_msgSend_1ye7gfr = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Double,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        double,
      )
    >();
final _objc_msgSend_1ye7gfrFpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Double,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        double,
      )
    >();
late final _sel_rulerView_didMoveMarker_ = objc.registerName(
  "rulerView:didMoveMarker:",
);
late final _sel_rulerView_shouldRemoveMarker_ = objc.registerName(
  "rulerView:shouldRemoveMarker:",
);
late final _sel_rulerView_didRemoveMarker_ = objc.registerName(
  "rulerView:didRemoveMarker:",
);
late final _sel_rulerView_shouldAddMarker_ = objc.registerName(
  "rulerView:shouldAddMarker:",
);
late final _sel_rulerView_willAddMarker_atLocation_ = objc.registerName(
  "rulerView:willAddMarker:atLocation:",
);
late final _sel_rulerView_didAddMarker_ = objc.registerName(
  "rulerView:didAddMarker:",
);
late final _sel_rulerView_handleMouseDown_ = objc.registerName(
  "rulerView:handleMouseDown:",
);
late final _sel_rulerView_willSetClientView_ = objc.registerName(
  "rulerView:willSetClientView:",
);
late final _sel_rulerView_locationForPoint_ = objc.registerName(
  "rulerView:locationForPoint:",
);
final _objc_msgSend_vxtdi1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          objc.CGPoint,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        objc.CGPoint,
      )
    >();
final _objc_msgSend_vxtdi1Fpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          objc.CGPoint,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        objc.CGPoint,
      )
    >();
late final _sel_rulerView_pointForLocation_ = objc.registerName(
  "rulerView:pointForLocation:",
);
final _objc_msgSend_17l1gu5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGPoint Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Double,
        )
      >
    >()
    .asFunction<
      objc.CGPoint Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        double,
      )
    >();
final _objc_msgSend_17l1gu5Stret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGPoint>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Double,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGPoint>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        double,
      )
    >();

/// NSRulerMarkerClientViewDelegation
extension NSRulerMarkerClientViewDelegation on NSView {
  /// rulerView:didAddMarker:
  void rulerView(NSRulerView ruler, {required NSRulerMarker didAddMarker}) {
    objc.checkOsVersionInternal(
      'NSView.rulerView:didAddMarker:',
      iOS: (true, null),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_rulerView_didAddMarker_,
      ruler.ref.pointer,
      didAddMarker.ref.pointer,
    );
  }

  /// rulerView:didMoveMarker:
  void rulerView$1(NSRulerView ruler, {required NSRulerMarker didMoveMarker}) {
    objc.checkOsVersionInternal(
      'NSView.rulerView:didMoveMarker:',
      iOS: (true, null),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_rulerView_didMoveMarker_,
      ruler.ref.pointer,
      didMoveMarker.ref.pointer,
    );
  }

  /// rulerView:didRemoveMarker:
  void rulerView$2(
    NSRulerView ruler, {
    required NSRulerMarker didRemoveMarker,
  }) {
    objc.checkOsVersionInternal(
      'NSView.rulerView:didRemoveMarker:',
      iOS: (true, null),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_rulerView_didRemoveMarker_,
      ruler.ref.pointer,
      didRemoveMarker.ref.pointer,
    );
  }

  /// rulerView:handleMouseDown:
  void rulerView$3(NSRulerView ruler, {required NSEvent handleMouseDown}) {
    objc.checkOsVersionInternal(
      'NSView.rulerView:handleMouseDown:',
      iOS: (true, null),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_rulerView_handleMouseDown_,
      ruler.ref.pointer,
      handleMouseDown.ref.pointer,
    );
  }

  /// rulerView:locationForPoint:
  double rulerView$4(
    NSRulerView ruler, {
    required objc.CGPoint locationForPoint,
  }) {
    objc.checkOsVersionInternal(
      'NSView.rulerView:locationForPoint:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_vxtdi1Fpret(
            object$.ref.pointer,
            _sel_rulerView_locationForPoint_,
            ruler.ref.pointer,
            locationForPoint,
          )
        : _objc_msgSend_vxtdi1(
            object$.ref.pointer,
            _sel_rulerView_locationForPoint_,
            ruler.ref.pointer,
            locationForPoint,
          );
  }

  /// rulerView:pointForLocation:
  objc.CGPoint rulerView$5(
    NSRulerView ruler, {
    required double pointForLocation,
  }) {
    objc.checkOsVersionInternal(
      'NSView.rulerView:pointForLocation:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_17l1gu5Stret(
            $ptr,
            object$.ref.pointer,
            _sel_rulerView_pointForLocation_,
            ruler.ref.pointer,
            pointForLocation,
          )
        : $ptr.ref = _objc_msgSend_17l1gu5(
            object$.ref.pointer,
            _sel_rulerView_pointForLocation_,
            ruler.ref.pointer,
            pointForLocation,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// rulerView:shouldAddMarker:
  bool rulerView$6(
    NSRulerView ruler, {
    required NSRulerMarker shouldAddMarker,
  }) {
    objc.checkOsVersionInternal(
      'NSView.rulerView:shouldAddMarker:',
      iOS: (true, null),
    );
    return _objc_msgSend_1lsax7n(
      object$.ref.pointer,
      _sel_rulerView_shouldAddMarker_,
      ruler.ref.pointer,
      shouldAddMarker.ref.pointer,
    );
  }

  /// rulerView:shouldMoveMarker:
  bool rulerView$7(
    NSRulerView ruler, {
    required NSRulerMarker shouldMoveMarker,
  }) {
    objc.checkOsVersionInternal(
      'NSView.rulerView:shouldMoveMarker:',
      iOS: (true, null),
    );
    return _objc_msgSend_1lsax7n(
      object$.ref.pointer,
      _sel_rulerView_shouldMoveMarker_,
      ruler.ref.pointer,
      shouldMoveMarker.ref.pointer,
    );
  }

  /// rulerView:shouldRemoveMarker:
  bool rulerView$8(
    NSRulerView ruler, {
    required NSRulerMarker shouldRemoveMarker,
  }) {
    objc.checkOsVersionInternal(
      'NSView.rulerView:shouldRemoveMarker:',
      iOS: (true, null),
    );
    return _objc_msgSend_1lsax7n(
      object$.ref.pointer,
      _sel_rulerView_shouldRemoveMarker_,
      ruler.ref.pointer,
      shouldRemoveMarker.ref.pointer,
    );
  }

  /// rulerView:willAddMarker:atLocation:
  double rulerView$9(
    NSRulerView ruler, {
    required NSRulerMarker willAddMarker,
    required double atLocation,
  }) {
    objc.checkOsVersionInternal(
      'NSView.rulerView:willAddMarker:atLocation:',
      iOS: (true, null),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ye7gfrFpret(
            object$.ref.pointer,
            _sel_rulerView_willAddMarker_atLocation_,
            ruler.ref.pointer,
            willAddMarker.ref.pointer,
            atLocation,
          )
        : _objc_msgSend_1ye7gfr(
            object$.ref.pointer,
            _sel_rulerView_willAddMarker_atLocation_,
            ruler.ref.pointer,
            willAddMarker.ref.pointer,
            atLocation,
          );
  }

  /// rulerView:willMoveMarker:toLocation:
  double rulerView$10(
    NSRulerView ruler, {
    required NSRulerMarker willMoveMarker,
    required double toLocation,
  }) {
    objc.checkOsVersionInternal(
      'NSView.rulerView:willMoveMarker:toLocation:',
      iOS: (true, null),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ye7gfrFpret(
            object$.ref.pointer,
            _sel_rulerView_willMoveMarker_toLocation_,
            ruler.ref.pointer,
            willMoveMarker.ref.pointer,
            toLocation,
          )
        : _objc_msgSend_1ye7gfr(
            object$.ref.pointer,
            _sel_rulerView_willMoveMarker_toLocation_,
            ruler.ref.pointer,
            willMoveMarker.ref.pointer,
            toLocation,
          );
  }

  /// rulerView:willSetClientView:
  void rulerView$11(NSRulerView ruler, {required NSView willSetClientView}) {
    objc.checkOsVersionInternal(
      'NSView.rulerView:willSetClientView:',
      iOS: (true, null),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_rulerView_willSetClientView_,
      ruler.ref.pointer,
      willSetClientView.ref.pointer,
    );
  }
}

late final _sel_wantsBestResolutionOpenGLSurface = objc.registerName(
  "wantsBestResolutionOpenGLSurface",
);
late final _sel_setWantsBestResolutionOpenGLSurface_ = objc.registerName(
  "setWantsBestResolutionOpenGLSurface:",
);

/// NSOpenGLSurfaceResolution
extension NSOpenGLSurfaceResolution on NSView {
  /// setWantsBestResolutionOpenGLSurface:
  set wantsBestResolutionOpenGLSurface(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setWantsBestResolutionOpenGLSurface:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setWantsBestResolutionOpenGLSurface_,
      value,
    );
  }

  /// wantsBestResolutionOpenGLSurface
  bool get wantsBestResolutionOpenGLSurface {
    objc.checkOsVersionInternal(
      'NSView.wantsBestResolutionOpenGLSurface',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_wantsBestResolutionOpenGLSurface,
    );
  }
}

late final _sel_wantsExtendedDynamicRangeOpenGLSurface = objc.registerName(
  "wantsExtendedDynamicRangeOpenGLSurface",
);
late final _sel_setWantsExtendedDynamicRangeOpenGLSurface_ = objc.registerName(
  "setWantsExtendedDynamicRangeOpenGLSurface:",
);

/// NSExtendedDynamicRange
extension NSExtendedDynamicRange on NSView {
  /// setWantsExtendedDynamicRangeOpenGLSurface:
  set wantsExtendedDynamicRangeOpenGLSurface(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setWantsExtendedDynamicRangeOpenGLSurface:',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setWantsExtendedDynamicRangeOpenGLSurface_,
      value,
    );
  }

  /// wantsExtendedDynamicRangeOpenGLSurface
  bool get wantsExtendedDynamicRangeOpenGLSurface {
    objc.checkOsVersionInternal(
      'NSView.wantsExtendedDynamicRangeOpenGLSurface',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_wantsExtendedDynamicRangeOpenGLSurface,
    );
  }
}

/// WARNING: NSPressureConfiguration$1 is a stub. To generate bindings for this class, include
/// NSPressureConfiguration in your config's objc-interfaces list.
///
/// NSPressureConfiguration
extension type NSPressureConfiguration$1._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSPressureConfiguration$1] that points to the same underlying object as [other].
  NSPressureConfiguration$1.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSPressureConfiguration',
      iOS: (true, null),
      macOS: (false, (10, 10, 3)),
    );
  }

  /// Constructs a [NSPressureConfiguration$1] that wraps the given raw object pointer.
  NSPressureConfiguration$1.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSPressureConfiguration',
      iOS: (true, null),
      macOS: (false, (10, 10, 3)),
    );
  }
}

late final _sel_pressureConfiguration = objc.registerName(
  "pressureConfiguration",
);
late final _sel_setPressureConfiguration_ = objc.registerName(
  "setPressureConfiguration:",
);

/// NSPressureConfiguration
extension NSPressureConfiguration on NSView {
  /// pressureConfiguration
  NSPressureConfiguration$1? get pressureConfiguration {
    objc.checkOsVersionInternal(
      'NSView.pressureConfiguration',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_pressureConfiguration,
    );
    return $ret.address == 0
        ? null
        : NSPressureConfiguration$1.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// setPressureConfiguration:
  set pressureConfiguration(NSPressureConfiguration$1? value) {
    objc.checkOsVersionInternal(
      'NSView.setPressureConfiguration:',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setPressureConfiguration_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }
}

/// NSView
extension type NSView._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        NSResponder,
        NSAnimatablePropertyContainer,
        NSUserInterfaceItemIdentification,
        NSDraggingDestination,
        NSAppearanceCustomization,
        NSAccessibilityElement,
        NSAccessibility {
  /// Constructs a [NSView] that points to the same underlying object as [other].
  NSView.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSView', iOS: (true, null));
    assert(isA(object$));
  }

  /// Constructs a [NSView] that wraps the given raw object pointer.
  NSView.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSView', iOS: (true, null));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NSView].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NSView,
  );

  /// alloc
  static NSView alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSView, _sel_alloc);
    return NSView.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSView allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSView,
      _sel_allocWithZone_,
      zone,
    );
    return NSView.fromPointer($ret, retain: false, release: true);
  }

  /// defaultAnimationForKey:
  static objc.ObjCObject? defaultAnimationForKey(objc.NSString key) {
    objc.checkOsVersionInternal(
      'NSView.defaultAnimationForKey:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSView,
      _sel_defaultAnimationForKey_,
      key.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// defaultMenu
  static NSMenu? getDefaultMenu() {
    objc.checkOsVersionInternal('NSView.defaultMenu', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(_class_NSView, _sel_defaultMenu);
    return $ret.address == 0
        ? null
        : NSMenu.fromPointer($ret, retain: true, release: true);
  }

  /// focusView
  static NSView? getFocusView() {
    objc.checkOsVersionInternal('NSView.focusView', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(_class_NSView, _sel_focusView);
    return $ret.address == 0
        ? null
        : NSView.fromPointer($ret, retain: true, release: true);
  }

  /// isCompatibleWithResponsiveScrolling
  static bool getIsCompatibleWithResponsiveScrolling() {
    objc.checkOsVersionInternal(
      'NSView.isCompatibleWithResponsiveScrolling',
      iOS: (true, null),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_91o635(
      _class_NSView,
      _sel_isCompatibleWithResponsiveScrolling,
    );
  }

  /// new
  static NSView new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSView, _sel_new);
    return NSView.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of NSView constructed with the default `new` method.
  NSView() : this.as(new$().object$);
}

extension NSView$Methods on NSView {
  /// acceptsFirstMouse:
  bool acceptsFirstMouse(NSEvent? event) {
    objc.checkOsVersionInternal('NSView.acceptsFirstMouse:', iOS: (true, null));
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_acceptsFirstMouse_,
      event?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// acceptsTouchEvents
  bool get acceptsTouchEvents {
    objc.checkOsVersionInternal(
      'NSView.acceptsTouchEvents',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_acceptsTouchEvents);
  }

  /// accessibilityActivationPoint
  objc.CGPoint get accessibilityActivationPoint {
    objc.checkOsVersionInternal(
      'NSView.accessibilityActivationPoint',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret(
            $ptr,
            object$.ref.pointer,
            _sel_accessibilityActivationPoint,
          )
        : $ptr.ref = _objc_msgSend_1uwdhlk(
            object$.ref.pointer,
            _sel_accessibilityActivationPoint,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// accessibilityAllowedValues
  objc.NSArray? get accessibilityAllowedValues {
    objc.checkOsVersionInternal(
      'NSView.accessibilityAllowedValues',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityAllowedValues,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityApplicationFocusedUIElement
  objc.ObjCObject? get accessibilityApplicationFocusedUIElement {
    objc.checkOsVersionInternal(
      'NSView.accessibilityApplicationFocusedUIElement',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityApplicationFocusedUIElement,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityAttributedStringForRange:
  objc.NSAttributedString? accessibilityAttributedStringForRange(
    objc.NSRange range,
  ) {
    objc.checkOsVersionInternal(
      'NSView.accessibilityAttributedStringForRange:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_1k1o1s7(
      object$.ref.pointer,
      _sel_accessibilityAttributedStringForRange_,
      range,
    );
    return $ret.address == 0
        ? null
        : objc.NSAttributedString.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// accessibilityAttributedUserInputLabels
  objc.NSArray? get accessibilityAttributedUserInputLabels {
    objc.checkOsVersionInternal(
      'NSView.accessibilityAttributedUserInputLabels',
      iOS: (true, null),
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityAttributedUserInputLabels,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityCancelButton
  objc.ObjCObject? get accessibilityCancelButton {
    objc.checkOsVersionInternal(
      'NSView.accessibilityCancelButton',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityCancelButton,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityCellForColumn:row:
  objc.ObjCObject? accessibilityCellForColumn(int column, {required int row}) {
    objc.checkOsVersionInternal(
      'NSView.accessibilityCellForColumn:row:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_1nzyvs1(
      object$.ref.pointer,
      _sel_accessibilityCellForColumn_row_,
      column,
      row,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityChildren
  objc.NSArray? get accessibilityChildren {
    objc.checkOsVersionInternal(
      'NSView.accessibilityChildren',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityChildren,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityChildrenInNavigationOrder
  objc.NSArray? get accessibilityChildrenInNavigationOrder {
    objc.checkOsVersionInternal(
      'NSView.accessibilityChildrenInNavigationOrder',
      iOS: (true, null),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityChildrenInNavigationOrder,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityClearButton
  objc.ObjCObject? get accessibilityClearButton {
    objc.checkOsVersionInternal(
      'NSView.accessibilityClearButton',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityClearButton,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityCloseButton
  objc.ObjCObject? get accessibilityCloseButton {
    objc.checkOsVersionInternal(
      'NSView.accessibilityCloseButton',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityCloseButton,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityColumnCount
  int get accessibilityColumnCount {
    objc.checkOsVersionInternal(
      'NSView.accessibilityColumnCount',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_1hz7y9r(
      object$.ref.pointer,
      _sel_accessibilityColumnCount,
    );
  }

  /// accessibilityColumnHeaderUIElements
  objc.NSArray? get accessibilityColumnHeaderUIElements {
    objc.checkOsVersionInternal(
      'NSView.accessibilityColumnHeaderUIElements',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityColumnHeaderUIElements,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityColumnIndexRange
  objc.NSRange get accessibilityColumnIndexRange {
    objc.checkOsVersionInternal(
      'NSView.accessibilityColumnIndexRange',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1u11dbbStret(
            $ptr,
            object$.ref.pointer,
            _sel_accessibilityColumnIndexRange,
          )
        : $ptr.ref = _objc_msgSend_1u11dbb(
            object$.ref.pointer,
            _sel_accessibilityColumnIndexRange,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.NSRange>($finalizable);
  }

  /// accessibilityColumnTitles
  objc.NSArray? get accessibilityColumnTitles {
    objc.checkOsVersionInternal(
      'NSView.accessibilityColumnTitles',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityColumnTitles,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityColumns
  objc.NSArray? get accessibilityColumns {
    objc.checkOsVersionInternal(
      'NSView.accessibilityColumns',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityColumns,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityContents
  objc.NSArray? get accessibilityContents {
    objc.checkOsVersionInternal(
      'NSView.accessibilityContents',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityContents,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityCriticalValue
  objc.ObjCObject? get accessibilityCriticalValue {
    objc.checkOsVersionInternal(
      'NSView.accessibilityCriticalValue',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityCriticalValue,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityCustomActions
  objc.NSArray? get accessibilityCustomActions {
    objc.checkOsVersionInternal(
      'NSView.accessibilityCustomActions',
      iOS: (true, null),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityCustomActions,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityCustomRotors
  objc.NSArray get accessibilityCustomRotors {
    objc.checkOsVersionInternal(
      'NSView.accessibilityCustomRotors',
      iOS: (true, null),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityCustomRotors,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityDecrementButton
  objc.ObjCObject? get accessibilityDecrementButton {
    objc.checkOsVersionInternal(
      'NSView.accessibilityDecrementButton',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityDecrementButton,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityDefaultButton
  objc.ObjCObject? get accessibilityDefaultButton {
    objc.checkOsVersionInternal(
      'NSView.accessibilityDefaultButton',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityDefaultButton,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityDisclosedByRow
  objc.ObjCObject? get accessibilityDisclosedByRow {
    objc.checkOsVersionInternal(
      'NSView.accessibilityDisclosedByRow',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityDisclosedByRow,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityDisclosedRows
  objc.ObjCObject? get accessibilityDisclosedRows {
    objc.checkOsVersionInternal(
      'NSView.accessibilityDisclosedRows',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityDisclosedRows,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityDisclosureLevel
  int get accessibilityDisclosureLevel {
    objc.checkOsVersionInternal(
      'NSView.accessibilityDisclosureLevel',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_1hz7y9r(
      object$.ref.pointer,
      _sel_accessibilityDisclosureLevel,
    );
  }

  /// accessibilityDocument
  objc.NSString? get accessibilityDocument {
    objc.checkOsVersionInternal(
      'NSView.accessibilityDocument',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityDocument,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityExtrasMenuBar
  objc.ObjCObject? get accessibilityExtrasMenuBar {
    objc.checkOsVersionInternal(
      'NSView.accessibilityExtrasMenuBar',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityExtrasMenuBar,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityFilename
  objc.NSString? get accessibilityFilename {
    objc.checkOsVersionInternal(
      'NSView.accessibilityFilename',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityFilename,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityFocusedWindow
  objc.ObjCObject? get accessibilityFocusedWindow {
    objc.checkOsVersionInternal(
      'NSView.accessibilityFocusedWindow',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityFocusedWindow,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityFrame
  objc.CGRect get accessibilityFrame {
    objc.checkOsVersionInternal(
      'NSView.accessibilityFrame',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(
            $ptr,
            object$.ref.pointer,
            _sel_accessibilityFrame,
          )
        : $ptr.ref = _objc_msgSend_bu1hbw(
            object$.ref.pointer,
            _sel_accessibilityFrame,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// accessibilityFrameForRange:
  objc.CGRect accessibilityFrameForRange(objc.NSRange range) {
    objc.checkOsVersionInternal(
      'NSView.accessibilityFrameForRange:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1c8xwawStret(
            $ptr,
            object$.ref.pointer,
            _sel_accessibilityFrameForRange_,
            range,
          )
        : $ptr.ref = _objc_msgSend_1c8xwaw(
            object$.ref.pointer,
            _sel_accessibilityFrameForRange_,
            range,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// accessibilityFullScreenButton
  objc.ObjCObject? get accessibilityFullScreenButton {
    objc.checkOsVersionInternal(
      'NSView.accessibilityFullScreenButton',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityFullScreenButton,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityGrowArea
  objc.ObjCObject? get accessibilityGrowArea {
    objc.checkOsVersionInternal(
      'NSView.accessibilityGrowArea',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityGrowArea,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityHandles
  objc.NSArray? get accessibilityHandles {
    objc.checkOsVersionInternal(
      'NSView.accessibilityHandles',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityHandles,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityHeader
  objc.ObjCObject? get accessibilityHeader {
    objc.checkOsVersionInternal(
      'NSView.accessibilityHeader',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityHeader,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityHelp
  objc.NSString? get accessibilityHelp {
    objc.checkOsVersionInternal(
      'NSView.accessibilityHelp',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityHelp,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityHorizontalScrollBar
  objc.ObjCObject? get accessibilityHorizontalScrollBar {
    objc.checkOsVersionInternal(
      'NSView.accessibilityHorizontalScrollBar',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityHorizontalScrollBar,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityHorizontalUnitDescription
  objc.NSString? get accessibilityHorizontalUnitDescription {
    objc.checkOsVersionInternal(
      'NSView.accessibilityHorizontalUnitDescription',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityHorizontalUnitDescription,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityHorizontalUnits
  NSAccessibilityUnits get accessibilityHorizontalUnits {
    objc.checkOsVersionInternal(
      'NSView.accessibilityHorizontalUnits',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_k2hzvx(
      object$.ref.pointer,
      _sel_accessibilityHorizontalUnits,
    );
    return NSAccessibilityUnits.fromValue($ret);
  }

  /// accessibilityIdentifier
  objc.NSString? get accessibilityIdentifier {
    objc.checkOsVersionInternal(
      'NSView.accessibilityIdentifier',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityIdentifier,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityIncrementButton
  objc.ObjCObject? get accessibilityIncrementButton {
    objc.checkOsVersionInternal(
      'NSView.accessibilityIncrementButton',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityIncrementButton,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityIndex
  int get accessibilityIndex {
    objc.checkOsVersionInternal(
      'NSView.accessibilityIndex',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_accessibilityIndex);
  }

  /// accessibilityInsertionPointLineNumber
  int get accessibilityInsertionPointLineNumber {
    objc.checkOsVersionInternal(
      'NSView.accessibilityInsertionPointLineNumber',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_1hz7y9r(
      object$.ref.pointer,
      _sel_accessibilityInsertionPointLineNumber,
    );
  }

  /// accessibilityLabel
  objc.NSString? get accessibilityLabel {
    objc.checkOsVersionInternal(
      'NSView.accessibilityLabel',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityLabel,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityLabelUIElements
  objc.NSArray? get accessibilityLabelUIElements {
    objc.checkOsVersionInternal(
      'NSView.accessibilityLabelUIElements',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityLabelUIElements,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityLabelValue
  double get accessibilityLabelValue {
    objc.checkOsVersionInternal(
      'NSView.accessibilityLabelValue',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_2cgrxlFpret(
            object$.ref.pointer,
            _sel_accessibilityLabelValue,
          )
        : _objc_msgSend_2cgrxl(
            object$.ref.pointer,
            _sel_accessibilityLabelValue,
          );
  }

  /// accessibilityLayoutPointForScreenPoint:
  objc.CGPoint accessibilityLayoutPointForScreenPoint(objc.CGPoint point) {
    objc.checkOsVersionInternal(
      'NSView.accessibilityLayoutPointForScreenPoint:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1w4qqqrStret(
            $ptr,
            object$.ref.pointer,
            _sel_accessibilityLayoutPointForScreenPoint_,
            point,
          )
        : $ptr.ref = _objc_msgSend_1w4qqqr(
            object$.ref.pointer,
            _sel_accessibilityLayoutPointForScreenPoint_,
            point,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// accessibilityLayoutSizeForScreenSize:
  objc.CGSize accessibilityLayoutSizeForScreenSize(objc.CGSize size) {
    objc.checkOsVersionInternal(
      'NSView.accessibilityLayoutSizeForScreenSize:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1owrp3bStret(
            $ptr,
            object$.ref.pointer,
            _sel_accessibilityLayoutSizeForScreenSize_,
            size,
          )
        : $ptr.ref = _objc_msgSend_1owrp3b(
            object$.ref.pointer,
            _sel_accessibilityLayoutSizeForScreenSize_,
            size,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// accessibilityLineForIndex:
  int accessibilityLineForIndex(int index) {
    objc.checkOsVersionInternal(
      'NSView.accessibilityLineForIndex:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_12hwf9n(
      object$.ref.pointer,
      _sel_accessibilityLineForIndex_,
      index,
    );
  }

  /// accessibilityLinkedUIElements
  objc.NSArray? get accessibilityLinkedUIElements {
    objc.checkOsVersionInternal(
      'NSView.accessibilityLinkedUIElements',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityLinkedUIElements,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityMainWindow
  objc.ObjCObject? get accessibilityMainWindow {
    objc.checkOsVersionInternal(
      'NSView.accessibilityMainWindow',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityMainWindow,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityMarkerGroupUIElement
  objc.ObjCObject? get accessibilityMarkerGroupUIElement {
    objc.checkOsVersionInternal(
      'NSView.accessibilityMarkerGroupUIElement',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityMarkerGroupUIElement,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityMarkerTypeDescription
  objc.NSString? get accessibilityMarkerTypeDescription {
    objc.checkOsVersionInternal(
      'NSView.accessibilityMarkerTypeDescription',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityMarkerTypeDescription,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityMarkerUIElements
  objc.NSArray? get accessibilityMarkerUIElements {
    objc.checkOsVersionInternal(
      'NSView.accessibilityMarkerUIElements',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityMarkerUIElements,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityMarkerValues
  objc.ObjCObject? get accessibilityMarkerValues {
    objc.checkOsVersionInternal(
      'NSView.accessibilityMarkerValues',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityMarkerValues,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityMaxValue
  objc.ObjCObject? get accessibilityMaxValue {
    objc.checkOsVersionInternal(
      'NSView.accessibilityMaxValue',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityMaxValue,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityMenuBar
  objc.ObjCObject? get accessibilityMenuBar {
    objc.checkOsVersionInternal(
      'NSView.accessibilityMenuBar',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityMenuBar,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityMinValue
  objc.ObjCObject? get accessibilityMinValue {
    objc.checkOsVersionInternal(
      'NSView.accessibilityMinValue',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityMinValue,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityMinimizeButton
  objc.ObjCObject? get accessibilityMinimizeButton {
    objc.checkOsVersionInternal(
      'NSView.accessibilityMinimizeButton',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityMinimizeButton,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityNextContents
  objc.NSArray? get accessibilityNextContents {
    objc.checkOsVersionInternal(
      'NSView.accessibilityNextContents',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityNextContents,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityNumberOfCharacters
  int get accessibilityNumberOfCharacters {
    objc.checkOsVersionInternal(
      'NSView.accessibilityNumberOfCharacters',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_1hz7y9r(
      object$.ref.pointer,
      _sel_accessibilityNumberOfCharacters,
    );
  }

  /// accessibilityOrientation
  NSAccessibilityOrientation get accessibilityOrientation {
    objc.checkOsVersionInternal(
      'NSView.accessibilityOrientation',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_hnn3gk(
      object$.ref.pointer,
      _sel_accessibilityOrientation,
    );
    return NSAccessibilityOrientation.fromValue($ret);
  }

  /// accessibilityOverflowButton
  objc.ObjCObject? get accessibilityOverflowButton {
    objc.checkOsVersionInternal(
      'NSView.accessibilityOverflowButton',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityOverflowButton,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityParent
  objc.ObjCObject? get accessibilityParent {
    objc.checkOsVersionInternal(
      'NSView.accessibilityParent',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityParent,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityPerformCancel
  bool accessibilityPerformCancel() {
    objc.checkOsVersionInternal(
      'NSView.accessibilityPerformCancel',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_accessibilityPerformCancel,
    );
  }

  /// accessibilityPerformConfirm
  bool accessibilityPerformConfirm() {
    objc.checkOsVersionInternal(
      'NSView.accessibilityPerformConfirm',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_accessibilityPerformConfirm,
    );
  }

  /// accessibilityPerformDecrement
  bool accessibilityPerformDecrement() {
    objc.checkOsVersionInternal(
      'NSView.accessibilityPerformDecrement',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_accessibilityPerformDecrement,
    );
  }

  /// accessibilityPerformDelete
  bool accessibilityPerformDelete() {
    objc.checkOsVersionInternal(
      'NSView.accessibilityPerformDelete',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_accessibilityPerformDelete,
    );
  }

  /// accessibilityPerformIncrement
  bool accessibilityPerformIncrement() {
    objc.checkOsVersionInternal(
      'NSView.accessibilityPerformIncrement',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_accessibilityPerformIncrement,
    );
  }

  /// accessibilityPerformPick
  bool accessibilityPerformPick() {
    objc.checkOsVersionInternal(
      'NSView.accessibilityPerformPick',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_accessibilityPerformPick,
    );
  }

  /// accessibilityPerformPress
  bool accessibilityPerformPress() {
    objc.checkOsVersionInternal(
      'NSView.accessibilityPerformPress',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_accessibilityPerformPress,
    );
  }

  /// accessibilityPerformRaise
  bool accessibilityPerformRaise() {
    objc.checkOsVersionInternal(
      'NSView.accessibilityPerformRaise',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_accessibilityPerformRaise,
    );
  }

  /// accessibilityPerformShowAlternateUI
  bool accessibilityPerformShowAlternateUI() {
    objc.checkOsVersionInternal(
      'NSView.accessibilityPerformShowAlternateUI',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_accessibilityPerformShowAlternateUI,
    );
  }

  /// accessibilityPerformShowDefaultUI
  bool accessibilityPerformShowDefaultUI() {
    objc.checkOsVersionInternal(
      'NSView.accessibilityPerformShowDefaultUI',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_accessibilityPerformShowDefaultUI,
    );
  }

  /// accessibilityPerformShowMenu
  bool accessibilityPerformShowMenu() {
    objc.checkOsVersionInternal(
      'NSView.accessibilityPerformShowMenu',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_accessibilityPerformShowMenu,
    );
  }

  /// accessibilityPlaceholderValue
  objc.NSString? get accessibilityPlaceholderValue {
    objc.checkOsVersionInternal(
      'NSView.accessibilityPlaceholderValue',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityPlaceholderValue,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityPreviousContents
  objc.NSArray? get accessibilityPreviousContents {
    objc.checkOsVersionInternal(
      'NSView.accessibilityPreviousContents',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityPreviousContents,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityProxy
  objc.ObjCObject? get accessibilityProxy {
    objc.checkOsVersionInternal(
      'NSView.accessibilityProxy',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityProxy,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityRTFForRange:
  objc.NSData? accessibilityRTFForRange(objc.NSRange range) {
    objc.checkOsVersionInternal(
      'NSView.accessibilityRTFForRange:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_1k1o1s7(
      object$.ref.pointer,
      _sel_accessibilityRTFForRange_,
      range,
    );
    return $ret.address == 0
        ? null
        : objc.NSData.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityRangeForIndex:
  objc.NSRange accessibilityRangeForIndex(int index) {
    objc.checkOsVersionInternal(
      'NSView.accessibilityRangeForIndex:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_118andfStret(
            $ptr,
            object$.ref.pointer,
            _sel_accessibilityRangeForIndex_,
            index,
          )
        : $ptr.ref = _objc_msgSend_118andf(
            object$.ref.pointer,
            _sel_accessibilityRangeForIndex_,
            index,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.NSRange>($finalizable);
  }

  /// accessibilityRangeForLine:
  objc.NSRange accessibilityRangeForLine(int line) {
    objc.checkOsVersionInternal(
      'NSView.accessibilityRangeForLine:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_118andfStret(
            $ptr,
            object$.ref.pointer,
            _sel_accessibilityRangeForLine_,
            line,
          )
        : $ptr.ref = _objc_msgSend_118andf(
            object$.ref.pointer,
            _sel_accessibilityRangeForLine_,
            line,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.NSRange>($finalizable);
  }

  /// accessibilityRangeForPosition:
  objc.NSRange accessibilityRangeForPosition(objc.CGPoint point) {
    objc.checkOsVersionInternal(
      'NSView.accessibilityRangeForPosition:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_d3jy2uStret(
            $ptr,
            object$.ref.pointer,
            _sel_accessibilityRangeForPosition_,
            point,
          )
        : $ptr.ref = _objc_msgSend_d3jy2u(
            object$.ref.pointer,
            _sel_accessibilityRangeForPosition_,
            point,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.NSRange>($finalizable);
  }

  /// accessibilityRole
  objc.NSString? get accessibilityRole {
    objc.checkOsVersionInternal(
      'NSView.accessibilityRole',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityRole,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityRoleDescription
  objc.NSString? get accessibilityRoleDescription {
    objc.checkOsVersionInternal(
      'NSView.accessibilityRoleDescription',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityRoleDescription,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityRowCount
  int get accessibilityRowCount {
    objc.checkOsVersionInternal(
      'NSView.accessibilityRowCount',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_1hz7y9r(
      object$.ref.pointer,
      _sel_accessibilityRowCount,
    );
  }

  /// accessibilityRowHeaderUIElements
  objc.NSArray? get accessibilityRowHeaderUIElements {
    objc.checkOsVersionInternal(
      'NSView.accessibilityRowHeaderUIElements',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityRowHeaderUIElements,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityRowIndexRange
  objc.NSRange get accessibilityRowIndexRange {
    objc.checkOsVersionInternal(
      'NSView.accessibilityRowIndexRange',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1u11dbbStret(
            $ptr,
            object$.ref.pointer,
            _sel_accessibilityRowIndexRange,
          )
        : $ptr.ref = _objc_msgSend_1u11dbb(
            object$.ref.pointer,
            _sel_accessibilityRowIndexRange,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.NSRange>($finalizable);
  }

  /// accessibilityRows
  objc.NSArray? get accessibilityRows {
    objc.checkOsVersionInternal(
      'NSView.accessibilityRows',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityRows,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityRulerMarkerType
  NSAccessibilityRulerMarkerType get accessibilityRulerMarkerType {
    objc.checkOsVersionInternal(
      'NSView.accessibilityRulerMarkerType',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_w95izs(
      object$.ref.pointer,
      _sel_accessibilityRulerMarkerType,
    );
    return NSAccessibilityRulerMarkerType.fromValue($ret);
  }

  /// accessibilityScreenPointForLayoutPoint:
  objc.CGPoint accessibilityScreenPointForLayoutPoint(objc.CGPoint point) {
    objc.checkOsVersionInternal(
      'NSView.accessibilityScreenPointForLayoutPoint:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1w4qqqrStret(
            $ptr,
            object$.ref.pointer,
            _sel_accessibilityScreenPointForLayoutPoint_,
            point,
          )
        : $ptr.ref = _objc_msgSend_1w4qqqr(
            object$.ref.pointer,
            _sel_accessibilityScreenPointForLayoutPoint_,
            point,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// accessibilityScreenSizeForLayoutSize:
  objc.CGSize accessibilityScreenSizeForLayoutSize(objc.CGSize size) {
    objc.checkOsVersionInternal(
      'NSView.accessibilityScreenSizeForLayoutSize:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1owrp3bStret(
            $ptr,
            object$.ref.pointer,
            _sel_accessibilityScreenSizeForLayoutSize_,
            size,
          )
        : $ptr.ref = _objc_msgSend_1owrp3b(
            object$.ref.pointer,
            _sel_accessibilityScreenSizeForLayoutSize_,
            size,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// accessibilitySearchButton
  objc.ObjCObject? get accessibilitySearchButton {
    objc.checkOsVersionInternal(
      'NSView.accessibilitySearchButton',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilitySearchButton,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilitySearchMenu
  objc.ObjCObject? get accessibilitySearchMenu {
    objc.checkOsVersionInternal(
      'NSView.accessibilitySearchMenu',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilitySearchMenu,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilitySelectedCells
  objc.NSArray? get accessibilitySelectedCells {
    objc.checkOsVersionInternal(
      'NSView.accessibilitySelectedCells',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilitySelectedCells,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilitySelectedChildren
  objc.NSArray? get accessibilitySelectedChildren {
    objc.checkOsVersionInternal(
      'NSView.accessibilitySelectedChildren',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilitySelectedChildren,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilitySelectedColumns
  objc.NSArray? get accessibilitySelectedColumns {
    objc.checkOsVersionInternal(
      'NSView.accessibilitySelectedColumns',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilitySelectedColumns,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilitySelectedRows
  objc.NSArray? get accessibilitySelectedRows {
    objc.checkOsVersionInternal(
      'NSView.accessibilitySelectedRows',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilitySelectedRows,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilitySelectedText
  objc.NSString? get accessibilitySelectedText {
    objc.checkOsVersionInternal(
      'NSView.accessibilitySelectedText',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilitySelectedText,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilitySelectedTextRange
  objc.NSRange get accessibilitySelectedTextRange {
    objc.checkOsVersionInternal(
      'NSView.accessibilitySelectedTextRange',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1u11dbbStret(
            $ptr,
            object$.ref.pointer,
            _sel_accessibilitySelectedTextRange,
          )
        : $ptr.ref = _objc_msgSend_1u11dbb(
            object$.ref.pointer,
            _sel_accessibilitySelectedTextRange,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.NSRange>($finalizable);
  }

  /// accessibilitySelectedTextRanges
  objc.NSArray? get accessibilitySelectedTextRanges {
    objc.checkOsVersionInternal(
      'NSView.accessibilitySelectedTextRanges',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilitySelectedTextRanges,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityServesAsTitleForUIElements
  objc.NSArray? get accessibilityServesAsTitleForUIElements {
    objc.checkOsVersionInternal(
      'NSView.accessibilityServesAsTitleForUIElements',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityServesAsTitleForUIElements,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilitySharedCharacterRange
  objc.NSRange get accessibilitySharedCharacterRange {
    objc.checkOsVersionInternal(
      'NSView.accessibilitySharedCharacterRange',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1u11dbbStret(
            $ptr,
            object$.ref.pointer,
            _sel_accessibilitySharedCharacterRange,
          )
        : $ptr.ref = _objc_msgSend_1u11dbb(
            object$.ref.pointer,
            _sel_accessibilitySharedCharacterRange,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.NSRange>($finalizable);
  }

  /// accessibilitySharedFocusElements
  objc.NSArray? get accessibilitySharedFocusElements {
    objc.checkOsVersionInternal(
      'NSView.accessibilitySharedFocusElements',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilitySharedFocusElements,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilitySharedTextUIElements
  objc.NSArray? get accessibilitySharedTextUIElements {
    objc.checkOsVersionInternal(
      'NSView.accessibilitySharedTextUIElements',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilitySharedTextUIElements,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityShownMenu
  objc.ObjCObject? get accessibilityShownMenu {
    objc.checkOsVersionInternal(
      'NSView.accessibilityShownMenu',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityShownMenu,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilitySortDirection
  NSAccessibilitySortDirection get accessibilitySortDirection {
    objc.checkOsVersionInternal(
      'NSView.accessibilitySortDirection',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_16y6cxr(
      object$.ref.pointer,
      _sel_accessibilitySortDirection,
    );
    return NSAccessibilitySortDirection.fromValue($ret);
  }

  /// accessibilitySplitters
  objc.NSArray? get accessibilitySplitters {
    objc.checkOsVersionInternal(
      'NSView.accessibilitySplitters',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilitySplitters,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityStringForRange:
  objc.NSString? accessibilityStringForRange(objc.NSRange range) {
    objc.checkOsVersionInternal(
      'NSView.accessibilityStringForRange:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_1k1o1s7(
      object$.ref.pointer,
      _sel_accessibilityStringForRange_,
      range,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityStyleRangeForIndex:
  objc.NSRange accessibilityStyleRangeForIndex(int index) {
    objc.checkOsVersionInternal(
      'NSView.accessibilityStyleRangeForIndex:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_118andfStret(
            $ptr,
            object$.ref.pointer,
            _sel_accessibilityStyleRangeForIndex_,
            index,
          )
        : $ptr.ref = _objc_msgSend_118andf(
            object$.ref.pointer,
            _sel_accessibilityStyleRangeForIndex_,
            index,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.NSRange>($finalizable);
  }

  /// accessibilitySubrole
  objc.NSString? get accessibilitySubrole {
    objc.checkOsVersionInternal(
      'NSView.accessibilitySubrole',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilitySubrole,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityTabs
  objc.NSArray? get accessibilityTabs {
    objc.checkOsVersionInternal(
      'NSView.accessibilityTabs',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityTabs,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityTitle
  objc.NSString? get accessibilityTitle {
    objc.checkOsVersionInternal(
      'NSView.accessibilityTitle',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityTitle,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityTitleUIElement
  objc.ObjCObject? get accessibilityTitleUIElement {
    objc.checkOsVersionInternal(
      'NSView.accessibilityTitleUIElement',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityTitleUIElement,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityToolbarButton
  objc.ObjCObject? get accessibilityToolbarButton {
    objc.checkOsVersionInternal(
      'NSView.accessibilityToolbarButton',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityToolbarButton,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityTopLevelUIElement
  objc.ObjCObject? get accessibilityTopLevelUIElement {
    objc.checkOsVersionInternal(
      'NSView.accessibilityTopLevelUIElement',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityTopLevelUIElement,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityURL
  objc.NSURL? get accessibilityURL {
    objc.checkOsVersionInternal(
      'NSView.accessibilityURL',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityURL,
    );
    return $ret.address == 0
        ? null
        : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityUnitDescription
  objc.NSString? get accessibilityUnitDescription {
    objc.checkOsVersionInternal(
      'NSView.accessibilityUnitDescription',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityUnitDescription,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityUnits
  NSAccessibilityUnits get accessibilityUnits {
    objc.checkOsVersionInternal(
      'NSView.accessibilityUnits',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_k2hzvx(
      object$.ref.pointer,
      _sel_accessibilityUnits,
    );
    return NSAccessibilityUnits.fromValue($ret);
  }

  /// accessibilityUserInputLabels
  objc.NSArray? get accessibilityUserInputLabels {
    objc.checkOsVersionInternal(
      'NSView.accessibilityUserInputLabels',
      iOS: (true, null),
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityUserInputLabels,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityValue
  objc.ObjCObject? get accessibilityValue {
    objc.checkOsVersionInternal(
      'NSView.accessibilityValue',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityValue,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityValueDescription
  objc.NSString? get accessibilityValueDescription {
    objc.checkOsVersionInternal(
      'NSView.accessibilityValueDescription',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityValueDescription,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityVerticalScrollBar
  objc.ObjCObject? get accessibilityVerticalScrollBar {
    objc.checkOsVersionInternal(
      'NSView.accessibilityVerticalScrollBar',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityVerticalScrollBar,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityVerticalUnitDescription
  objc.NSString? get accessibilityVerticalUnitDescription {
    objc.checkOsVersionInternal(
      'NSView.accessibilityVerticalUnitDescription',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityVerticalUnitDescription,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityVerticalUnits
  NSAccessibilityUnits get accessibilityVerticalUnits {
    objc.checkOsVersionInternal(
      'NSView.accessibilityVerticalUnits',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_k2hzvx(
      object$.ref.pointer,
      _sel_accessibilityVerticalUnits,
    );
    return NSAccessibilityUnits.fromValue($ret);
  }

  /// accessibilityVisibleCells
  objc.NSArray? get accessibilityVisibleCells {
    objc.checkOsVersionInternal(
      'NSView.accessibilityVisibleCells',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityVisibleCells,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityVisibleCharacterRange
  objc.NSRange get accessibilityVisibleCharacterRange {
    objc.checkOsVersionInternal(
      'NSView.accessibilityVisibleCharacterRange',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1u11dbbStret(
            $ptr,
            object$.ref.pointer,
            _sel_accessibilityVisibleCharacterRange,
          )
        : $ptr.ref = _objc_msgSend_1u11dbb(
            object$.ref.pointer,
            _sel_accessibilityVisibleCharacterRange,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.NSRange>($finalizable);
  }

  /// accessibilityVisibleChildren
  objc.NSArray? get accessibilityVisibleChildren {
    objc.checkOsVersionInternal(
      'NSView.accessibilityVisibleChildren',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityVisibleChildren,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityVisibleColumns
  objc.NSArray? get accessibilityVisibleColumns {
    objc.checkOsVersionInternal(
      'NSView.accessibilityVisibleColumns',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityVisibleColumns,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityVisibleRows
  objc.NSArray? get accessibilityVisibleRows {
    objc.checkOsVersionInternal(
      'NSView.accessibilityVisibleRows',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityVisibleRows,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityWarningValue
  objc.ObjCObject? get accessibilityWarningValue {
    objc.checkOsVersionInternal(
      'NSView.accessibilityWarningValue',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityWarningValue,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityWindow
  objc.ObjCObject? get accessibilityWindow {
    objc.checkOsVersionInternal(
      'NSView.accessibilityWindow',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityWindow,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// accessibilityWindows
  objc.NSArray? get accessibilityWindows {
    objc.checkOsVersionInternal(
      'NSView.accessibilityWindows',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityWindows,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// accessibilityZoomButton
  objc.ObjCObject? get accessibilityZoomButton {
    objc.checkOsVersionInternal(
      'NSView.accessibilityZoomButton',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityZoomButton,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// addSubview:
  void addSubview(NSView view) {
    objc.checkOsVersionInternal('NSView.addSubview:', iOS: (true, null));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_addSubview_,
      view.ref.pointer,
    );
  }

  /// addSubview:positioned:relativeTo:
  void addSubview$1(
    NSView view, {
    required NSWindowOrderingMode positioned,
    NSView? relativeTo,
  }) {
    objc.checkOsVersionInternal(
      'NSView.addSubview:positioned:relativeTo:',
      iOS: (true, null),
    );
    _objc_msgSend_2y3j65(
      object$.ref.pointer,
      _sel_addSubview_positioned_relativeTo_,
      view.ref.pointer,
      positioned.value,
      relativeTo?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// addToolTipRect:owner:userData:
  int addToolTipRect(
    objc.CGRect rect, {
    required objc.ObjCObject owner,
    required ffi.Pointer<ffi.Void> userData,
  }) {
    objc.checkOsVersionInternal(
      'NSView.addToolTipRect:owner:userData:',
      iOS: (true, null),
    );
    return _objc_msgSend_n11w24(
      object$.ref.pointer,
      _sel_addToolTipRect_owner_userData_,
      rect,
      owner.ref.pointer,
      userData,
    );
  }

  /// adjustScroll:
  objc.CGRect adjustScroll(objc.CGRect newVisible) {
    objc.checkOsVersionInternal('NSView.adjustScroll:', iOS: (true, null));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1gn1s3dStret(
            $ptr,
            object$.ref.pointer,
            _sel_adjustScroll_,
            newVisible,
          )
        : $ptr.ref = _objc_msgSend_1gn1s3d(
            object$.ref.pointer,
            _sel_adjustScroll_,
            newVisible,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// allowsVibrancy
  bool get allowsVibrancy {
    objc.checkOsVersionInternal(
      'NSView.allowsVibrancy',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_allowsVibrancy);
  }

  /// alphaValue
  double get alphaValue {
    objc.checkOsVersionInternal(
      'NSView.alphaValue',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_alphaValue)
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_alphaValue);
  }

  /// ancestorSharedWithView:
  NSView? ancestorSharedWithView(NSView view) {
    objc.checkOsVersionInternal(
      'NSView.ancestorSharedWithView:',
      iOS: (true, null),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_ancestorSharedWithView_,
      view.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSView.fromPointer($ret, retain: true, release: true);
  }

  /// animationForKey:
  objc.ObjCObject? animationForKey(objc.NSString key) {
    objc.checkOsVersionInternal(
      'NSView.animationForKey:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_animationForKey_,
      key.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// animations
  objc.NSDictionary get animations {
    objc.checkOsVersionInternal(
      'NSView.animations',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_animations);
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// animator
  NSView animator() {
    objc.checkOsVersionInternal(
      'NSView.animator',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_animator);
    return NSView.fromPointer($ret, retain: true, release: true);
  }

  /// appearance
  NSAppearance? get appearance {
    objc.checkOsVersionInternal(
      'NSView.appearance',
      iOS: (true, null),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_appearance);
    return $ret.address == 0
        ? null
        : NSAppearance.fromPointer($ret, retain: true, release: true);
  }

  /// autoresizesSubviews
  bool get autoresizesSubviews {
    objc.checkOsVersionInternal(
      'NSView.autoresizesSubviews',
      iOS: (true, null),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_autoresizesSubviews);
  }

  /// autoresizingMask
  int get autoresizingMask {
    objc.checkOsVersionInternal('NSView.autoresizingMask', iOS: (true, null));
    return _objc_msgSend_1stg510(object$.ref.pointer, _sel_autoresizingMask);
  }

  /// autoscroll:
  bool autoscroll(NSEvent event) {
    objc.checkOsVersionInternal('NSView.autoscroll:', iOS: (true, null));
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_autoscroll_,
      event.ref.pointer,
    );
  }

  /// backgroundFilters
  objc.NSArray get backgroundFilters {
    objc.checkOsVersionInternal(
      'NSView.backgroundFilters',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_backgroundFilters,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// backingAlignedRect:options:
  objc.CGRect backingAlignedRect(objc.CGRect rect, {required int options}) {
    objc.checkOsVersionInternal(
      'NSView.backingAlignedRect:options:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_qmdcb3Stret(
            $ptr,
            object$.ref.pointer,
            _sel_backingAlignedRect_options_,
            rect,
            options,
          )
        : $ptr.ref = _objc_msgSend_qmdcb3(
            object$.ref.pointer,
            _sel_backingAlignedRect_options_,
            rect,
            options,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// bitmapImageRepForCachingDisplayInRect:
  NSBitmapImageRep? bitmapImageRepForCachingDisplayInRect(objc.CGRect rect) {
    objc.checkOsVersionInternal(
      'NSView.bitmapImageRepForCachingDisplayInRect:',
      iOS: (true, null),
    );
    final $ret = _objc_msgSend_15yz4e6(
      object$.ref.pointer,
      _sel_bitmapImageRepForCachingDisplayInRect_,
      rect,
    );
    return $ret.address == 0
        ? null
        : NSBitmapImageRep.fromPointer($ret, retain: true, release: true);
  }

  /// bounds
  objc.CGRect get bounds {
    objc.checkOsVersionInternal('NSView.bounds', iOS: (true, null));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_bounds)
        : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_bounds);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// boundsRotation
  double get boundsRotation {
    objc.checkOsVersionInternal('NSView.boundsRotation', iOS: (true, null));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_boundsRotation)
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_boundsRotation);
  }

  /// cacheDisplayInRect:toBitmapImageRep:
  void cacheDisplayInRect(
    objc.CGRect rect, {
    required NSBitmapImageRep toBitmapImageRep,
  }) {
    objc.checkOsVersionInternal(
      'NSView.cacheDisplayInRect:toBitmapImageRep:',
      iOS: (true, null),
    );
    _objc_msgSend_f227js(
      object$.ref.pointer,
      _sel_cacheDisplayInRect_toBitmapImageRep_,
      rect,
      toBitmapImageRep.ref.pointer,
    );
  }

  /// canDraw
  bool get canDraw {
    objc.checkOsVersionInternal(
      'NSView.canDraw',
      iOS: (true, null),
      macOS: (false, (10, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_canDraw);
  }

  /// canDrawConcurrently
  bool get canDrawConcurrently {
    objc.checkOsVersionInternal(
      'NSView.canDrawConcurrently',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_canDrawConcurrently);
  }

  /// canDrawSubviewsIntoLayer
  bool get canDrawSubviewsIntoLayer {
    objc.checkOsVersionInternal(
      'NSView.canDrawSubviewsIntoLayer',
      iOS: (true, null),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_canDrawSubviewsIntoLayer,
    );
  }

  /// centerScanRect:
  objc.CGRect centerScanRect(objc.CGRect rect) {
    objc.checkOsVersionInternal('NSView.centerScanRect:', iOS: (true, null));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1gn1s3dStret(
            $ptr,
            object$.ref.pointer,
            _sel_centerScanRect_,
            rect,
          )
        : $ptr.ref = _objc_msgSend_1gn1s3d(
            object$.ref.pointer,
            _sel_centerScanRect_,
            rect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// clipsToBounds
  bool get clipsToBounds {
    objc.checkOsVersionInternal(
      'NSView.clipsToBounds',
      iOS: (true, null),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_clipsToBounds);
  }

  /// compositingFilter
  CIFilter? get compositingFilter {
    objc.checkOsVersionInternal(
      'NSView.compositingFilter',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_compositingFilter,
    );
    return $ret.address == 0
        ? null
        : CIFilter.fromPointer($ret, retain: true, release: true);
  }

  /// concludeDragOperation:
  void concludeDragOperation(NSDraggingInfo? sender) {
    objc.checkOsVersionInternal(
      'NSView.concludeDragOperation:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_concludeDragOperation_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSView',
        'concludeDragOperation:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_concludeDragOperation_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// contentFilters
  objc.NSArray get contentFilters {
    objc.checkOsVersionInternal(
      'NSView.contentFilters',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_contentFilters,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// convertPoint:fromView:
  objc.CGPoint convertPoint(objc.CGPoint point, {NSView? fromView}) {
    objc.checkOsVersionInternal(
      'NSView.convertPoint:fromView:',
      iOS: (true, null),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            $ptr,
            object$.ref.pointer,
            _sel_convertPoint_fromView_,
            point,
            fromView?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_3l1tu1(
            object$.ref.pointer,
            _sel_convertPoint_fromView_,
            point,
            fromView?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// convertPoint:toView:
  objc.CGPoint convertPoint$1(objc.CGPoint point, {NSView? toView}) {
    objc.checkOsVersionInternal(
      'NSView.convertPoint:toView:',
      iOS: (true, null),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            $ptr,
            object$.ref.pointer,
            _sel_convertPoint_toView_,
            point,
            toView?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_3l1tu1(
            object$.ref.pointer,
            _sel_convertPoint_toView_,
            point,
            toView?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// convertPointFromBacking:
  objc.CGPoint convertPointFromBacking(objc.CGPoint point) {
    objc.checkOsVersionInternal(
      'NSView.convertPointFromBacking:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1w4qqqrStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertPointFromBacking_,
            point,
          )
        : $ptr.ref = _objc_msgSend_1w4qqqr(
            object$.ref.pointer,
            _sel_convertPointFromBacking_,
            point,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// convertPointFromLayer:
  objc.CGPoint convertPointFromLayer(objc.CGPoint point) {
    objc.checkOsVersionInternal(
      'NSView.convertPointFromLayer:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1w4qqqrStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertPointFromLayer_,
            point,
          )
        : $ptr.ref = _objc_msgSend_1w4qqqr(
            object$.ref.pointer,
            _sel_convertPointFromLayer_,
            point,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// convertPointToBacking:
  objc.CGPoint convertPointToBacking(objc.CGPoint point) {
    objc.checkOsVersionInternal(
      'NSView.convertPointToBacking:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1w4qqqrStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertPointToBacking_,
            point,
          )
        : $ptr.ref = _objc_msgSend_1w4qqqr(
            object$.ref.pointer,
            _sel_convertPointToBacking_,
            point,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// convertPointToLayer:
  objc.CGPoint convertPointToLayer(objc.CGPoint point) {
    objc.checkOsVersionInternal(
      'NSView.convertPointToLayer:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1w4qqqrStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertPointToLayer_,
            point,
          )
        : $ptr.ref = _objc_msgSend_1w4qqqr(
            object$.ref.pointer,
            _sel_convertPointToLayer_,
            point,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// convertRect:fromView:
  objc.CGRect convertRect(objc.CGRect rect, {NSView? fromView}) {
    objc.checkOsVersionInternal(
      'NSView.convertRect:fromView:',
      iOS: (true, null),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertRect_fromView_,
            rect,
            fromView?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_2olghr(
            object$.ref.pointer,
            _sel_convertRect_fromView_,
            rect,
            fromView?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// convertRect:toView:
  objc.CGRect convertRect$1(objc.CGRect rect, {NSView? toView}) {
    objc.checkOsVersionInternal(
      'NSView.convertRect:toView:',
      iOS: (true, null),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertRect_toView_,
            rect,
            toView?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_2olghr(
            object$.ref.pointer,
            _sel_convertRect_toView_,
            rect,
            toView?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// convertRectFromBacking:
  objc.CGRect convertRectFromBacking(objc.CGRect rect) {
    objc.checkOsVersionInternal(
      'NSView.convertRectFromBacking:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1gn1s3dStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertRectFromBacking_,
            rect,
          )
        : $ptr.ref = _objc_msgSend_1gn1s3d(
            object$.ref.pointer,
            _sel_convertRectFromBacking_,
            rect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// convertRectFromLayer:
  objc.CGRect convertRectFromLayer(objc.CGRect rect) {
    objc.checkOsVersionInternal(
      'NSView.convertRectFromLayer:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1gn1s3dStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertRectFromLayer_,
            rect,
          )
        : $ptr.ref = _objc_msgSend_1gn1s3d(
            object$.ref.pointer,
            _sel_convertRectFromLayer_,
            rect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// convertRectToBacking:
  objc.CGRect convertRectToBacking(objc.CGRect rect) {
    objc.checkOsVersionInternal(
      'NSView.convertRectToBacking:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1gn1s3dStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertRectToBacking_,
            rect,
          )
        : $ptr.ref = _objc_msgSend_1gn1s3d(
            object$.ref.pointer,
            _sel_convertRectToBacking_,
            rect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// convertRectToLayer:
  objc.CGRect convertRectToLayer(objc.CGRect rect) {
    objc.checkOsVersionInternal(
      'NSView.convertRectToLayer:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1gn1s3dStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertRectToLayer_,
            rect,
          )
        : $ptr.ref = _objc_msgSend_1gn1s3d(
            object$.ref.pointer,
            _sel_convertRectToLayer_,
            rect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// convertSize:fromView:
  objc.CGSize convertSize(objc.CGSize size, {NSView? fromView}) {
    objc.checkOsVersionInternal(
      'NSView.convertSize:fromView:',
      iOS: (true, null),
    );
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_4fmiilStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertSize_fromView_,
            size,
            fromView?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_4fmiil(
            object$.ref.pointer,
            _sel_convertSize_fromView_,
            size,
            fromView?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// convertSize:toView:
  objc.CGSize convertSize$1(objc.CGSize size, {NSView? toView}) {
    objc.checkOsVersionInternal(
      'NSView.convertSize:toView:',
      iOS: (true, null),
    );
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_4fmiilStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertSize_toView_,
            size,
            toView?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_4fmiil(
            object$.ref.pointer,
            _sel_convertSize_toView_,
            size,
            toView?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// convertSizeFromBacking:
  objc.CGSize convertSizeFromBacking(objc.CGSize size) {
    objc.checkOsVersionInternal(
      'NSView.convertSizeFromBacking:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1owrp3bStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertSizeFromBacking_,
            size,
          )
        : $ptr.ref = _objc_msgSend_1owrp3b(
            object$.ref.pointer,
            _sel_convertSizeFromBacking_,
            size,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// convertSizeFromLayer:
  objc.CGSize convertSizeFromLayer(objc.CGSize size) {
    objc.checkOsVersionInternal(
      'NSView.convertSizeFromLayer:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1owrp3bStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertSizeFromLayer_,
            size,
          )
        : $ptr.ref = _objc_msgSend_1owrp3b(
            object$.ref.pointer,
            _sel_convertSizeFromLayer_,
            size,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// convertSizeToBacking:
  objc.CGSize convertSizeToBacking(objc.CGSize size) {
    objc.checkOsVersionInternal(
      'NSView.convertSizeToBacking:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1owrp3bStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertSizeToBacking_,
            size,
          )
        : $ptr.ref = _objc_msgSend_1owrp3b(
            object$.ref.pointer,
            _sel_convertSizeToBacking_,
            size,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// convertSizeToLayer:
  objc.CGSize convertSizeToLayer(objc.CGSize size) {
    objc.checkOsVersionInternal(
      'NSView.convertSizeToLayer:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1owrp3bStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertSizeToLayer_,
            size,
          )
        : $ptr.ref = _objc_msgSend_1owrp3b(
            object$.ref.pointer,
            _sel_convertSizeToLayer_,
            size,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// didAddSubview:
  void didAddSubview(NSView subview) {
    objc.checkOsVersionInternal('NSView.didAddSubview:', iOS: (true, null));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_didAddSubview_,
      subview.ref.pointer,
    );
  }

  /// didCloseMenu:withEvent:
  void didCloseMenu(NSMenu menu, {NSEvent? withEvent}) {
    objc.checkOsVersionInternal(
      'NSView.didCloseMenu:withEvent:',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_didCloseMenu_withEvent_,
      menu.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// display
  void display() {
    objc.checkOsVersionInternal('NSView.display', iOS: (true, null));
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_display);
  }

  /// displayIfNeeded
  void displayIfNeeded() {
    objc.checkOsVersionInternal('NSView.displayIfNeeded', iOS: (true, null));
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_displayIfNeeded);
  }

  /// displayIfNeededIgnoringOpacity
  void displayIfNeededIgnoringOpacity() {
    objc.checkOsVersionInternal(
      'NSView.displayIfNeededIgnoringOpacity',
      iOS: (true, null),
    );
    _objc_msgSend_1pl9qdv(
      object$.ref.pointer,
      _sel_displayIfNeededIgnoringOpacity,
    );
  }

  /// displayIfNeededInRect:
  void displayIfNeededInRect(objc.CGRect rect) {
    objc.checkOsVersionInternal(
      'NSView.displayIfNeededInRect:',
      iOS: (true, null),
    );
    _objc_msgSend_1okkq16(
      object$.ref.pointer,
      _sel_displayIfNeededInRect_,
      rect,
    );
  }

  /// displayIfNeededInRectIgnoringOpacity:
  void displayIfNeededInRectIgnoringOpacity(objc.CGRect rect) {
    objc.checkOsVersionInternal(
      'NSView.displayIfNeededInRectIgnoringOpacity:',
      iOS: (true, null),
    );
    _objc_msgSend_1okkq16(
      object$.ref.pointer,
      _sel_displayIfNeededInRectIgnoringOpacity_,
      rect,
    );
  }

  /// displayRect:
  void displayRect(objc.CGRect rect) {
    objc.checkOsVersionInternal('NSView.displayRect:', iOS: (true, null));
    _objc_msgSend_1okkq16(object$.ref.pointer, _sel_displayRect_, rect);
  }

  /// displayRectIgnoringOpacity:
  void displayRectIgnoringOpacity(objc.CGRect rect) {
    objc.checkOsVersionInternal(
      'NSView.displayRectIgnoringOpacity:',
      iOS: (true, null),
    );
    _objc_msgSend_1okkq16(
      object$.ref.pointer,
      _sel_displayRectIgnoringOpacity_,
      rect,
    );
  }

  /// displayRectIgnoringOpacity:inContext:
  void displayRectIgnoringOpacity$1(
    objc.CGRect rect, {
    required NSGraphicsContext inContext,
  }) {
    objc.checkOsVersionInternal(
      'NSView.displayRectIgnoringOpacity:inContext:',
      iOS: (true, null),
    );
    _objc_msgSend_f227js(
      object$.ref.pointer,
      _sel_displayRectIgnoringOpacity_inContext_,
      rect,
      inContext.ref.pointer,
    );
  }

  /// draggingEnded:
  void draggingEnded(NSDraggingInfo sender) {
    objc.checkOsVersionInternal('NSView.draggingEnded:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_draggingEnded_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSView',
        'draggingEnded:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_draggingEnded_,
      sender.ref.pointer,
    );
  }

  /// draggingEntered:
  int draggingEntered(NSDraggingInfo sender) {
    objc.checkOsVersionInternal('NSView.draggingEntered:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_draggingEntered_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSView',
        'draggingEntered:',
      );
    }
    return _objc_msgSend_us60nl(
      object$.ref.pointer,
      _sel_draggingEntered_,
      sender.ref.pointer,
    );
  }

  /// draggingExited:
  void draggingExited(NSDraggingInfo? sender) {
    objc.checkOsVersionInternal('NSView.draggingExited:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_draggingExited_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSView',
        'draggingExited:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_draggingExited_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// draggingUpdated:
  int draggingUpdated(NSDraggingInfo sender) {
    objc.checkOsVersionInternal('NSView.draggingUpdated:', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_draggingUpdated_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSView',
        'draggingUpdated:',
      );
    }
    return _objc_msgSend_us60nl(
      object$.ref.pointer,
      _sel_draggingUpdated_,
      sender.ref.pointer,
    );
  }

  /// drawRect:
  void drawRect(objc.CGRect dirtyRect) {
    objc.checkOsVersionInternal('NSView.drawRect:', iOS: (true, null));
    _objc_msgSend_1okkq16(object$.ref.pointer, _sel_drawRect_, dirtyRect);
  }

  /// effectiveAppearance
  NSAppearance get effectiveAppearance {
    objc.checkOsVersionInternal(
      'NSView.effectiveAppearance',
      iOS: (true, null),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_effectiveAppearance,
    );
    return NSAppearance.fromPointer($ret, retain: true, release: true);
  }

  /// enclosingScrollView
  NSScrollView? get enclosingScrollView {
    objc.checkOsVersionInternal(
      'NSView.enclosingScrollView',
      iOS: (true, null),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_enclosingScrollView,
    );
    return $ret.address == 0
        ? null
        : NSScrollView.fromPointer($ret, retain: true, release: true);
  }

  /// frame
  objc.CGRect get frame {
    objc.checkOsVersionInternal('NSView.frame', iOS: (true, null));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_frame)
        : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_frame);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// frameCenterRotation
  double get frameCenterRotation {
    objc.checkOsVersionInternal(
      'NSView.frameCenterRotation',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            object$.ref.pointer,
            _sel_frameCenterRotation,
          )
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_frameCenterRotation);
  }

  /// frameRotation
  double get frameRotation {
    objc.checkOsVersionInternal('NSView.frameRotation', iOS: (true, null));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_frameRotation)
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_frameRotation);
  }

  /// getRectsBeingDrawn:count:
  void getRectsBeingDrawn(
    ffi.Pointer<ffi.Pointer<objc.CGRect>> rects, {
    required ffi.Pointer<ffi.Long> count,
  }) {
    objc.checkOsVersionInternal(
      'NSView.getRectsBeingDrawn:count:',
      iOS: (true, null),
    );
    _objc_msgSend_1e6ypoe(
      object$.ref.pointer,
      _sel_getRectsBeingDrawn_count_,
      rects,
      count,
    );
  }

  /// getRectsExposedDuringLiveResize:count:
  void getRectsExposedDuringLiveResize(
    ffi.Pointer<objc.CGRect> exposedRects, {
    required ffi.Pointer<ffi.Long> count,
  }) {
    objc.checkOsVersionInternal(
      'NSView.getRectsExposedDuringLiveResize:count:',
      iOS: (true, null),
    );
    _objc_msgSend_145wlaw(
      object$.ref.pointer,
      _sel_getRectsExposedDuringLiveResize_count_,
      exposedRects,
      count,
    );
  }

  /// hitTest:
  NSView? hitTest(objc.CGPoint point) {
    objc.checkOsVersionInternal('NSView.hitTest:', iOS: (true, null));
    final $ret = _objc_msgSend_wgkxx2(
      object$.ref.pointer,
      _sel_hitTest_,
      point,
    );
    return $ret.address == 0
        ? null
        : NSView.fromPointer($ret, retain: true, release: true);
  }

  /// identifier
  objc.NSString? get identifier {
    objc.checkOsVersionInternal('NSView.identifier', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_identifier);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// inLiveResize
  bool get inLiveResize {
    objc.checkOsVersionInternal('NSView.inLiveResize', iOS: (true, null));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_inLiveResize);
  }

  /// init
  NSView init() {
    objc.checkOsVersionInternal(
      'NSView.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSView.fromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSView? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSView.fromPointer($ret, retain: false, release: true);
  }

  /// initWithFrame:
  NSView initWithFrame(objc.CGRect frameRect) {
    objc.checkOsVersionInternal('NSView.initWithFrame:', iOS: (true, null));
    final $ret = _objc_msgSend_15yz4e6(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithFrame_,
      frameRect,
    );
    return NSView.fromPointer($ret, retain: false, release: true);
  }

  /// inputContext
  NSTextInputContext? get inputContext {
    objc.checkOsVersionInternal(
      'NSView.inputContext',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_inputContext);
    return $ret.address == 0
        ? null
        : NSTextInputContext.fromPointer($ret, retain: true, release: true);
  }

  /// isAccessibilityAlternateUIVisible
  bool get isAccessibilityAlternateUIVisible {
    objc.checkOsVersionInternal(
      'NSView.isAccessibilityAlternateUIVisible',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isAccessibilityAlternateUIVisible,
    );
  }

  /// isAccessibilityDisclosed
  bool get isAccessibilityDisclosed {
    objc.checkOsVersionInternal(
      'NSView.isAccessibilityDisclosed',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isAccessibilityDisclosed,
    );
  }

  /// isAccessibilityEdited
  bool get isAccessibilityEdited {
    objc.checkOsVersionInternal(
      'NSView.isAccessibilityEdited',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isAccessibilityEdited,
    );
  }

  /// isAccessibilityElement
  bool get isAccessibilityElement {
    objc.checkOsVersionInternal(
      'NSView.isAccessibilityElement',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isAccessibilityElement,
    );
  }

  /// isAccessibilityEnabled
  bool get isAccessibilityEnabled {
    objc.checkOsVersionInternal(
      'NSView.isAccessibilityEnabled',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isAccessibilityEnabled,
    );
  }

  /// isAccessibilityExpanded
  bool get isAccessibilityExpanded {
    objc.checkOsVersionInternal(
      'NSView.isAccessibilityExpanded',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isAccessibilityExpanded,
    );
  }

  /// isAccessibilityFocused
  bool get isAccessibilityFocused {
    objc.checkOsVersionInternal(
      'NSView.isAccessibilityFocused',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isAccessibilityFocused,
    );
  }

  /// isAccessibilityFrontmost
  bool get isAccessibilityFrontmost {
    objc.checkOsVersionInternal(
      'NSView.isAccessibilityFrontmost',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isAccessibilityFrontmost,
    );
  }

  /// isAccessibilityHidden
  bool get isAccessibilityHidden {
    objc.checkOsVersionInternal(
      'NSView.isAccessibilityHidden',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isAccessibilityHidden,
    );
  }

  /// isAccessibilityMain
  bool get isAccessibilityMain {
    objc.checkOsVersionInternal(
      'NSView.isAccessibilityMain',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isAccessibilityMain);
  }

  /// isAccessibilityMinimized
  bool get isAccessibilityMinimized {
    objc.checkOsVersionInternal(
      'NSView.isAccessibilityMinimized',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isAccessibilityMinimized,
    );
  }

  /// isAccessibilityModal
  bool get isAccessibilityModal {
    objc.checkOsVersionInternal(
      'NSView.isAccessibilityModal',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isAccessibilityModal);
  }

  /// isAccessibilityOrderedByRow
  bool get isAccessibilityOrderedByRow {
    objc.checkOsVersionInternal(
      'NSView.isAccessibilityOrderedByRow',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isAccessibilityOrderedByRow,
    );
  }

  /// isAccessibilityProtectedContent
  bool get isAccessibilityProtectedContent {
    objc.checkOsVersionInternal(
      'NSView.isAccessibilityProtectedContent',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isAccessibilityProtectedContent,
    );
  }

  /// isAccessibilityRequired
  bool get isAccessibilityRequired {
    objc.checkOsVersionInternal(
      'NSView.isAccessibilityRequired',
      iOS: (true, null),
      macOS: (false, (10, 12, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isAccessibilityRequired,
    );
  }

  /// isAccessibilitySelected
  bool get isAccessibilitySelected {
    objc.checkOsVersionInternal(
      'NSView.isAccessibilitySelected',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isAccessibilitySelected,
    );
  }

  /// isAccessibilitySelectorAllowed:
  bool isAccessibilitySelectorAllowed(ffi.Pointer<objc.ObjCSelector> selector) {
    objc.checkOsVersionInternal(
      'NSView.isAccessibilitySelectorAllowed:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_1srf6wk(
      object$.ref.pointer,
      _sel_isAccessibilitySelectorAllowed_,
      selector,
    );
  }

  /// isDescendantOf:
  bool isDescendantOf(NSView view) {
    objc.checkOsVersionInternal('NSView.isDescendantOf:', iOS: (true, null));
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_isDescendantOf_,
      view.ref.pointer,
    );
  }

  /// isFlipped
  bool get isFlipped {
    objc.checkOsVersionInternal('NSView.isFlipped', iOS: (true, null));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isFlipped);
  }

  /// isHidden
  bool get isHidden {
    objc.checkOsVersionInternal('NSView.isHidden', iOS: (true, null));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isHidden);
  }

  /// isHiddenOrHasHiddenAncestor
  bool get isHiddenOrHasHiddenAncestor {
    objc.checkOsVersionInternal(
      'NSView.isHiddenOrHasHiddenAncestor',
      iOS: (true, null),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isHiddenOrHasHiddenAncestor,
    );
  }

  /// isOpaque
  bool get isOpaque {
    objc.checkOsVersionInternal('NSView.isOpaque', iOS: (true, null));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isOpaque);
  }

  /// isRotatedFromBase
  bool get isRotatedFromBase {
    objc.checkOsVersionInternal('NSView.isRotatedFromBase', iOS: (true, null));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isRotatedFromBase);
  }

  /// isRotatedOrScaledFromBase
  bool get isRotatedOrScaledFromBase {
    objc.checkOsVersionInternal(
      'NSView.isRotatedOrScaledFromBase',
      iOS: (true, null),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isRotatedOrScaledFromBase,
    );
  }

  /// layer
  CALayer? get layer {
    objc.checkOsVersionInternal(
      'NSView.layer',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_layer);
    return $ret.address == 0
        ? null
        : CALayer.fromPointer($ret, retain: true, release: true);
  }

  /// layerContentsPlacement
  NSViewLayerContentsPlacement get layerContentsPlacement {
    objc.checkOsVersionInternal(
      'NSView.layerContentsPlacement',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_1eacaxd(
      object$.ref.pointer,
      _sel_layerContentsPlacement,
    );
    return NSViewLayerContentsPlacement.fromValue($ret);
  }

  /// layerContentsRedrawPolicy
  NSViewLayerContentsRedrawPolicy get layerContentsRedrawPolicy {
    objc.checkOsVersionInternal(
      'NSView.layerContentsRedrawPolicy',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_13txbxf(
      object$.ref.pointer,
      _sel_layerContentsRedrawPolicy,
    );
    return NSViewLayerContentsRedrawPolicy.fromValue($ret);
  }

  /// layerUsesCoreImageFilters
  bool get layerUsesCoreImageFilters {
    objc.checkOsVersionInternal(
      'NSView.layerUsesCoreImageFilters',
      iOS: (true, null),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_layerUsesCoreImageFilters,
    );
  }

  /// layout
  void layout() {
    objc.checkOsVersionInternal(
      'NSView.layout',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_layout);
  }

  /// layoutSubtreeIfNeeded
  void layoutSubtreeIfNeeded() {
    objc.checkOsVersionInternal(
      'NSView.layoutSubtreeIfNeeded',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_layoutSubtreeIfNeeded);
  }

  /// lockFocus
  void lockFocus() {
    objc.checkOsVersionInternal(
      'NSView.lockFocus',
      iOS: (true, null),
      macOS: (false, (10, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_lockFocus);
  }

  /// lockFocusIfCanDraw
  bool lockFocusIfCanDraw() {
    objc.checkOsVersionInternal(
      'NSView.lockFocusIfCanDraw',
      iOS: (true, null),
      macOS: (false, (10, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_lockFocusIfCanDraw);
  }

  /// lockFocusIfCanDrawInContext:
  bool lockFocusIfCanDrawInContext(NSGraphicsContext context) {
    objc.checkOsVersionInternal(
      'NSView.lockFocusIfCanDrawInContext:',
      iOS: (true, null),
      macOS: (false, (10, 4, 0)),
    );
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_lockFocusIfCanDrawInContext_,
      context.ref.pointer,
    );
  }

  /// makeBackingLayer
  CALayer makeBackingLayer() {
    objc.checkOsVersionInternal(
      'NSView.makeBackingLayer',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_makeBackingLayer,
    );
    return CALayer.fromPointer($ret, retain: true, release: true);
  }

  /// menuForEvent:
  NSMenu? menuForEvent(NSEvent event) {
    objc.checkOsVersionInternal('NSView.menuForEvent:', iOS: (true, null));
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_menuForEvent_,
      event.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSMenu.fromPointer($ret, retain: true, release: true);
  }

  /// mouse:inRect:
  bool mouse(objc.CGPoint point, {required objc.CGRect inRect}) {
    objc.checkOsVersionInternal('NSView.mouse:inRect:', iOS: (true, null));
    return _objc_msgSend_1dxtbtd(
      object$.ref.pointer,
      _sel_mouse_inRect_,
      point,
      inRect,
    );
  }

  /// mouseDownCanMoveWindow
  bool get mouseDownCanMoveWindow {
    objc.checkOsVersionInternal(
      'NSView.mouseDownCanMoveWindow',
      iOS: (true, null),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_mouseDownCanMoveWindow,
    );
  }

  /// needsDisplay
  bool get needsDisplay {
    objc.checkOsVersionInternal('NSView.needsDisplay', iOS: (true, null));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_needsDisplay);
  }

  /// needsLayout
  bool get needsLayout {
    objc.checkOsVersionInternal(
      'NSView.needsLayout',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_needsLayout);
  }

  /// needsPanelToBecomeKey
  bool get needsPanelToBecomeKey {
    objc.checkOsVersionInternal(
      'NSView.needsPanelToBecomeKey',
      iOS: (true, null),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_needsPanelToBecomeKey,
    );
  }

  /// needsToDrawRect:
  bool needsToDrawRect(objc.CGRect rect) {
    objc.checkOsVersionInternal('NSView.needsToDrawRect:', iOS: (true, null));
    return _objc_msgSend_fcioro(
      object$.ref.pointer,
      _sel_needsToDrawRect_,
      rect,
    );
  }

  /// opaqueAncestor
  NSView? get opaqueAncestor {
    objc.checkOsVersionInternal('NSView.opaqueAncestor', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_opaqueAncestor,
    );
    return $ret.address == 0
        ? null
        : NSView.fromPointer($ret, retain: true, release: true);
  }

  /// performDragOperation:
  bool performDragOperation(NSDraggingInfo sender) {
    objc.checkOsVersionInternal(
      'NSView.performDragOperation:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_performDragOperation_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSView',
        'performDragOperation:',
      );
    }
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_performDragOperation_,
      sender.ref.pointer,
    );
  }

  /// performKeyEquivalent:
  bool performKeyEquivalent(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSView.performKeyEquivalent:',
      iOS: (true, null),
    );
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_performKeyEquivalent_,
      event.ref.pointer,
    );
  }

  /// postsBoundsChangedNotifications
  bool get postsBoundsChangedNotifications {
    objc.checkOsVersionInternal(
      'NSView.postsBoundsChangedNotifications',
      iOS: (true, null),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_postsBoundsChangedNotifications,
    );
  }

  /// postsFrameChangedNotifications
  bool get postsFrameChangedNotifications {
    objc.checkOsVersionInternal(
      'NSView.postsFrameChangedNotifications',
      iOS: (true, null),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_postsFrameChangedNotifications,
    );
  }

  /// prepareContentInRect:
  void prepareContentInRect(objc.CGRect rect) {
    objc.checkOsVersionInternal(
      'NSView.prepareContentInRect:',
      iOS: (true, null),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1okkq16(
      object$.ref.pointer,
      _sel_prepareContentInRect_,
      rect,
    );
  }

  /// prepareForDragOperation:
  bool prepareForDragOperation(NSDraggingInfo sender) {
    objc.checkOsVersionInternal(
      'NSView.prepareForDragOperation:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_prepareForDragOperation_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSView',
        'prepareForDragOperation:',
      );
    }
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_prepareForDragOperation_,
      sender.ref.pointer,
    );
  }

  /// prepareForReuse
  void prepareForReuse() {
    objc.checkOsVersionInternal(
      'NSView.prepareForReuse',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_prepareForReuse);
  }

  /// preparedContentRect
  objc.CGRect get preparedContentRect {
    objc.checkOsVersionInternal(
      'NSView.preparedContentRect',
      iOS: (true, null),
      macOS: (false, (10, 9, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(
            $ptr,
            object$.ref.pointer,
            _sel_preparedContentRect,
          )
        : $ptr.ref = _objc_msgSend_bu1hbw(
            object$.ref.pointer,
            _sel_preparedContentRect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// preservesContentDuringLiveResize
  bool get preservesContentDuringLiveResize {
    objc.checkOsVersionInternal(
      'NSView.preservesContentDuringLiveResize',
      iOS: (true, null),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_preservesContentDuringLiveResize,
    );
  }

  /// rectForSmartMagnificationAtPoint:inRect:
  objc.CGRect rectForSmartMagnificationAtPoint(
    objc.CGPoint location, {
    required objc.CGRect inRect,
  }) {
    objc.checkOsVersionInternal(
      'NSView.rectForSmartMagnificationAtPoint:inRect:',
      iOS: (true, null),
      macOS: (false, (10, 8, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_mtf8w4Stret(
            $ptr,
            object$.ref.pointer,
            _sel_rectForSmartMagnificationAtPoint_inRect_,
            location,
            inRect,
          )
        : $ptr.ref = _objc_msgSend_mtf8w4(
            object$.ref.pointer,
            _sel_rectForSmartMagnificationAtPoint_inRect_,
            location,
            inRect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// rectPreservedDuringLiveResize
  objc.CGRect get rectPreservedDuringLiveResize {
    objc.checkOsVersionInternal(
      'NSView.rectPreservedDuringLiveResize',
      iOS: (true, null),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(
            $ptr,
            object$.ref.pointer,
            _sel_rectPreservedDuringLiveResize,
          )
        : $ptr.ref = _objc_msgSend_bu1hbw(
            object$.ref.pointer,
            _sel_rectPreservedDuringLiveResize,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// removeAllToolTips
  void removeAllToolTips() {
    objc.checkOsVersionInternal('NSView.removeAllToolTips', iOS: (true, null));
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_removeAllToolTips);
  }

  /// removeFromSuperview
  void removeFromSuperview() {
    objc.checkOsVersionInternal(
      'NSView.removeFromSuperview',
      iOS: (true, null),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_removeFromSuperview);
  }

  /// removeFromSuperviewWithoutNeedingDisplay
  void removeFromSuperviewWithoutNeedingDisplay() {
    objc.checkOsVersionInternal(
      'NSView.removeFromSuperviewWithoutNeedingDisplay',
      iOS: (true, null),
    );
    _objc_msgSend_1pl9qdv(
      object$.ref.pointer,
      _sel_removeFromSuperviewWithoutNeedingDisplay,
    );
  }

  /// removeToolTip:
  void removeToolTip(int tag) {
    objc.checkOsVersionInternal('NSView.removeToolTip:', iOS: (true, null));
    _objc_msgSend_4sp4xj(object$.ref.pointer, _sel_removeToolTip_, tag);
  }

  /// replaceSubview:with:
  void replaceSubview(NSView oldView, {required NSView with$}) {
    objc.checkOsVersionInternal(
      'NSView.replaceSubview:with:',
      iOS: (true, null),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_replaceSubview_with_,
      oldView.ref.pointer,
      with$.ref.pointer,
    );
  }

  /// resizeSubviewsWithOldSize:
  void resizeSubviewsWithOldSize(objc.CGSize oldSize) {
    objc.checkOsVersionInternal(
      'NSView.resizeSubviewsWithOldSize:',
      iOS: (true, null),
    );
    _objc_msgSend_13lgpwz(
      object$.ref.pointer,
      _sel_resizeSubviewsWithOldSize_,
      oldSize,
    );
  }

  /// resizeWithOldSuperviewSize:
  void resizeWithOldSuperviewSize(objc.CGSize oldSize) {
    objc.checkOsVersionInternal(
      'NSView.resizeWithOldSuperviewSize:',
      iOS: (true, null),
    );
    _objc_msgSend_13lgpwz(
      object$.ref.pointer,
      _sel_resizeWithOldSuperviewSize_,
      oldSize,
    );
  }

  /// rotateByAngle:
  void rotateByAngle(double angle) {
    objc.checkOsVersionInternal('NSView.rotateByAngle:', iOS: (true, null));
    _objc_msgSend_hwm8nu(object$.ref.pointer, _sel_rotateByAngle_, angle);
  }

  /// scaleUnitSquareToSize:
  void scaleUnitSquareToSize(objc.CGSize newUnitSize) {
    objc.checkOsVersionInternal(
      'NSView.scaleUnitSquareToSize:',
      iOS: (true, null),
    );
    _objc_msgSend_13lgpwz(
      object$.ref.pointer,
      _sel_scaleUnitSquareToSize_,
      newUnitSize,
    );
  }

  /// scrollPoint:
  void scrollPoint(objc.CGPoint point) {
    objc.checkOsVersionInternal('NSView.scrollPoint:', iOS: (true, null));
    _objc_msgSend_iy8iz6(object$.ref.pointer, _sel_scrollPoint_, point);
  }

  /// scrollRect:by:
  void scrollRect(objc.CGRect rect, {required objc.CGSize by}) {
    objc.checkOsVersionInternal(
      'NSView.scrollRect:by:',
      iOS: (true, null),
      macOS: (false, (10, 0, 0)),
    );
    _objc_msgSend_7turk2(object$.ref.pointer, _sel_scrollRect_by_, rect, by);
  }

  /// scrollRectToVisible:
  bool scrollRectToVisible(objc.CGRect rect) {
    objc.checkOsVersionInternal(
      'NSView.scrollRectToVisible:',
      iOS: (true, null),
    );
    return _objc_msgSend_fcioro(
      object$.ref.pointer,
      _sel_scrollRectToVisible_,
      rect,
    );
  }

  /// setAcceptsTouchEvents:
  set acceptsTouchEvents(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setAcceptsTouchEvents:',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAcceptsTouchEvents_,
      value,
    );
  }

  /// setAccessibilityActivationPoint:
  set accessibilityActivationPoint(objc.CGPoint value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityActivationPoint:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_iy8iz6(
      object$.ref.pointer,
      _sel_setAccessibilityActivationPoint_,
      value,
    );
  }

  /// setAccessibilityAllowedValues:
  set accessibilityAllowedValues(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityAllowedValues:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityAllowedValues_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityAlternateUIVisible:
  set isAccessibilityAlternateUIVisible(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityAlternateUIVisible:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAccessibilityAlternateUIVisible_,
      value,
    );
  }

  /// setAccessibilityApplicationFocusedUIElement:
  set accessibilityApplicationFocusedUIElement(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityApplicationFocusedUIElement:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityApplicationFocusedUIElement_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityAttributedUserInputLabels:
  set accessibilityAttributedUserInputLabels(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityAttributedUserInputLabels:',
      iOS: (true, null),
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityAttributedUserInputLabels_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityCancelButton:
  set accessibilityCancelButton(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityCancelButton:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityCancelButton_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityChildren:
  set accessibilityChildren(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityChildren:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityChildren_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityChildrenInNavigationOrder:
  set accessibilityChildrenInNavigationOrder(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityChildrenInNavigationOrder:',
      iOS: (true, null),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityChildrenInNavigationOrder_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityClearButton:
  set accessibilityClearButton(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityClearButton:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityClearButton_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityCloseButton:
  set accessibilityCloseButton(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityCloseButton:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityCloseButton_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityColumnCount:
  set accessibilityColumnCount(int value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityColumnCount:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_4sp4xj(
      object$.ref.pointer,
      _sel_setAccessibilityColumnCount_,
      value,
    );
  }

  /// setAccessibilityColumnHeaderUIElements:
  set accessibilityColumnHeaderUIElements(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityColumnHeaderUIElements:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityColumnHeaderUIElements_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityColumnIndexRange:
  set accessibilityColumnIndexRange(objc.NSRange value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityColumnIndexRange:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1e3pm0z(
      object$.ref.pointer,
      _sel_setAccessibilityColumnIndexRange_,
      value,
    );
  }

  /// setAccessibilityColumnTitles:
  set accessibilityColumnTitles(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityColumnTitles:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityColumnTitles_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityColumns:
  set accessibilityColumns(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityColumns:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityColumns_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityContents:
  set accessibilityContents(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityContents:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityContents_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityCriticalValue:
  set accessibilityCriticalValue(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityCriticalValue:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityCriticalValue_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityCustomActions:
  set accessibilityCustomActions(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityCustomActions:',
      iOS: (true, null),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityCustomActions_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityCustomRotors:
  set accessibilityCustomRotors(objc.NSArray value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityCustomRotors:',
      iOS: (true, null),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityCustomRotors_,
      value.ref.pointer,
    );
  }

  /// setAccessibilityDecrementButton:
  set accessibilityDecrementButton(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityDecrementButton:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityDecrementButton_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityDefaultButton:
  set accessibilityDefaultButton(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityDefaultButton:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityDefaultButton_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityDisclosed:
  set isAccessibilityDisclosed(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityDisclosed:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAccessibilityDisclosed_,
      value,
    );
  }

  /// setAccessibilityDisclosedByRow:
  set accessibilityDisclosedByRow(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityDisclosedByRow:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityDisclosedByRow_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityDisclosedRows:
  set accessibilityDisclosedRows(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityDisclosedRows:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityDisclosedRows_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityDisclosureLevel:
  set accessibilityDisclosureLevel(int value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityDisclosureLevel:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_4sp4xj(
      object$.ref.pointer,
      _sel_setAccessibilityDisclosureLevel_,
      value,
    );
  }

  /// setAccessibilityDocument:
  set accessibilityDocument(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityDocument:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityDocument_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityEdited:
  set isAccessibilityEdited(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityEdited:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAccessibilityEdited_,
      value,
    );
  }

  /// setAccessibilityElement:
  set isAccessibilityElement(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityElement:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAccessibilityElement_,
      value,
    );
  }

  /// setAccessibilityEnabled:
  set isAccessibilityEnabled(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityEnabled:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAccessibilityEnabled_,
      value,
    );
  }

  /// setAccessibilityExpanded:
  set isAccessibilityExpanded(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityExpanded:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAccessibilityExpanded_,
      value,
    );
  }

  /// setAccessibilityExtrasMenuBar:
  set accessibilityExtrasMenuBar(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityExtrasMenuBar:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityExtrasMenuBar_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityFilename:
  set accessibilityFilename(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityFilename:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityFilename_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityFocused:
  set isAccessibilityFocused(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityFocused:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAccessibilityFocused_,
      value,
    );
  }

  /// setAccessibilityFocusedWindow:
  set accessibilityFocusedWindow(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityFocusedWindow:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityFocusedWindow_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityFrame:
  set accessibilityFrame(objc.CGRect value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityFrame:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1okkq16(
      object$.ref.pointer,
      _sel_setAccessibilityFrame_,
      value,
    );
  }

  /// setAccessibilityFrontmost:
  set isAccessibilityFrontmost(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityFrontmost:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAccessibilityFrontmost_,
      value,
    );
  }

  /// setAccessibilityFullScreenButton:
  set accessibilityFullScreenButton(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityFullScreenButton:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityFullScreenButton_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityGrowArea:
  set accessibilityGrowArea(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityGrowArea:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityGrowArea_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityHandles:
  set accessibilityHandles(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityHandles:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityHandles_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityHeader:
  set accessibilityHeader(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityHeader:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityHeader_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityHelp:
  set accessibilityHelp(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityHelp:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityHelp_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityHidden:
  set isAccessibilityHidden(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityHidden:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAccessibilityHidden_,
      value,
    );
  }

  /// setAccessibilityHorizontalScrollBar:
  set accessibilityHorizontalScrollBar(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityHorizontalScrollBar:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityHorizontalScrollBar_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityHorizontalUnitDescription:
  set accessibilityHorizontalUnitDescription(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityHorizontalUnitDescription:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityHorizontalUnitDescription_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityHorizontalUnits:
  set accessibilityHorizontalUnits(NSAccessibilityUnits value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityHorizontalUnits:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_kr9ig9(
      object$.ref.pointer,
      _sel_setAccessibilityHorizontalUnits_,
      value.value,
    );
  }

  /// setAccessibilityIdentifier:
  set accessibilityIdentifier(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityIdentifier:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityIdentifier_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityIncrementButton:
  set accessibilityIncrementButton(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityIncrementButton:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityIncrementButton_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityIndex:
  set accessibilityIndex(int value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityIndex:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_4sp4xj(
      object$.ref.pointer,
      _sel_setAccessibilityIndex_,
      value,
    );
  }

  /// setAccessibilityInsertionPointLineNumber:
  set accessibilityInsertionPointLineNumber(int value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityInsertionPointLineNumber:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_4sp4xj(
      object$.ref.pointer,
      _sel_setAccessibilityInsertionPointLineNumber_,
      value,
    );
  }

  /// setAccessibilityLabel:
  set accessibilityLabel(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityLabel:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityLabel_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityLabelUIElements:
  set accessibilityLabelUIElements(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityLabelUIElements:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityLabelUIElements_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityLabelValue:
  set accessibilityLabelValue(double value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityLabelValue:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_v5hmet(
      object$.ref.pointer,
      _sel_setAccessibilityLabelValue_,
      value,
    );
  }

  /// setAccessibilityLinkedUIElements:
  set accessibilityLinkedUIElements(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityLinkedUIElements:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityLinkedUIElements_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityMain:
  set isAccessibilityMain(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityMain:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAccessibilityMain_,
      value,
    );
  }

  /// setAccessibilityMainWindow:
  set accessibilityMainWindow(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityMainWindow:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityMainWindow_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityMarkerGroupUIElement:
  set accessibilityMarkerGroupUIElement(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityMarkerGroupUIElement:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityMarkerGroupUIElement_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityMarkerTypeDescription:
  set accessibilityMarkerTypeDescription(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityMarkerTypeDescription:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityMarkerTypeDescription_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityMarkerUIElements:
  set accessibilityMarkerUIElements(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityMarkerUIElements:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityMarkerUIElements_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityMarkerValues:
  set accessibilityMarkerValues(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityMarkerValues:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityMarkerValues_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityMaxValue:
  set accessibilityMaxValue(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityMaxValue:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityMaxValue_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityMenuBar:
  set accessibilityMenuBar(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityMenuBar:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityMenuBar_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityMinValue:
  set accessibilityMinValue(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityMinValue:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityMinValue_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityMinimizeButton:
  set accessibilityMinimizeButton(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityMinimizeButton:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityMinimizeButton_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityMinimized:
  set isAccessibilityMinimized(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityMinimized:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAccessibilityMinimized_,
      value,
    );
  }

  /// setAccessibilityModal:
  set isAccessibilityModal(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityModal:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAccessibilityModal_,
      value,
    );
  }

  /// setAccessibilityNextContents:
  set accessibilityNextContents(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityNextContents:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityNextContents_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityNumberOfCharacters:
  set accessibilityNumberOfCharacters(int value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityNumberOfCharacters:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_4sp4xj(
      object$.ref.pointer,
      _sel_setAccessibilityNumberOfCharacters_,
      value,
    );
  }

  /// setAccessibilityOrderedByRow:
  set isAccessibilityOrderedByRow(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityOrderedByRow:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAccessibilityOrderedByRow_,
      value,
    );
  }

  /// setAccessibilityOrientation:
  set accessibilityOrientation(NSAccessibilityOrientation value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityOrientation:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1jcoroy(
      object$.ref.pointer,
      _sel_setAccessibilityOrientation_,
      value.value,
    );
  }

  /// setAccessibilityOverflowButton:
  set accessibilityOverflowButton(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityOverflowButton:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityOverflowButton_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityParent:
  set accessibilityParent(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityParent:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityParent_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityPlaceholderValue:
  set accessibilityPlaceholderValue(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityPlaceholderValue:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityPlaceholderValue_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityPreviousContents:
  set accessibilityPreviousContents(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityPreviousContents:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityPreviousContents_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityProtectedContent:
  set isAccessibilityProtectedContent(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityProtectedContent:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAccessibilityProtectedContent_,
      value,
    );
  }

  /// setAccessibilityProxy:
  set accessibilityProxy(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityProxy:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityProxy_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityRequired:
  set isAccessibilityRequired(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityRequired:',
      iOS: (true, null),
      macOS: (false, (10, 12, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAccessibilityRequired_,
      value,
    );
  }

  /// setAccessibilityRole:
  set accessibilityRole(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityRole:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityRole_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityRoleDescription:
  set accessibilityRoleDescription(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityRoleDescription:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityRoleDescription_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityRowCount:
  set accessibilityRowCount(int value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityRowCount:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_4sp4xj(
      object$.ref.pointer,
      _sel_setAccessibilityRowCount_,
      value,
    );
  }

  /// setAccessibilityRowHeaderUIElements:
  set accessibilityRowHeaderUIElements(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityRowHeaderUIElements:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityRowHeaderUIElements_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityRowIndexRange:
  set accessibilityRowIndexRange(objc.NSRange value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityRowIndexRange:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1e3pm0z(
      object$.ref.pointer,
      _sel_setAccessibilityRowIndexRange_,
      value,
    );
  }

  /// setAccessibilityRows:
  set accessibilityRows(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityRows:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityRows_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityRulerMarkerType:
  set accessibilityRulerMarkerType(NSAccessibilityRulerMarkerType value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityRulerMarkerType:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1y0966(
      object$.ref.pointer,
      _sel_setAccessibilityRulerMarkerType_,
      value.value,
    );
  }

  /// setAccessibilitySearchButton:
  set accessibilitySearchButton(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilitySearchButton:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilitySearchButton_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilitySearchMenu:
  set accessibilitySearchMenu(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilitySearchMenu:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilitySearchMenu_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilitySelected:
  set isAccessibilitySelected(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilitySelected:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAccessibilitySelected_,
      value,
    );
  }

  /// setAccessibilitySelectedCells:
  set accessibilitySelectedCells(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilitySelectedCells:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilitySelectedCells_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilitySelectedChildren:
  set accessibilitySelectedChildren(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilitySelectedChildren:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilitySelectedChildren_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilitySelectedColumns:
  set accessibilitySelectedColumns(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilitySelectedColumns:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilitySelectedColumns_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilitySelectedRows:
  set accessibilitySelectedRows(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilitySelectedRows:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilitySelectedRows_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilitySelectedText:
  set accessibilitySelectedText(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilitySelectedText:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilitySelectedText_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilitySelectedTextRange:
  set accessibilitySelectedTextRange(objc.NSRange value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilitySelectedTextRange:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1e3pm0z(
      object$.ref.pointer,
      _sel_setAccessibilitySelectedTextRange_,
      value,
    );
  }

  /// setAccessibilitySelectedTextRanges:
  set accessibilitySelectedTextRanges(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilitySelectedTextRanges:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilitySelectedTextRanges_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityServesAsTitleForUIElements:
  set accessibilityServesAsTitleForUIElements(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityServesAsTitleForUIElements:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityServesAsTitleForUIElements_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilitySharedCharacterRange:
  set accessibilitySharedCharacterRange(objc.NSRange value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilitySharedCharacterRange:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1e3pm0z(
      object$.ref.pointer,
      _sel_setAccessibilitySharedCharacterRange_,
      value,
    );
  }

  /// setAccessibilitySharedFocusElements:
  set accessibilitySharedFocusElements(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilitySharedFocusElements:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilitySharedFocusElements_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilitySharedTextUIElements:
  set accessibilitySharedTextUIElements(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilitySharedTextUIElements:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilitySharedTextUIElements_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityShownMenu:
  set accessibilityShownMenu(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityShownMenu:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityShownMenu_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilitySortDirection:
  set accessibilitySortDirection(NSAccessibilitySortDirection value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilitySortDirection:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_5reanf(
      object$.ref.pointer,
      _sel_setAccessibilitySortDirection_,
      value.value,
    );
  }

  /// setAccessibilitySplitters:
  set accessibilitySplitters(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilitySplitters:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilitySplitters_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilitySubrole:
  set accessibilitySubrole(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilitySubrole:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilitySubrole_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityTabs:
  set accessibilityTabs(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityTabs:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityTabs_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityTitle:
  set accessibilityTitle(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityTitle:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityTitle_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityTitleUIElement:
  set accessibilityTitleUIElement(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityTitleUIElement:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityTitleUIElement_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityToolbarButton:
  set accessibilityToolbarButton(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityToolbarButton:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityToolbarButton_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityTopLevelUIElement:
  set accessibilityTopLevelUIElement(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityTopLevelUIElement:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityTopLevelUIElement_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityURL:
  set accessibilityURL(objc.NSURL? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityURL:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityURL_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityUnitDescription:
  set accessibilityUnitDescription(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityUnitDescription:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityUnitDescription_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityUnits:
  set accessibilityUnits(NSAccessibilityUnits value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityUnits:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_kr9ig9(
      object$.ref.pointer,
      _sel_setAccessibilityUnits_,
      value.value,
    );
  }

  /// setAccessibilityUserInputLabels:
  set accessibilityUserInputLabels(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityUserInputLabels:',
      iOS: (true, null),
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityUserInputLabels_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityValue:
  set accessibilityValue(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityValue:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityValue_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityValueDescription:
  set accessibilityValueDescription(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityValueDescription:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityValueDescription_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityVerticalScrollBar:
  set accessibilityVerticalScrollBar(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityVerticalScrollBar:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityVerticalScrollBar_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityVerticalUnitDescription:
  set accessibilityVerticalUnitDescription(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityVerticalUnitDescription:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityVerticalUnitDescription_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityVerticalUnits:
  set accessibilityVerticalUnits(NSAccessibilityUnits value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityVerticalUnits:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_kr9ig9(
      object$.ref.pointer,
      _sel_setAccessibilityVerticalUnits_,
      value.value,
    );
  }

  /// setAccessibilityVisibleCells:
  set accessibilityVisibleCells(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityVisibleCells:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityVisibleCells_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityVisibleCharacterRange:
  set accessibilityVisibleCharacterRange(objc.NSRange value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityVisibleCharacterRange:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1e3pm0z(
      object$.ref.pointer,
      _sel_setAccessibilityVisibleCharacterRange_,
      value,
    );
  }

  /// setAccessibilityVisibleChildren:
  set accessibilityVisibleChildren(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityVisibleChildren:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityVisibleChildren_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityVisibleColumns:
  set accessibilityVisibleColumns(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityVisibleColumns:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityVisibleColumns_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityVisibleRows:
  set accessibilityVisibleRows(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityVisibleRows:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityVisibleRows_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityWarningValue:
  set accessibilityWarningValue(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityWarningValue:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityWarningValue_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityWindow:
  set accessibilityWindow(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityWindow:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityWindow_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityWindows:
  set accessibilityWindows(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityWindows:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityWindows_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAccessibilityZoomButton:
  set accessibilityZoomButton(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'NSView.setAccessibilityZoomButton:',
      iOS: (true, null),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityZoomButton_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAlphaValue:
  set alphaValue(double value) {
    objc.checkOsVersionInternal(
      'NSView.setAlphaValue:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setAlphaValue_, value);
  }

  /// setAnimations:
  set animations(objc.NSDictionary value) {
    objc.checkOsVersionInternal(
      'NSView.setAnimations:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAnimations_,
      value.ref.pointer,
    );
  }

  /// setAppearance:
  set appearance(NSAppearance? value) {
    objc.checkOsVersionInternal(
      'NSView.setAppearance:',
      iOS: (true, null),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAppearance_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAutoresizesSubviews:
  set autoresizesSubviews(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setAutoresizesSubviews:',
      iOS: (true, null),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAutoresizesSubviews_,
      value,
    );
  }

  /// setAutoresizingMask:
  set autoresizingMask(int value) {
    objc.checkOsVersionInternal(
      'NSView.setAutoresizingMask:',
      iOS: (true, null),
    );
    _objc_msgSend_1scx73y(
      object$.ref.pointer,
      _sel_setAutoresizingMask_,
      value,
    );
  }

  /// setBackgroundFilters:
  set backgroundFilters(objc.NSArray value) {
    objc.checkOsVersionInternal(
      'NSView.setBackgroundFilters:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setBackgroundFilters_,
      value.ref.pointer,
    );
  }

  /// setBounds:
  set bounds(objc.CGRect value) {
    objc.checkOsVersionInternal('NSView.setBounds:', iOS: (true, null));
    _objc_msgSend_1okkq16(object$.ref.pointer, _sel_setBounds_, value);
  }

  /// setBoundsOrigin:
  void setBoundsOrigin(objc.CGPoint newOrigin) {
    objc.checkOsVersionInternal('NSView.setBoundsOrigin:', iOS: (true, null));
    _objc_msgSend_iy8iz6(object$.ref.pointer, _sel_setBoundsOrigin_, newOrigin);
  }

  /// setBoundsRotation:
  set boundsRotation(double value) {
    objc.checkOsVersionInternal('NSView.setBoundsRotation:', iOS: (true, null));
    _objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setBoundsRotation_, value);
  }

  /// setBoundsSize:
  void setBoundsSize(objc.CGSize newSize) {
    objc.checkOsVersionInternal('NSView.setBoundsSize:', iOS: (true, null));
    _objc_msgSend_13lgpwz(object$.ref.pointer, _sel_setBoundsSize_, newSize);
  }

  /// setCanDrawConcurrently:
  set canDrawConcurrently(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setCanDrawConcurrently:',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setCanDrawConcurrently_,
      value,
    );
  }

  /// setCanDrawSubviewsIntoLayer:
  set canDrawSubviewsIntoLayer(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setCanDrawSubviewsIntoLayer:',
      iOS: (true, null),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setCanDrawSubviewsIntoLayer_,
      value,
    );
  }

  /// setClipsToBounds:
  set clipsToBounds(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setClipsToBounds:',
      iOS: (true, null),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setClipsToBounds_, value);
  }

  /// setCompositingFilter:
  set compositingFilter(CIFilter? value) {
    objc.checkOsVersionInternal(
      'NSView.setCompositingFilter:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setCompositingFilter_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setContentFilters:
  set contentFilters(objc.NSArray value) {
    objc.checkOsVersionInternal(
      'NSView.setContentFilters:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setContentFilters_,
      value.ref.pointer,
    );
  }

  /// setFrame:
  set frame(objc.CGRect value) {
    objc.checkOsVersionInternal('NSView.setFrame:', iOS: (true, null));
    _objc_msgSend_1okkq16(object$.ref.pointer, _sel_setFrame_, value);
  }

  /// setFrameCenterRotation:
  set frameCenterRotation(double value) {
    objc.checkOsVersionInternal(
      'NSView.setFrameCenterRotation:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_hwm8nu(
      object$.ref.pointer,
      _sel_setFrameCenterRotation_,
      value,
    );
  }

  /// setFrameOrigin:
  void setFrameOrigin(objc.CGPoint newOrigin) {
    objc.checkOsVersionInternal('NSView.setFrameOrigin:', iOS: (true, null));
    _objc_msgSend_iy8iz6(object$.ref.pointer, _sel_setFrameOrigin_, newOrigin);
  }

  /// setFrameRotation:
  set frameRotation(double value) {
    objc.checkOsVersionInternal('NSView.setFrameRotation:', iOS: (true, null));
    _objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setFrameRotation_, value);
  }

  /// setFrameSize:
  void setFrameSize(objc.CGSize newSize) {
    objc.checkOsVersionInternal('NSView.setFrameSize:', iOS: (true, null));
    _objc_msgSend_13lgpwz(object$.ref.pointer, _sel_setFrameSize_, newSize);
  }

  /// setHidden:
  set isHidden(bool value) {
    objc.checkOsVersionInternal('NSView.setHidden:', iOS: (true, null));
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setHidden_, value);
  }

  /// setIdentifier:
  set identifier(objc.NSString? value) {
    objc.checkOsVersionInternal('NSView.setIdentifier:', iOS: (true, null));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setIdentifier_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setLayer:
  set layer(CALayer? value) {
    objc.checkOsVersionInternal(
      'NSView.setLayer:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setLayer_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setLayerContentsPlacement:
  set layerContentsPlacement(NSViewLayerContentsPlacement value) {
    objc.checkOsVersionInternal(
      'NSView.setLayerContentsPlacement:',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_3dohm9(
      object$.ref.pointer,
      _sel_setLayerContentsPlacement_,
      value.value,
    );
  }

  /// setLayerContentsRedrawPolicy:
  set layerContentsRedrawPolicy(NSViewLayerContentsRedrawPolicy value) {
    objc.checkOsVersionInternal(
      'NSView.setLayerContentsRedrawPolicy:',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_1skjrc7(
      object$.ref.pointer,
      _sel_setLayerContentsRedrawPolicy_,
      value.value,
    );
  }

  /// setLayerUsesCoreImageFilters:
  set layerUsesCoreImageFilters(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setLayerUsesCoreImageFilters:',
      iOS: (true, null),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setLayerUsesCoreImageFilters_,
      value,
    );
  }

  /// setNeedsDisplay:
  set needsDisplay(bool value) {
    objc.checkOsVersionInternal('NSView.setNeedsDisplay:', iOS: (true, null));
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setNeedsDisplay_, value);
  }

  /// setNeedsDisplayInRect:
  void setNeedsDisplayInRect(objc.CGRect invalidRect) {
    objc.checkOsVersionInternal(
      'NSView.setNeedsDisplayInRect:',
      iOS: (true, null),
    );
    _objc_msgSend_1okkq16(
      object$.ref.pointer,
      _sel_setNeedsDisplayInRect_,
      invalidRect,
    );
  }

  /// setNeedsLayout:
  set needsLayout(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setNeedsLayout:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setNeedsLayout_, value);
  }

  /// setPostsBoundsChangedNotifications:
  set postsBoundsChangedNotifications(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setPostsBoundsChangedNotifications:',
      iOS: (true, null),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setPostsBoundsChangedNotifications_,
      value,
    );
  }

  /// setPostsFrameChangedNotifications:
  set postsFrameChangedNotifications(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setPostsFrameChangedNotifications:',
      iOS: (true, null),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setPostsFrameChangedNotifications_,
      value,
    );
  }

  /// setPreparedContentRect:
  set preparedContentRect(objc.CGRect value) {
    objc.checkOsVersionInternal(
      'NSView.setPreparedContentRect:',
      iOS: (true, null),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1okkq16(
      object$.ref.pointer,
      _sel_setPreparedContentRect_,
      value,
    );
  }

  /// setShadow:
  set shadow(NSShadow? value) {
    objc.checkOsVersionInternal(
      'NSView.setShadow:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setShadow_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setSubviews:
  set subviews(objc.NSArray value) {
    objc.checkOsVersionInternal('NSView.setSubviews:', iOS: (true, null));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setSubviews_,
      value.ref.pointer,
    );
  }

  /// setToolTip:
  set toolTip(objc.NSString? value) {
    objc.checkOsVersionInternal('NSView.setToolTip:', iOS: (true, null));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setToolTip_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setUserInterfaceLayoutDirection:
  set userInterfaceLayoutDirection(NSUserInterfaceLayoutDirection value) {
    objc.checkOsVersionInternal(
      'NSView.setUserInterfaceLayoutDirection:',
      iOS: (true, null),
      macOS: (false, (10, 8, 0)),
    );
    _objc_msgSend_9se2j(
      object$.ref.pointer,
      _sel_setUserInterfaceLayoutDirection_,
      value.value,
    );
  }

  /// setWantsLayer:
  set wantsLayer(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setWantsLayer:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setWantsLayer_, value);
  }

  /// setWantsRestingTouches:
  set wantsRestingTouches(bool value) {
    objc.checkOsVersionInternal(
      'NSView.setWantsRestingTouches:',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setWantsRestingTouches_,
      value,
    );
  }

  /// shadow
  NSShadow? get shadow {
    objc.checkOsVersionInternal(
      'NSView.shadow',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_shadow);
    return $ret.address == 0
        ? null
        : NSShadow.fromPointer($ret, retain: true, release: true);
  }

  /// shouldDelayWindowOrderingForEvent:
  bool shouldDelayWindowOrderingForEvent(NSEvent event) {
    objc.checkOsVersionInternal(
      'NSView.shouldDelayWindowOrderingForEvent:',
      iOS: (true, null),
    );
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_shouldDelayWindowOrderingForEvent_,
      event.ref.pointer,
    );
  }

  /// sortSubviewsUsingFunction:context:
  void sortSubviewsUsingFunction(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<ffi.Void>,
        )
      >
    >
    compare, {
    required ffi.Pointer<ffi.Void> context,
  }) {
    objc.checkOsVersionInternal(
      'NSView.sortSubviewsUsingFunction:context:',
      iOS: (true, null),
    );
    _objc_msgSend_11nb6m0(
      object$.ref.pointer,
      _sel_sortSubviewsUsingFunction_context_,
      compare,
      context,
    );
  }

  /// subviews
  objc.NSArray get subviews {
    objc.checkOsVersionInternal('NSView.subviews', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_subviews);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// superview
  NSView? get superview {
    objc.checkOsVersionInternal('NSView.superview', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_superview);
    return $ret.address == 0
        ? null
        : NSView.fromPointer($ret, retain: true, release: true);
  }

  /// tag
  int get tag {
    objc.checkOsVersionInternal('NSView.tag', iOS: (true, null));
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_tag);
  }

  /// toolTip
  objc.NSString? get toolTip {
    objc.checkOsVersionInternal('NSView.toolTip', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_toolTip);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// translateOriginToPoint:
  void translateOriginToPoint(objc.CGPoint translation) {
    objc.checkOsVersionInternal(
      'NSView.translateOriginToPoint:',
      iOS: (true, null),
    );
    _objc_msgSend_iy8iz6(
      object$.ref.pointer,
      _sel_translateOriginToPoint_,
      translation,
    );
  }

  /// translateRectsNeedingDisplayInRect:by:
  void translateRectsNeedingDisplayInRect(
    objc.CGRect clipRect, {
    required objc.CGSize by,
  }) {
    objc.checkOsVersionInternal(
      'NSView.translateRectsNeedingDisplayInRect:by:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_7turk2(
      object$.ref.pointer,
      _sel_translateRectsNeedingDisplayInRect_by_,
      clipRect,
      by,
    );
  }

  /// unlockFocus
  void unlockFocus() {
    objc.checkOsVersionInternal(
      'NSView.unlockFocus',
      iOS: (true, null),
      macOS: (false, (10, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_unlockFocus);
  }

  /// updateDraggingItemsForDrag:
  void updateDraggingItemsForDrag(NSDraggingInfo? sender) {
    objc.checkOsVersionInternal(
      'NSView.updateDraggingItemsForDrag:',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_updateDraggingItemsForDrag_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSView',
        'updateDraggingItemsForDrag:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_updateDraggingItemsForDrag_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// updateLayer
  void updateLayer() {
    objc.checkOsVersionInternal(
      'NSView.updateLayer',
      iOS: (true, null),
      macOS: (false, (10, 8, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_updateLayer);
  }

  /// userInterfaceLayoutDirection
  NSUserInterfaceLayoutDirection get userInterfaceLayoutDirection {
    objc.checkOsVersionInternal(
      'NSView.userInterfaceLayoutDirection',
      iOS: (true, null),
      macOS: (false, (10, 8, 0)),
    );
    final $ret = _objc_msgSend_1spww5v(
      object$.ref.pointer,
      _sel_userInterfaceLayoutDirection,
    );
    return NSUserInterfaceLayoutDirection.fromValue($ret);
  }

  /// viewDidChangeBackingProperties
  void viewDidChangeBackingProperties() {
    objc.checkOsVersionInternal(
      'NSView.viewDidChangeBackingProperties',
      iOS: (true, null),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1pl9qdv(
      object$.ref.pointer,
      _sel_viewDidChangeBackingProperties,
    );
  }

  /// viewDidChangeEffectiveAppearance
  void viewDidChangeEffectiveAppearance() {
    objc.checkOsVersionInternal(
      'NSView.viewDidChangeEffectiveAppearance',
      iOS: (true, null),
      macOS: (false, (10, 14, 0)),
    );
    _objc_msgSend_1pl9qdv(
      object$.ref.pointer,
      _sel_viewDidChangeEffectiveAppearance,
    );
  }

  /// viewDidEndLiveResize
  void viewDidEndLiveResize() {
    objc.checkOsVersionInternal(
      'NSView.viewDidEndLiveResize',
      iOS: (true, null),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_viewDidEndLiveResize);
  }

  /// viewDidHide
  void viewDidHide() {
    objc.checkOsVersionInternal(
      'NSView.viewDidHide',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_viewDidHide);
  }

  /// viewDidMoveToSuperview
  void viewDidMoveToSuperview() {
    objc.checkOsVersionInternal(
      'NSView.viewDidMoveToSuperview',
      iOS: (true, null),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_viewDidMoveToSuperview);
  }

  /// viewDidMoveToWindow
  void viewDidMoveToWindow() {
    objc.checkOsVersionInternal(
      'NSView.viewDidMoveToWindow',
      iOS: (true, null),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_viewDidMoveToWindow);
  }

  /// viewDidUnhide
  void viewDidUnhide() {
    objc.checkOsVersionInternal(
      'NSView.viewDidUnhide',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_viewDidUnhide);
  }

  /// viewWillDraw
  void viewWillDraw() {
    objc.checkOsVersionInternal(
      'NSView.viewWillDraw',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_viewWillDraw);
  }

  /// viewWillMoveToSuperview:
  void viewWillMoveToSuperview(NSView? newSuperview) {
    objc.checkOsVersionInternal(
      'NSView.viewWillMoveToSuperview:',
      iOS: (true, null),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_viewWillMoveToSuperview_,
      newSuperview?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// viewWillMoveToWindow:
  void viewWillMoveToWindow(NSWindow? newWindow) {
    objc.checkOsVersionInternal(
      'NSView.viewWillMoveToWindow:',
      iOS: (true, null),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_viewWillMoveToWindow_,
      newWindow?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// viewWillStartLiveResize
  void viewWillStartLiveResize() {
    objc.checkOsVersionInternal(
      'NSView.viewWillStartLiveResize',
      iOS: (true, null),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_viewWillStartLiveResize);
  }

  /// viewWithTag:
  NSView? viewWithTag(int tag) {
    objc.checkOsVersionInternal('NSView.viewWithTag:', iOS: (true, null));
    final $ret = _objc_msgSend_qugqlf(
      object$.ref.pointer,
      _sel_viewWithTag_,
      tag,
    );
    return $ret.address == 0
        ? null
        : NSView.fromPointer($ret, retain: true, release: true);
  }

  /// visibleRect
  objc.CGRect get visibleRect {
    objc.checkOsVersionInternal('NSView.visibleRect', iOS: (true, null));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_visibleRect)
        : $ptr.ref = _objc_msgSend_bu1hbw(
            object$.ref.pointer,
            _sel_visibleRect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// wantsDefaultClipping
  bool get wantsDefaultClipping {
    objc.checkOsVersionInternal(
      'NSView.wantsDefaultClipping',
      iOS: (true, null),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_wantsDefaultClipping);
  }

  /// wantsLayer
  bool get wantsLayer {
    objc.checkOsVersionInternal(
      'NSView.wantsLayer',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_wantsLayer);
  }

  /// wantsPeriodicDraggingUpdates
  bool wantsPeriodicDraggingUpdates() {
    objc.checkOsVersionInternal(
      'NSView.wantsPeriodicDraggingUpdates',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_wantsPeriodicDraggingUpdates,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSView',
        'wantsPeriodicDraggingUpdates',
      );
    }
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_wantsPeriodicDraggingUpdates,
    );
  }

  /// wantsRestingTouches
  bool get wantsRestingTouches {
    objc.checkOsVersionInternal(
      'NSView.wantsRestingTouches',
      iOS: (true, null),
      macOS: (false, (10, 6, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_wantsRestingTouches);
  }

  /// wantsUpdateLayer
  bool get wantsUpdateLayer {
    objc.checkOsVersionInternal(
      'NSView.wantsUpdateLayer',
      iOS: (true, null),
      macOS: (false, (10, 8, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_wantsUpdateLayer);
  }

  /// willOpenMenu:withEvent:
  void willOpenMenu(NSMenu menu, {required NSEvent withEvent}) {
    objc.checkOsVersionInternal(
      'NSView.willOpenMenu:withEvent:',
      iOS: (true, null),
      macOS: (false, (10, 11, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_willOpenMenu_withEvent_,
      menu.ref.pointer,
      withEvent.ref.pointer,
    );
  }

  /// willRemoveSubview:
  void willRemoveSubview(NSView subview) {
    objc.checkOsVersionInternal('NSView.willRemoveSubview:', iOS: (true, null));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_willRemoveSubview_,
      subview.ref.pointer,
    );
  }

  /// window
  NSWindow? get window {
    objc.checkOsVersionInternal('NSView.window', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_window);
    return $ret.address == 0
        ? null
        : NSWindow.fromPointer($ret, retain: true, release: true);
  }
}

enum NSWritingDirection {
  NSWritingDirectionNatural(-1),
  NSWritingDirectionLeftToRight(0),
  NSWritingDirectionRightToLeft(1);

  final int value;
  const NSWritingDirection(this.value);

  static NSWritingDirection fromValue(int value) => switch (value) {
    -1 => NSWritingDirectionNatural,
    0 => NSWritingDirectionLeftToRight,
    1 => NSWritingDirectionRightToLeft,
    _ => throw ArgumentError('Unknown value for NSWritingDirection: $value'),
  };
}

enum NSTextAlignment {
  NSTextAlignmentLeft(0),
  NSTextAlignmentCenter(1),
  NSTextAlignmentRight(2),
  NSTextAlignmentJustified(3),
  NSTextAlignmentNatural(4);

  final int value;
  const NSTextAlignment(this.value);

  static NSTextAlignment fromValue(int value) => switch (value) {
    0 => NSTextAlignmentLeft,
    1 => NSTextAlignmentCenter,
    2 => NSTextAlignmentRight,
    3 => NSTextAlignmentJustified,
    4 => NSTextAlignmentNatural,
    _ => throw ArgumentError('Unknown value for NSTextAlignment: $value'),
  };
}

enum NSLineBreakMode {
  NSLineBreakByWordWrapping(0),
  NSLineBreakByCharWrapping(1),
  NSLineBreakByClipping(2),
  NSLineBreakByTruncatingHead(3),
  NSLineBreakByTruncatingTail(4),
  NSLineBreakByTruncatingMiddle(5);

  final int value;
  const NSLineBreakMode(this.value);

  static NSLineBreakMode fromValue(int value) => switch (value) {
    0 => NSLineBreakByWordWrapping,
    1 => NSLineBreakByCharWrapping,
    2 => NSLineBreakByClipping,
    3 => NSLineBreakByTruncatingHead,
    4 => NSLineBreakByTruncatingTail,
    5 => NSLineBreakByTruncatingMiddle,
    _ => throw ArgumentError('Unknown value for NSLineBreakMode: $value'),
  };
}

sealed class NSLineBreakStrategy {
  static const NSLineBreakStrategyNone = 0;
  static const NSLineBreakStrategyPushOut = 1;
  static const NSLineBreakStrategyHangulWordPriority = 2;
  static const NSLineBreakStrategyStandard = 65535;
}

enum NSTextTabType {
  NSLeftTabStopType(0),
  NSRightTabStopType(1),
  NSCenterTabStopType(2),
  NSDecimalTabStopType(3);

  final int value;
  const NSTextTabType(this.value);

  static NSTextTabType fromValue(int value) => switch (value) {
    0 => NSLeftTabStopType,
    1 => NSRightTabStopType,
    2 => NSCenterTabStopType,
    3 => NSDecimalTabStopType,
    _ => throw ArgumentError('Unknown value for NSTextTabType: $value'),
  };
}

enum NSCellType {
  NSNullCellType(0),
  NSTextCellType(1),
  NSImageCellType(2);

  final int value;
  const NSCellType(this.value);

  static NSCellType fromValue(int value) => switch (value) {
    0 => NSNullCellType,
    1 => NSTextCellType,
    2 => NSImageCellType,
    _ => throw ArgumentError('Unknown value for NSCellType: $value'),
  };
}

enum NSCellAttribute {
  NSCellDisabled(0),
  NSCellState(1),
  NSPushInCell(2),
  NSCellEditable(3),
  NSChangeGrayCell(4),
  NSCellHighlighted(5),
  NSCellLightsByContents(6),
  NSCellLightsByGray(7),
  NSChangeBackgroundCell(8),
  NSCellLightsByBackground(9),
  NSCellIsBordered(10),
  NSCellHasOverlappingImage(11),
  NSCellHasImageHorizontal(12),
  NSCellHasImageOnLeftOrBottom(13),
  NSCellChangesContents(14),
  NSCellIsInsetButton(15),
  NSCellAllowsMixedState(16);

  final int value;
  const NSCellAttribute(this.value);

  static NSCellAttribute fromValue(int value) => switch (value) {
    0 => NSCellDisabled,
    1 => NSCellState,
    2 => NSPushInCell,
    3 => NSCellEditable,
    4 => NSChangeGrayCell,
    5 => NSCellHighlighted,
    6 => NSCellLightsByContents,
    7 => NSCellLightsByGray,
    8 => NSChangeBackgroundCell,
    9 => NSCellLightsByBackground,
    10 => NSCellIsBordered,
    11 => NSCellHasOverlappingImage,
    12 => NSCellHasImageHorizontal,
    13 => NSCellHasImageOnLeftOrBottom,
    14 => NSCellChangesContents,
    15 => NSCellIsInsetButton,
    16 => NSCellAllowsMixedState,
    _ => throw ArgumentError('Unknown value for NSCellAttribute: $value'),
  };
}

enum NSCellImagePosition {
  NSNoImage(0),
  NSImageOnly(1),
  NSImageLeft(2),
  NSImageRight(3),
  NSImageBelow(4),
  NSImageAbove(5),
  NSImageOverlaps(6),
  NSImageLeading(7),
  NSImageTrailing(8);

  final int value;
  const NSCellImagePosition(this.value);

  static NSCellImagePosition fromValue(int value) => switch (value) {
    0 => NSNoImage,
    1 => NSImageOnly,
    2 => NSImageLeft,
    3 => NSImageRight,
    4 => NSImageBelow,
    5 => NSImageAbove,
    6 => NSImageOverlaps,
    7 => NSImageLeading,
    8 => NSImageTrailing,
    _ => throw ArgumentError('Unknown value for NSCellImagePosition: $value'),
  };
}

enum NSImageScaling {
  NSImageScaleProportionallyDown(0),
  NSImageScaleAxesIndependently(1),
  NSImageScaleNone(2),
  NSImageScaleProportionallyUpOrDown(3);

  static const NSScaleProportionally = NSImageScaleProportionallyDown;
  static const NSScaleToFit = NSImageScaleAxesIndependently;
  static const NSScaleNone = NSImageScaleNone;

  final int value;
  const NSImageScaling(this.value);

  static NSImageScaling fromValue(int value) => switch (value) {
    0 => NSImageScaleProportionallyDown,
    1 => NSImageScaleAxesIndependently,
    2 => NSImageScaleNone,
    3 => NSImageScaleProportionallyUpOrDown,
    _ => throw ArgumentError('Unknown value for NSImageScaling: $value'),
  };

  @override
  String toString() {
    if (this == NSImageScaleProportionallyDown)
      return "NSImageScaling.NSImageScaleProportionallyDown, NSImageScaling.NSScaleProportionally";
    if (this == NSImageScaleAxesIndependently)
      return "NSImageScaling.NSImageScaleAxesIndependently, NSImageScaling.NSScaleToFit";
    if (this == NSImageScaleNone)
      return "NSImageScaling.NSImageScaleNone, NSImageScaling.NSScaleNone";
    return super.toString();
  }
}

sealed class NSCellStyleMask {
  static const NSNoCellMask = 0;
  static const NSContentsCellMask = 1;
  static const NSPushInCellMask = 2;
  static const NSChangeGrayCellMask = 4;
  static const NSChangeBackgroundCellMask = 8;
}

enum NSControlTint {
  NSDefaultControlTint(0),
  NSBlueControlTint(1),
  NSGraphiteControlTint(6),
  NSClearControlTint(7);

  final int value;
  const NSControlTint(this.value);

  static NSControlTint fromValue(int value) => switch (value) {
    0 => NSDefaultControlTint,
    1 => NSBlueControlTint,
    6 => NSGraphiteControlTint,
    7 => NSClearControlTint,
    _ => throw ArgumentError('Unknown value for NSControlTint: $value'),
  };
}

enum NSControlSize {
  NSControlSizeRegular(0),
  NSControlSizeSmall(1),
  NSControlSizeMini(2),
  NSControlSizeLarge(3),
  NSControlSizeExtraLarge(4);

  final int value;
  const NSControlSize(this.value);

  static NSControlSize fromValue(int value) => switch (value) {
    0 => NSControlSizeRegular,
    1 => NSControlSizeSmall,
    2 => NSControlSizeMini,
    3 => NSControlSizeLarge,
    4 => NSControlSizeExtraLarge,
    _ => throw ArgumentError('Unknown value for NSControlSize: $value'),
  };
}

sealed class NSCellHitResult {
  static const NSCellHitNone = 0;
  static const NSCellHitContentArea = 1;
  static const NSCellHitEditableTextArea = 2;
  static const NSCellHitTrackableArea = 4;
}

enum NSBackgroundStyle {
  NSBackgroundStyleNormal(0),
  NSBackgroundStyleEmphasized(1),
  NSBackgroundStyleRaised(2),
  NSBackgroundStyleLowered(3);

  final int value;
  const NSBackgroundStyle(this.value);

  static NSBackgroundStyle fromValue(int value) => switch (value) {
    0 => NSBackgroundStyleNormal,
    1 => NSBackgroundStyleEmphasized,
    2 => NSBackgroundStyleRaised,
    3 => NSBackgroundStyleLowered,
    _ => throw ArgumentError('Unknown value for NSBackgroundStyle: $value'),
  };
}

enum NSMenuPresentationStyle {
  NSMenuPresentationStyleRegular(0),
  NSMenuPresentationStylePalette(1);

  final int value;
  const NSMenuPresentationStyle(this.value);

  static NSMenuPresentationStyle fromValue(int value) => switch (value) {
    0 => NSMenuPresentationStyleRegular,
    1 => NSMenuPresentationStylePalette,
    _ => throw ArgumentError(
      'Unknown value for NSMenuPresentationStyle: $value',
    ),
  };
}

enum NSMenuSelectionMode {
  NSMenuSelectionModeAutomatic(0),
  NSMenuSelectionModeSelectOne(1),
  NSMenuSelectionModeSelectAny(2);

  final int value;
  const NSMenuSelectionMode(this.value);

  static NSMenuSelectionMode fromValue(int value) => switch (value) {
    0 => NSMenuSelectionModeAutomatic,
    1 => NSMenuSelectionModeSelectOne,
    2 => NSMenuSelectionModeSelectAny,
    _ => throw ArgumentError('Unknown value for NSMenuSelectionMode: $value'),
  };
}

/// WARNING: NSMenuItemValidation is a stub. To generate bindings for this class, include
/// NSMenuItemValidation in your config's objc-protocols list.
///
/// NSMenuItemValidation
extension type NSMenuItemValidation._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [NSMenuItemValidation] that points to the same underlying object as [other].
  NSMenuItemValidation.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSMenuItemValidation] that wraps the given raw object pointer.
  NSMenuItemValidation.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

sealed class NSMenuProperties {
  static const NSMenuPropertyItemTitle = 1;
  static const NSMenuPropertyItemAttributedTitle = 2;
  static const NSMenuPropertyItemKeyEquivalent = 4;
  static const NSMenuPropertyItemImage = 8;
  static const NSMenuPropertyItemEnabled = 16;
  static const NSMenuPropertyItemAccessibilityDescription = 32;
}

sealed class NSFontTraitMask {
  static const NSItalicFontMask = 1;
  static const NSBoldFontMask = 2;
  static const NSUnboldFontMask = 4;
  static const NSNonStandardCharacterSetFontMask = 8;
  static const NSNarrowFontMask = 16;
  static const NSExpandedFontMask = 32;
  static const NSCondensedFontMask = 64;
  static const NSSmallCapsFontMask = 128;
  static const NSPosterFontMask = 256;
  static const NSCompressedFontMask = 512;
  static const NSFixedPitchFontMask = 1024;
  static const NSUnitalicFontMask = 16777216;
}

/// WARNING: WKBackForwardListItem is a stub. To generate bindings for this class, include
/// WKBackForwardListItem in your config's objc-interfaces list.
///
/// WKBackForwardListItem
extension type WKBackForwardListItem._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [WKBackForwardListItem] that points to the same underlying object as [other].
  WKBackForwardListItem.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKBackForwardListItem',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }

  /// Constructs a [WKBackForwardListItem] that wraps the given raw object pointer.
  WKBackForwardListItem.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKBackForwardListItem',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }
}

/// WARNING: WKBackForwardList is a stub. To generate bindings for this class, include
/// WKBackForwardList in your config's objc-interfaces list.
///
/// WKBackForwardList
extension type WKBackForwardList._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [WKBackForwardList] that points to the same underlying object as [other].
  WKBackForwardList.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKBackForwardList',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }

  /// Constructs a [WKBackForwardList] that wraps the given raw object pointer.
  WKBackForwardList.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKBackForwardList',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }
}

/// WARNING: WKContentWorld is a stub. To generate bindings for this class, include
/// WKContentWorld in your config's objc-interfaces list.
///
/// WKContentWorld
extension type WKContentWorld._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [WKContentWorld] that points to the same underlying object as [other].
  WKContentWorld.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKContentWorld',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
  }

  /// Constructs a [WKContentWorld] that wraps the given raw object pointer.
  WKContentWorld.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKContentWorld',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
  }
}

/// WARNING: WKDownload is a stub. To generate bindings for this class, include
/// WKDownload in your config's objc-interfaces list.
///
/// WKDownload
extension type WKDownload._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, NSProgressReporting {
  /// Constructs a [WKDownload] that points to the same underlying object as [other].
  WKDownload.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKDownload',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
  }

  /// Constructs a [WKDownload] that wraps the given raw object pointer.
  WKDownload.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKDownload',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
  }
}

enum WKDownloadRedirectPolicy {
  WKDownloadRedirectPolicyCancel(0),
  WKDownloadRedirectPolicyAllow(1);

  final int value;
  const WKDownloadRedirectPolicy(this.value);

  static WKDownloadRedirectPolicy fromValue(int value) => switch (value) {
    0 => WKDownloadRedirectPolicyCancel,
    1 => WKDownloadRedirectPolicyAllow,
    _ => throw ArgumentError(
      'Unknown value for WKDownloadRedirectPolicy: $value',
    ),
  };
}

enum WKDownloadPlaceholderPolicy {
  WKDownloadPlaceholderPolicyDisable(0),
  WKDownloadPlaceholderPolicyEnable(1);

  final int value;
  const WKDownloadPlaceholderPolicy(this.value);

  static WKDownloadPlaceholderPolicy fromValue(int value) => switch (value) {
    0 => WKDownloadPlaceholderPolicyDisable,
    1 => WKDownloadPlaceholderPolicyEnable,
    _ => throw ArgumentError(
      'Unknown value for WKDownloadPlaceholderPolicy: $value',
    ),
  };
}

/// WARNING: WKFindConfiguration is a stub. To generate bindings for this class, include
/// WKFindConfiguration in your config's objc-interfaces list.
///
/// WKFindConfiguration
extension type WKFindConfiguration._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [WKFindConfiguration] that points to the same underlying object as [other].
  WKFindConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKFindConfiguration',
      iOS: (false, (13, 4, 0)),
      macOS: (false, (10, 15, 4)),
    );
  }

  /// Constructs a [WKFindConfiguration] that wraps the given raw object pointer.
  WKFindConfiguration.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKFindConfiguration',
      iOS: (false, (13, 4, 0)),
      macOS: (false, (10, 15, 4)),
    );
  }
}

/// WARNING: WKFindResult is a stub. To generate bindings for this class, include
/// WKFindResult in your config's objc-interfaces list.
///
/// WKFindResult
extension type WKFindResult._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [WKFindResult] that points to the same underlying object as [other].
  WKFindResult.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKFindResult',
      iOS: (false, (13, 4, 0)),
      macOS: (false, (10, 15, 4)),
    );
  }

  /// Constructs a [WKFindResult] that wraps the given raw object pointer.
  WKFindResult.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKFindResult',
      iOS: (false, (13, 4, 0)),
      macOS: (false, (10, 15, 4)),
    );
  }
}

enum NSImageInterpolation {
  NSImageInterpolationDefault(0),
  NSImageInterpolationNone(1),
  NSImageInterpolationLow(2),
  NSImageInterpolationMedium(4),
  NSImageInterpolationHigh(3);

  final int value;
  const NSImageInterpolation(this.value);

  static NSImageInterpolation fromValue(int value) => switch (value) {
    0 => NSImageInterpolationDefault,
    1 => NSImageInterpolationNone,
    2 => NSImageInterpolationLow,
    4 => NSImageInterpolationMedium,
    3 => NSImageInterpolationHigh,
    _ => throw ArgumentError('Unknown value for NSImageInterpolation: $value'),
  };
}

enum NSPrinterTableStatus {
  NSPrinterTableOK(0),
  NSPrinterTableNotFound(1),
  NSPrinterTableError(2);

  final int value;
  const NSPrinterTableStatus(this.value);

  static NSPrinterTableStatus fromValue(int value) => switch (value) {
    0 => NSPrinterTableOK,
    1 => NSPrinterTableNotFound,
    2 => NSPrinterTableError,
    _ => throw ArgumentError('Unknown value for NSPrinterTableStatus: $value'),
  };
}

enum NSPaperOrientation {
  NSPaperOrientationPortrait(0),
  NSPaperOrientationLandscape(1);

  final int value;
  const NSPaperOrientation(this.value);

  static NSPaperOrientation fromValue(int value) => switch (value) {
    0 => NSPaperOrientationPortrait,
    1 => NSPaperOrientationLandscape,
    _ => throw ArgumentError('Unknown value for NSPaperOrientation: $value'),
  };
}

enum NSPrintingPaginationMode {
  NSPrintingPaginationModeAutomatic(0),
  NSPrintingPaginationModeFit(1),
  NSPrintingPaginationModeClip(2);

  final int value;
  const NSPrintingPaginationMode(this.value);

  static NSPrintingPaginationMode fromValue(int value) => switch (value) {
    0 => NSPrintingPaginationModeAutomatic,
    1 => NSPrintingPaginationModeFit,
    2 => NSPrintingPaginationModeClip,
    _ => throw ArgumentError(
      'Unknown value for NSPrintingPaginationMode: $value',
    ),
  };
}

/// WARNING: NSPrintInfo is a stub. To generate bindings for this class, include
/// NSPrintInfo in your config's objc-interfaces list.
///
/// NSPrintInfo
extension type NSPrintInfo._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying, objc.NSCoding {
  /// Constructs a [NSPrintInfo] that points to the same underlying object as [other].
  NSPrintInfo.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSPrintInfo', iOS: (true, null));
  }

  /// Constructs a [NSPrintInfo] that wraps the given raw object pointer.
  NSPrintInfo.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSPrintInfo', iOS: (true, null));
  }
}

sealed class NSApplicationPresentationOptions {
  static const NSApplicationPresentationDefault = 0;
  static const NSApplicationPresentationAutoHideDock = 1;
  static const NSApplicationPresentationHideDock = 2;
  static const NSApplicationPresentationAutoHideMenuBar = 4;
  static const NSApplicationPresentationHideMenuBar = 8;
  static const NSApplicationPresentationDisableAppleMenu = 16;
  static const NSApplicationPresentationDisableProcessSwitching = 32;
  static const NSApplicationPresentationDisableForceQuit = 64;
  static const NSApplicationPresentationDisableSessionTermination = 128;
  static const NSApplicationPresentationDisableHideApplication = 256;
  static const NSApplicationPresentationDisableMenuBarTransparency = 512;
  static const NSApplicationPresentationFullScreen = 1024;
  static const NSApplicationPresentationAutoHideToolbar = 2048;
  static const NSApplicationPresentationDisableCursorLocationAssistance = 4096;
}

enum NSColorType {
  NSColorTypeComponentBased(0),
  NSColorTypePattern(1),
  NSColorTypeCatalog(2);

  final int value;
  const NSColorType(this.value);

  static NSColorType fromValue(int value) => switch (value) {
    0 => NSColorTypeComponentBased,
    1 => NSColorTypePattern,
    2 => NSColorTypeCatalog,
    _ => throw ArgumentError('Unknown value for NSColorType: $value'),
  };
}

enum NSColorSystemEffect {
  NSColorSystemEffectNone(0),
  NSColorSystemEffectPressed(1),
  NSColorSystemEffectDeepPressed(2),
  NSColorSystemEffectDisabled(3),
  NSColorSystemEffectRollover(4);

  final int value;
  const NSColorSystemEffect(this.value);

  static NSColorSystemEffect fromValue(int value) => switch (value) {
    0 => NSColorSystemEffectNone,
    1 => NSColorSystemEffectPressed,
    2 => NSColorSystemEffectDeepPressed,
    3 => NSColorSystemEffectDisabled,
    4 => NSColorSystemEffectRollover,
    _ => throw ArgumentError('Unknown value for NSColorSystemEffect: $value'),
  };
}

/// WARNING: NSColor is a stub. To generate bindings for this class, include
/// NSColor in your config's objc-interfaces list.
///
/// NSColor
extension type NSColor._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSCopying,
        objc.NSSecureCoding,
        NSPasteboardReading,
        NSPasteboardWriting {
  /// Constructs a [NSColor] that points to the same underlying object as [other].
  NSColor.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSColor', iOS: (true, null));
  }

  /// Constructs a [NSColor] that wraps the given raw object pointer.
  NSColor.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSColor', iOS: (true, null));
  }
}

enum NSControlBorderShape {
  NSControlBorderShapeAutomatic(0),
  NSControlBorderShapeCapsule(1),
  NSControlBorderShapeRoundedRectangle(2),
  NSControlBorderShapeCircle(3);

  final int value;
  const NSControlBorderShape(this.value);

  static NSControlBorderShape fromValue(int value) => switch (value) {
    0 => NSControlBorderShapeAutomatic,
    1 => NSControlBorderShapeCapsule,
    2 => NSControlBorderShapeRoundedRectangle,
    3 => NSControlBorderShapeCircle,
    _ => throw ArgumentError('Unknown value for NSControlBorderShape: $value'),
  };
}

enum NSButtonType {
  NSButtonTypeMomentaryLight(0),
  NSButtonTypePushOnPushOff(1),
  NSButtonTypeToggle(2),
  NSButtonTypeSwitch(3),
  NSButtonTypeRadio(4),
  NSButtonTypeMomentaryChange(5),
  NSButtonTypeOnOff(6),
  NSButtonTypeMomentaryPushIn(7),
  NSButtonTypeAccelerator(8),
  NSButtonTypeMultiLevelAccelerator(9);

  final int value;
  const NSButtonType(this.value);

  static NSButtonType fromValue(int value) => switch (value) {
    0 => NSButtonTypeMomentaryLight,
    1 => NSButtonTypePushOnPushOff,
    2 => NSButtonTypeToggle,
    3 => NSButtonTypeSwitch,
    4 => NSButtonTypeRadio,
    5 => NSButtonTypeMomentaryChange,
    6 => NSButtonTypeOnOff,
    7 => NSButtonTypeMomentaryPushIn,
    8 => NSButtonTypeAccelerator,
    9 => NSButtonTypeMultiLevelAccelerator,
    _ => throw ArgumentError('Unknown value for NSButtonType: $value'),
  };
}

enum NSBezelStyle {
  NSBezelStyleAutomatic(0),
  NSBezelStylePush(1),
  NSBezelStyleFlexiblePush(2),
  NSBezelStyleDisclosure(5),
  NSBezelStyleCircular(7),
  NSBezelStyleHelpButton(9),
  NSBezelStyleSmallSquare(10),
  NSBezelStyleToolbar(11),
  NSBezelStyleAccessoryBarAction(12),
  NSBezelStyleAccessoryBar(13),
  NSBezelStylePushDisclosure(14),
  NSBezelStyleBadge(15),
  NSBezelStyleGlass(16),
  NSBezelStyleShadowlessSquare(6),
  NSBezelStyleTexturedSquare(8);

  static const NSBezelStyleRounded = NSBezelStylePush;
  static const NSBezelStyleRegularSquare = NSBezelStyleFlexiblePush;
  static const NSBezelStyleTexturedRounded = NSBezelStyleToolbar;
  static const NSBezelStyleRoundRect = NSBezelStyleAccessoryBarAction;
  static const NSBezelStyleRecessed = NSBezelStyleAccessoryBar;
  static const NSBezelStyleRoundedDisclosure = NSBezelStylePushDisclosure;
  static const NSBezelStyleInline = NSBezelStyleBadge;

  final int value;
  const NSBezelStyle(this.value);

  static NSBezelStyle fromValue(int value) => switch (value) {
    0 => NSBezelStyleAutomatic,
    1 => NSBezelStylePush,
    2 => NSBezelStyleFlexiblePush,
    5 => NSBezelStyleDisclosure,
    7 => NSBezelStyleCircular,
    9 => NSBezelStyleHelpButton,
    10 => NSBezelStyleSmallSquare,
    11 => NSBezelStyleToolbar,
    12 => NSBezelStyleAccessoryBarAction,
    13 => NSBezelStyleAccessoryBar,
    14 => NSBezelStylePushDisclosure,
    15 => NSBezelStyleBadge,
    16 => NSBezelStyleGlass,
    6 => NSBezelStyleShadowlessSquare,
    8 => NSBezelStyleTexturedSquare,
    _ => throw ArgumentError('Unknown value for NSBezelStyle: $value'),
  };

  @override
  String toString() {
    if (this == NSBezelStylePush)
      return "NSBezelStyle.NSBezelStylePush, NSBezelStyle.NSBezelStyleRounded";
    if (this == NSBezelStyleFlexiblePush)
      return "NSBezelStyle.NSBezelStyleFlexiblePush, NSBezelStyle.NSBezelStyleRegularSquare";
    if (this == NSBezelStyleToolbar)
      return "NSBezelStyle.NSBezelStyleToolbar, NSBezelStyle.NSBezelStyleTexturedRounded";
    if (this == NSBezelStyleAccessoryBarAction)
      return "NSBezelStyle.NSBezelStyleAccessoryBarAction, NSBezelStyle.NSBezelStyleRoundRect";
    if (this == NSBezelStyleAccessoryBar)
      return "NSBezelStyle.NSBezelStyleAccessoryBar, NSBezelStyle.NSBezelStyleRecessed";
    if (this == NSBezelStylePushDisclosure)
      return "NSBezelStyle.NSBezelStylePushDisclosure, NSBezelStyle.NSBezelStyleRoundedDisclosure";
    if (this == NSBezelStyleBadge)
      return "NSBezelStyle.NSBezelStyleBadge, NSBezelStyle.NSBezelStyleInline";
    return super.toString();
  }
}

enum NSGradientType {
  NSGradientNone(0),
  NSGradientConcaveWeak(1),
  NSGradientConcaveStrong(2),
  NSGradientConvexWeak(3),
  NSGradientConvexStrong(4);

  final int value;
  const NSGradientType(this.value);

  static NSGradientType fromValue(int value) => switch (value) {
    0 => NSGradientNone,
    1 => NSGradientConcaveWeak,
    2 => NSGradientConcaveStrong,
    3 => NSGradientConvexWeak,
    4 => NSGradientConvexStrong,
    _ => throw ArgumentError('Unknown value for NSGradientType: $value'),
  };
}

enum NSTintProminence {
  NSTintProminenceAutomatic(0),
  NSTintProminenceNone(1),
  NSTintProminencePrimary(2),
  NSTintProminenceSecondary(3);

  final int value;
  const NSTintProminence(this.value);

  static NSTintProminence fromValue(int value) => switch (value) {
    0 => NSTintProminenceAutomatic,
    1 => NSTintProminenceNone,
    2 => NSTintProminencePrimary,
    3 => NSTintProminenceSecondary,
    _ => throw ArgumentError('Unknown value for NSTintProminence: $value'),
  };
}

/// WARNING: NSTouchBarItem is a stub. To generate bindings for this class, include
/// NSTouchBarItem in your config's objc-interfaces list.
///
/// NSTouchBarItem
extension type NSTouchBarItem._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCoding {
  /// Constructs a [NSTouchBarItem] that points to the same underlying object as [other].
  NSTouchBarItem.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSTouchBarItem',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 12, 2)),
    );
  }

  /// Constructs a [NSTouchBarItem] that wraps the given raw object pointer.
  NSTouchBarItem.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSTouchBarItem',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 12, 2)),
    );
  }
}

enum NSPopoverBehavior {
  NSPopoverBehaviorApplicationDefined(0),
  NSPopoverBehaviorTransient(1),
  NSPopoverBehaviorSemitransient(2);

  final int value;
  const NSPopoverBehavior(this.value);

  static NSPopoverBehavior fromValue(int value) => switch (value) {
    0 => NSPopoverBehaviorApplicationDefined,
    1 => NSPopoverBehaviorTransient,
    2 => NSPopoverBehaviorSemitransient,
    _ => throw ArgumentError('Unknown value for NSPopoverBehavior: $value'),
  };
}

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(objc.NSCoder)>`.
abstract final class ObjCBlock_objcObjCObjectImpl_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(objc.NSCoder)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(objc.NSCoder)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(objc.NSCoder)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(objc.NSCoder)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(objc.NSCoder)
  >
  fromFunction(
    objc.ObjCObject? Function(objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(objc.NSCoder)>(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
              fn(
                objc.NSCoder.fromPointer(arg0, retain: true, release: true),
              )?.ref.retainAndAutorelease() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(objc.NSCoder)>`.
extension ObjCBlock_objcObjCObjectImpl_NSCoder$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObjectImpl>? Function(objc.NSCoder)
        > {
  objc.ObjCObject? call(objc.NSCoder arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<objc.ObjCObjectImpl> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0.ref.pointer)
              .address ==
          0
      ? null
      : objc.ObjCObject(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<objc.ObjCObjectImpl> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0.ref.pointer),
          retain: true,
          release: true,
        );
}

sealed class NSViewControllerTransitionOptions {
  static const NSViewControllerTransitionNone = 0;
  static const NSViewControllerTransitionCrossfade = 1;
  static const NSViewControllerTransitionSlideUp = 16;
  static const NSViewControllerTransitionSlideDown = 32;
  static const NSViewControllerTransitionSlideLeft = 64;
  static const NSViewControllerTransitionSlideRight = 128;
  static const NSViewControllerTransitionSlideForward = 320;
  static const NSViewControllerTransitionSlideBackward = 384;
  static const NSViewControllerTransitionAllowUserInteraction = 4096;
}

sealed class NSHorizontalDirections {
  static const NSHorizontalDirectionsLeft = 1;
  static const NSHorizontalDirectionsRight = 2;
  static const NSHorizontalDirectionsAll = 3;
}

sealed class NSVerticalDirections {
  static const NSVerticalDirectionsUp = 1;
  static const NSVerticalDirectionsDown = 2;
  static const NSVerticalDirectionsAll = 3;
}

sealed class NSFontDescriptorSymbolicTraits {
  static const NSFontDescriptorTraitItalic = 1;
  static const NSFontDescriptorTraitBold = 2;
  static const NSFontDescriptorTraitExpanded = 32;
  static const NSFontDescriptorTraitCondensed = 64;
  static const NSFontDescriptorTraitMonoSpace = 1024;
  static const NSFontDescriptorTraitVertical = 2048;
  static const NSFontDescriptorTraitUIOptimized = 4096;
  static const NSFontDescriptorTraitTightLeading = 32768;
  static const NSFontDescriptorTraitLooseLeading = 65536;
  static const NSFontDescriptorTraitEmphasized = 2;
  static const NSFontDescriptorClassMask = -268435456;
  static const NSFontDescriptorClassUnknown = 0;
  static const NSFontDescriptorClassOldStyleSerifs = 268435456;
  static const NSFontDescriptorClassTransitionalSerifs = 536870912;
  static const NSFontDescriptorClassModernSerifs = 805306368;
  static const NSFontDescriptorClassClarendonSerifs = 1073741824;
  static const NSFontDescriptorClassSlabSerifs = 1342177280;
  static const NSFontDescriptorClassFreeformSerifs = 1879048192;
  static const NSFontDescriptorClassSansSerif = -2147483648;
  static const NSFontDescriptorClassOrnamentals = -1879048192;
  static const NSFontDescriptorClassScripts = -1610612736;
  static const NSFontDescriptorClassSymbolic = -1073741824;
}

enum NSFontRenderingMode {
  NSFontDefaultRenderingMode(0),
  NSFontAntialiasedRenderingMode(1),
  NSFontIntegerAdvancementsRenderingMode(2),
  NSFontAntialiasedIntegerAdvancementsRenderingMode(3);

  final int value;
  const NSFontRenderingMode(this.value);

  static NSFontRenderingMode fromValue(int value) => switch (value) {
    0 => NSFontDefaultRenderingMode,
    1 => NSFontAntialiasedRenderingMode,
    2 => NSFontIntegerAdvancementsRenderingMode,
    3 => NSFontAntialiasedIntegerAdvancementsRenderingMode,
    _ => throw ArgumentError('Unknown value for NSFontRenderingMode: $value'),
  };
}

sealed class NSWindowStyleMask {
  static const NSWindowStyleMaskBorderless = 0;
  static const NSWindowStyleMaskTitled = 1;
  static const NSWindowStyleMaskClosable = 2;
  static const NSWindowStyleMaskMiniaturizable = 4;
  static const NSWindowStyleMaskResizable = 8;
  static const NSWindowStyleMaskTexturedBackground = 256;
  static const NSWindowStyleMaskUnifiedTitleAndToolbar = 4096;
  static const NSWindowStyleMaskFullScreen = 16384;
  static const NSWindowStyleMaskFullSizeContentView = 32768;
  static const NSWindowStyleMaskUtilityWindow = 16;
  static const NSWindowStyleMaskDocModalWindow = 64;
  static const NSWindowStyleMaskNonactivatingPanel = 128;
  static const NSWindowStyleMaskHUDWindow = 8192;
}

enum NSWindowSharingType {
  NSWindowSharingNone(0),
  NSWindowSharingReadOnly(1);

  final int value;
  const NSWindowSharingType(this.value);

  static NSWindowSharingType fromValue(int value) => switch (value) {
    0 => NSWindowSharingNone,
    1 => NSWindowSharingReadOnly,
    _ => throw ArgumentError('Unknown value for NSWindowSharingType: $value'),
  };
}

sealed class NSWindowCollectionBehavior {
  static const NSWindowCollectionBehaviorDefault = 0;
  static const NSWindowCollectionBehaviorCanJoinAllSpaces = 1;
  static const NSWindowCollectionBehaviorMoveToActiveSpace = 2;
  static const NSWindowCollectionBehaviorManaged = 4;
  static const NSWindowCollectionBehaviorTransient = 8;
  static const NSWindowCollectionBehaviorStationary = 16;
  static const NSWindowCollectionBehaviorParticipatesInCycle = 32;
  static const NSWindowCollectionBehaviorIgnoresCycle = 64;
  static const NSWindowCollectionBehaviorFullScreenPrimary = 128;
  static const NSWindowCollectionBehaviorFullScreenAuxiliary = 256;
  static const NSWindowCollectionBehaviorFullScreenNone = 512;
  static const NSWindowCollectionBehaviorFullScreenAllowsTiling = 2048;
  static const NSWindowCollectionBehaviorFullScreenDisallowsTiling = 4096;
  static const NSWindowCollectionBehaviorPrimary = 65536;
  static const NSWindowCollectionBehaviorAuxiliary = 131072;
  static const NSWindowCollectionBehaviorCanJoinAllApplications = 262144;
}

enum NSWindowAnimationBehavior {
  NSWindowAnimationBehaviorDefault(0),
  NSWindowAnimationBehaviorNone(2),
  NSWindowAnimationBehaviorDocumentWindow(3),
  NSWindowAnimationBehaviorUtilityWindow(4),
  NSWindowAnimationBehaviorAlertPanel(5);

  final int value;
  const NSWindowAnimationBehavior(this.value);

  static NSWindowAnimationBehavior fromValue(int value) => switch (value) {
    0 => NSWindowAnimationBehaviorDefault,
    2 => NSWindowAnimationBehaviorNone,
    3 => NSWindowAnimationBehaviorDocumentWindow,
    4 => NSWindowAnimationBehaviorUtilityWindow,
    5 => NSWindowAnimationBehaviorAlertPanel,
    _ => throw ArgumentError(
      'Unknown value for NSWindowAnimationBehavior: $value',
    ),
  };
}

sealed class NSWindowNumberListOptions {
  static const NSWindowNumberListAllApplications = 1;
  static const NSWindowNumberListAllSpaces = 16;
}

sealed class NSWindowOcclusionState {
  static const NSWindowOcclusionStateVisible = 2;
}

enum NSSelectionDirection {
  NSDirectSelection(0),
  NSSelectingNext(1),
  NSSelectingPrevious(2);

  final int value;
  const NSSelectionDirection(this.value);

  static NSSelectionDirection fromValue(int value) => switch (value) {
    0 => NSDirectSelection,
    1 => NSSelectingNext,
    2 => NSSelectingPrevious,
    _ => throw ArgumentError('Unknown value for NSSelectionDirection: $value'),
  };
}

enum NSWindowButton {
  NSWindowCloseButton(0),
  NSWindowMiniaturizeButton(1),
  NSWindowZoomButton(2),
  NSWindowToolbarButton(3),
  NSWindowDocumentIconButton(4),
  NSWindowDocumentVersionsButton(6);

  final int value;
  const NSWindowButton(this.value);

  static NSWindowButton fromValue(int value) => switch (value) {
    0 => NSWindowCloseButton,
    1 => NSWindowMiniaturizeButton,
    2 => NSWindowZoomButton,
    3 => NSWindowToolbarButton,
    4 => NSWindowDocumentIconButton,
    6 => NSWindowDocumentVersionsButton,
    _ => throw ArgumentError('Unknown value for NSWindowButton: $value'),
  };
}

enum NSWindowTitleVisibility {
  NSWindowTitleVisible(0),
  NSWindowTitleHidden(1);

  final int value;
  const NSWindowTitleVisibility(this.value);

  static NSWindowTitleVisibility fromValue(int value) => switch (value) {
    0 => NSWindowTitleVisible,
    1 => NSWindowTitleHidden,
    _ => throw ArgumentError(
      'Unknown value for NSWindowTitleVisibility: $value',
    ),
  };
}

enum NSWindowToolbarStyle {
  NSWindowToolbarStyleAutomatic(0),
  NSWindowToolbarStyleExpanded(1),
  NSWindowToolbarStylePreference(2),
  NSWindowToolbarStyleUnified(3),
  NSWindowToolbarStyleUnifiedCompact(4);

  final int value;
  const NSWindowToolbarStyle(this.value);

  static NSWindowToolbarStyle fromValue(int value) => switch (value) {
    0 => NSWindowToolbarStyleAutomatic,
    1 => NSWindowToolbarStyleExpanded,
    2 => NSWindowToolbarStylePreference,
    3 => NSWindowToolbarStyleUnified,
    4 => NSWindowToolbarStyleUnifiedCompact,
    _ => throw ArgumentError('Unknown value for NSWindowToolbarStyle: $value'),
  };
}

enum NSWindowUserTabbingPreference {
  NSWindowUserTabbingPreferenceManual(0),
  NSWindowUserTabbingPreferenceAlways(1),
  NSWindowUserTabbingPreferenceInFullScreen(2);

  final int value;
  const NSWindowUserTabbingPreference(this.value);

  static NSWindowUserTabbingPreference fromValue(int value) => switch (value) {
    0 => NSWindowUserTabbingPreferenceManual,
    1 => NSWindowUserTabbingPreferenceAlways,
    2 => NSWindowUserTabbingPreferenceInFullScreen,
    _ => throw ArgumentError(
      'Unknown value for NSWindowUserTabbingPreference: $value',
    ),
  };
}

enum NSWindowTabbingMode {
  NSWindowTabbingModeAutomatic(0),
  NSWindowTabbingModePreferred(1),
  NSWindowTabbingModeDisallowed(2);

  final int value;
  const NSWindowTabbingMode(this.value);

  static NSWindowTabbingMode fromValue(int value) => switch (value) {
    0 => NSWindowTabbingModeAutomatic,
    1 => NSWindowTabbingModePreferred,
    2 => NSWindowTabbingModeDisallowed,
    _ => throw ArgumentError('Unknown value for NSWindowTabbingMode: $value'),
  };
}

enum NSTitlebarSeparatorStyle {
  NSTitlebarSeparatorStyleAutomatic(0),
  NSTitlebarSeparatorStyleNone(1),
  NSTitlebarSeparatorStyleLine(2),
  NSTitlebarSeparatorStyleShadow(3);

  final int value;
  const NSTitlebarSeparatorStyle(this.value);

  static NSTitlebarSeparatorStyle fromValue(int value) => switch (value) {
    0 => NSTitlebarSeparatorStyleAutomatic,
    1 => NSTitlebarSeparatorStyleNone,
    2 => NSTitlebarSeparatorStyleLine,
    3 => NSTitlebarSeparatorStyleShadow,
    _ => throw ArgumentError(
      'Unknown value for NSTitlebarSeparatorStyle: $value',
    ),
  };
}

enum NSWindowBackingLocation {
  NSWindowBackingLocationDefault(0),
  NSWindowBackingLocationVideoMemory(1),
  NSWindowBackingLocationMainMemory(2);

  final int value;
  const NSWindowBackingLocation(this.value);

  static NSWindowBackingLocation fromValue(int value) => switch (value) {
    0 => NSWindowBackingLocationDefault,
    1 => NSWindowBackingLocationVideoMemory,
    2 => NSWindowBackingLocationMainMemory,
    _ => throw ArgumentError(
      'Unknown value for NSWindowBackingLocation: $value',
    ),
  };
}

enum NSMenuItemBadgeType {
  NSMenuItemBadgeTypeNone(0),
  NSMenuItemBadgeTypeUpdates(1),
  NSMenuItemBadgeTypeNewItems(2),
  NSMenuItemBadgeTypeAlerts(3);

  final int value;
  const NSMenuItemBadgeType(this.value);

  static NSMenuItemBadgeType fromValue(int value) => switch (value) {
    0 => NSMenuItemBadgeTypeNone,
    1 => NSMenuItemBadgeTypeUpdates,
    2 => NSMenuItemBadgeTypeNewItems,
    3 => NSMenuItemBadgeTypeAlerts,
    _ => throw ArgumentError('Unknown value for NSMenuItemBadgeType: $value'),
  };
}

enum NSColorSpaceModel {
  NSColorSpaceModelUnknown(-1),
  NSColorSpaceModelGray(0),
  NSColorSpaceModelRGB(1),
  NSColorSpaceModelCMYK(2),
  NSColorSpaceModelLAB(3),
  NSColorSpaceModelDeviceN(4),
  NSColorSpaceModelIndexed(5),
  NSColorSpaceModelPatterned(6);

  final int value;
  const NSColorSpaceModel(this.value);

  static NSColorSpaceModel fromValue(int value) => switch (value) {
    -1 => NSColorSpaceModelUnknown,
    0 => NSColorSpaceModelGray,
    1 => NSColorSpaceModelRGB,
    2 => NSColorSpaceModelCMYK,
    3 => NSColorSpaceModelLAB,
    4 => NSColorSpaceModelDeviceN,
    5 => NSColorSpaceModelIndexed,
    6 => NSColorSpaceModelPatterned,
    _ => throw ArgumentError('Unknown value for NSColorSpaceModel: $value'),
  };
}

enum NSImageLayoutDirection {
  NSImageLayoutDirectionUnspecified(-1),
  NSImageLayoutDirectionLeftToRight(2),
  NSImageLayoutDirectionRightToLeft(3);

  final int value;
  const NSImageLayoutDirection(this.value);

  static NSImageLayoutDirection fromValue(int value) => switch (value) {
    -1 => NSImageLayoutDirectionUnspecified,
    2 => NSImageLayoutDirectionLeftToRight,
    3 => NSImageLayoutDirectionRightToLeft,
    _ => throw ArgumentError(
      'Unknown value for NSImageLayoutDirection: $value',
    ),
  };
}

/// WARNING: NSImageRep is a stub. To generate bindings for this class, include
/// NSImageRep in your config's objc-interfaces list.
///
/// NSImageRep
extension type NSImageRep._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying, objc.NSCoding {
  /// Constructs a [NSImageRep] that points to the same underlying object as [other].
  NSImageRep.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSImageRep', iOS: (true, null));
  }

  /// Constructs a [NSImageRep] that wraps the given raw object pointer.
  NSImageRep.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSImageRep', iOS: (true, null));
  }
}

enum NSTIFFCompression {
  NSTIFFCompressionNone(1),
  NSTIFFCompressionCCITTFAX3(3),
  NSTIFFCompressionCCITTFAX4(4),
  NSTIFFCompressionLZW(5),
  NSTIFFCompressionJPEG(6),
  NSTIFFCompressionNEXT(32766),
  NSTIFFCompressionPackBits(32773),
  NSTIFFCompressionOldJPEG(32865);

  final int value;
  const NSTIFFCompression(this.value);

  static NSTIFFCompression fromValue(int value) => switch (value) {
    1 => NSTIFFCompressionNone,
    3 => NSTIFFCompressionCCITTFAX3,
    4 => NSTIFFCompressionCCITTFAX4,
    5 => NSTIFFCompressionLZW,
    6 => NSTIFFCompressionJPEG,
    32766 => NSTIFFCompressionNEXT,
    32773 => NSTIFFCompressionPackBits,
    32865 => NSTIFFCompressionOldJPEG,
    _ => throw ArgumentError('Unknown value for NSTIFFCompression: $value'),
  };
}

enum NSBitmapImageFileType {
  NSBitmapImageFileTypeTIFF(0),
  NSBitmapImageFileTypeBMP(1),
  NSBitmapImageFileTypeGIF(2),
  NSBitmapImageFileTypeJPEG(3),
  NSBitmapImageFileTypePNG(4),
  NSBitmapImageFileTypeJPEG2000(5);

  final int value;
  const NSBitmapImageFileType(this.value);

  static NSBitmapImageFileType fromValue(int value) => switch (value) {
    0 => NSBitmapImageFileTypeTIFF,
    1 => NSBitmapImageFileTypeBMP,
    2 => NSBitmapImageFileTypeGIF,
    3 => NSBitmapImageFileTypeJPEG,
    4 => NSBitmapImageFileTypePNG,
    5 => NSBitmapImageFileTypeJPEG2000,
    _ => throw ArgumentError('Unknown value for NSBitmapImageFileType: $value'),
  };
}

sealed class NSBitmapFormat {
  static const NSBitmapFormatAlphaFirst = 1;
  static const NSBitmapFormatAlphaNonpremultiplied = 2;
  static const NSBitmapFormatFloatingPointSamples = 4;
  static const NSBitmapFormatSixteenBitLittleEndian = 256;
  static const NSBitmapFormatThirtyTwoBitLittleEndian = 512;
  static const NSBitmapFormatSixteenBitBigEndian = 1024;
  static const NSBitmapFormatThirtyTwoBitBigEndian = 2048;
}

final class __CVBuffer extends ffi.Opaque {}

enum NSColorPanelMode {
  NSColorPanelModeNone(-1),
  NSColorPanelModeGray(0),
  NSColorPanelModeRGB(1),
  NSColorPanelModeCMYK(2),
  NSColorPanelModeHSB(3),
  NSColorPanelModeCustomPalette(4),
  NSColorPanelModeColorList(5),
  NSColorPanelModeWheel(6),
  NSColorPanelModeCrayon(7);

  final int value;
  const NSColorPanelMode(this.value);

  static NSColorPanelMode fromValue(int value) => switch (value) {
    -1 => NSColorPanelModeNone,
    0 => NSColorPanelModeGray,
    1 => NSColorPanelModeRGB,
    2 => NSColorPanelModeCMYK,
    3 => NSColorPanelModeHSB,
    4 => NSColorPanelModeCustomPalette,
    5 => NSColorPanelModeColorList,
    6 => NSColorPanelModeWheel,
    7 => NSColorPanelModeCrayon,
    _ => throw ArgumentError('Unknown value for NSColorPanelMode: $value'),
  };
}

sealed class NSColorPanelOptions {
  static const NSColorPanelGrayModeMask = 1;
  static const NSColorPanelRGBModeMask = 2;
  static const NSColorPanelCMYKModeMask = 4;
  static const NSColorPanelHSBModeMask = 8;
  static const NSColorPanelCustomPaletteModeMask = 16;
  static const NSColorPanelColorListModeMask = 32;
  static const NSColorPanelWheelModeMask = 64;
  static const NSColorPanelCrayonModeMask = 128;
  static const NSColorPanelAllModesMask = 65535;
}

enum NSCursorFrameResizePosition {
  NSCursorFrameResizePositionTop(1),
  NSCursorFrameResizePositionLeft(2),
  NSCursorFrameResizePositionBottom(4),
  NSCursorFrameResizePositionRight(8),
  NSCursorFrameResizePositionTopLeft(3),
  NSCursorFrameResizePositionTopRight(9),
  NSCursorFrameResizePositionBottomLeft(6),
  NSCursorFrameResizePositionBottomRight(12);

  final int value;
  const NSCursorFrameResizePosition(this.value);

  static NSCursorFrameResizePosition fromValue(int value) => switch (value) {
    1 => NSCursorFrameResizePositionTop,
    2 => NSCursorFrameResizePositionLeft,
    4 => NSCursorFrameResizePositionBottom,
    8 => NSCursorFrameResizePositionRight,
    3 => NSCursorFrameResizePositionTopLeft,
    9 => NSCursorFrameResizePositionTopRight,
    6 => NSCursorFrameResizePositionBottomLeft,
    12 => NSCursorFrameResizePositionBottomRight,
    _ => throw ArgumentError(
      'Unknown value for NSCursorFrameResizePosition: $value',
    ),
  };
}

sealed class NSCursorFrameResizeDirections {
  static const NSCursorFrameResizeDirectionsInward = 1;
  static const NSCursorFrameResizeDirectionsOutward = 2;
  static const NSCursorFrameResizeDirectionsAll = 3;
}

enum NSGestureRecognizerState {
  NSGestureRecognizerStatePossible(0),
  NSGestureRecognizerStateBegan(1),
  NSGestureRecognizerStateChanged(2),
  NSGestureRecognizerStateEnded(3),
  NSGestureRecognizerStateCancelled(4),
  NSGestureRecognizerStateFailed(5);

  static const NSGestureRecognizerStateRecognized =
      NSGestureRecognizerStateEnded;

  final int value;
  const NSGestureRecognizerState(this.value);

  static NSGestureRecognizerState fromValue(int value) => switch (value) {
    0 => NSGestureRecognizerStatePossible,
    1 => NSGestureRecognizerStateBegan,
    2 => NSGestureRecognizerStateChanged,
    3 => NSGestureRecognizerStateEnded,
    4 => NSGestureRecognizerStateCancelled,
    5 => NSGestureRecognizerStateFailed,
    _ => throw ArgumentError(
      'Unknown value for NSGestureRecognizerState: $value',
    ),
  };

  @override
  String toString() {
    if (this == NSGestureRecognizerStateEnded)
      return "NSGestureRecognizerState.NSGestureRecognizerStateEnded, NSGestureRecognizerState.NSGestureRecognizerStateRecognized";
    return super.toString();
  }
}

/// WARNING: NSLayoutAnchor is a stub. To generate bindings for this class, include
/// NSLayoutAnchor in your config's objc-interfaces list.
///
/// NSLayoutAnchor
extension type NSLayoutAnchor._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying, objc.NSCoding {
  /// Constructs a [NSLayoutAnchor] that points to the same underlying object as [other].
  NSLayoutAnchor.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSLayoutAnchor',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }

  /// Constructs a [NSLayoutAnchor] that wraps the given raw object pointer.
  NSLayoutAnchor.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSLayoutAnchor',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }
}

enum NSLayoutRelation {
  NSLayoutRelationLessThanOrEqual(-1),
  NSLayoutRelationEqual(0),
  NSLayoutRelationGreaterThanOrEqual(1);

  final int value;
  const NSLayoutRelation(this.value);

  static NSLayoutRelation fromValue(int value) => switch (value) {
    -1 => NSLayoutRelationLessThanOrEqual,
    0 => NSLayoutRelationEqual,
    1 => NSLayoutRelationGreaterThanOrEqual,
    _ => throw ArgumentError('Unknown value for NSLayoutRelation: $value'),
  };
}

enum NSLayoutAttribute {
  NSLayoutAttributeLeft(1),
  NSLayoutAttributeRight(2),
  NSLayoutAttributeTop(3),
  NSLayoutAttributeBottom(4),
  NSLayoutAttributeLeading(5),
  NSLayoutAttributeTrailing(6),
  NSLayoutAttributeWidth(7),
  NSLayoutAttributeHeight(8),
  NSLayoutAttributeCenterX(9),
  NSLayoutAttributeCenterY(10),
  NSLayoutAttributeLastBaseline(11),
  NSLayoutAttributeFirstBaseline(12),
  NSLayoutAttributeNotAnAttribute(0);

  static const NSLayoutAttributeBaseline = NSLayoutAttributeLastBaseline;

  final int value;
  const NSLayoutAttribute(this.value);

  static NSLayoutAttribute fromValue(int value) => switch (value) {
    1 => NSLayoutAttributeLeft,
    2 => NSLayoutAttributeRight,
    3 => NSLayoutAttributeTop,
    4 => NSLayoutAttributeBottom,
    5 => NSLayoutAttributeLeading,
    6 => NSLayoutAttributeTrailing,
    7 => NSLayoutAttributeWidth,
    8 => NSLayoutAttributeHeight,
    9 => NSLayoutAttributeCenterX,
    10 => NSLayoutAttributeCenterY,
    11 => NSLayoutAttributeLastBaseline,
    12 => NSLayoutAttributeFirstBaseline,
    0 => NSLayoutAttributeNotAnAttribute,
    _ => throw ArgumentError('Unknown value for NSLayoutAttribute: $value'),
  };

  @override
  String toString() {
    if (this == NSLayoutAttributeLastBaseline)
      return "NSLayoutAttribute.NSLayoutAttributeLastBaseline, NSLayoutAttribute.NSLayoutAttributeBaseline";
    return super.toString();
  }
}

sealed class NSLayoutFormatOptions {
  static const NSLayoutFormatAlignAllLeft = 2;
  static const NSLayoutFormatAlignAllRight = 4;
  static const NSLayoutFormatAlignAllTop = 8;
  static const NSLayoutFormatAlignAllBottom = 16;
  static const NSLayoutFormatAlignAllLeading = 32;
  static const NSLayoutFormatAlignAllTrailing = 64;
  static const NSLayoutFormatAlignAllCenterX = 512;
  static const NSLayoutFormatAlignAllCenterY = 1024;
  static const NSLayoutFormatAlignAllLastBaseline = 2048;
  static const NSLayoutFormatAlignAllFirstBaseline = 4096;
  static const NSLayoutFormatAlignAllBaseline = 2048;
  static const NSLayoutFormatAlignmentMask = 65535;
  static const NSLayoutFormatDirectionLeadingToTrailing = 0;
  static const NSLayoutFormatDirectionLeftToRight = 65536;
  static const NSLayoutFormatDirectionRightToLeft = 131072;
  static const NSLayoutFormatDirectionMask = 196608;
}

enum NSImageLoadStatus {
  NSImageLoadStatusCompleted(0),
  NSImageLoadStatusCancelled(1),
  NSImageLoadStatusInvalidData(2),
  NSImageLoadStatusUnexpectedEOF(3),
  NSImageLoadStatusReadError(4);

  final int value;
  const NSImageLoadStatus(this.value);

  static NSImageLoadStatus fromValue(int value) => switch (value) {
    0 => NSImageLoadStatusCompleted,
    1 => NSImageLoadStatusCancelled,
    2 => NSImageLoadStatusInvalidData,
    3 => NSImageLoadStatusUnexpectedEOF,
    4 => NSImageLoadStatusReadError,
    _ => throw ArgumentError('Unknown value for NSImageLoadStatus: $value'),
  };
}

enum NSImageCacheMode {
  NSImageCacheDefault(0),
  NSImageCacheAlways(1),
  NSImageCacheBySize(2),
  NSImageCacheNever(3);

  final int value;
  const NSImageCacheMode(this.value);

  static NSImageCacheMode fromValue(int value) => switch (value) {
    0 => NSImageCacheDefault,
    1 => NSImageCacheAlways,
    2 => NSImageCacheBySize,
    3 => NSImageCacheNever,
    _ => throw ArgumentError('Unknown value for NSImageCacheMode: $value'),
  };
}

enum NSImageResizingMode {
  NSImageResizingModeTile(0),
  NSImageResizingModeStretch(1);

  final int value;
  const NSImageResizingMode(this.value);

  static NSImageResizingMode fromValue(int value) => switch (value) {
    0 => NSImageResizingModeTile,
    1 => NSImageResizingModeStretch,
    _ => throw ArgumentError('Unknown value for NSImageResizingMode: $value'),
  };
}

enum NSImageSymbolScale {
  NSImageSymbolScaleSmall(1),
  NSImageSymbolScaleMedium(2),
  NSImageSymbolScaleLarge(3);

  final int value;
  const NSImageSymbolScale(this.value);

  static NSImageSymbolScale fromValue(int value) => switch (value) {
    1 => NSImageSymbolScaleSmall,
    2 => NSImageSymbolScaleMedium,
    3 => NSImageSymbolScaleLarge,
    _ => throw ArgumentError('Unknown value for NSImageSymbolScale: $value'),
  };
}

enum NSImageSymbolVariableValueMode {
  NSImageSymbolVariableValueModeAutomatic(0),
  NSImageSymbolVariableValueModeColor(1),
  NSImageSymbolVariableValueModeDraw(2);

  final int value;
  const NSImageSymbolVariableValueMode(this.value);

  static NSImageSymbolVariableValueMode fromValue(int value) => switch (value) {
    0 => NSImageSymbolVariableValueModeAutomatic,
    1 => NSImageSymbolVariableValueModeColor,
    2 => NSImageSymbolVariableValueModeDraw,
    _ => throw ArgumentError(
      'Unknown value for NSImageSymbolVariableValueMode: $value',
    ),
  };
}

enum NSImageSymbolColorRenderingMode {
  NSImageSymbolColorRenderingModeAutomatic(0),
  NSImageSymbolColorRenderingModeFlat(1),
  NSImageSymbolColorRenderingModeGradient(2);

  final int value;
  const NSImageSymbolColorRenderingMode(this.value);

  static NSImageSymbolColorRenderingMode fromValue(int value) =>
      switch (value) {
        0 => NSImageSymbolColorRenderingModeAutomatic,
        1 => NSImageSymbolColorRenderingModeFlat,
        2 => NSImageSymbolColorRenderingModeGradient,
        _ => throw ArgumentError(
          'Unknown value for NSImageSymbolColorRenderingMode: $value',
        ),
      };
}

enum NSSharingContentScope {
  NSSharingContentScopeItem(0),
  NSSharingContentScopePartial(1),
  NSSharingContentScopeFull(2);

  final int value;
  const NSSharingContentScope(this.value);

  static NSSharingContentScope fromValue(int value) => switch (value) {
    0 => NSSharingContentScopeItem,
    1 => NSSharingContentScopePartial,
    2 => NSSharingContentScopeFull,
    _ => throw ArgumentError('Unknown value for NSSharingContentScope: $value'),
  };
}

enum NSPrintingPageOrder {
  NSDescendingPageOrder(-1),
  NSSpecialPageOrder(0),
  NSAscendingPageOrder(1),
  NSUnknownPageOrder(2);

  final int value;
  const NSPrintingPageOrder(this.value);

  static NSPrintingPageOrder fromValue(int value) => switch (value) {
    -1 => NSDescendingPageOrder,
    0 => NSSpecialPageOrder,
    1 => NSAscendingPageOrder,
    2 => NSUnknownPageOrder,
    _ => throw ArgumentError('Unknown value for NSPrintingPageOrder: $value'),
  };
}

enum NSPrintRenderingQuality {
  NSPrintRenderingQualityBest(0),
  NSPrintRenderingQualityResponsive(1);

  final int value;
  const NSPrintRenderingQuality(this.value);

  static NSPrintRenderingQuality fromValue(int value) => switch (value) {
    0 => NSPrintRenderingQualityBest,
    1 => NSPrintRenderingQualityResponsive,
    _ => throw ArgumentError(
      'Unknown value for NSPrintRenderingQuality: $value',
    ),
  };
}

/// WARNING: NSPrintOperation is a stub. To generate bindings for this class, include
/// NSPrintOperation in your config's objc-interfaces list.
///
/// NSPrintOperation
extension type NSPrintOperation._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSPrintOperation] that points to the same underlying object as [other].
  NSPrintOperation.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('NSPrintOperation', iOS: (true, null));
  }

  /// Constructs a [NSPrintOperation] that wraps the given raw object pointer.
  NSPrintOperation.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSPrintOperation', iOS: (true, null));
  }
}

enum NSPrintPanelResult {
  NSPrintPanelResultCancelled(0),
  NSPrintPanelResultPrinted(1);

  final int value;
  const NSPrintPanelResult(this.value);

  static NSPrintPanelResult fromValue(int value) => switch (value) {
    0 => NSPrintPanelResultCancelled,
    1 => NSPrintPanelResultPrinted,
    _ => throw ArgumentError('Unknown value for NSPrintPanelResult: $value'),
  };
}

sealed class NSPrintPanelOptions {
  static const NSPrintPanelShowsCopies = 1;
  static const NSPrintPanelShowsPageRange = 2;
  static const NSPrintPanelShowsPaperSize = 4;
  static const NSPrintPanelShowsOrientation = 8;
  static const NSPrintPanelShowsScaling = 16;
  static const NSPrintPanelShowsPrintSelection = 32;
  static const NSPrintPanelShowsPageSetupAccessory = 256;
  static const NSPrintPanelShowsPreview = 131072;
}

sealed class NSPDFPanelOptions {
  static const NSPDFPanelShowsPaperSize = 4;
  static const NSPDFPanelShowsOrientation = 8;
  static const NSPDFPanelRequestsParentDirectory = 16777216;
}

enum NSUsableScrollerParts {
  NSNoScrollerParts(0),
  NSOnlyScrollerArrows(1),
  NSAllScrollerParts(2);

  final int value;
  const NSUsableScrollerParts(this.value);

  static NSUsableScrollerParts fromValue(int value) => switch (value) {
    0 => NSNoScrollerParts,
    1 => NSOnlyScrollerArrows,
    2 => NSAllScrollerParts,
    _ => throw ArgumentError('Unknown value for NSUsableScrollerParts: $value'),
  };
}

enum NSScrollerPart {
  NSScrollerNoPart(0),
  NSScrollerDecrementPage(1),
  NSScrollerKnob(2),
  NSScrollerIncrementPage(3),
  NSScrollerDecrementLine(4),
  NSScrollerIncrementLine(5),
  NSScrollerKnobSlot(6);

  final int value;
  const NSScrollerPart(this.value);

  static NSScrollerPart fromValue(int value) => switch (value) {
    0 => NSScrollerNoPart,
    1 => NSScrollerDecrementPage,
    2 => NSScrollerKnob,
    3 => NSScrollerIncrementPage,
    4 => NSScrollerDecrementLine,
    5 => NSScrollerIncrementLine,
    6 => NSScrollerKnobSlot,
    _ => throw ArgumentError('Unknown value for NSScrollerPart: $value'),
  };
}

enum NSScrollerStyle {
  NSScrollerStyleLegacy(0),
  NSScrollerStyleOverlay(1);

  final int value;
  const NSScrollerStyle(this.value);

  static NSScrollerStyle fromValue(int value) => switch (value) {
    0 => NSScrollerStyleLegacy,
    1 => NSScrollerStyleOverlay,
    _ => throw ArgumentError('Unknown value for NSScrollerStyle: $value'),
  };
}

enum NSScrollerKnobStyle {
  NSScrollerKnobStyleDefault(0),
  NSScrollerKnobStyleDark(1),
  NSScrollerKnobStyleLight(2);

  final int value;
  const NSScrollerKnobStyle(this.value);

  static NSScrollerKnobStyle fromValue(int value) => switch (value) {
    0 => NSScrollerKnobStyleDefault,
    1 => NSScrollerKnobStyleDark,
    2 => NSScrollerKnobStyleLight,
    _ => throw ArgumentError('Unknown value for NSScrollerKnobStyle: $value'),
  };
}

enum NSScrollArrowPosition {
  NSScrollerArrowsMaxEnd(0),
  NSScrollerArrowsMinEnd(1),
  NSScrollerArrowsNone(2);

  static const NSScrollerArrowsDefaultSetting = NSScrollerArrowsMaxEnd;

  final int value;
  const NSScrollArrowPosition(this.value);

  static NSScrollArrowPosition fromValue(int value) => switch (value) {
    0 => NSScrollerArrowsMaxEnd,
    1 => NSScrollerArrowsMinEnd,
    2 => NSScrollerArrowsNone,
    _ => throw ArgumentError('Unknown value for NSScrollArrowPosition: $value'),
  };

  @override
  String toString() {
    if (this == NSScrollerArrowsMaxEnd)
      return "NSScrollArrowPosition.NSScrollerArrowsMaxEnd, NSScrollArrowPosition.NSScrollerArrowsDefaultSetting";
    return super.toString();
  }
}

enum NSScrollerArrow {
  NSScrollerIncrementArrow(0),
  NSScrollerDecrementArrow(1);

  final int value;
  const NSScrollerArrow(this.value);

  static NSScrollerArrow fromValue(int value) => switch (value) {
    0 => NSScrollerIncrementArrow,
    1 => NSScrollerDecrementArrow,
    _ => throw ArgumentError('Unknown value for NSScrollerArrow: $value'),
  };
}

/// WARNING: NSTextFinderClient is a stub. To generate bindings for this class, include
/// NSTextFinderClient in your config's objc-protocols list.
///
/// NSTextFinderClient
extension type NSTextFinderClient._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [NSTextFinderClient] that points to the same underlying object as [other].
  NSTextFinderClient.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSTextFinderClient] that wraps the given raw object pointer.
  NSTextFinderClient.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// WARNING: NSTextFinderBarContainer is a stub. To generate bindings for this class, include
/// NSTextFinderBarContainer in your config's objc-protocols list.
///
/// NSTextFinderBarContainer
extension type NSTextFinderBarContainer._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [NSTextFinderBarContainer] that points to the same underlying object as [other].
  NSTextFinderBarContainer.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSTextFinderBarContainer] that wraps the given raw object pointer.
  NSTextFinderBarContainer.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

enum NSScrollElasticity {
  NSScrollElasticityAutomatic(0),
  NSScrollElasticityNone(1),
  NSScrollElasticityAllowed(2);

  final int value;
  const NSScrollElasticity(this.value);

  static NSScrollElasticity fromValue(int value) => switch (value) {
    0 => NSScrollElasticityAutomatic,
    1 => NSScrollElasticityNone,
    2 => NSScrollElasticityAllowed,
    _ => throw ArgumentError('Unknown value for NSScrollElasticity: $value'),
  };
}

enum NSScrollViewFindBarPosition {
  NSScrollViewFindBarPositionAboveHorizontalRuler(0),
  NSScrollViewFindBarPositionAboveContent(1),
  NSScrollViewFindBarPositionBelowContent(2);

  final int value;
  const NSScrollViewFindBarPosition(this.value);

  static NSScrollViewFindBarPosition fromValue(int value) => switch (value) {
    0 => NSScrollViewFindBarPositionAboveHorizontalRuler,
    1 => NSScrollViewFindBarPositionAboveContent,
    2 => NSScrollViewFindBarPositionBelowContent,
    _ => throw ArgumentError(
      'Unknown value for NSScrollViewFindBarPosition: $value',
    ),
  };
}

enum NSTextCursorAccessoryPlacement {
  NSTextCursorAccessoryPlacementUnspecified(0),
  NSTextCursorAccessoryPlacementBackward(1),
  NSTextCursorAccessoryPlacementForward(2),
  NSTextCursorAccessoryPlacementInvisible(3),
  NSTextCursorAccessoryPlacementCenter(4),
  NSTextCursorAccessoryPlacementOffscreenLeft(5),
  NSTextCursorAccessoryPlacementOffscreenTop(6),
  NSTextCursorAccessoryPlacementOffscreenRight(7),
  NSTextCursorAccessoryPlacementOffscreenBottom(8);

  final int value;
  const NSTextCursorAccessoryPlacement(this.value);

  static NSTextCursorAccessoryPlacement fromValue(int value) => switch (value) {
    0 => NSTextCursorAccessoryPlacementUnspecified,
    1 => NSTextCursorAccessoryPlacementBackward,
    2 => NSTextCursorAccessoryPlacementForward,
    3 => NSTextCursorAccessoryPlacementInvisible,
    4 => NSTextCursorAccessoryPlacementCenter,
    5 => NSTextCursorAccessoryPlacementOffscreenLeft,
    6 => NSTextCursorAccessoryPlacementOffscreenTop,
    7 => NSTextCursorAccessoryPlacementOffscreenRight,
    8 => NSTextCursorAccessoryPlacementOffscreenBottom,
    _ => throw ArgumentError(
      'Unknown value for NSTextCursorAccessoryPlacement: $value',
    ),
  };
}

enum NSTextInputTraitType {
  NSTextInputTraitTypeDefault(0),
  NSTextInputTraitTypeNo(1),
  NSTextInputTraitTypeYes(2);

  final int value;
  const NSTextInputTraitType(this.value);

  static NSTextInputTraitType fromValue(int value) => switch (value) {
    0 => NSTextInputTraitTypeDefault,
    1 => NSTextInputTraitTypeNo,
    2 => NSTextInputTraitTypeYes,
    _ => throw ArgumentError('Unknown value for NSTextInputTraitType: $value'),
  };
}

enum NSWritingToolsBehavior {
  NSWritingToolsBehaviorNone(-1),
  NSWritingToolsBehaviorDefault(0),
  NSWritingToolsBehaviorComplete(1),
  NSWritingToolsBehaviorLimited(2);

  final int value;
  const NSWritingToolsBehavior(this.value);

  static NSWritingToolsBehavior fromValue(int value) => switch (value) {
    -1 => NSWritingToolsBehaviorNone,
    0 => NSWritingToolsBehaviorDefault,
    1 => NSWritingToolsBehaviorComplete,
    2 => NSWritingToolsBehaviorLimited,
    _ => throw ArgumentError(
      'Unknown value for NSWritingToolsBehavior: $value',
    ),
  };
}

sealed class NSWritingToolsResultOptions {
  static const NSWritingToolsResultDefault = 0;
  static const NSWritingToolsResultPlainText = 1;
  static const NSWritingToolsResultRichText = 2;
  static const NSWritingToolsResultList = 4;
  static const NSWritingToolsResultTable = 8;
  static const NSWritingToolsResultPresentationIntent = 16;
}

sealed class NSTextStorageEditActions {
  static const NSTextStorageEditedAttributes = 1;
  static const NSTextStorageEditedCharacters = 2;
}

enum NSTextLayoutOrientation {
  NSTextLayoutOrientationHorizontal(0),
  NSTextLayoutOrientationVertical(1);

  final int value;
  const NSTextLayoutOrientation(this.value);

  static NSTextLayoutOrientation fromValue(int value) => switch (value) {
    0 => NSTextLayoutOrientationHorizontal,
    1 => NSTextLayoutOrientationVertical,
    _ => throw ArgumentError(
      'Unknown value for NSTextLayoutOrientation: $value',
    ),
  };
}

sealed class NSGlyphProperty {
  static const NSGlyphPropertyNull = 1;
  static const NSGlyphPropertyControlCharacter = 2;
  static const NSGlyphPropertyElastic = 4;
  static const NSGlyphPropertyNonBaseCharacter = 8;
}

sealed class NSControlCharacterAction {
  static const NSControlCharacterActionZeroAdvancement = 1;
  static const NSControlCharacterActionWhitespace = 2;
  static const NSControlCharacterActionHorizontalTab = 4;
  static const NSControlCharacterActionLineBreak = 8;
  static const NSControlCharacterActionParagraphBreak = 16;
  static const NSControlCharacterActionContainerBreak = 32;
}

enum NSTypesetterBehavior {
  NSTypesetterLatestBehavior(-1),
  NSTypesetterOriginalBehavior(0),
  NSTypesetterBehavior_10_2_WithCompatibility(1),
  NSTypesetterBehavior_10_2(2),
  NSTypesetterBehavior_10_3(3),
  NSTypesetterBehavior_10_4(4);

  final int value;
  const NSTypesetterBehavior(this.value);

  static NSTypesetterBehavior fromValue(int value) => switch (value) {
    -1 => NSTypesetterLatestBehavior,
    0 => NSTypesetterOriginalBehavior,
    1 => NSTypesetterBehavior_10_2_WithCompatibility,
    2 => NSTypesetterBehavior_10_2,
    3 => NSTypesetterBehavior_10_3,
    4 => NSTypesetterBehavior_10_4,
    _ => throw ArgumentError('Unknown value for NSTypesetterBehavior: $value'),
  };
}

enum NSGlyphInscription {
  NSGlyphInscribeBase(0),
  NSGlyphInscribeBelow(1),
  NSGlyphInscribeAbove(2),
  NSGlyphInscribeOverstrike(3),
  NSGlyphInscribeOverBelow(4);

  final int value;
  const NSGlyphInscription(this.value);

  static NSGlyphInscription fromValue(int value) => switch (value) {
    0 => NSGlyphInscribeBase,
    1 => NSGlyphInscribeBelow,
    2 => NSGlyphInscribeAbove,
    3 => NSGlyphInscribeOverstrike,
    4 => NSGlyphInscribeOverBelow,
    _ => throw ArgumentError('Unknown value for NSGlyphInscription: $value'),
  };
}

enum NSLineSweepDirection {
  NSLineSweepLeft(0),
  NSLineSweepRight(1),
  NSLineSweepDown(2),
  NSLineSweepUp(3);

  final int value;
  const NSLineSweepDirection(this.value);

  static NSLineSweepDirection fromValue(int value) => switch (value) {
    0 => NSLineSweepLeft,
    1 => NSLineSweepRight,
    2 => NSLineSweepDown,
    3 => NSLineSweepUp,
    _ => throw ArgumentError('Unknown value for NSLineSweepDirection: $value'),
  };
}

enum NSLineMovementDirection {
  NSLineDoesntMove(0),
  NSLineMovesLeft(1),
  NSLineMovesRight(2),
  NSLineMovesDown(3),
  NSLineMovesUp(4);

  final int value;
  const NSLineMovementDirection(this.value);

  static NSLineMovementDirection fromValue(int value) => switch (value) {
    0 => NSLineDoesntMove,
    1 => NSLineMovesLeft,
    2 => NSLineMovesRight,
    3 => NSLineMovesDown,
    4 => NSLineMovesUp,
    _ => throw ArgumentError(
      'Unknown value for NSLineMovementDirection: $value',
    ),
  };
}

sealed class NSTrackingAreaOptions {
  static const NSTrackingMouseEnteredAndExited = 1;
  static const NSTrackingMouseMoved = 2;
  static const NSTrackingCursorUpdate = 4;
  static const NSTrackingActiveWhenFirstResponder = 16;
  static const NSTrackingActiveInKeyWindow = 32;
  static const NSTrackingActiveInActiveApp = 64;
  static const NSTrackingActiveAlways = 128;
  static const NSTrackingAssumeInside = 256;
  static const NSTrackingInVisibleRect = 512;
  static const NSTrackingEnabledDuringMouseDrag = 1024;
}

enum NSToolbarDisplayMode {
  NSToolbarDisplayModeDefault(0),
  NSToolbarDisplayModeIconAndLabel(1),
  NSToolbarDisplayModeIconOnly(2),
  NSToolbarDisplayModeLabelOnly(3);

  final int value;
  const NSToolbarDisplayMode(this.value);

  static NSToolbarDisplayMode fromValue(int value) => switch (value) {
    0 => NSToolbarDisplayModeDefault,
    1 => NSToolbarDisplayModeIconAndLabel,
    2 => NSToolbarDisplayModeIconOnly,
    3 => NSToolbarDisplayModeLabelOnly,
    _ => throw ArgumentError('Unknown value for NSToolbarDisplayMode: $value'),
  };
}

enum NSToolbarSizeMode {
  NSToolbarSizeModeDefault(0),
  NSToolbarSizeModeRegular(1),
  NSToolbarSizeModeSmall(2);

  final int value;
  const NSToolbarSizeMode(this.value);

  static NSToolbarSizeMode fromValue(int value) => switch (value) {
    0 => NSToolbarSizeModeDefault,
    1 => NSToolbarSizeModeRegular,
    2 => NSToolbarSizeModeSmall,
    _ => throw ArgumentError('Unknown value for NSToolbarSizeMode: $value'),
  };
}

enum NSToolbarItemStyle {
  NSToolbarItemStylePlain(0),
  NSToolbarItemStyleProminent(1);

  final int value;
  const NSToolbarItemStyle(this.value);

  static NSToolbarItemStyle fromValue(int value) => switch (value) {
    0 => NSToolbarItemStylePlain,
    1 => NSToolbarItemStyleProminent,
    _ => throw ArgumentError('Unknown value for NSToolbarItemStyle: $value'),
  };
}

enum NSViewLayoutRegionAdaptivityAxis {
  NSViewLayoutRegionAdaptivityAxisNone(0),
  NSViewLayoutRegionAdaptivityAxisHorizontal(1),
  NSViewLayoutRegionAdaptivityAxisVertical(2);

  final int value;
  const NSViewLayoutRegionAdaptivityAxis(this.value);

  static NSViewLayoutRegionAdaptivityAxis fromValue(int value) =>
      switch (value) {
        0 => NSViewLayoutRegionAdaptivityAxisNone,
        1 => NSViewLayoutRegionAdaptivityAxisHorizontal,
        2 => NSViewLayoutRegionAdaptivityAxisVertical,
        _ => throw ArgumentError(
          'Unknown value for NSViewLayoutRegionAdaptivityAxis: $value',
        ),
      };
}

enum NSSelectionGranularity {
  NSSelectByCharacter(0),
  NSSelectByWord(1),
  NSSelectByParagraph(2);

  final int value;
  const NSSelectionGranularity(this.value);

  static NSSelectionGranularity fromValue(int value) => switch (value) {
    0 => NSSelectByCharacter,
    1 => NSSelectByWord,
    2 => NSSelectByParagraph,
    _ => throw ArgumentError(
      'Unknown value for NSSelectionGranularity: $value',
    ),
  };
}

enum NSSelectionAffinity {
  NSSelectionAffinityUpstream(0),
  NSSelectionAffinityDownstream(1);

  final int value;
  const NSSelectionAffinity(this.value);

  static NSSelectionAffinity fromValue(int value) => switch (value) {
    0 => NSSelectionAffinityUpstream,
    1 => NSSelectionAffinityDownstream,
    _ => throw ArgumentError('Unknown value for NSSelectionAffinity: $value'),
  };
}

enum NSRulerOrientation {
  NSHorizontalRuler(0),
  NSVerticalRuler(1);

  final int value;
  const NSRulerOrientation(this.value);

  static NSRulerOrientation fromValue(int value) => switch (value) {
    0 => NSHorizontalRuler,
    1 => NSVerticalRuler,
    _ => throw ArgumentError('Unknown value for NSRulerOrientation: $value'),
  };
}

enum NSLineCapStyle {
  NSLineCapStyleButt(0),
  NSLineCapStyleRound(1),
  NSLineCapStyleSquare(2);

  final int value;
  const NSLineCapStyle(this.value);

  static NSLineCapStyle fromValue(int value) => switch (value) {
    0 => NSLineCapStyleButt,
    1 => NSLineCapStyleRound,
    2 => NSLineCapStyleSquare,
    _ => throw ArgumentError('Unknown value for NSLineCapStyle: $value'),
  };
}

enum NSLineJoinStyle {
  NSLineJoinStyleMiter(0),
  NSLineJoinStyleRound(1),
  NSLineJoinStyleBevel(2);

  final int value;
  const NSLineJoinStyle(this.value);

  static NSLineJoinStyle fromValue(int value) => switch (value) {
    0 => NSLineJoinStyleMiter,
    1 => NSLineJoinStyleRound,
    2 => NSLineJoinStyleBevel,
    _ => throw ArgumentError('Unknown value for NSLineJoinStyle: $value'),
  };
}

enum NSWindingRule {
  NSWindingRuleNonZero(0),
  NSWindingRuleEvenOdd(1);

  final int value;
  const NSWindingRule(this.value);

  static NSWindingRule fromValue(int value) => switch (value) {
    0 => NSWindingRuleNonZero,
    1 => NSWindingRuleEvenOdd,
    _ => throw ArgumentError('Unknown value for NSWindingRule: $value'),
  };
}

enum NSBezierPathElement {
  NSBezierPathElementMoveTo(0),
  NSBezierPathElementLineTo(1),
  NSBezierPathElementCubicCurveTo(2),
  NSBezierPathElementClosePath(3),
  NSBezierPathElementQuadraticCurveTo(4);

  static const NSBezierPathElementCurveTo = NSBezierPathElementCubicCurveTo;

  final int value;
  const NSBezierPathElement(this.value);

  static NSBezierPathElement fromValue(int value) => switch (value) {
    0 => NSBezierPathElementMoveTo,
    1 => NSBezierPathElementLineTo,
    2 => NSBezierPathElementCubicCurveTo,
    3 => NSBezierPathElementClosePath,
    4 => NSBezierPathElementQuadraticCurveTo,
    _ => throw ArgumentError('Unknown value for NSBezierPathElement: $value'),
  };

  @override
  String toString() {
    if (this == NSBezierPathElementCubicCurveTo)
      return "NSBezierPathElement.NSBezierPathElementCubicCurveTo, NSBezierPathElement.NSBezierPathElementCurveTo";
    return super.toString();
  }
}

/// WARNING: CAMediaTiming is a stub. To generate bindings for this class, include
/// CAMediaTiming in your config's objc-protocols list.
///
/// CAMediaTiming
extension type CAMediaTiming._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol {
  /// Constructs a [CAMediaTiming] that points to the same underlying object as [other].
  CAMediaTiming.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [CAMediaTiming] that wraps the given raw object pointer.
  CAMediaTiming.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

final class CATransform3D extends ffi.Struct {
  @ffi.Double()
  external double m11;

  @ffi.Double()
  external double m12;

  @ffi.Double()
  external double m13;

  @ffi.Double()
  external double m14;

  @ffi.Double()
  external double m21;

  @ffi.Double()
  external double m22;

  @ffi.Double()
  external double m23;

  @ffi.Double()
  external double m24;

  @ffi.Double()
  external double m31;

  @ffi.Double()
  external double m32;

  @ffi.Double()
  external double m33;

  @ffi.Double()
  external double m34;

  @ffi.Double()
  external double m41;

  @ffi.Double()
  external double m42;

  @ffi.Double()
  external double m43;

  @ffi.Double()
  external double m44;
}

sealed class CAAutoresizingMask {
  static const kCALayerNotSizable = 0;
  static const kCALayerMinXMargin = 1;
  static const kCALayerWidthSizable = 2;
  static const kCALayerMaxXMargin = 4;
  static const kCALayerMinYMargin = 8;
  static const kCALayerHeightSizable = 16;
  static const kCALayerMaxYMargin = 32;
}

sealed class CAEdgeAntialiasingMask {
  static const kCALayerLeftEdge = 1;
  static const kCALayerRightEdge = 2;
  static const kCALayerBottomEdge = 4;
  static const kCALayerTopEdge = 8;
}

sealed class CACornerMask {
  static const kCALayerMinXMinYCorner = 1;
  static const kCALayerMaxXMinYCorner = 2;
  static const kCALayerMinXMaxYCorner = 4;
  static const kCALayerMaxXMaxYCorner = 8;
}

sealed class NSTypesetterControlCharacterAction {
  static const NSTypesetterZeroAdvancementAction = 1;
  static const NSTypesetterWhitespaceAction = 2;
  static const NSTypesetterHorizontalTabAction = 4;
  static const NSTypesetterLineBreakAction = 8;
  static const NSTypesetterParagraphBreakAction = 16;
  static const NSTypesetterContainerBreakAction = 32;
}

enum NSTextBlockValueType {
  NSTextBlockAbsoluteValueType(0),
  NSTextBlockPercentageValueType(1);

  final int value;
  const NSTextBlockValueType(this.value);

  static NSTextBlockValueType fromValue(int value) => switch (value) {
    0 => NSTextBlockAbsoluteValueType,
    1 => NSTextBlockPercentageValueType,
    _ => throw ArgumentError('Unknown value for NSTextBlockValueType: $value'),
  };
}

enum NSTextBlockDimension {
  NSTextBlockWidth(0),
  NSTextBlockMinimumWidth(1),
  NSTextBlockMaximumWidth(2),
  NSTextBlockHeight(4),
  NSTextBlockMinimumHeight(5),
  NSTextBlockMaximumHeight(6);

  final int value;
  const NSTextBlockDimension(this.value);

  static NSTextBlockDimension fromValue(int value) => switch (value) {
    0 => NSTextBlockWidth,
    1 => NSTextBlockMinimumWidth,
    2 => NSTextBlockMaximumWidth,
    4 => NSTextBlockHeight,
    5 => NSTextBlockMinimumHeight,
    6 => NSTextBlockMaximumHeight,
    _ => throw ArgumentError('Unknown value for NSTextBlockDimension: $value'),
  };
}

enum NSTextBlockLayer {
  NSTextBlockPadding(-1),
  NSTextBlockBorder(0),
  NSTextBlockMargin(1);

  final int value;
  const NSTextBlockLayer(this.value);

  static NSTextBlockLayer fromValue(int value) => switch (value) {
    -1 => NSTextBlockPadding,
    0 => NSTextBlockBorder,
    1 => NSTextBlockMargin,
    _ => throw ArgumentError('Unknown value for NSTextBlockLayer: $value'),
  };
}

enum NSTextBlockVerticalAlignment {
  NSTextBlockTopAlignment(0),
  NSTextBlockMiddleAlignment(1),
  NSTextBlockBottomAlignment(2),
  NSTextBlockBaselineAlignment(3);

  final int value;
  const NSTextBlockVerticalAlignment(this.value);

  static NSTextBlockVerticalAlignment fromValue(int value) => switch (value) {
    0 => NSTextBlockTopAlignment,
    1 => NSTextBlockMiddleAlignment,
    2 => NSTextBlockBottomAlignment,
    3 => NSTextBlockBaselineAlignment,
    _ => throw ArgumentError(
      'Unknown value for NSTextBlockVerticalAlignment: $value',
    ),
  };
}

enum NSTextSelectionGranularity {
  NSTextSelectionGranularityCharacter(0),
  NSTextSelectionGranularityWord(1),
  NSTextSelectionGranularityParagraph(2),
  NSTextSelectionGranularityLine(3),
  NSTextSelectionGranularitySentence(4);

  final int value;
  const NSTextSelectionGranularity(this.value);

  static NSTextSelectionGranularity fromValue(int value) => switch (value) {
    0 => NSTextSelectionGranularityCharacter,
    1 => NSTextSelectionGranularityWord,
    2 => NSTextSelectionGranularityParagraph,
    3 => NSTextSelectionGranularityLine,
    4 => NSTextSelectionGranularitySentence,
    _ => throw ArgumentError(
      'Unknown value for NSTextSelectionGranularity: $value',
    ),
  };
}

enum NSTextSelectionAffinity {
  NSTextSelectionAffinityUpstream(0),
  NSTextSelectionAffinityDownstream(1);

  final int value;
  const NSTextSelectionAffinity(this.value);

  static NSTextSelectionAffinity fromValue(int value) => switch (value) {
    0 => NSTextSelectionAffinityUpstream,
    1 => NSTextSelectionAffinityDownstream,
    _ => throw ArgumentError(
      'Unknown value for NSTextSelectionAffinity: $value',
    ),
  };
}

enum NSTextSelectionNavigationDirection {
  NSTextSelectionNavigationDirectionForward(0),
  NSTextSelectionNavigationDirectionBackward(1),
  NSTextSelectionNavigationDirectionRight(2),
  NSTextSelectionNavigationDirectionLeft(3),
  NSTextSelectionNavigationDirectionUp(4),
  NSTextSelectionNavigationDirectionDown(5);

  final int value;
  const NSTextSelectionNavigationDirection(this.value);

  static NSTextSelectionNavigationDirection fromValue(int value) =>
      switch (value) {
        0 => NSTextSelectionNavigationDirectionForward,
        1 => NSTextSelectionNavigationDirectionBackward,
        2 => NSTextSelectionNavigationDirectionRight,
        3 => NSTextSelectionNavigationDirectionLeft,
        4 => NSTextSelectionNavigationDirectionUp,
        5 => NSTextSelectionNavigationDirectionDown,
        _ => throw ArgumentError(
          'Unknown value for NSTextSelectionNavigationDirection: $value',
        ),
      };
}

enum NSTextSelectionNavigationDestination {
  NSTextSelectionNavigationDestinationCharacter(0),
  NSTextSelectionNavigationDestinationWord(1),
  NSTextSelectionNavigationDestinationLine(2),
  NSTextSelectionNavigationDestinationSentence(3),
  NSTextSelectionNavigationDestinationParagraph(4),
  NSTextSelectionNavigationDestinationContainer(5),
  NSTextSelectionNavigationDestinationDocument(6);

  final int value;
  const NSTextSelectionNavigationDestination(this.value);

  static NSTextSelectionNavigationDestination fromValue(int value) =>
      switch (value) {
        0 => NSTextSelectionNavigationDestinationCharacter,
        1 => NSTextSelectionNavigationDestinationWord,
        2 => NSTextSelectionNavigationDestinationLine,
        3 => NSTextSelectionNavigationDestinationSentence,
        4 => NSTextSelectionNavigationDestinationParagraph,
        5 => NSTextSelectionNavigationDestinationContainer,
        6 => NSTextSelectionNavigationDestinationDocument,
        _ => throw ArgumentError(
          'Unknown value for NSTextSelectionNavigationDestination: $value',
        ),
      };
}

sealed class NSTextSelectionNavigationModifier {
  static const NSTextSelectionNavigationModifierExtend = 1;
  static const NSTextSelectionNavigationModifierVisual = 2;
  static const NSTextSelectionNavigationModifierMultiple = 4;
}

enum NSTextSelectionNavigationWritingDirection {
  NSTextSelectionNavigationWritingDirectionLeftToRight(0),
  NSTextSelectionNavigationWritingDirectionRightToLeft(1);

  final int value;
  const NSTextSelectionNavigationWritingDirection(this.value);

  static NSTextSelectionNavigationWritingDirection fromValue(int value) =>
      switch (value) {
        0 => NSTextSelectionNavigationWritingDirectionLeftToRight,
        1 => NSTextSelectionNavigationWritingDirectionRightToLeft,
        _ => throw ArgumentError(
          'Unknown value for NSTextSelectionNavigationWritingDirection: $value',
        ),
      };
}

enum NSTextSelectionNavigationLayoutOrientation {
  NSTextSelectionNavigationLayoutOrientationHorizontal(0),
  NSTextSelectionNavigationLayoutOrientationVertical(1);

  final int value;
  const NSTextSelectionNavigationLayoutOrientation(this.value);

  static NSTextSelectionNavigationLayoutOrientation fromValue(
    int value,
  ) => switch (value) {
    0 => NSTextSelectionNavigationLayoutOrientationHorizontal,
    1 => NSTextSelectionNavigationLayoutOrientationVertical,
    _ => throw ArgumentError(
      'Unknown value for NSTextSelectionNavigationLayoutOrientation: $value',
    ),
  };
}

sealed class NSTextContentManagerEnumerationOptions {
  static const NSTextContentManagerEnumerationOptionsNone = 0;
  static const NSTextContentManagerEnumerationOptionsReverse = 1;
}

sealed class NSTextLayoutFragmentEnumerationOptions {
  static const NSTextLayoutFragmentEnumerationOptionsNone = 0;
  static const NSTextLayoutFragmentEnumerationOptionsReverse = 1;
  static const NSTextLayoutFragmentEnumerationOptionsEstimatesSize = 2;
  static const NSTextLayoutFragmentEnumerationOptionsEnsuresLayout = 4;
  static const NSTextLayoutFragmentEnumerationOptionsEnsuresExtraLineFragment =
      8;
}

enum NSTextLayoutFragmentState {
  NSTextLayoutFragmentStateNone(0),
  NSTextLayoutFragmentStateEstimatedUsageBounds(1),
  NSTextLayoutFragmentStateCalculatedUsageBounds(2),
  NSTextLayoutFragmentStateLayoutAvailable(3);

  final int value;
  const NSTextLayoutFragmentState(this.value);

  static NSTextLayoutFragmentState fromValue(int value) => switch (value) {
    0 => NSTextLayoutFragmentStateNone,
    1 => NSTextLayoutFragmentStateEstimatedUsageBounds,
    2 => NSTextLayoutFragmentStateCalculatedUsageBounds,
    3 => NSTextLayoutFragmentStateLayoutAvailable,
    _ => throw ArgumentError(
      'Unknown value for NSTextLayoutFragmentState: $value',
    ),
  };
}

enum NSTextLayoutManagerSegmentType {
  NSTextLayoutManagerSegmentTypeStandard(0),
  NSTextLayoutManagerSegmentTypeSelection(1),
  NSTextLayoutManagerSegmentTypeHighlight(2);

  final int value;
  const NSTextLayoutManagerSegmentType(this.value);

  static NSTextLayoutManagerSegmentType fromValue(int value) => switch (value) {
    0 => NSTextLayoutManagerSegmentTypeStandard,
    1 => NSTextLayoutManagerSegmentTypeSelection,
    2 => NSTextLayoutManagerSegmentTypeHighlight,
    _ => throw ArgumentError(
      'Unknown value for NSTextLayoutManagerSegmentType: $value',
    ),
  };
}

sealed class NSTextLayoutManagerSegmentOptions {
  static const NSTextLayoutManagerSegmentOptionsNone = 0;
  static const NSTextLayoutManagerSegmentOptionsRangeNotRequired = 1;
  static const NSTextLayoutManagerSegmentOptionsMiddleFragmentsExcluded = 2;
  static const NSTextLayoutManagerSegmentOptionsHeadSegmentExtended = 4;
  static const NSTextLayoutManagerSegmentOptionsTailSegmentExtended = 8;
  static const NSTextLayoutManagerSegmentOptionsUpstreamAffinity = 16;
}

enum NSWritingToolsCoordinatorTextUpdateReason {
  NSWritingToolsCoordinatorTextUpdateReasonTyping(0),
  NSWritingToolsCoordinatorTextUpdateReasonUndoRedo(1);

  final int value;
  const NSWritingToolsCoordinatorTextUpdateReason(this.value);

  static NSWritingToolsCoordinatorTextUpdateReason fromValue(int value) =>
      switch (value) {
        0 => NSWritingToolsCoordinatorTextUpdateReasonTyping,
        1 => NSWritingToolsCoordinatorTextUpdateReasonUndoRedo,
        _ => throw ArgumentError(
          'Unknown value for NSWritingToolsCoordinatorTextUpdateReason: $value',
        ),
      };
}

enum NSWritingToolsCoordinatorState {
  NSWritingToolsCoordinatorStateInactive(0),
  NSWritingToolsCoordinatorStateNoninteractive(1),
  NSWritingToolsCoordinatorStateInteractiveResting(2),
  NSWritingToolsCoordinatorStateInteractiveStreaming(3);

  final int value;
  const NSWritingToolsCoordinatorState(this.value);

  static NSWritingToolsCoordinatorState fromValue(int value) => switch (value) {
    0 => NSWritingToolsCoordinatorStateInactive,
    1 => NSWritingToolsCoordinatorStateNoninteractive,
    2 => NSWritingToolsCoordinatorStateInteractiveResting,
    3 => NSWritingToolsCoordinatorStateInteractiveStreaming,
    _ => throw ArgumentError(
      'Unknown value for NSWritingToolsCoordinatorState: $value',
    ),
  };
}

enum NSWritingToolsCoordinatorTextReplacementReason {
  NSWritingToolsCoordinatorTextReplacementReasonInteractive(0),
  NSWritingToolsCoordinatorTextReplacementReasonNoninteractive(1);

  final int value;
  const NSWritingToolsCoordinatorTextReplacementReason(this.value);

  static NSWritingToolsCoordinatorTextReplacementReason fromValue(
    int value,
  ) => switch (value) {
    0 => NSWritingToolsCoordinatorTextReplacementReasonInteractive,
    1 => NSWritingToolsCoordinatorTextReplacementReasonNoninteractive,
    _ => throw ArgumentError(
      'Unknown value for NSWritingToolsCoordinatorTextReplacementReason: $value',
    ),
  };
}

enum NSWritingToolsCoordinatorContextScope {
  NSWritingToolsCoordinatorContextScopeUserSelection(0),
  NSWritingToolsCoordinatorContextScopeFullDocument(1),
  NSWritingToolsCoordinatorContextScopeVisibleArea(2);

  final int value;
  const NSWritingToolsCoordinatorContextScope(this.value);

  static NSWritingToolsCoordinatorContextScope fromValue(int value) =>
      switch (value) {
        0 => NSWritingToolsCoordinatorContextScopeUserSelection,
        1 => NSWritingToolsCoordinatorContextScopeFullDocument,
        2 => NSWritingToolsCoordinatorContextScopeVisibleArea,
        _ => throw ArgumentError(
          'Unknown value for NSWritingToolsCoordinatorContextScope: $value',
        ),
      };
}

enum NSWritingToolsCoordinatorTextAnimation {
  NSWritingToolsCoordinatorTextAnimationAnticipate(0),
  NSWritingToolsCoordinatorTextAnimationRemove(1),
  NSWritingToolsCoordinatorTextAnimationInsert(2),
  NSWritingToolsCoordinatorTextAnimationAnticipateInactive(8),
  NSWritingToolsCoordinatorTextAnimationTranslate(9);

  final int value;
  const NSWritingToolsCoordinatorTextAnimation(this.value);

  static NSWritingToolsCoordinatorTextAnimation fromValue(int value) =>
      switch (value) {
        0 => NSWritingToolsCoordinatorTextAnimationAnticipate,
        1 => NSWritingToolsCoordinatorTextAnimationRemove,
        2 => NSWritingToolsCoordinatorTextAnimationInsert,
        8 => NSWritingToolsCoordinatorTextAnimationAnticipateInactive,
        9 => NSWritingToolsCoordinatorTextAnimationTranslate,
        _ => throw ArgumentError(
          'Unknown value for NSWritingToolsCoordinatorTextAnimation: $value',
        ),
      };
}

late final _class_WKWebView = objc.getClass("WKWebView");
late final _class_WKWebViewConfiguration = objc.getClass(
  "WKWebViewConfiguration",
);

/// WARNING: WKProcessPool is a stub. To generate bindings for this class, include
/// WKProcessPool in your config's objc-interfaces list.
///
/// WKProcessPool
extension type WKProcessPool._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSSecureCoding {
  /// Constructs a [WKProcessPool] that points to the same underlying object as [other].
  WKProcessPool.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKProcessPool',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }

  /// Constructs a [WKProcessPool] that wraps the given raw object pointer.
  WKProcessPool.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKProcessPool',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }
}

late final _sel_processPool = objc.registerName("processPool");
late final _sel_setProcessPool_ = objc.registerName("setProcessPool:");

/// WARNING: WKPreferences is a stub. To generate bindings for this class, include
/// WKPreferences in your config's objc-interfaces list.
///
/// WKPreferences
extension type WKPreferences._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSSecureCoding {
  /// Constructs a [WKPreferences] that points to the same underlying object as [other].
  WKPreferences.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKPreferences',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }

  /// Constructs a [WKPreferences] that wraps the given raw object pointer.
  WKPreferences.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKPreferences',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }
}

late final _sel_preferences = objc.registerName("preferences");
late final _sel_setPreferences_ = objc.registerName("setPreferences:");

/// WARNING: WKUserContentController is a stub. To generate bindings for this class, include
/// WKUserContentController in your config's objc-interfaces list.
///
/// WKUserContentController
extension type WKUserContentController._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSSecureCoding {
  /// Constructs a [WKUserContentController] that points to the same underlying object as [other].
  WKUserContentController.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKUserContentController',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }

  /// Constructs a [WKUserContentController] that wraps the given raw object pointer.
  WKUserContentController.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKUserContentController',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }
}

late final _sel_userContentController = objc.registerName(
  "userContentController",
);
late final _sel_setUserContentController_ = objc.registerName(
  "setUserContentController:",
);

/// WARNING: WKWebExtensionController is a stub. To generate bindings for this class, include
/// WKWebExtensionController in your config's objc-interfaces list.
///
/// WKWebExtensionController
extension type WKWebExtensionController._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [WKWebExtensionController] that points to the same underlying object as [other].
  WKWebExtensionController.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKWebExtensionController',
      iOS: (false, (18, 4, 0)),
      macOS: (false, (15, 4, 0)),
    );
  }

  /// Constructs a [WKWebExtensionController] that wraps the given raw object pointer.
  WKWebExtensionController.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKWebExtensionController',
      iOS: (false, (18, 4, 0)),
      macOS: (false, (15, 4, 0)),
    );
  }
}

late final _sel_webExtensionController = objc.registerName(
  "webExtensionController",
);
late final _sel_setWebExtensionController_ = objc.registerName(
  "setWebExtensionController:",
);

/// WARNING: WKWebsiteDataStore is a stub. To generate bindings for this class, include
/// WKWebsiteDataStore in your config's objc-interfaces list.
///
/// WKWebsiteDataStore
extension type WKWebsiteDataStore._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSSecureCoding {
  /// Constructs a [WKWebsiteDataStore] that points to the same underlying object as [other].
  WKWebsiteDataStore.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKWebsiteDataStore',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }

  /// Constructs a [WKWebsiteDataStore] that wraps the given raw object pointer.
  WKWebsiteDataStore.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKWebsiteDataStore',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }
}

late final _sel_websiteDataStore = objc.registerName("websiteDataStore");
late final _sel_setWebsiteDataStore_ = objc.registerName(
  "setWebsiteDataStore:",
);
late final _sel_suppressesIncrementalRendering = objc.registerName(
  "suppressesIncrementalRendering",
);
late final _sel_setSuppressesIncrementalRendering_ = objc.registerName(
  "setSuppressesIncrementalRendering:",
);
late final _sel_applicationNameForUserAgent = objc.registerName(
  "applicationNameForUserAgent",
);
late final _sel_setApplicationNameForUserAgent_ = objc.registerName(
  "setApplicationNameForUserAgent:",
);
late final _sel_allowsAirPlayForMediaPlayback = objc.registerName(
  "allowsAirPlayForMediaPlayback",
);
late final _sel_setAllowsAirPlayForMediaPlayback_ = objc.registerName(
  "setAllowsAirPlayForMediaPlayback:",
);
late final _sel_showsSystemScreenTimeBlockingView = objc.registerName(
  "showsSystemScreenTimeBlockingView",
);
late final _sel_setShowsSystemScreenTimeBlockingView_ = objc.registerName(
  "setShowsSystemScreenTimeBlockingView:",
);
late final _sel_upgradeKnownHostsToHTTPS = objc.registerName(
  "upgradeKnownHostsToHTTPS",
);
late final _sel_setUpgradeKnownHostsToHTTPS_ = objc.registerName(
  "setUpgradeKnownHostsToHTTPS:",
);

sealed class WKAudiovisualMediaTypes {
  static const WKAudiovisualMediaTypeNone = 0;
  static const WKAudiovisualMediaTypeAudio = 1;
  static const WKAudiovisualMediaTypeVideo = 2;
  static const WKAudiovisualMediaTypeAll = -1;
}

late final _sel_mediaTypesRequiringUserActionForPlayback = objc.registerName(
  "mediaTypesRequiringUserActionForPlayback",
);
final _objc_msgSend_qtd8pu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setMediaTypesRequiringUserActionForPlayback_ = objc
    .registerName("setMediaTypesRequiringUserActionForPlayback:");
final _objc_msgSend_jrlv5k = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// WARNING: WKWebpagePreferences is a stub. To generate bindings for this class, include
/// WKWebpagePreferences in your config's objc-interfaces list.
///
/// WKWebpagePreferences
extension type WKWebpagePreferences._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [WKWebpagePreferences] that points to the same underlying object as [other].
  WKWebpagePreferences.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKWebpagePreferences',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
  }

  /// Constructs a [WKWebpagePreferences] that wraps the given raw object pointer.
  WKWebpagePreferences.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKWebpagePreferences',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
  }
}

late final _sel_defaultWebpagePreferences = objc.registerName(
  "defaultWebpagePreferences",
);
late final _sel_setDefaultWebpagePreferences_ = objc.registerName(
  "setDefaultWebpagePreferences:",
);
late final _sel_limitsNavigationsToAppBoundDomains = objc.registerName(
  "limitsNavigationsToAppBoundDomains",
);
late final _sel_setLimitsNavigationsToAppBoundDomains_ = objc.registerName(
  "setLimitsNavigationsToAppBoundDomains:",
);
late final _sel_allowsInlinePredictions = objc.registerName(
  "allowsInlinePredictions",
);
late final _sel_setAllowsInlinePredictions_ = objc.registerName(
  "setAllowsInlinePredictions:",
);

enum WKUserInterfaceDirectionPolicy {
  WKUserInterfaceDirectionPolicyContent(0),
  WKUserInterfaceDirectionPolicySystem(1);

  final int value;
  const WKUserInterfaceDirectionPolicy(this.value);

  static WKUserInterfaceDirectionPolicy fromValue(int value) => switch (value) {
    0 => WKUserInterfaceDirectionPolicyContent,
    1 => WKUserInterfaceDirectionPolicySystem,
    _ => throw ArgumentError(
      'Unknown value for WKUserInterfaceDirectionPolicy: $value',
    ),
  };
}

late final _sel_userInterfaceDirectionPolicy = objc.registerName(
  "userInterfaceDirectionPolicy",
);
final _objc_msgSend_1rk956u = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setUserInterfaceDirectionPolicy_ = objc.registerName(
  "setUserInterfaceDirectionPolicy:",
);
final _objc_msgSend_3z6ts = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// WARNING: WKURLSchemeHandler is a stub. To generate bindings for this class, include
/// WKURLSchemeHandler in your config's objc-protocols list.
///
/// WKURLSchemeHandler
extension type WKURLSchemeHandler._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [WKURLSchemeHandler] that points to the same underlying object as [other].
  WKURLSchemeHandler.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [WKURLSchemeHandler] that wraps the given raw object pointer.
  WKURLSchemeHandler.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_setURLSchemeHandler_forURLScheme_ = objc.registerName(
  "setURLSchemeHandler:forURLScheme:",
);
late final _sel_urlSchemeHandlerForURLScheme_ = objc.registerName(
  "urlSchemeHandlerForURLScheme:",
);
late final _sel_supportsAdaptiveImageGlyph = objc.registerName(
  "supportsAdaptiveImageGlyph",
);
late final _sel_setSupportsAdaptiveImageGlyph_ = objc.registerName(
  "setSupportsAdaptiveImageGlyph:",
);
late final _sel_writingToolsBehavior = objc.registerName(
  "writingToolsBehavior",
);
final _objc_msgSend_1i5rhvn = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setWritingToolsBehavior_ = objc.registerName(
  "setWritingToolsBehavior:",
);
final _objc_msgSend_14jprsr = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// WKWebViewConfiguration
extension type WKWebViewConfiguration._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSSecureCoding,
        objc.NSCopying {
  /// Constructs a [WKWebViewConfiguration] that points to the same underlying object as [other].
  WKWebViewConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [WKWebViewConfiguration] that wraps the given raw object pointer.
  WKWebViewConfiguration.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [WKWebViewConfiguration].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_WKWebViewConfiguration,
  );

  /// alloc
  static WKWebViewConfiguration alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_WKWebViewConfiguration,
      _sel_alloc,
    );
    return WKWebViewConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static WKWebViewConfiguration allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_WKWebViewConfiguration,
      _sel_allocWithZone_,
      zone,
    );
    return WKWebViewConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static WKWebViewConfiguration new$() {
    final $ret = _objc_msgSend_151sglz(_class_WKWebViewConfiguration, _sel_new);
    return WKWebViewConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
      _class_WKWebViewConfiguration,
      _sel_supportsSecureCoding,
    );
  }

  /// Returns a new instance of WKWebViewConfiguration constructed with the default `new` method.
  WKWebViewConfiguration() : this.as(new$().object$);
}

extension WKWebViewConfiguration$Methods on WKWebViewConfiguration {
  /// allowsAirPlayForMediaPlayback
  bool get allowsAirPlayForMediaPlayback {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.allowsAirPlayForMediaPlayback',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowsAirPlayForMediaPlayback,
    );
  }

  /// allowsInlinePredictions
  bool get allowsInlinePredictions {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.allowsInlinePredictions',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowsInlinePredictions,
    );
  }

  /// applicationNameForUserAgent
  objc.NSString? get applicationNameForUserAgent {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.applicationNameForUserAgent',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_applicationNameForUserAgent,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// defaultWebpagePreferences
  WKWebpagePreferences get defaultWebpagePreferences {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.defaultWebpagePreferences',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_defaultWebpagePreferences,
    );
    return WKWebpagePreferences.fromPointer($ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// init
  WKWebViewConfiguration init() {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return WKWebViewConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCoder:
  WKWebViewConfiguration? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : WKWebViewConfiguration.fromPointer(
            $ret,
            retain: false,
            release: true,
          );
  }

  /// limitsNavigationsToAppBoundDomains
  bool get limitsNavigationsToAppBoundDomains {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.limitsNavigationsToAppBoundDomains',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_limitsNavigationsToAppBoundDomains,
    );
  }

  /// mediaTypesRequiringUserActionForPlayback
  int get mediaTypesRequiringUserActionForPlayback {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.mediaTypesRequiringUserActionForPlayback',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
    return _objc_msgSend_qtd8pu(
      object$.ref.pointer,
      _sel_mediaTypesRequiringUserActionForPlayback,
    );
  }

  /// preferences
  WKPreferences get preferences {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.preferences',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_preferences);
    return WKPreferences.fromPointer($ret, retain: true, release: true);
  }

  /// processPool
  WKProcessPool get processPool {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.processPool',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_processPool);
    return WKProcessPool.fromPointer($ret, retain: true, release: true);
  }

  /// setAllowsAirPlayForMediaPlayback:
  set allowsAirPlayForMediaPlayback(bool value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setAllowsAirPlayForMediaPlayback:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAllowsAirPlayForMediaPlayback_,
      value,
    );
  }

  /// setAllowsInlinePredictions:
  set allowsInlinePredictions(bool value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setAllowsInlinePredictions:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAllowsInlinePredictions_,
      value,
    );
  }

  /// setApplicationNameForUserAgent:
  set applicationNameForUserAgent(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setApplicationNameForUserAgent:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setApplicationNameForUserAgent_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setDefaultWebpagePreferences:
  set defaultWebpagePreferences(WKWebpagePreferences value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setDefaultWebpagePreferences:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setDefaultWebpagePreferences_,
      value.ref.pointer,
    );
  }

  /// setLimitsNavigationsToAppBoundDomains:
  set limitsNavigationsToAppBoundDomains(bool value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setLimitsNavigationsToAppBoundDomains:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setLimitsNavigationsToAppBoundDomains_,
      value,
    );
  }

  /// setMediaTypesRequiringUserActionForPlayback:
  set mediaTypesRequiringUserActionForPlayback(int value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setMediaTypesRequiringUserActionForPlayback:',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
    _objc_msgSend_jrlv5k(
      object$.ref.pointer,
      _sel_setMediaTypesRequiringUserActionForPlayback_,
      value,
    );
  }

  /// setPreferences:
  set preferences(WKPreferences value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setPreferences:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setPreferences_,
      value.ref.pointer,
    );
  }

  /// setProcessPool:
  set processPool(WKProcessPool value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setProcessPool:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setProcessPool_,
      value.ref.pointer,
    );
  }

  /// setShowsSystemScreenTimeBlockingView:
  set showsSystemScreenTimeBlockingView(bool value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setShowsSystemScreenTimeBlockingView:',
      iOS: (false, (26, 0, 0)),
      macOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setShowsSystemScreenTimeBlockingView_,
      value,
    );
  }

  /// setSupportsAdaptiveImageGlyph:
  set supportsAdaptiveImageGlyph(bool value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setSupportsAdaptiveImageGlyph:',
      iOS: (false, (18, 0, 0)),
      macOS: (false, (15, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setSupportsAdaptiveImageGlyph_,
      value,
    );
  }

  /// setSuppressesIncrementalRendering:
  set suppressesIncrementalRendering(bool value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setSuppressesIncrementalRendering:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setSuppressesIncrementalRendering_,
      value,
    );
  }

  /// setURLSchemeHandler:forURLScheme:
  void setURLSchemeHandler(
    WKURLSchemeHandler? urlSchemeHandler, {
    required objc.NSString forURLScheme,
  }) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setURLSchemeHandler:forURLScheme:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_setURLSchemeHandler_forURLScheme_,
      urlSchemeHandler?.ref.pointer ?? ffi.nullptr,
      forURLScheme.ref.pointer,
    );
  }

  /// setUpgradeKnownHostsToHTTPS:
  set upgradeKnownHostsToHTTPS(bool value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setUpgradeKnownHostsToHTTPS:',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setUpgradeKnownHostsToHTTPS_,
      value,
    );
  }

  /// setUserContentController:
  set userContentController(WKUserContentController value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setUserContentController:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setUserContentController_,
      value.ref.pointer,
    );
  }

  /// setUserInterfaceDirectionPolicy:
  set userInterfaceDirectionPolicy(WKUserInterfaceDirectionPolicy value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setUserInterfaceDirectionPolicy:',
      macOS: (false, (10, 12, 0)),
    );
    _objc_msgSend_3z6ts(
      object$.ref.pointer,
      _sel_setUserInterfaceDirectionPolicy_,
      value.value,
    );
  }

  /// setWebExtensionController:
  set webExtensionController(WKWebExtensionController? value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setWebExtensionController:',
      iOS: (false, (18, 4, 0)),
      macOS: (false, (15, 4, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setWebExtensionController_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setWebsiteDataStore:
  set websiteDataStore(WKWebsiteDataStore value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setWebsiteDataStore:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setWebsiteDataStore_,
      value.ref.pointer,
    );
  }

  /// setWritingToolsBehavior:
  set writingToolsBehavior(NSWritingToolsBehavior value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setWritingToolsBehavior:',
      macOS: (false, (15, 0, 0)),
    );
    _objc_msgSend_14jprsr(
      object$.ref.pointer,
      _sel_setWritingToolsBehavior_,
      value.value,
    );
  }

  /// showsSystemScreenTimeBlockingView
  bool get showsSystemScreenTimeBlockingView {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.showsSystemScreenTimeBlockingView',
      iOS: (false, (26, 0, 0)),
      macOS: (false, (26, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_showsSystemScreenTimeBlockingView,
    );
  }

  /// supportsAdaptiveImageGlyph
  bool get supportsAdaptiveImageGlyph {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.supportsAdaptiveImageGlyph',
      iOS: (false, (18, 0, 0)),
      macOS: (false, (15, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_supportsAdaptiveImageGlyph,
    );
  }

  /// suppressesIncrementalRendering
  bool get suppressesIncrementalRendering {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.suppressesIncrementalRendering',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_suppressesIncrementalRendering,
    );
  }

  /// upgradeKnownHostsToHTTPS
  bool get upgradeKnownHostsToHTTPS {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.upgradeKnownHostsToHTTPS',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_upgradeKnownHostsToHTTPS,
    );
  }

  /// urlSchemeHandlerForURLScheme:
  WKURLSchemeHandler? urlSchemeHandlerForURLScheme(objc.NSString urlScheme) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.urlSchemeHandlerForURLScheme:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_urlSchemeHandlerForURLScheme_,
      urlScheme.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : WKURLSchemeHandler.fromPointer($ret, retain: true, release: true);
  }

  /// userContentController
  WKUserContentController get userContentController {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.userContentController',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_userContentController,
    );
    return WKUserContentController.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// userInterfaceDirectionPolicy
  WKUserInterfaceDirectionPolicy get userInterfaceDirectionPolicy {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.userInterfaceDirectionPolicy',
      macOS: (false, (10, 12, 0)),
    );
    final $ret = _objc_msgSend_1rk956u(
      object$.ref.pointer,
      _sel_userInterfaceDirectionPolicy,
    );
    return WKUserInterfaceDirectionPolicy.fromValue($ret);
  }

  /// webExtensionController
  WKWebExtensionController? get webExtensionController {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.webExtensionController',
      iOS: (false, (18, 4, 0)),
      macOS: (false, (15, 4, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_webExtensionController,
    );
    return $ret.address == 0
        ? null
        : WKWebExtensionController.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// websiteDataStore
  WKWebsiteDataStore get websiteDataStore {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.websiteDataStore',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_websiteDataStore,
    );
    return WKWebsiteDataStore.fromPointer($ret, retain: true, release: true);
  }

  /// writingToolsBehavior
  NSWritingToolsBehavior get writingToolsBehavior {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.writingToolsBehavior',
      macOS: (false, (15, 0, 0)),
    );
    final $ret = _objc_msgSend_1i5rhvn(
      object$.ref.pointer,
      _sel_writingToolsBehavior,
    );
    return NSWritingToolsBehavior.fromValue($ret);
  }
}

late final _sel_configuration = objc.registerName("configuration");
late final _protocol_WKNavigationDelegate = objc.getProtocol(
  "WKNavigationDelegate",
);
late final _sel_conformsToProtocol_ = objc.registerName("conformsToProtocol:");
final _objc_msgSend_e3qsqz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCProtocolImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCProtocolImpl>,
      )
    >();

/// WARNING: WKNavigationAction is a stub. To generate bindings for this class, include
/// WKNavigationAction in your config's objc-interfaces list.
///
/// WKNavigationAction
extension type WKNavigationAction._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [WKNavigationAction] that points to the same underlying object as [other].
  WKNavigationAction.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKNavigationAction',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }

  /// Constructs a [WKNavigationAction] that wraps the given raw object pointer.
  WKNavigationAction.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKNavigationAction',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }
}

enum WKNavigationActionPolicy {
  WKNavigationActionPolicyCancel(0),
  WKNavigationActionPolicyAllow(1),
  WKNavigationActionPolicyDownload(2);

  final int value;
  const WKNavigationActionPolicy(this.value);

  static WKNavigationActionPolicy fromValue(int value) => switch (value) {
    0 => WKNavigationActionPolicyCancel,
    1 => WKNavigationActionPolicyAllow,
    2 => WKNavigationActionPolicyDownload,
    _ => throw ArgumentError(
      'Unknown value for WKNavigationActionPolicy: $value',
    ),
  };
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Long)>`.
abstract final class ObjCBlock_ffiVoid_WKNavigationActionPolicy {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Long arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> fromFunction(
    void Function(WKNavigationActionPolicy) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
    objc.newClosureBlock(
      _closureCallable,
      (int arg0) => fn(WKNavigationActionPolicy.fromValue(arg0)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> listener(
    void Function(WKNavigationActionPolicy) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (int arg0) => fn(WKNavigationActionPolicy.fromValue(arg0)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_108000h(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> blocking(
    void Function(WKNavigationActionPolicy) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (int arg0) => fn(WKNavigationActionPolicy.fromValue(arg0)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (int arg0) => fn(WKNavigationActionPolicy.fromValue(arg0)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_108000h(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
  ) {
    (objc.getBlockClosure(block) as void Function(int))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    int arg0,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(int))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Long arg0)>>()
      .asFunction<void Function(int)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
  ) => (objc.getBlockClosure(block) as void Function(int))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Long)>`.
extension ObjCBlock_ffiVoid_WKNavigationActionPolicy$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Long)> {
  void call(WKNavigationActionPolicy arg0) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Long arg0,
              )
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, int)>()(
        ref.pointer,
        arg0.value,
      );
}

late final _sel_webView_decidePolicyForNavigationAction_decisionHandler_ = objc
    .registerName("webView:decidePolicyForNavigationAction:decisionHandler:");
final _objc_msgSend_18qun1e = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NSWindow?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSWindow_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(NSWindow?, objc.NSError?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(NSWindow?, objc.NSError?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSWindow?, objc.NSError?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(NSWindow?, objc.NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NSWindow?, objc.NSError?)>
  fromFunction(
    void Function(NSWindow?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(NSWindow?, objc.NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : NSWindow.fromPointer(arg0, retain: true, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NSWindow?, objc.NSError?)> listener(
    void Function(NSWindow?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : NSWindow.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(NSWindow?, objc.NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(NSWindow?, objc.NSError?)> blocking(
    void Function(NSWindow?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : NSWindow.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : NSWindow.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(NSWindow?, objc.NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NSWindow?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSWindow_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(NSWindow?, objc.NSError?)> {
  void call(NSWindow? arg0, objc.NSError? arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObjectImpl> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0?.ref.pointer ?? ffi.nullptr,
        arg1?.ref.pointer ?? ffi.nullptr,
      );
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigationAction, objc.ObjCBlock<ffi.Void Function(ffi.Long)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_ffiVoidWKNavigationActionPolicy {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationAction,
          objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCBlockImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationAction,
          objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationAction,
          objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3,
          ) => fn(
            arg0,
            WKWebView.fromPointer(arg1, retain: true, release: true),
            WKNavigationAction.fromPointer(arg2, retain: true, release: true),
            ObjCBlock_ffiVoid_WKNavigationActionPolicy.fromPointer(
              arg3,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationAction.fromPointer(arg2, retain: false, release: true),
        ObjCBlock_ffiVoid_WKNavigationActionPolicy.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_bklti2(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigationAction,
        objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationAction.fromPointer(arg2, retain: false, release: true),
        ObjCBlock_ffiVoid_WKNavigationActionPolicy.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationAction.fromPointer(arg2, retain: false, release: true),
        ObjCBlock_ffiVoid_WKNavigationActionPolicy.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_bklti2(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigationAction,
        objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigationAction, objc.ObjCBlock<ffi.Void Function(ffi.Long)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_ffiVoidWKNavigationActionPolicy$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            WKWebView,
            WKNavigationAction,
            objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    WKWebView arg1,
    WKNavigationAction arg2,
    objc.ObjCBlock<ffi.Void Function(ffi.Long)> arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCBlockImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>`.
abstract final class ObjCBlock_ffiVoid_WKNavigationActionPolicy_WKWebpagePreferences {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Long arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>
  fromFunction(
    void Function(WKNavigationActionPolicy, WKWebpagePreferences) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>(
    objc.newClosureBlock(
      _closureCallable,
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        WKNavigationActionPolicy.fromValue(arg0),
        WKWebpagePreferences.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>
  listener(
    void Function(WKNavigationActionPolicy, WKWebpagePreferences) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        WKNavigationActionPolicy.fromValue(arg0),
        WKWebpagePreferences.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_d2nojr(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>
  blocking(
    void Function(WKNavigationActionPolicy, WKWebpagePreferences) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        WKNavigationActionPolicy.fromValue(arg0),
        WKWebpagePreferences.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        WKNavigationActionPolicy.fromValue(arg0),
        WKWebpagePreferences.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_d2nojr(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(int, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(int, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      block.ref.target
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Long arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<void Function(int, ffi.Pointer<objc.ObjCObjectImpl>)>()(
        arg0,
        arg1,
      );
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Long,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(int, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Long,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>`.
extension ObjCBlock_ffiVoid_WKNavigationActionPolicy_WKWebpagePreferences$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)> {
  void call(WKNavigationActionPolicy arg0, WKWebpagePreferences arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Long arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          int,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0.value, arg1.ref.pointer);
}

late final _sel_webView_decidePolicyForNavigationAction_preferences_decisionHandler_ =
    objc.registerName(
      "webView:decidePolicyForNavigationAction:preferences:decisionHandler:",
    );
final _objc_msgSend_m7tls4 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function()>`.
abstract final class ObjCBlock_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function()> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function()>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function()> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function()>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> fromFunction(
    void Function() fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function()>(
    objc.newClosureBlock(_closureCallable, () => fn(), keepIsolateAlive),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> listener(
    void Function() fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1pl9qdv(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function()>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function()> blocking(
    void Function() fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1pl9qdv(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function()>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block) {
    (objc.getBlockClosure(block) as void Function())();
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function())();
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block) => block
      .ref
      .target
      .cast<ffi.NativeFunction<ffi.Void Function()>>()
      .asFunction<void Function()>()();
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block) =>
      (objc.getBlockClosure(block) as void Function())();
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function()>`.
extension ObjCBlock_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Void Function()> {
  void call() =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block)
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>)>()(
        ref.pointer,
      );
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigationAction, WKWebpagePreferences, objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_WKWebpagePreferences_ffiVoidWKNavigationActionPolicyWKWebpagePreferences {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationAction,
          WKWebpagePreferences,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ffi.Pointer<objc.ObjCBlockImpl> arg4,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationAction,
          WKWebpagePreferences,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationAction,
          WKWebpagePreferences,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4,
          ) => fn(
            arg0,
            WKWebView.fromPointer(arg1, retain: true, release: true),
            WKNavigationAction.fromPointer(arg2, retain: true, release: true),
            WKWebpagePreferences.fromPointer(arg3, retain: true, release: true),
            ObjCBlock_ffiVoid_WKNavigationActionPolicy_WKWebpagePreferences.fromPointer(
              arg4,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationAction.fromPointer(arg2, retain: false, release: true),
        WKWebpagePreferences.fromPointer(arg3, retain: false, release: true),
        ObjCBlock_ffiVoid_WKNavigationActionPolicy_WKWebpagePreferences.fromPointer(
          arg4,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_xx612k(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigationAction,
        WKWebpagePreferences,
        objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationAction.fromPointer(arg2, retain: false, release: true),
        WKWebpagePreferences.fromPointer(arg3, retain: false, release: true),
        ObjCBlock_ffiVoid_WKNavigationActionPolicy_WKWebpagePreferences.fromPointer(
          arg4,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationAction.fromPointer(arg2, retain: false, release: true),
        WKWebpagePreferences.fromPointer(arg3, retain: false, release: true),
        ObjCBlock_ffiVoid_WKNavigationActionPolicy_WKWebpagePreferences.fromPointer(
          arg4,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_xx612k(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigationAction,
        WKWebpagePreferences,
        objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1, arg2, arg3, arg4);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3, arg4);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigationAction, WKWebpagePreferences, objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_WKWebpagePreferences_ffiVoidWKNavigationActionPolicyWKWebpagePreferences$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            WKWebView,
            WKNavigationAction,
            WKWebpagePreferences,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    WKWebView arg1,
    WKNavigationAction arg2,
    WKWebpagePreferences arg3,
    objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)> arg4,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
        arg4.ref.pointer,
      );
}

/// WARNING: WKNavigationResponse is a stub. To generate bindings for this class, include
/// WKNavigationResponse in your config's objc-interfaces list.
///
/// WKNavigationResponse
extension type WKNavigationResponse._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [WKNavigationResponse] that points to the same underlying object as [other].
  WKNavigationResponse.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKNavigationResponse',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }

  /// Constructs a [WKNavigationResponse] that wraps the given raw object pointer.
  WKNavigationResponse.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKNavigationResponse',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }
}

enum WKNavigationResponsePolicy {
  WKNavigationResponsePolicyCancel(0),
  WKNavigationResponsePolicyAllow(1),
  WKNavigationResponsePolicyDownload(2);

  final int value;
  const WKNavigationResponsePolicy(this.value);

  static WKNavigationResponsePolicy fromValue(int value) => switch (value) {
    0 => WKNavigationResponsePolicyCancel,
    1 => WKNavigationResponsePolicyAllow,
    2 => WKNavigationResponsePolicyDownload,
    _ => throw ArgumentError(
      'Unknown value for WKNavigationResponsePolicy: $value',
    ),
  };
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Long)>`.
abstract final class ObjCBlock_ffiVoid_WKNavigationResponsePolicy {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Long arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> fromFunction(
    void Function(WKNavigationResponsePolicy) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
    objc.newClosureBlock(
      _closureCallable,
      (int arg0) => fn(WKNavigationResponsePolicy.fromValue(arg0)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> listener(
    void Function(WKNavigationResponsePolicy) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (int arg0) => fn(WKNavigationResponsePolicy.fromValue(arg0)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1a5qge(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> blocking(
    void Function(WKNavigationResponsePolicy) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (int arg0) => fn(WKNavigationResponsePolicy.fromValue(arg0)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (int arg0) => fn(WKNavigationResponsePolicy.fromValue(arg0)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1a5qge(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
  ) {
    (objc.getBlockClosure(block) as void Function(int))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    int arg0,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(int))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Long arg0)>>()
      .asFunction<void Function(int)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
  ) => (objc.getBlockClosure(block) as void Function(int))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Long)>`.
extension ObjCBlock_ffiVoid_WKNavigationResponsePolicy$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Long)> {
  void call(WKNavigationResponsePolicy arg0) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Long arg0,
              )
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, int)>()(
        ref.pointer,
        arg0.value,
      );
}

late final _sel_webView_decidePolicyForNavigationResponse_decisionHandler_ =
    objc.registerName(
      "webView:decidePolicyForNavigationResponse:decisionHandler:",
    );

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigationResponse, objc.ObjCBlock<ffi.Void Function(ffi.Long)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationResponse_ffiVoidWKNavigationResponsePolicy {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationResponse,
          objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCBlockImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationResponse,
          objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationResponse,
          objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3,
          ) => fn(
            arg0,
            WKWebView.fromPointer(arg1, retain: true, release: true),
            WKNavigationResponse.fromPointer(arg2, retain: true, release: true),
            ObjCBlock_ffiVoid_WKNavigationResponsePolicy.fromPointer(
              arg3,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationResponse.fromPointer(arg2, retain: false, release: true),
        ObjCBlock_ffiVoid_WKNavigationResponsePolicy.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_bklti2(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigationResponse,
        objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationResponse.fromPointer(arg2, retain: false, release: true),
        ObjCBlock_ffiVoid_WKNavigationResponsePolicy.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationResponse.fromPointer(arg2, retain: false, release: true),
        ObjCBlock_ffiVoid_WKNavigationResponsePolicy.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_bklti2(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigationResponse,
        objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigationResponse, objc.ObjCBlock<ffi.Void Function(ffi.Long)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationResponse_ffiVoidWKNavigationResponsePolicy$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            WKWebView,
            WKNavigationResponse,
            objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    WKWebView arg1,
    WKNavigationResponse arg2,
    objc.ObjCBlock<ffi.Void Function(ffi.Long)> arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCBlockImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

/// WARNING: WKNavigation is a stub. To generate bindings for this class, include
/// WKNavigation in your config's objc-interfaces list.
///
/// WKNavigation
extension type WKNavigation._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [WKNavigation] that points to the same underlying object as [other].
  WKNavigation.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKNavigation',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }

  /// Constructs a [WKNavigation] that wraps the given raw object pointer.
  WKNavigation.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKNavigation',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }
}

late final _sel_webView_didStartProvisionalNavigation_ = objc.registerName(
  "webView:didStartProvisionalNavigation:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0,
            WKWebView.fromPointer(arg1, retain: true, release: true),
            WKNavigation.fromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigation.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigation.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigation.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_fjrv01(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)>`.
extension ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, WKWebView arg1, WKNavigation arg2) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_webView_didReceiveServerRedirectForProvisionalNavigation_ = objc
    .registerName("webView:didReceiveServerRedirectForProvisionalNavigation:");
late final _sel_webView_didFailProvisionalNavigation_withError_ = objc
    .registerName("webView:didFailProvisionalNavigation:withError:");
final _objc_msgSend_r8gdi7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation, objc.NSError)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigation,
      objc.NSError,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigation,
          objc.NSError,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigation,
      objc.NSError,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigation,
          objc.NSError,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigation,
      objc.NSError,
    )
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation, objc.NSError)
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigation,
          objc.NSError,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ) => fn(
            arg0,
            WKWebView.fromPointer(arg1, retain: true, release: true),
            WKNavigation.fromPointer(arg2, retain: true, release: true),
            objc.NSError.fromPointer(arg3, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigation,
      objc.NSError,
    )
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation, objc.NSError)
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigation.fromPointer(arg2, retain: false, release: true),
        objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigation,
        objc.NSError,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigation,
      objc.NSError,
    )
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation, objc.NSError)
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigation.fromPointer(arg2, retain: false, release: true),
        objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigation.fromPointer(arg2, retain: false, release: true),
        objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1tz5yf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigation,
        objc.NSError,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation, objc.NSError)>`.
extension ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            WKWebView,
            WKNavigation,
            objc.NSError,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    WKWebView arg1,
    WKNavigation arg2,
    objc.NSError arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

late final _sel_webView_didCommitNavigation_ = objc.registerName(
  "webView:didCommitNavigation:",
);
late final _sel_webView_didFinishNavigation_ = objc.registerName(
  "webView:didFinishNavigation:",
);
late final _sel_webView_didFailNavigation_withError_ = objc.registerName(
  "webView:didFailNavigation:withError:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>`.
abstract final class ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Long arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
  fromFunction(
    void Function(NSURLSessionAuthChallengeDisposition, NSURLCredential?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>(
    objc.newClosureBlock(
      _closureCallable,
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        NSURLSessionAuthChallengeDisposition.fromValue(arg0),
        arg1.address == 0
            ? null
            : NSURLCredential.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)> listener(
    void Function(NSURLSessionAuthChallengeDisposition, NSURLCredential?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        NSURLSessionAuthChallengeDisposition.fromValue(arg0),
        arg1.address == 0
            ? null
            : NSURLCredential.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_n8yd09(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)> blocking(
    void Function(NSURLSessionAuthChallengeDisposition, NSURLCredential?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        NSURLSessionAuthChallengeDisposition.fromValue(arg0),
        arg1.address == 0
            ? null
            : NSURLCredential.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        NSURLSessionAuthChallengeDisposition.fromValue(arg0),
        arg1.address == 0
            ? null
            : NSURLCredential.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_n8yd09(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(int, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(int, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      block.ref.target
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Long arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<void Function(int, ffi.Pointer<objc.ObjCObjectImpl>)>()(
        arg0,
        arg1,
      );
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Long,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(int, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Long,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>`.
extension ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)> {
  void call(NSURLSessionAuthChallengeDisposition arg0, NSURLCredential? arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Long arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              int,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(ref.pointer, arg0.value, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_webView_didReceiveAuthenticationChallenge_completionHandler_ =
    objc.registerName(
      "webView:didReceiveAuthenticationChallenge:completionHandler:",
    );

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_WKWebView_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCBlockImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3,
          ) => fn(
            arg0,
            WKWebView.fromPointer(arg1, retain: true, release: true),
            NSURLAuthenticationChallenge.fromPointer(
              arg2,
              retain: true,
              release: true,
            ),
            ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential.fromPointer(
              arg3,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        NSURLAuthenticationChallenge.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_bklti2(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        NSURLAuthenticationChallenge,
        objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        NSURLAuthenticationChallenge.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        NSURLAuthenticationChallenge.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_bklti2(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        NSURLAuthenticationChallenge,
        objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_WKWebView_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            WKWebView,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    WKWebView arg1,
    NSURLAuthenticationChallenge arg2,
    objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)> arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCBlockImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

late final _sel_webViewWebContentProcessDidTerminate_ = objc.registerName(
  "webViewWebContentProcessDidTerminate:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_WKWebView {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, WKWebView) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, WKWebView.fromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, WKWebView) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, WKWebView.fromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, WKWebView) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, WKWebView.fromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, WKWebView.fromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>`.
extension ObjCBlock_ffiVoid_ffiVoid_WKWebView$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)> {
  void call(ffi.Pointer<ffi.Void> arg0, WKWebView arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Bool)>`.
abstract final class ObjCBlock_ffiVoid_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> fromFunction(
    void Function(bool) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
    objc.newClosureBlock(
      _closureCallable,
      (bool arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> listener(
    void Function(bool) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (bool arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1s56lr9(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> blocking(
    void Function(bool) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (bool arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (bool arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1s56lr9(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    bool arg0,
  ) {
    (objc.getBlockClosure(block) as void Function(bool))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    bool arg0,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(bool))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Bool,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Bool,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Bool,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Bool,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    bool arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Bool arg0)>>()
      .asFunction<void Function(bool)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    bool arg0,
  ) => (objc.getBlockClosure(block) as void Function(bool))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Bool)>`.
extension ObjCBlock_ffiVoid_bool$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Bool)> {
  void call(bool arg0) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Bool arg0,
              )
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, bool)>()(
        ref.pointer,
        arg0,
      );
}

late final _sel_webView_authenticationChallenge_shouldAllowDeprecatedTLS_ = objc
    .registerName("webView:authenticationChallenge:shouldAllowDeprecatedTLS:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(ffi.Bool)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_WKWebView_NSURLAuthenticationChallenge_ffiVoidbool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCBlockImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3,
          ) => fn(
            arg0,
            WKWebView.fromPointer(arg1, retain: true, release: true),
            NSURLAuthenticationChallenge.fromPointer(
              arg2,
              retain: true,
              release: true,
            ),
            ObjCBlock_ffiVoid_bool.fromPointer(
              arg3,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        NSURLAuthenticationChallenge.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        ObjCBlock_ffiVoid_bool.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_bklti2(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        NSURLAuthenticationChallenge,
        objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        NSURLAuthenticationChallenge.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        ObjCBlock_ffiVoid_bool.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        NSURLAuthenticationChallenge.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        ObjCBlock_ffiVoid_bool.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_bklti2(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        NSURLAuthenticationChallenge,
        objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(ffi.Bool)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_WKWebView_NSURLAuthenticationChallenge_ffiVoidbool$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            WKWebView,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    WKWebView arg1,
    NSURLAuthenticationChallenge arg2,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)> arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCBlockImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

late final _sel_webView_navigationAction_didBecomeDownload_ = objc.registerName(
  "webView:navigationAction:didBecomeDownload:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigationAction, WKDownload)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_WKDownload {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKDownload,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationAction,
          WKDownload,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKDownload,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationAction,
          WKDownload,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKDownload,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKDownload,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationAction,
          WKDownload,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ) => fn(
            arg0,
            WKWebView.fromPointer(arg1, retain: true, release: true),
            WKNavigationAction.fromPointer(arg2, retain: true, release: true),
            WKDownload.fromPointer(arg3, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKDownload,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKDownload,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationAction.fromPointer(arg2, retain: false, release: true),
        WKDownload.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigationAction,
        WKDownload,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKDownload,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKDownload,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationAction.fromPointer(arg2, retain: false, release: true),
        WKDownload.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationAction.fromPointer(arg2, retain: false, release: true),
        WKDownload.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1tz5yf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigationAction,
        WKDownload,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigationAction, WKDownload)>`.
extension ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_WKDownload$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            WKWebView,
            WKNavigationAction,
            WKDownload,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    WKWebView arg1,
    WKNavigationAction arg2,
    WKDownload arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

late final _sel_webView_navigationResponse_didBecomeDownload_ = objc
    .registerName("webView:navigationResponse:didBecomeDownload:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigationResponse, WKDownload)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationResponse_WKDownload {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      WKDownload,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationResponse,
          WKDownload,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      WKDownload,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationResponse,
          WKDownload,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      WKDownload,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      WKDownload,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationResponse,
          WKDownload,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ) => fn(
            arg0,
            WKWebView.fromPointer(arg1, retain: true, release: true),
            WKNavigationResponse.fromPointer(arg2, retain: true, release: true),
            WKDownload.fromPointer(arg3, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      WKDownload,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      WKDownload,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationResponse.fromPointer(arg2, retain: false, release: true),
        WKDownload.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigationResponse,
        WKDownload,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      WKDownload,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      WKDownload,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationResponse.fromPointer(arg2, retain: false, release: true),
        WKDownload.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationResponse.fromPointer(arg2, retain: false, release: true),
        WKDownload.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1tz5yf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigationResponse,
        WKDownload,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigationResponse, WKDownload)>`.
extension ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationResponse_WKDownload$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            WKWebView,
            WKNavigationResponse,
            WKDownload,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    WKWebView arg1,
    WKNavigationResponse arg2,
    WKDownload arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

late final _sel_webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_ =
    objc.registerName(
      "webView:shouldGoToBackForwardListItem:willUseInstantBack:completionHandler:",
    );
final _objc_msgSend_1imhooq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Bool,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        bool,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKBackForwardListItem, ffi.Bool, objc.ObjCBlock<ffi.Void Function(ffi.Bool)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKBackForwardListItem_bool_ffiVoidbool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKBackForwardListItem,
      ffi.Bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKBackForwardListItem,
          ffi.Bool,
          objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKBackForwardListItem,
      ffi.Bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Bool arg3,
          ffi.Pointer<objc.ObjCBlockImpl> arg4,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKBackForwardListItem,
          ffi.Bool,
          objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKBackForwardListItem,
      ffi.Bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKBackForwardListItem,
      bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKBackForwardListItem,
          ffi.Bool,
          objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            bool arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4,
          ) => fn(
            arg0,
            WKWebView.fromPointer(arg1, retain: true, release: true),
            WKBackForwardListItem.fromPointer(
              arg2,
              retain: true,
              release: true,
            ),
            arg3,
            ObjCBlock_ffiVoid_bool.fromPointer(
              arg4,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKBackForwardListItem,
      ffi.Bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKBackForwardListItem,
      bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        bool arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKBackForwardListItem.fromPointer(arg2, retain: false, release: true),
        arg3,
        ObjCBlock_ffiVoid_bool.fromPointer(arg4, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_axwdf6(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKBackForwardListItem,
        ffi.Bool,
        objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKBackForwardListItem,
      ffi.Bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKBackForwardListItem,
      bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        bool arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKBackForwardListItem.fromPointer(arg2, retain: false, release: true),
        arg3,
        ObjCBlock_ffiVoid_bool.fromPointer(arg4, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        bool arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKBackForwardListItem.fromPointer(arg2, retain: false, release: true),
        arg3,
        ObjCBlock_ffiVoid_bool.fromPointer(arg4, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_axwdf6(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKBackForwardListItem,
        ffi.Bool,
        objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    bool arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          bool,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1, arg2, arg3, arg4);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Bool,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Bool,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    bool arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3, arg4);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Bool,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Bool,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Bool,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Bool,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    bool arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Bool arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          bool,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Bool,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    bool arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Bool,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKBackForwardListItem, ffi.Bool, objc.ObjCBlock<ffi.Void Function(ffi.Bool)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKBackForwardListItem_bool_ffiVoidbool$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            WKWebView,
            WKBackForwardListItem,
            ffi.Bool,
            objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    WKWebView arg1,
    WKBackForwardListItem arg2,
    bool arg3,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)> arg4,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Bool arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              bool,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3,
        arg4.ref.pointer,
      );
}

/// WKNavigationDelegate
extension type WKNavigationDelegate._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [WKNavigationDelegate] that points to the same underlying object as [other].
  WKNavigationDelegate.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [WKNavigationDelegate] that wraps the given raw object pointer.
  WKNavigationDelegate.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [WKNavigationDelegate].
  static bool conformsTo(objc.ObjCObject obj) {
    return _objc_msgSend_e3qsqz(
      obj.ref.pointer,
      _sel_conformsToProtocol_,
      _protocol_WKNavigationDelegate,
    );
  }
}

extension WKNavigationDelegate$Methods on WKNavigationDelegate {
  /// webView:authenticationChallenge:shouldAllowDeprecatedTLS:
  void webView(
    WKWebView webView, {
    required NSURLAuthenticationChallenge authenticationChallenge,
    required objc.ObjCBlock<ffi.Void Function(ffi.Bool)>
    shouldAllowDeprecatedTLS,
  }) {
    objc.checkOsVersionInternal(
      'WKNavigationDelegate.webView:authenticationChallenge:shouldAllowDeprecatedTLS:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:authenticationChallenge:shouldAllowDeprecatedTLS:',
      );
    }
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
      webView.ref.pointer,
      authenticationChallenge.ref.pointer,
      shouldAllowDeprecatedTLS.ref.pointer,
    );
  }

  /// webView:decidePolicyForNavigationAction:decisionHandler:
  void webView$1(
    WKWebView webView, {
    required WKNavigationAction decidePolicyForNavigationAction,
    required objc.ObjCBlock<ffi.Void Function(ffi.Long)> decisionHandler,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_decidePolicyForNavigationAction_decisionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:decidePolicyForNavigationAction:decisionHandler:',
      );
    }
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_webView_decidePolicyForNavigationAction_decisionHandler_,
      webView.ref.pointer,
      decidePolicyForNavigationAction.ref.pointer,
      decisionHandler.ref.pointer,
    );
  }

  /// webView:decidePolicyForNavigationAction:preferences:decisionHandler:
  void webView$2(
    WKWebView webView, {
    required WKNavigationAction decidePolicyForNavigationAction,
    required WKWebpagePreferences preferences,
    required objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>
    decisionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKNavigationDelegate.webView:decidePolicyForNavigationAction:preferences:decisionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:decidePolicyForNavigationAction:preferences:decisionHandler:',
      );
    }
    _objc_msgSend_m7tls4(
      object$.ref.pointer,
      _sel_webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
      webView.ref.pointer,
      decidePolicyForNavigationAction.ref.pointer,
      preferences.ref.pointer,
      decisionHandler.ref.pointer,
    );
  }

  /// webView:decidePolicyForNavigationResponse:decisionHandler:
  void webView$3(
    WKWebView webView, {
    required WKNavigationResponse decidePolicyForNavigationResponse,
    required objc.ObjCBlock<ffi.Void Function(ffi.Long)> decisionHandler,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_decidePolicyForNavigationResponse_decisionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:decidePolicyForNavigationResponse:decisionHandler:',
      );
    }
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_webView_decidePolicyForNavigationResponse_decisionHandler_,
      webView.ref.pointer,
      decidePolicyForNavigationResponse.ref.pointer,
      decisionHandler.ref.pointer,
    );
  }

  /// webView:didCommitNavigation:
  void webView$4(
    WKWebView webView, {
    required WKNavigation didCommitNavigation,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_didCommitNavigation_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:didCommitNavigation:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_webView_didCommitNavigation_,
      webView.ref.pointer,
      didCommitNavigation.ref.pointer,
    );
  }

  /// webView:didFailNavigation:withError:
  void webView$5(
    WKWebView webView, {
    required WKNavigation didFailNavigation,
    required objc.NSError withError,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_didFailNavigation_withError_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:didFailNavigation:withError:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_webView_didFailNavigation_withError_,
      webView.ref.pointer,
      didFailNavigation.ref.pointer,
      withError.ref.pointer,
    );
  }

  /// webView:didFailProvisionalNavigation:withError:
  void webView$6(
    WKWebView webView, {
    required WKNavigation didFailProvisionalNavigation,
    required objc.NSError withError,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_didFailProvisionalNavigation_withError_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:didFailProvisionalNavigation:withError:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_webView_didFailProvisionalNavigation_withError_,
      webView.ref.pointer,
      didFailProvisionalNavigation.ref.pointer,
      withError.ref.pointer,
    );
  }

  /// webView:didFinishNavigation:
  void webView$7(
    WKWebView webView, {
    required WKNavigation didFinishNavigation,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_didFinishNavigation_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:didFinishNavigation:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_webView_didFinishNavigation_,
      webView.ref.pointer,
      didFinishNavigation.ref.pointer,
    );
  }

  /// webView:didReceiveAuthenticationChallenge:completionHandler:
  void webView$8(
    WKWebView webView, {
    required NSURLAuthenticationChallenge didReceiveAuthenticationChallenge,
    required objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
    completionHandler,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_didReceiveAuthenticationChallenge_completionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:didReceiveAuthenticationChallenge:completionHandler:',
      );
    }
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_webView_didReceiveAuthenticationChallenge_completionHandler_,
      webView.ref.pointer,
      didReceiveAuthenticationChallenge.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// webView:didReceiveServerRedirectForProvisionalNavigation:
  void webView$9(
    WKWebView webView, {
    required WKNavigation didReceiveServerRedirectForProvisionalNavigation,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_didReceiveServerRedirectForProvisionalNavigation_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:didReceiveServerRedirectForProvisionalNavigation:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_webView_didReceiveServerRedirectForProvisionalNavigation_,
      webView.ref.pointer,
      didReceiveServerRedirectForProvisionalNavigation.ref.pointer,
    );
  }

  /// webView:didStartProvisionalNavigation:
  void webView$10(
    WKWebView webView, {
    required WKNavigation didStartProvisionalNavigation,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_didStartProvisionalNavigation_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:didStartProvisionalNavigation:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_webView_didStartProvisionalNavigation_,
      webView.ref.pointer,
      didStartProvisionalNavigation.ref.pointer,
    );
  }

  /// webView:navigationAction:didBecomeDownload:
  void webView$11(
    WKWebView webView, {
    required WKNavigationAction navigationAction,
    required WKDownload didBecomeDownload,
  }) {
    objc.checkOsVersionInternal(
      'WKNavigationDelegate.webView:navigationAction:didBecomeDownload:',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_navigationAction_didBecomeDownload_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:navigationAction:didBecomeDownload:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_webView_navigationAction_didBecomeDownload_,
      webView.ref.pointer,
      navigationAction.ref.pointer,
      didBecomeDownload.ref.pointer,
    );
  }

  /// webView:navigationResponse:didBecomeDownload:
  void webView$12(
    WKWebView webView, {
    required WKNavigationResponse navigationResponse,
    required WKDownload didBecomeDownload,
  }) {
    objc.checkOsVersionInternal(
      'WKNavigationDelegate.webView:navigationResponse:didBecomeDownload:',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_navigationResponse_didBecomeDownload_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:navigationResponse:didBecomeDownload:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_webView_navigationResponse_didBecomeDownload_,
      webView.ref.pointer,
      navigationResponse.ref.pointer,
      didBecomeDownload.ref.pointer,
    );
  }

  /// webView:shouldGoToBackForwardListItem:willUseInstantBack:completionHandler:
  void webView$13(
    WKWebView webView, {
    required WKBackForwardListItem shouldGoToBackForwardListItem,
    required bool willUseInstantBack,
    required objc.ObjCBlock<ffi.Void Function(ffi.Bool)> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKNavigationDelegate.webView:shouldGoToBackForwardListItem:willUseInstantBack:completionHandler:',
      iOS: (false, (26, 0, 0)),
      macOS: (false, (26, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:shouldGoToBackForwardListItem:willUseInstantBack:completionHandler:',
      );
    }
    _objc_msgSend_1imhooq(
      object$.ref.pointer,
      _sel_webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
      webView.ref.pointer,
      shouldGoToBackForwardListItem.ref.pointer,
      willUseInstantBack,
      completionHandler.ref.pointer,
    );
  }

  /// webViewWebContentProcessDidTerminate:
  void webViewWebContentProcessDidTerminate(WKWebView webView) {
    objc.checkOsVersionInternal(
      'WKNavigationDelegate.webViewWebContentProcessDidTerminate:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webViewWebContentProcessDidTerminate_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webViewWebContentProcessDidTerminate:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_webViewWebContentProcessDidTerminate_,
      webView.ref.pointer,
    );
  }
}

interface class WKNavigationDelegate$Builder {
  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.fromPointer(_protocol_WKNavigationDelegate.cast());

  /// Builds an object that implements the WKNavigationDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static WKNavigationDelegate implement({
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
    void Function(
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationAction_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )?
    webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationResponse_decisionHandler_,
    void Function(WKWebView, WKNavigation)? webView_didCommitNavigation_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailNavigation_withError_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailProvisionalNavigation_withError_,
    void Function(WKWebView, WKNavigation)? webView_didFinishNavigation_,
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    webView_didReceiveAuthenticationChallenge_completionHandler_,
    void Function(WKWebView, WKNavigation)?
    webView_didReceiveServerRedirectForProvisionalNavigation_,
    void Function(WKWebView, WKNavigation)?
    webView_didStartProvisionalNavigation_,
    void Function(WKWebView, WKNavigationAction, WKDownload)?
    webView_navigationAction_didBecomeDownload_,
    void Function(WKWebView, WKNavigationResponse, WKDownload)?
    webView_navigationResponse_didBecomeDownload_,
    void Function(
      WKWebView,
      WKBackForwardListItem,
      bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
    void Function(WKWebView)? webViewWebContentProcessDidTerminate_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'WKNavigationDelegate');
    WKNavigationDelegate$Builder
        .webView_authenticationChallenge_shouldAllowDeprecatedTLS_
        .implement(
          builder,
          webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_decisionHandler_
        .implement(
          builder,
          webView_decidePolicyForNavigationAction_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_preferences_decisionHandler_
        .implement(
          builder,
          webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationResponse_decisionHandler_
        .implement(
          builder,
          webView_decidePolicyForNavigationResponse_decisionHandler_,
        );
    WKNavigationDelegate$Builder.webView_didCommitNavigation_.implement(
      builder,
      webView_didCommitNavigation_,
    );
    WKNavigationDelegate$Builder.webView_didFailNavigation_withError_.implement(
      builder,
      webView_didFailNavigation_withError_,
    );
    WKNavigationDelegate$Builder.webView_didFailProvisionalNavigation_withError_
        .implement(builder, webView_didFailProvisionalNavigation_withError_);
    WKNavigationDelegate$Builder.webView_didFinishNavigation_.implement(
      builder,
      webView_didFinishNavigation_,
    );
    WKNavigationDelegate$Builder
        .webView_didReceiveAuthenticationChallenge_completionHandler_
        .implement(
          builder,
          webView_didReceiveAuthenticationChallenge_completionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_didReceiveServerRedirectForProvisionalNavigation_
        .implement(
          builder,
          webView_didReceiveServerRedirectForProvisionalNavigation_,
        );
    WKNavigationDelegate$Builder.webView_didStartProvisionalNavigation_
        .implement(builder, webView_didStartProvisionalNavigation_);
    WKNavigationDelegate$Builder.webView_navigationAction_didBecomeDownload_
        .implement(builder, webView_navigationAction_didBecomeDownload_);
    WKNavigationDelegate$Builder.webView_navigationResponse_didBecomeDownload_
        .implement(builder, webView_navigationResponse_didBecomeDownload_);
    WKNavigationDelegate$Builder
        .webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_
        .implement(
          builder,
          webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
        );
    WKNavigationDelegate$Builder.webViewWebContentProcessDidTerminate_
        .implement(builder, webViewWebContentProcessDidTerminate_);
    builder.addProtocol($protocol);
    return WKNavigationDelegate.as(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the WKNavigationDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(
    objc.ObjCProtocolBuilder builder, {
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
    void Function(
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationAction_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )?
    webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationResponse_decisionHandler_,
    void Function(WKWebView, WKNavigation)? webView_didCommitNavigation_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailNavigation_withError_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailProvisionalNavigation_withError_,
    void Function(WKWebView, WKNavigation)? webView_didFinishNavigation_,
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    webView_didReceiveAuthenticationChallenge_completionHandler_,
    void Function(WKWebView, WKNavigation)?
    webView_didReceiveServerRedirectForProvisionalNavigation_,
    void Function(WKWebView, WKNavigation)?
    webView_didStartProvisionalNavigation_,
    void Function(WKWebView, WKNavigationAction, WKDownload)?
    webView_navigationAction_didBecomeDownload_,
    void Function(WKWebView, WKNavigationResponse, WKDownload)?
    webView_navigationResponse_didBecomeDownload_,
    void Function(
      WKWebView,
      WKBackForwardListItem,
      bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
    void Function(WKWebView)? webViewWebContentProcessDidTerminate_,
    bool $keepIsolateAlive = true,
  }) {
    WKNavigationDelegate$Builder
        .webView_authenticationChallenge_shouldAllowDeprecatedTLS_
        .implement(
          builder,
          webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_decisionHandler_
        .implement(
          builder,
          webView_decidePolicyForNavigationAction_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_preferences_decisionHandler_
        .implement(
          builder,
          webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationResponse_decisionHandler_
        .implement(
          builder,
          webView_decidePolicyForNavigationResponse_decisionHandler_,
        );
    WKNavigationDelegate$Builder.webView_didCommitNavigation_.implement(
      builder,
      webView_didCommitNavigation_,
    );
    WKNavigationDelegate$Builder.webView_didFailNavigation_withError_.implement(
      builder,
      webView_didFailNavigation_withError_,
    );
    WKNavigationDelegate$Builder.webView_didFailProvisionalNavigation_withError_
        .implement(builder, webView_didFailProvisionalNavigation_withError_);
    WKNavigationDelegate$Builder.webView_didFinishNavigation_.implement(
      builder,
      webView_didFinishNavigation_,
    );
    WKNavigationDelegate$Builder
        .webView_didReceiveAuthenticationChallenge_completionHandler_
        .implement(
          builder,
          webView_didReceiveAuthenticationChallenge_completionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_didReceiveServerRedirectForProvisionalNavigation_
        .implement(
          builder,
          webView_didReceiveServerRedirectForProvisionalNavigation_,
        );
    WKNavigationDelegate$Builder.webView_didStartProvisionalNavigation_
        .implement(builder, webView_didStartProvisionalNavigation_);
    WKNavigationDelegate$Builder.webView_navigationAction_didBecomeDownload_
        .implement(builder, webView_navigationAction_didBecomeDownload_);
    WKNavigationDelegate$Builder.webView_navigationResponse_didBecomeDownload_
        .implement(builder, webView_navigationResponse_didBecomeDownload_);
    WKNavigationDelegate$Builder
        .webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_
        .implement(
          builder,
          webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
        );
    WKNavigationDelegate$Builder.webViewWebContentProcessDidTerminate_
        .implement(builder, webViewWebContentProcessDidTerminate_);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the WKNavigationDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static WKNavigationDelegate implementAsListener({
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
    void Function(
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationAction_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )?
    webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationResponse_decisionHandler_,
    void Function(WKWebView, WKNavigation)? webView_didCommitNavigation_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailNavigation_withError_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailProvisionalNavigation_withError_,
    void Function(WKWebView, WKNavigation)? webView_didFinishNavigation_,
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    webView_didReceiveAuthenticationChallenge_completionHandler_,
    void Function(WKWebView, WKNavigation)?
    webView_didReceiveServerRedirectForProvisionalNavigation_,
    void Function(WKWebView, WKNavigation)?
    webView_didStartProvisionalNavigation_,
    void Function(WKWebView, WKNavigationAction, WKDownload)?
    webView_navigationAction_didBecomeDownload_,
    void Function(WKWebView, WKNavigationResponse, WKDownload)?
    webView_navigationResponse_didBecomeDownload_,
    void Function(
      WKWebView,
      WKBackForwardListItem,
      bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
    void Function(WKWebView)? webViewWebContentProcessDidTerminate_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'WKNavigationDelegate');
    WKNavigationDelegate$Builder
        .webView_authenticationChallenge_shouldAllowDeprecatedTLS_
        .implementAsListener(
          builder,
          webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_decisionHandler_
        .implementAsListener(
          builder,
          webView_decidePolicyForNavigationAction_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_preferences_decisionHandler_
        .implementAsListener(
          builder,
          webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationResponse_decisionHandler_
        .implementAsListener(
          builder,
          webView_decidePolicyForNavigationResponse_decisionHandler_,
        );
    WKNavigationDelegate$Builder.webView_didCommitNavigation_
        .implementAsListener(builder, webView_didCommitNavigation_);
    WKNavigationDelegate$Builder.webView_didFailNavigation_withError_
        .implementAsListener(builder, webView_didFailNavigation_withError_);
    WKNavigationDelegate$Builder.webView_didFailProvisionalNavigation_withError_
        .implementAsListener(
          builder,
          webView_didFailProvisionalNavigation_withError_,
        );
    WKNavigationDelegate$Builder.webView_didFinishNavigation_
        .implementAsListener(builder, webView_didFinishNavigation_);
    WKNavigationDelegate$Builder
        .webView_didReceiveAuthenticationChallenge_completionHandler_
        .implementAsListener(
          builder,
          webView_didReceiveAuthenticationChallenge_completionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_didReceiveServerRedirectForProvisionalNavigation_
        .implementAsListener(
          builder,
          webView_didReceiveServerRedirectForProvisionalNavigation_,
        );
    WKNavigationDelegate$Builder.webView_didStartProvisionalNavigation_
        .implementAsListener(builder, webView_didStartProvisionalNavigation_);
    WKNavigationDelegate$Builder.webView_navigationAction_didBecomeDownload_
        .implementAsListener(
          builder,
          webView_navigationAction_didBecomeDownload_,
        );
    WKNavigationDelegate$Builder.webView_navigationResponse_didBecomeDownload_
        .implementAsListener(
          builder,
          webView_navigationResponse_didBecomeDownload_,
        );
    WKNavigationDelegate$Builder
        .webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_
        .implementAsListener(
          builder,
          webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
        );
    WKNavigationDelegate$Builder.webViewWebContentProcessDidTerminate_
        .implementAsListener(builder, webViewWebContentProcessDidTerminate_);
    builder.addProtocol($protocol);
    return WKNavigationDelegate.as(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the WKNavigationDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(
    objc.ObjCProtocolBuilder builder, {
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
    void Function(
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationAction_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )?
    webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationResponse_decisionHandler_,
    void Function(WKWebView, WKNavigation)? webView_didCommitNavigation_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailNavigation_withError_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailProvisionalNavigation_withError_,
    void Function(WKWebView, WKNavigation)? webView_didFinishNavigation_,
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    webView_didReceiveAuthenticationChallenge_completionHandler_,
    void Function(WKWebView, WKNavigation)?
    webView_didReceiveServerRedirectForProvisionalNavigation_,
    void Function(WKWebView, WKNavigation)?
    webView_didStartProvisionalNavigation_,
    void Function(WKWebView, WKNavigationAction, WKDownload)?
    webView_navigationAction_didBecomeDownload_,
    void Function(WKWebView, WKNavigationResponse, WKDownload)?
    webView_navigationResponse_didBecomeDownload_,
    void Function(
      WKWebView,
      WKBackForwardListItem,
      bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
    void Function(WKWebView)? webViewWebContentProcessDidTerminate_,
    bool $keepIsolateAlive = true,
  }) {
    WKNavigationDelegate$Builder
        .webView_authenticationChallenge_shouldAllowDeprecatedTLS_
        .implementAsListener(
          builder,
          webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_decisionHandler_
        .implementAsListener(
          builder,
          webView_decidePolicyForNavigationAction_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_preferences_decisionHandler_
        .implementAsListener(
          builder,
          webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationResponse_decisionHandler_
        .implementAsListener(
          builder,
          webView_decidePolicyForNavigationResponse_decisionHandler_,
        );
    WKNavigationDelegate$Builder.webView_didCommitNavigation_
        .implementAsListener(builder, webView_didCommitNavigation_);
    WKNavigationDelegate$Builder.webView_didFailNavigation_withError_
        .implementAsListener(builder, webView_didFailNavigation_withError_);
    WKNavigationDelegate$Builder.webView_didFailProvisionalNavigation_withError_
        .implementAsListener(
          builder,
          webView_didFailProvisionalNavigation_withError_,
        );
    WKNavigationDelegate$Builder.webView_didFinishNavigation_
        .implementAsListener(builder, webView_didFinishNavigation_);
    WKNavigationDelegate$Builder
        .webView_didReceiveAuthenticationChallenge_completionHandler_
        .implementAsListener(
          builder,
          webView_didReceiveAuthenticationChallenge_completionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_didReceiveServerRedirectForProvisionalNavigation_
        .implementAsListener(
          builder,
          webView_didReceiveServerRedirectForProvisionalNavigation_,
        );
    WKNavigationDelegate$Builder.webView_didStartProvisionalNavigation_
        .implementAsListener(builder, webView_didStartProvisionalNavigation_);
    WKNavigationDelegate$Builder.webView_navigationAction_didBecomeDownload_
        .implementAsListener(
          builder,
          webView_navigationAction_didBecomeDownload_,
        );
    WKNavigationDelegate$Builder.webView_navigationResponse_didBecomeDownload_
        .implementAsListener(
          builder,
          webView_navigationResponse_didBecomeDownload_,
        );
    WKNavigationDelegate$Builder
        .webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_
        .implementAsListener(
          builder,
          webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
        );
    WKNavigationDelegate$Builder.webViewWebContentProcessDidTerminate_
        .implementAsListener(builder, webViewWebContentProcessDidTerminate_);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the WKNavigationDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static WKNavigationDelegate implementAsBlocking({
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
    void Function(
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationAction_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )?
    webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationResponse_decisionHandler_,
    void Function(WKWebView, WKNavigation)? webView_didCommitNavigation_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailNavigation_withError_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailProvisionalNavigation_withError_,
    void Function(WKWebView, WKNavigation)? webView_didFinishNavigation_,
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    webView_didReceiveAuthenticationChallenge_completionHandler_,
    void Function(WKWebView, WKNavigation)?
    webView_didReceiveServerRedirectForProvisionalNavigation_,
    void Function(WKWebView, WKNavigation)?
    webView_didStartProvisionalNavigation_,
    void Function(WKWebView, WKNavigationAction, WKDownload)?
    webView_navigationAction_didBecomeDownload_,
    void Function(WKWebView, WKNavigationResponse, WKDownload)?
    webView_navigationResponse_didBecomeDownload_,
    void Function(
      WKWebView,
      WKBackForwardListItem,
      bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
    void Function(WKWebView)? webViewWebContentProcessDidTerminate_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'WKNavigationDelegate');
    WKNavigationDelegate$Builder
        .webView_authenticationChallenge_shouldAllowDeprecatedTLS_
        .implementAsBlocking(
          builder,
          webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_decisionHandler_
        .implementAsBlocking(
          builder,
          webView_decidePolicyForNavigationAction_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_preferences_decisionHandler_
        .implementAsBlocking(
          builder,
          webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationResponse_decisionHandler_
        .implementAsBlocking(
          builder,
          webView_decidePolicyForNavigationResponse_decisionHandler_,
        );
    WKNavigationDelegate$Builder.webView_didCommitNavigation_
        .implementAsBlocking(builder, webView_didCommitNavigation_);
    WKNavigationDelegate$Builder.webView_didFailNavigation_withError_
        .implementAsBlocking(builder, webView_didFailNavigation_withError_);
    WKNavigationDelegate$Builder.webView_didFailProvisionalNavigation_withError_
        .implementAsBlocking(
          builder,
          webView_didFailProvisionalNavigation_withError_,
        );
    WKNavigationDelegate$Builder.webView_didFinishNavigation_
        .implementAsBlocking(builder, webView_didFinishNavigation_);
    WKNavigationDelegate$Builder
        .webView_didReceiveAuthenticationChallenge_completionHandler_
        .implementAsBlocking(
          builder,
          webView_didReceiveAuthenticationChallenge_completionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_didReceiveServerRedirectForProvisionalNavigation_
        .implementAsBlocking(
          builder,
          webView_didReceiveServerRedirectForProvisionalNavigation_,
        );
    WKNavigationDelegate$Builder.webView_didStartProvisionalNavigation_
        .implementAsBlocking(builder, webView_didStartProvisionalNavigation_);
    WKNavigationDelegate$Builder.webView_navigationAction_didBecomeDownload_
        .implementAsBlocking(
          builder,
          webView_navigationAction_didBecomeDownload_,
        );
    WKNavigationDelegate$Builder.webView_navigationResponse_didBecomeDownload_
        .implementAsBlocking(
          builder,
          webView_navigationResponse_didBecomeDownload_,
        );
    WKNavigationDelegate$Builder
        .webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_
        .implementAsBlocking(
          builder,
          webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
        );
    WKNavigationDelegate$Builder.webViewWebContentProcessDidTerminate_
        .implementAsBlocking(builder, webViewWebContentProcessDidTerminate_);
    builder.addProtocol($protocol);
    return WKNavigationDelegate.as(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the WKNavigationDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(
    objc.ObjCProtocolBuilder builder, {
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
    void Function(
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationAction_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )?
    webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationResponse_decisionHandler_,
    void Function(WKWebView, WKNavigation)? webView_didCommitNavigation_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailNavigation_withError_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailProvisionalNavigation_withError_,
    void Function(WKWebView, WKNavigation)? webView_didFinishNavigation_,
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    webView_didReceiveAuthenticationChallenge_completionHandler_,
    void Function(WKWebView, WKNavigation)?
    webView_didReceiveServerRedirectForProvisionalNavigation_,
    void Function(WKWebView, WKNavigation)?
    webView_didStartProvisionalNavigation_,
    void Function(WKWebView, WKNavigationAction, WKDownload)?
    webView_navigationAction_didBecomeDownload_,
    void Function(WKWebView, WKNavigationResponse, WKDownload)?
    webView_navigationResponse_didBecomeDownload_,
    void Function(
      WKWebView,
      WKBackForwardListItem,
      bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
    void Function(WKWebView)? webViewWebContentProcessDidTerminate_,
    bool $keepIsolateAlive = true,
  }) {
    WKNavigationDelegate$Builder
        .webView_authenticationChallenge_shouldAllowDeprecatedTLS_
        .implementAsBlocking(
          builder,
          webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_decisionHandler_
        .implementAsBlocking(
          builder,
          webView_decidePolicyForNavigationAction_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_preferences_decisionHandler_
        .implementAsBlocking(
          builder,
          webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationResponse_decisionHandler_
        .implementAsBlocking(
          builder,
          webView_decidePolicyForNavigationResponse_decisionHandler_,
        );
    WKNavigationDelegate$Builder.webView_didCommitNavigation_
        .implementAsBlocking(builder, webView_didCommitNavigation_);
    WKNavigationDelegate$Builder.webView_didFailNavigation_withError_
        .implementAsBlocking(builder, webView_didFailNavigation_withError_);
    WKNavigationDelegate$Builder.webView_didFailProvisionalNavigation_withError_
        .implementAsBlocking(
          builder,
          webView_didFailProvisionalNavigation_withError_,
        );
    WKNavigationDelegate$Builder.webView_didFinishNavigation_
        .implementAsBlocking(builder, webView_didFinishNavigation_);
    WKNavigationDelegate$Builder
        .webView_didReceiveAuthenticationChallenge_completionHandler_
        .implementAsBlocking(
          builder,
          webView_didReceiveAuthenticationChallenge_completionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_didReceiveServerRedirectForProvisionalNavigation_
        .implementAsBlocking(
          builder,
          webView_didReceiveServerRedirectForProvisionalNavigation_,
        );
    WKNavigationDelegate$Builder.webView_didStartProvisionalNavigation_
        .implementAsBlocking(builder, webView_didStartProvisionalNavigation_);
    WKNavigationDelegate$Builder.webView_navigationAction_didBecomeDownload_
        .implementAsBlocking(
          builder,
          webView_navigationAction_didBecomeDownload_,
        );
    WKNavigationDelegate$Builder.webView_navigationResponse_didBecomeDownload_
        .implementAsBlocking(
          builder,
          webView_navigationResponse_didBecomeDownload_,
        );
    WKNavigationDelegate$Builder
        .webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_
        .implementAsBlocking(
          builder,
          webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
        );
    WKNavigationDelegate$Builder.webViewWebContentProcessDidTerminate_
        .implementAsBlocking(builder, webViewWebContentProcessDidTerminate_);
    builder.addProtocol($protocol);
  }

  /// webView:authenticationChallenge:shouldAllowDeprecatedTLS:
  static final webView_authenticationChallenge_shouldAllowDeprecatedTLS_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          WKWebView,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
        )
      >(
        _protocol_WKNavigationDelegate,
        _sel_webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_bklti2)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            WKWebView,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_NSURLAuthenticationChallenge_ffiVoidbool.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                NSURLAuthenticationChallenge arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Bool)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            WKWebView,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_NSURLAuthenticationChallenge_ffiVoidbool.listener(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                NSURLAuthenticationChallenge arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Bool)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            WKWebView,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_NSURLAuthenticationChallenge_ffiVoidbool.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                NSURLAuthenticationChallenge arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Bool)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// webView:decidePolicyForNavigationAction:decisionHandler:
  static final webView_decidePolicyForNavigationAction_decisionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          WKWebView,
          WKNavigationAction,
          objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
        )
      >(
        _protocol_WKNavigationDelegate,
        _sel_webView_decidePolicyForNavigationAction_decisionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_bklti2)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_decidePolicyForNavigationAction_decisionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            WKWebView,
            WKNavigationAction,
            objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_ffiVoidWKNavigationActionPolicy.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationAction arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            WKWebView,
            WKNavigationAction,
            objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_ffiVoidWKNavigationActionPolicy.listener(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationAction arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            WKWebView,
            WKNavigationAction,
            objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_ffiVoidWKNavigationActionPolicy.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationAction arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// webView:decidePolicyForNavigationAction:preferences:decisionHandler:
  static final webView_decidePolicyForNavigationAction_preferences_decisionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          WKWebView,
          WKNavigationAction,
          WKWebpagePreferences,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
        )
      >(
        _protocol_WKNavigationDelegate,
        _sel_webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_xx612k)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            WKWebView,
            WKNavigationAction,
            WKWebpagePreferences,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_WKWebpagePreferences_ffiVoidWKNavigationActionPolicyWKWebpagePreferences.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationAction arg2,
                WKWebpagePreferences arg3,
                objc.ObjCBlock<
                  ffi.Void Function(ffi.Long, WKWebpagePreferences)
                >
                arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            WKWebView,
            WKNavigationAction,
            WKWebpagePreferences,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_WKWebpagePreferences_ffiVoidWKNavigationActionPolicyWKWebpagePreferences.listener(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationAction arg2,
                WKWebpagePreferences arg3,
                objc.ObjCBlock<
                  ffi.Void Function(ffi.Long, WKWebpagePreferences)
                >
                arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            WKWebView,
            WKNavigationAction,
            WKWebpagePreferences,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_WKWebpagePreferences_ffiVoidWKNavigationActionPolicyWKWebpagePreferences.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationAction arg2,
                WKWebpagePreferences arg3,
                objc.ObjCBlock<
                  ffi.Void Function(ffi.Long, WKWebpagePreferences)
                >
                arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
      );

  /// webView:decidePolicyForNavigationResponse:decisionHandler:
  static final webView_decidePolicyForNavigationResponse_decisionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          WKWebView,
          WKNavigationResponse,
          objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
        )
      >(
        _protocol_WKNavigationDelegate,
        _sel_webView_decidePolicyForNavigationResponse_decisionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_bklti2)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_decidePolicyForNavigationResponse_decisionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            WKWebView,
            WKNavigationResponse,
            objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationResponse_ffiVoidWKNavigationResponsePolicy.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationResponse arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            WKWebView,
            WKNavigationResponse,
            objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationResponse_ffiVoidWKNavigationResponsePolicy.listener(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationResponse arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            WKWebView,
            WKNavigationResponse,
            objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationResponse_ffiVoidWKNavigationResponsePolicy.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationResponse arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// webView:didCommitNavigation:
  static final webView_didCommitNavigation_ =
      objc.ObjCProtocolListenableMethod<void Function(WKWebView, WKNavigation)>(
        _protocol_WKNavigationDelegate,
        _sel_webView_didCommitNavigation_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_didCommitNavigation_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.fromFunction(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.listener(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.blocking(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
      );

  /// webView:didFailNavigation:withError:
  static final webView_didFailNavigation_withError_ =
      objc.ObjCProtocolListenableMethod<
        void Function(WKWebView, WKNavigation, objc.NSError)
      >(
        _protocol_WKNavigationDelegate,
        _sel_webView_didFailNavigation_withError_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_didFailNavigation_withError_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(WKWebView, WKNavigation, objc.NSError) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigation arg2,
                objc.NSError arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(WKWebView, WKNavigation, objc.NSError) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigation arg2,
                objc.NSError arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(WKWebView, WKNavigation, objc.NSError) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigation arg2,
                objc.NSError arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// webView:didFailProvisionalNavigation:withError:
  static final webView_didFailProvisionalNavigation_withError_ =
      objc.ObjCProtocolListenableMethod<
        void Function(WKWebView, WKNavigation, objc.NSError)
      >(
        _protocol_WKNavigationDelegate,
        _sel_webView_didFailProvisionalNavigation_withError_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_didFailProvisionalNavigation_withError_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(WKWebView, WKNavigation, objc.NSError) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigation arg2,
                objc.NSError arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(WKWebView, WKNavigation, objc.NSError) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigation arg2,
                objc.NSError arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(WKWebView, WKNavigation, objc.NSError) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigation arg2,
                objc.NSError arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// webView:didFinishNavigation:
  static final webView_didFinishNavigation_ =
      objc.ObjCProtocolListenableMethod<void Function(WKWebView, WKNavigation)>(
        _protocol_WKNavigationDelegate,
        _sel_webView_didFinishNavigation_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_didFinishNavigation_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.fromFunction(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.listener(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.blocking(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
      );

  /// webView:didReceiveAuthenticationChallenge:completionHandler:
  static final webView_didReceiveAuthenticationChallenge_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          WKWebView,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
        )
      >(
        _protocol_WKNavigationDelegate,
        _sel_webView_didReceiveAuthenticationChallenge_completionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_bklti2)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_didReceiveAuthenticationChallenge_completionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            WKWebView,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                NSURLAuthenticationChallenge arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            WKWebView,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.listener(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                NSURLAuthenticationChallenge arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            WKWebView,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                NSURLAuthenticationChallenge arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// webView:didReceiveServerRedirectForProvisionalNavigation:
  static final webView_didReceiveServerRedirectForProvisionalNavigation_ =
      objc.ObjCProtocolListenableMethod<void Function(WKWebView, WKNavigation)>(
        _protocol_WKNavigationDelegate,
        _sel_webView_didReceiveServerRedirectForProvisionalNavigation_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_didReceiveServerRedirectForProvisionalNavigation_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.fromFunction(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.listener(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.blocking(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
      );

  /// webView:didStartProvisionalNavigation:
  static final webView_didStartProvisionalNavigation_ =
      objc.ObjCProtocolListenableMethod<void Function(WKWebView, WKNavigation)>(
        _protocol_WKNavigationDelegate,
        _sel_webView_didStartProvisionalNavigation_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_didStartProvisionalNavigation_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.fromFunction(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.listener(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.blocking(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
      );

  /// webView:navigationAction:didBecomeDownload:
  static final webView_navigationAction_didBecomeDownload_ =
      objc.ObjCProtocolListenableMethod<
        void Function(WKWebView, WKNavigationAction, WKDownload)
      >(
        _protocol_WKNavigationDelegate,
        _sel_webView_navigationAction_didBecomeDownload_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_navigationAction_didBecomeDownload_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(WKWebView, WKNavigationAction, WKDownload) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_WKDownload.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationAction arg2,
                WKDownload arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(WKWebView, WKNavigationAction, WKDownload) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_WKDownload.listener(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationAction arg2,
                WKDownload arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(WKWebView, WKNavigationAction, WKDownload) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_WKDownload.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationAction arg2,
                WKDownload arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// webView:navigationResponse:didBecomeDownload:
  static final webView_navigationResponse_didBecomeDownload_ =
      objc.ObjCProtocolListenableMethod<
        void Function(WKWebView, WKNavigationResponse, WKDownload)
      >(
        _protocol_WKNavigationDelegate,
        _sel_webView_navigationResponse_didBecomeDownload_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_navigationResponse_didBecomeDownload_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(WKWebView, WKNavigationResponse, WKDownload) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationResponse_WKDownload.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationResponse arg2,
                WKDownload arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(WKWebView, WKNavigationResponse, WKDownload) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationResponse_WKDownload.listener(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationResponse arg2,
                WKDownload arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(WKWebView, WKNavigationResponse, WKDownload) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationResponse_WKDownload.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationResponse arg2,
                WKDownload arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// webView:shouldGoToBackForwardListItem:willUseInstantBack:completionHandler:
  static final webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          WKWebView,
          WKBackForwardListItem,
          bool,
          objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
        )
      >(
        _protocol_WKNavigationDelegate,
        _sel_webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Bool,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_axwdf6)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            WKWebView,
            WKBackForwardListItem,
            bool,
            objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKBackForwardListItem_bool_ffiVoidbool.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKBackForwardListItem arg2,
                bool arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Bool)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            WKWebView,
            WKBackForwardListItem,
            bool,
            objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKBackForwardListItem_bool_ffiVoidbool.listener(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKBackForwardListItem arg2,
                bool arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Bool)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            WKWebView,
            WKBackForwardListItem,
            bool,
            objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKBackForwardListItem_bool_ffiVoidbool.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKBackForwardListItem arg2,
                bool arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Bool)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
      );

  /// webViewWebContentProcessDidTerminate:
  static final webViewWebContentProcessDidTerminate_ =
      objc.ObjCProtocolListenableMethod<void Function(WKWebView)>(
        _protocol_WKNavigationDelegate,
        _sel_webViewWebContentProcessDidTerminate_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_18v1jvf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webViewWebContentProcessDidTerminate_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(WKWebView) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView.fromFunction(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1) => func(arg1),
            ),
        (void Function(WKWebView) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView.listener(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1) => func(arg1),
            ),
        (void Function(WKWebView) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView.blocking(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1) => func(arg1),
            ),
      );
}

late final _sel_navigationDelegate = objc.registerName("navigationDelegate");
late final _sel_setNavigationDelegate_ = objc.registerName(
  "setNavigationDelegate:",
);

/// WARNING: WKUIDelegate is a stub. To generate bindings for this class, include
/// WKUIDelegate in your config's objc-protocols list.
///
/// WKUIDelegate
extension type WKUIDelegate._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [WKUIDelegate] that points to the same underlying object as [other].
  WKUIDelegate.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [WKUIDelegate] that wraps the given raw object pointer.
  WKUIDelegate.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_UIDelegate = objc.registerName("UIDelegate");
late final _sel_setUIDelegate_ = objc.registerName("setUIDelegate:");
late final _sel_backForwardList = objc.registerName("backForwardList");
late final _sel_initWithFrame_configuration_ = objc.registerName(
  "initWithFrame:configuration:",
);
final _objc_msgSend_gxusyk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_loadRequest_ = objc.registerName("loadRequest:");
late final _sel_loadFileURL_allowingReadAccessToURL_ = objc.registerName(
  "loadFileURL:allowingReadAccessToURL:",
);
late final _sel_loadHTMLString_baseURL_ = objc.registerName(
  "loadHTMLString:baseURL:",
);
late final _sel_loadData_MIMEType_characterEncodingName_baseURL_ = objc
    .registerName("loadData:MIMEType:characterEncodingName:baseURL:");
final _objc_msgSend_s92gih = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_goToBackForwardListItem_ = objc.registerName(
  "goToBackForwardListItem:",
);
late final _sel_title = objc.registerName("title");
late final _sel_isLoading = objc.registerName("isLoading");
late final _sel_estimatedProgress = objc.registerName("estimatedProgress");
late final _sel_hasOnlySecureContent = objc.registerName(
  "hasOnlySecureContent",
);
late final _sel_serverTrust = objc.registerName("serverTrust");
final _objc_msgSend_1ommad9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<__SecTrust> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<__SecTrust> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_canGoBack = objc.registerName("canGoBack");
late final _sel_canGoForward = objc.registerName("canGoForward");
late final _sel_goBack = objc.registerName("goBack");
late final _sel_goForward = objc.registerName("goForward");
late final _sel_reload = objc.registerName("reload");
late final _sel_reloadFromOrigin = objc.registerName("reloadFromOrigin");
late final _sel_stopLoading = objc.registerName("stopLoading");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_objcObjCObjectImpl_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
  >
  fromFunction(
    void Function(objc.ObjCObject, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ) => fn(
            objc.ObjCObject(arg0, retain: true, release: true),
            arg1.address == 0
                ? null
                : objc.NSError.fromPointer(arg1, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
  >
  listener(
    void Function(objc.ObjCObject, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        objc.ObjCObject(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
  >
  blocking(
    void Function(objc.ObjCObject, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        objc.ObjCObject(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        objc.ObjCObject(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_objcObjCObjectImpl_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
        > {
  void call(objc.ObjCObject arg0, objc.NSError? arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0.ref.pointer, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_evaluateJavaScript_completionHandler_ = objc.registerName(
  "evaluateJavaScript:completionHandler:",
);
final _objc_msgSend_o762yo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// WARNING: WKFrameInfo is a stub. To generate bindings for this class, include
/// WKFrameInfo in your config's objc-interfaces list.
///
/// WKFrameInfo
extension type WKFrameInfo._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [WKFrameInfo] that points to the same underlying object as [other].
  WKFrameInfo.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKFrameInfo',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }

  /// Constructs a [WKFrameInfo] that wraps the given raw object pointer.
  WKFrameInfo.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKFrameInfo',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }
}

late final _sel_evaluateJavaScript_inFrame_inContentWorld_completionHandler_ =
    objc.registerName(
      "evaluateJavaScript:inFrame:inContentWorld:completionHandler:",
    );
late final _sel_callAsyncJavaScript_arguments_inFrame_inContentWorld_completionHandler_ =
    objc.registerName(
      "callAsyncJavaScript:arguments:inFrame:inContentWorld:completionHandler:",
    );
final _objc_msgSend_e1wgee = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_closeAllMediaPresentationsWithCompletionHandler_ = objc
    .registerName("closeAllMediaPresentationsWithCompletionHandler:");
final _objc_msgSend_f167m6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_closeAllMediaPresentations = objc.registerName(
  "closeAllMediaPresentations",
);
late final _sel_pauseAllMediaPlaybackWithCompletionHandler_ = objc.registerName(
  "pauseAllMediaPlaybackWithCompletionHandler:",
);
late final _sel_pauseAllMediaPlayback_ = objc.registerName(
  "pauseAllMediaPlayback:",
);
late final _sel_setAllMediaPlaybackSuspended_completionHandler_ = objc
    .registerName("setAllMediaPlaybackSuspended:completionHandler:");
final _objc_msgSend_1ocak7a = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_resumeAllMediaPlayback_ = objc.registerName(
  "resumeAllMediaPlayback:",
);
late final _sel_suspendAllMediaPlayback_ = objc.registerName(
  "suspendAllMediaPlayback:",
);

enum WKMediaPlaybackState {
  WKMediaPlaybackStateNone(0),
  WKMediaPlaybackStatePlaying(1),
  WKMediaPlaybackStatePaused(2),
  WKMediaPlaybackStateSuspended(3);

  final int value;
  const WKMediaPlaybackState(this.value);

  static WKMediaPlaybackState fromValue(int value) => switch (value) {
    0 => WKMediaPlaybackStateNone,
    1 => WKMediaPlaybackStatePlaying,
    2 => WKMediaPlaybackStatePaused,
    3 => WKMediaPlaybackStateSuspended,
    _ => throw ArgumentError('Unknown value for WKMediaPlaybackState: $value'),
  };
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Long)>`.
abstract final class ObjCBlock_ffiVoid_WKMediaPlaybackState {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Long arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> fromFunction(
    void Function(WKMediaPlaybackState) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
    objc.newClosureBlock(
      _closureCallable,
      (int arg0) => fn(WKMediaPlaybackState.fromValue(arg0)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> listener(
    void Function(WKMediaPlaybackState) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (int arg0) => fn(WKMediaPlaybackState.fromValue(arg0)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_19s8ne9(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> blocking(
    void Function(WKMediaPlaybackState) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (int arg0) => fn(WKMediaPlaybackState.fromValue(arg0)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (int arg0) => fn(WKMediaPlaybackState.fromValue(arg0)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_19s8ne9(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
  ) {
    (objc.getBlockClosure(block) as void Function(int))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    int arg0,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(int))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Long arg0)>>()
      .asFunction<void Function(int)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
  ) => (objc.getBlockClosure(block) as void Function(int))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Long)>`.
extension ObjCBlock_ffiVoid_WKMediaPlaybackState$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Long)> {
  void call(WKMediaPlaybackState arg0) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Long arg0,
              )
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, int)>()(
        ref.pointer,
        arg0.value,
      );
}

late final _sel_requestMediaPlaybackStateWithCompletionHandler_ = objc
    .registerName("requestMediaPlaybackStateWithCompletionHandler:");
late final _sel_requestMediaPlaybackState_ = objc.registerName(
  "requestMediaPlaybackState:",
);

enum WKMediaCaptureState {
  WKMediaCaptureStateNone(0),
  WKMediaCaptureStateActive(1),
  WKMediaCaptureStateMuted(2);

  final int value;
  const WKMediaCaptureState(this.value);

  static WKMediaCaptureState fromValue(int value) => switch (value) {
    0 => WKMediaCaptureStateNone,
    1 => WKMediaCaptureStateActive,
    2 => WKMediaCaptureStateMuted,
    _ => throw ArgumentError('Unknown value for WKMediaCaptureState: $value'),
  };
}

late final _sel_cameraCaptureState = objc.registerName("cameraCaptureState");
final _objc_msgSend_1s3s7ey = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_microphoneCaptureState = objc.registerName(
  "microphoneCaptureState",
);
late final _sel_setCameraCaptureState_completionHandler_ = objc.registerName(
  "setCameraCaptureState:completionHandler:",
);
final _objc_msgSend_dhyh3z = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_setMicrophoneCaptureState_completionHandler_ = objc
    .registerName("setMicrophoneCaptureState:completionHandler:");

/// WARNING: WKSnapshotConfiguration is a stub. To generate bindings for this class, include
/// WKSnapshotConfiguration in your config's objc-interfaces list.
///
/// WKSnapshotConfiguration
extension type WKSnapshotConfiguration._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [WKSnapshotConfiguration] that points to the same underlying object as [other].
  WKSnapshotConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKSnapshotConfiguration',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
  }

  /// Constructs a [WKSnapshotConfiguration] that wraps the given raw object pointer.
  WKSnapshotConfiguration.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKSnapshotConfiguration',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
  }
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NSImage?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSImage_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(NSImage?, objc.NSError?)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(NSImage?, objc.NSError?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSImage?, objc.NSError?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(NSImage?, objc.NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NSImage?, objc.NSError?)>
  fromFunction(
    void Function(NSImage?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(NSImage?, objc.NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : NSImage.fromPointer(arg0, retain: true, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NSImage?, objc.NSError?)> listener(
    void Function(NSImage?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : NSImage.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(NSImage?, objc.NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(NSImage?, objc.NSError?)> blocking(
    void Function(NSImage?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : NSImage.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : NSImage.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(NSImage?, objc.NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NSImage?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSImage_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(NSImage?, objc.NSError?)> {
  void call(NSImage? arg0, objc.NSError? arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObjectImpl> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0?.ref.pointer ?? ffi.nullptr,
        arg1?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_takeSnapshotWithConfiguration_completionHandler_ = objc
    .registerName("takeSnapshotWithConfiguration:completionHandler:");
late final _class_WKPDFConfiguration = objc.getClass("WKPDFConfiguration");
late final _sel_rect = objc.registerName("rect");
late final _sel_setRect_ = objc.registerName("setRect:");
late final _sel_allowTransparentBackground = objc.registerName(
  "allowTransparentBackground",
);
late final _sel_setAllowTransparentBackground_ = objc.registerName(
  "setAllowTransparentBackground:",
);

/// WKPDFConfiguration
extension type WKPDFConfiguration._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [WKPDFConfiguration] that points to the same underlying object as [other].
  WKPDFConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKPDFConfiguration',
      iOS: (false, (13, 4, 0)),
      macOS: (false, (10, 15, 4)),
    );
    assert(isA(object$));
  }

  /// Constructs a [WKPDFConfiguration] that wraps the given raw object pointer.
  WKPDFConfiguration.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKPDFConfiguration',
      iOS: (false, (13, 4, 0)),
      macOS: (false, (10, 15, 4)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [WKPDFConfiguration].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_WKPDFConfiguration,
  );

  /// alloc
  static WKPDFConfiguration alloc() {
    final $ret = _objc_msgSend_151sglz(_class_WKPDFConfiguration, _sel_alloc);
    return WKPDFConfiguration.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static WKPDFConfiguration allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_WKPDFConfiguration,
      _sel_allocWithZone_,
      zone,
    );
    return WKPDFConfiguration.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static WKPDFConfiguration new$() {
    final $ret = _objc_msgSend_151sglz(_class_WKPDFConfiguration, _sel_new);
    return WKPDFConfiguration.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of WKPDFConfiguration constructed with the default `new` method.
  WKPDFConfiguration() : this.as(new$().object$);
}

extension WKPDFConfiguration$Methods on WKPDFConfiguration {
  /// allowTransparentBackground
  bool get allowTransparentBackground {
    objc.checkOsVersionInternal(
      'WKPDFConfiguration.allowTransparentBackground',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowTransparentBackground,
    );
  }

  /// init
  WKPDFConfiguration init() {
    objc.checkOsVersionInternal(
      'WKPDFConfiguration.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return WKPDFConfiguration.fromPointer($ret, retain: false, release: true);
  }

  /// rect
  objc.CGRect get rect {
    objc.checkOsVersionInternal(
      'WKPDFConfiguration.rect',
      iOS: (false, (13, 4, 0)),
      macOS: (false, (10, 15, 4)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_rect)
        : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_rect);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// setAllowTransparentBackground:
  set allowTransparentBackground(bool value) {
    objc.checkOsVersionInternal(
      'WKPDFConfiguration.setAllowTransparentBackground:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAllowTransparentBackground_,
      value,
    );
  }

  /// setRect:
  set rect(objc.CGRect value) {
    objc.checkOsVersionInternal(
      'WKPDFConfiguration.setRect:',
      iOS: (false, (13, 4, 0)),
      macOS: (false, (10, 15, 4)),
    );
    _objc_msgSend_1okkq16(object$.ref.pointer, _sel_setRect_, value);
  }
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSData_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
  fromFunction(
    void Function(objc.NSData?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : objc.NSData.fromPointer(arg0, retain: true, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
  listener(
    void Function(objc.NSData?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : objc.NSData.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
  blocking(
    void Function(objc.NSData?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : objc.NSData.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : objc.NSData.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSData_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> {
  void call(objc.NSData? arg0, objc.NSError? arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObjectImpl> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0?.ref.pointer ?? ffi.nullptr,
        arg1?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_createPDFWithConfiguration_completionHandler_ = objc
    .registerName("createPDFWithConfiguration:completionHandler:");
late final _sel_createWebArchiveDataWithCompletionHandler_ = objc.registerName(
  "createWebArchiveDataWithCompletionHandler:",
);
late final _sel_allowsBackForwardNavigationGestures = objc.registerName(
  "allowsBackForwardNavigationGestures",
);
late final _sel_setAllowsBackForwardNavigationGestures_ = objc.registerName(
  "setAllowsBackForwardNavigationGestures:",
);
late final _sel_customUserAgent = objc.registerName("customUserAgent");
late final _sel_setCustomUserAgent_ = objc.registerName("setCustomUserAgent:");
late final _sel_allowsLinkPreview = objc.registerName("allowsLinkPreview");
late final _sel_setAllowsLinkPreview_ = objc.registerName(
  "setAllowsLinkPreview:",
);
late final _sel_allowsMagnification = objc.registerName("allowsMagnification");
late final _sel_setAllowsMagnification_ = objc.registerName(
  "setAllowsMagnification:",
);
late final _sel_magnification = objc.registerName("magnification");
late final _sel_setMagnification_ = objc.registerName("setMagnification:");
late final _sel_setMagnification_centeredAtPoint_ = objc.registerName(
  "setMagnification:centeredAtPoint:",
);
final _objc_msgSend_1dt5h8l = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          objc.CGPoint,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        objc.CGPoint,
      )
    >();
late final _sel_pageZoom = objc.registerName("pageZoom");
late final _sel_setPageZoom_ = objc.registerName("setPageZoom:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(WKFindResult)>`.
abstract final class ObjCBlock_ffiVoid_WKFindResult {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(WKFindResult)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(WKFindResult)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(WKFindResult)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(WKFindResult)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(WKFindResult)> fromFunction(
    void Function(WKFindResult) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(WKFindResult)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(WKFindResult.fromPointer(arg0, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(WKFindResult)> listener(
    void Function(WKFindResult) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(WKFindResult.fromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(WKFindResult)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(WKFindResult)> blocking(
    void Function(WKFindResult) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(WKFindResult.fromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(WKFindResult.fromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(WKFindResult)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(WKFindResult)>`.
extension ObjCBlock_ffiVoid_WKFindResult$CallExtension
    on objc.ObjCBlock<ffi.Void Function(WKFindResult)> {
  void call(WKFindResult arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0.ref.pointer);
}

late final _sel_findString_withConfiguration_completionHandler_ = objc
    .registerName("findString:withConfiguration:completionHandler:");
late final _sel_handlesURLScheme_ = objc.registerName("handlesURLScheme:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(WKDownload)>`.
abstract final class ObjCBlock_ffiVoid_WKDownload {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(WKDownload)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(WKDownload)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(WKDownload)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(WKDownload)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(WKDownload)> fromFunction(
    void Function(WKDownload) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(WKDownload)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(WKDownload.fromPointer(arg0, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(WKDownload)> listener(
    void Function(WKDownload) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(WKDownload.fromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(WKDownload)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(WKDownload)> blocking(
    void Function(WKDownload) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(WKDownload.fromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(WKDownload.fromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(WKDownload)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(WKDownload)>`.
extension ObjCBlock_ffiVoid_WKDownload$CallExtension
    on objc.ObjCBlock<ffi.Void Function(WKDownload)> {
  void call(WKDownload arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0.ref.pointer);
}

late final _sel_startDownloadUsingRequest_completionHandler_ = objc
    .registerName("startDownloadUsingRequest:completionHandler:");
late final _sel_resumeDownloadFromResumeData_completionHandler_ = objc
    .registerName("resumeDownloadFromResumeData:completionHandler:");
late final _sel_mediaType = objc.registerName("mediaType");
late final _sel_setMediaType_ = objc.registerName("setMediaType:");
late final _sel_interactionState = objc.registerName("interactionState");
late final _sel_setInteractionState_ = objc.registerName(
  "setInteractionState:",
);
late final _sel_isBlockedByScreenTime = objc.registerName(
  "isBlockedByScreenTime",
);
late final _sel_loadSimulatedRequest_response_responseData_ = objc.registerName(
  "loadSimulatedRequest:response:responseData:",
);
late final _sel_loadSimulatedRequest_withResponse_responseData_ = objc
    .registerName("loadSimulatedRequest:withResponse:responseData:");
late final _sel_loadFileRequest_allowingReadAccessToURL_ = objc.registerName(
  "loadFileRequest:allowingReadAccessToURL:",
);
late final _sel_loadSimulatedRequest_responseHTMLString_ = objc.registerName(
  "loadSimulatedRequest:responseHTMLString:",
);
late final _sel_loadSimulatedRequest_withResponseHTMLString_ = objc
    .registerName("loadSimulatedRequest:withResponseHTMLString:");
late final _sel_printOperationWithPrintInfo_ = objc.registerName(
  "printOperationWithPrintInfo:",
);
late final _sel_themeColor = objc.registerName("themeColor");
late final _sel_underPageBackgroundColor = objc.registerName(
  "underPageBackgroundColor",
);
late final _sel_setUnderPageBackgroundColor_ = objc.registerName(
  "setUnderPageBackgroundColor:",
);

enum WKFullscreenState {
  WKFullscreenStateNotInFullscreen(0),
  WKFullscreenStateEnteringFullscreen(1),
  WKFullscreenStateInFullscreen(2),
  WKFullscreenStateExitingFullscreen(3);

  final int value;
  const WKFullscreenState(this.value);

  static WKFullscreenState fromValue(int value) => switch (value) {
    0 => WKFullscreenStateNotInFullscreen,
    1 => WKFullscreenStateEnteringFullscreen,
    2 => WKFullscreenStateInFullscreen,
    3 => WKFullscreenStateExitingFullscreen,
    _ => throw ArgumentError('Unknown value for WKFullscreenState: $value'),
  };
}

late final _sel_fullscreenState = objc.registerName("fullscreenState");
final _objc_msgSend_lnv78v = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_minimumViewportInset = objc.registerName(
  "minimumViewportInset",
);
late final _sel_maximumViewportInset = objc.registerName(
  "maximumViewportInset",
);
late final _sel_setMinimumViewportInset_maximumViewportInset_ = objc
    .registerName("setMinimumViewportInset:maximumViewportInset:");
final _objc_msgSend_n6tx5n = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.NSEdgeInsets,
          objc.NSEdgeInsets,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.NSEdgeInsets,
        objc.NSEdgeInsets,
      )
    >();
late final _sel_isInspectable = objc.registerName("isInspectable");
late final _sel_setInspectable_ = objc.registerName("setInspectable:");
late final _sel_isWritingToolsActive = objc.registerName(
  "isWritingToolsActive",
);

sealed class WKWebViewDataType {
  static const WKWebViewDataTypeSessionStorage = 1;
}

late final _sel_fetchDataOfTypes_completionHandler_ = objc.registerName(
  "fetchDataOfTypes:completionHandler:",
);
final _objc_msgSend_13b1z7j = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromFunction(
    void Function(objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSError.fromPointer(arg0, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> listener(
    void Function(objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSError.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> blocking(
    void Function(objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSError.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSError.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSError?)> {
  void call(objc.NSError? arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_restoreData_completionHandler_ = objc.registerName(
  "restoreData:completionHandler:",
);
late final _sel_obscuredContentInsets = objc.registerName(
  "obscuredContentInsets",
);
late final _sel_setObscuredContentInsets_ = objc.registerName(
  "setObscuredContentInsets:",
);
late final _sel_goBack_ = objc.registerName("goBack:");
late final _sel_goForward_ = objc.registerName("goForward:");
late final _sel_reload_ = objc.registerName("reload:");
late final _sel_reloadFromOrigin_ = objc.registerName("reloadFromOrigin:");
late final _sel_stopLoading_ = objc.registerName("stopLoading:");
late final _sel_validateUserInterfaceItem_ = objc.registerName(
  "validateUserInterfaceItem:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)>`.
abstract final class ObjCBlock_bool_ffiVoid_idNSValidatedUserInterfaceItem {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
  >
  fromFunction(
    bool Function(ffi.Pointer<ffi.Void>, NSValidatedUserInterfaceItem) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                NSValidatedUserInterfaceItem.fromPointer(
                  arg1,
                  retain: true,
                  release: true,
                ),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as bool Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)>`.
extension ObjCBlock_bool_ffiVoid_idNSValidatedUserInterfaceItem$CallExtension
    on
        objc.ObjCBlock<
          ffi.Bool Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        > {
  bool call(ffi.Pointer<ffi.Void> arg0, NSValidatedUserInterfaceItem arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Bool Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<
            bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// WKIBActions
extension WKIBActions on WKWebView {
  /// goBack:
  void goBack$1(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'WKWebView.goBack:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_goBack_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// goForward:
  void goForward$1(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'WKWebView.goForward:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_goForward_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// reload:
  void reload$1(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'WKWebView.reload:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_reload_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// reloadFromOrigin:
  void reloadFromOrigin$1(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'WKWebView.reloadFromOrigin:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_reloadFromOrigin_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// stopLoading:
  void stopLoading$1(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'WKWebView.stopLoading:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_stopLoading_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// validateUserInterfaceItem:
  bool validateUserInterfaceItem(NSValidatedUserInterfaceItem item) {
    objc.checkOsVersionInternal(
      'WKWebView.validateUserInterfaceItem:',
      iOS: (true, null),
    );
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_validateUserInterfaceItem_,
      item.ref.pointer,
    );
  }
}

late final _sel_isSelectable = objc.registerName("isSelectable");
late final _sel_allowsMultipleSelection = objc.registerName(
  "allowsMultipleSelection",
);
late final _sel_isEditable = objc.registerName("isEditable");
late final _sel_string = objc.registerName("string");

/// Construction methods for `objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSString_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    objc.NSString Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSString_ffiVoid$CallExtension
    on objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)> {
  objc.NSString call(ffi.Pointer<ffi.Void> arg0) => objc.NSString.fromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >()(ref.pointer, arg0),
    retain: true,
    release: true,
  );
}

late final _sel_stringAtIndex_effectiveRange_endsWithSearchBoundary_ = objc
    .registerName("stringAtIndex:effectiveRange:endsWithSearchBoundary:");
final _objc_msgSend_1evadvq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.NSRange>,
          ffi.Pointer<ffi.Bool>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.NSRange>,
        ffi.Pointer<ffi.Bool>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong, ffi.Pointer<objc.NSRange>, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_NSString_ffiVoid_NSUInteger_NSRangePointer_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.NSString Function(
      ffi.Pointer<ffi.Void>,
      ffi.UnsignedLong,
      ffi.Pointer<objc.NSRange>,
      ffi.Pointer<ffi.Bool>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        objc.NSString Function(
          ffi.Pointer<ffi.Void>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.NSRange>,
          ffi.Pointer<ffi.Bool>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.NSString Function(
      ffi.Pointer<ffi.Void>,
      ffi.UnsignedLong,
      ffi.Pointer<objc.NSRange>,
      ffi.Pointer<ffi.Bool>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.UnsignedLong arg1,
          ffi.Pointer<objc.NSRange> arg2,
          ffi.Pointer<ffi.Bool> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.NSString Function(
          ffi.Pointer<ffi.Void>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.NSRange>,
          ffi.Pointer<ffi.Bool>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.NSString Function(
      ffi.Pointer<ffi.Void>,
      ffi.UnsignedLong,
      ffi.Pointer<objc.NSRange>,
      ffi.Pointer<ffi.Bool>,
    )
  >
  fromFunction(
    objc.NSString Function(
      ffi.Pointer<ffi.Void>,
      int,
      ffi.Pointer<objc.NSRange>,
      ffi.Pointer<ffi.Bool>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.NSString Function(
          ffi.Pointer<ffi.Void>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.NSRange>,
          ffi.Pointer<ffi.Bool>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            int arg1,
            ffi.Pointer<objc.NSRange> arg2,
            ffi.Pointer<ffi.Bool> arg3,
          ) => fn(arg0, arg1, arg2, arg3).ref.retainAndAutorelease(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
    ffi.Pointer<objc.NSRange> arg2,
    ffi.Pointer<ffi.Bool> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.UnsignedLong arg1,
            ffi.Pointer<objc.NSRange> arg2,
            ffi.Pointer<ffi.Bool> arg3,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<objc.NSRange>,
          ffi.Pointer<ffi.Bool>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong,
              ffi.Pointer<objc.NSRange>,
              ffi.Pointer<ffi.Bool>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
    ffi.Pointer<objc.NSRange> arg2,
    ffi.Pointer<ffi.Bool> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void>,
            int,
            ffi.Pointer<objc.NSRange>,
            ffi.Pointer<ffi.Bool>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong,
              ffi.Pointer<objc.NSRange>,
              ffi.Pointer<ffi.Bool>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong, ffi.Pointer<objc.NSRange>, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_NSString_ffiVoid_NSUInteger_NSRangePointer_bool$CallExtension
    on
        objc.ObjCBlock<
          objc.NSString Function(
            ffi.Pointer<ffi.Void>,
            ffi.UnsignedLong,
            ffi.Pointer<objc.NSRange>,
            ffi.Pointer<ffi.Bool>,
          )
        > {
  objc.NSString call(
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
    ffi.Pointer<objc.NSRange> arg2,
    ffi.Pointer<ffi.Bool> arg3,
  ) => objc.NSString.fromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
              ffi.UnsignedLong arg1,
              ffi.Pointer<objc.NSRange> arg2,
              ffi.Pointer<ffi.Bool> arg3,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            int,
            ffi.Pointer<objc.NSRange>,
            ffi.Pointer<ffi.Bool>,
          )
        >()(ref.pointer, arg0, arg1, arg2, arg3),
    retain: true,
    release: true,
  );
}

late final _sel_stringLength = objc.registerName("stringLength");

/// Construction methods for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSUInteger_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    int Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static int _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.UnsignedLong Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline, 0)
          .cast();
  static int _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.UnsignedLong Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline, 0)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSUInteger_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> {
  int call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.UnsignedLong Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        int Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
      >()(ref.pointer, arg0);
}

late final _sel_firstSelectedRange = objc.registerName("firstSelectedRange");
late final _sel_selectedRanges = objc.registerName("selectedRanges");
late final _sel_setSelectedRanges_ = objc.registerName("setSelectedRanges:");
late final _sel_scrollRangeToVisible_ = objc.registerName(
  "scrollRangeToVisible:",
);
late final _sel_shouldReplaceCharactersInRanges_withStrings_ = objc
    .registerName("shouldReplaceCharactersInRanges:withStrings:");

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray, objc.NSArray)>`.
abstract final class ObjCBlock_bool_ffiVoid_NSArray_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray, objc.NSArray)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray, objc.NSArray)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray, objc.NSArray)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray, objc.NSArray)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray, objc.NSArray)
  >
  fromFunction(
    bool Function(ffi.Pointer<ffi.Void>, objc.NSArray, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray, objc.NSArray)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0,
            objc.NSArray.fromPointer(arg1, retain: true, release: true),
            objc.NSArray.fromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as bool Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray, objc.NSArray)>`.
extension ObjCBlock_bool_ffiVoid_NSArray_NSArray$CallExtension
    on
        objc.ObjCBlock<
          ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray, objc.NSArray)
        > {
  bool call(ffi.Pointer<ffi.Void> arg0, objc.NSArray arg1, objc.NSArray arg2) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Bool Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
              )
            >
          >()
          .asFunction<
            bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_replaceCharactersInRange_withString_ = objc.registerName(
  "replaceCharactersInRange:withString:",
);
final _objc_msgSend_1tv4uax = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.NSRange,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.NSRange,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, objc.NSString)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSRange_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, objc.NSString)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, objc.NSString)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, objc.NSString)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          objc.NSRange arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, objc.NSString)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, objc.NSString)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.NSRange, objc.NSString) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, objc.NSString)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            objc.NSRange arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0,
            arg1,
            objc.NSString.fromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, objc.NSString)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.NSRange, objc.NSString) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        objc.NSRange arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        arg1,
        objc.NSString.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1f6txb5(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, objc.NSString)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, objc.NSString)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.NSRange, objc.NSString) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        objc.NSRange arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        arg1,
        objc.NSString.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        objc.NSRange arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        arg1,
        objc.NSString.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1f6txb5(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, objc.NSString)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          objc.NSRange,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      objc.NSRange,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            objc.NSRange,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            objc.NSRange,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      objc.NSRange,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            objc.NSRange,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      objc.NSRange,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            objc.NSRange,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            objc.NSRange arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          objc.NSRange,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.NSRange,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            objc.NSRange,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.NSRange,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, objc.NSString)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSRange_NSString$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, objc.NSString)
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
    objc.NSString arg2,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.NSRange arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          objc.NSRange,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1, arg2.ref.pointer);
}

late final _sel_didReplaceCharacters = objc.registerName(
  "didReplaceCharacters",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> listener(
    void Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_ovsamd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> blocking(
    void Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_ovsamd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_ffiVoid_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> {
  void call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
      >()(ref.pointer, arg0);
}

late final _sel_contentViewAtIndex_effectiveCharacterRange_ = objc.registerName(
  "contentViewAtIndex:effectiveCharacterRange:",
);
final _objc_msgSend_1776v9k = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.NSRange>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.NSRange>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<NSView Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong, ffi.Pointer<objc.NSRange>)>`.
abstract final class ObjCBlock_NSView_ffiVoid_NSUInteger_NSRangePointer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    NSView Function(
      ffi.Pointer<ffi.Void>,
      ffi.UnsignedLong,
      ffi.Pointer<objc.NSRange>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        NSView Function(
          ffi.Pointer<ffi.Void>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.NSRange>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    NSView Function(
      ffi.Pointer<ffi.Void>,
      ffi.UnsignedLong,
      ffi.Pointer<objc.NSRange>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.UnsignedLong arg1,
          ffi.Pointer<objc.NSRange> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        NSView Function(
          ffi.Pointer<ffi.Void>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.NSRange>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    NSView Function(
      ffi.Pointer<ffi.Void>,
      ffi.UnsignedLong,
      ffi.Pointer<objc.NSRange>,
    )
  >
  fromFunction(
    NSView Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<objc.NSRange>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        NSView Function(
          ffi.Pointer<ffi.Void>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.NSRange>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            int arg1,
            ffi.Pointer<objc.NSRange> arg2,
          ) => fn(arg0, arg1, arg2).ref.retainAndAutorelease(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
    ffi.Pointer<objc.NSRange> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.UnsignedLong arg1,
            ffi.Pointer<objc.NSRange> arg2,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<objc.NSRange>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong,
              ffi.Pointer<objc.NSRange>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
    ffi.Pointer<objc.NSRange> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void>,
            int,
            ffi.Pointer<objc.NSRange>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong,
              ffi.Pointer<objc.NSRange>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<NSView Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong, ffi.Pointer<objc.NSRange>)>`.
extension ObjCBlock_NSView_ffiVoid_NSUInteger_NSRangePointer$CallExtension
    on
        objc.ObjCBlock<
          NSView Function(
            ffi.Pointer<ffi.Void>,
            ffi.UnsignedLong,
            ffi.Pointer<objc.NSRange>,
          )
        > {
  NSView call(
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
    ffi.Pointer<objc.NSRange> arg2,
  ) => NSView.fromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
              ffi.UnsignedLong arg1,
              ffi.Pointer<objc.NSRange> arg2,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            int,
            ffi.Pointer<objc.NSRange>,
          )
        >()(ref.pointer, arg0, arg1, arg2),
    retain: true,
    release: true,
  );
}

late final _sel_rectsForCharacterRange_ = objc.registerName(
  "rectsForCharacterRange:",
);

/// Construction methods for `objc.ObjCBlock<objc.NSArray? Function(ffi.Pointer<ffi.Void>, objc.NSRange)>`.
abstract final class ObjCBlock_NSArray_ffiVoid_NSRange {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.NSArray? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        objc.NSArray? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.NSArray? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void> arg0,
          objc.NSRange arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.NSArray? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.NSArray? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
  >
  fromFunction(
    objc.NSArray? Function(ffi.Pointer<ffi.Void>, objc.NSRange) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.NSArray? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, objc.NSRange arg1) =>
              fn(arg0, arg1)?.ref.retainAndAutorelease() ?? ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void> arg0,
            objc.NSRange arg1,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSRange,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.NSRange,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void>,
            objc.NSRange,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.NSRange,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSArray? Function(ffi.Pointer<ffi.Void>, objc.NSRange)>`.
extension ObjCBlock_NSArray_ffiVoid_NSRange$CallExtension
    on
        objc.ObjCBlock<
          objc.NSArray? Function(ffi.Pointer<ffi.Void>, objc.NSRange)
        > {
  objc.NSArray? call(ffi.Pointer<ffi.Void> arg0, objc.NSRange arg1) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    objc.NSRange arg1,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  objc.NSRange,
                )
              >()(ref.pointer, arg0, arg1)
              .address ==
          0
      ? null
      : objc.NSArray.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    objc.NSRange arg1,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  objc.NSRange,
                )
              >()(ref.pointer, arg0, arg1),
          retain: true,
          release: true,
        );
}

late final _sel_visibleCharacterRanges = objc.registerName(
  "visibleCharacterRanges",
);
late final _sel_drawCharactersInRange_forContentView_ = objc.registerName(
  "drawCharactersInRange:forContentView:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, NSView)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSRange_NSView {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, NSView)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, NSView)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, NSView)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          objc.NSRange arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, NSView)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, NSView)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.NSRange, NSView) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, NSView)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            objc.NSRange arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0,
            arg1,
            NSView.fromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, NSView)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.NSRange, NSView) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        objc.NSRange arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        arg1,
        NSView.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1f6txb5(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, NSView)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, NSView)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.NSRange, NSView) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        objc.NSRange arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        arg1,
        NSView.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        objc.NSRange arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        arg1,
        NSView.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1f6txb5(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, NSView)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          objc.NSRange,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      objc.NSRange,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            objc.NSRange,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            objc.NSRange,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      objc.NSRange,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            objc.NSRange,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      objc.NSRange,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            objc.NSRange,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            objc.NSRange arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          objc.NSRange,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.NSRange,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.NSRange arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            objc.NSRange,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.NSRange,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, NSView)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSRange_NSView$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSRange, NSView)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSRange arg1, NSView arg2) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.NSRange arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          objc.NSRange,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1, arg2.ref.pointer);
}

/// WKNSTextFinderClient
extension WKNSTextFinderClient on WKWebView {
  /// allowsMultipleSelection
  bool get allowsMultipleSelection {
    objc.checkOsVersionInternal(
      'WKWebView.allowsMultipleSelection',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_allowsMultipleSelection,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKWebView',
        'allowsMultipleSelection',
      );
    }
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowsMultipleSelection,
    );
  }

  /// contentViewAtIndex:effectiveCharacterRange:
  NSView contentViewAtIndex(
    int index, {
    required ffi.Pointer<objc.NSRange> effectiveCharacterRange,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.contentViewAtIndex:effectiveCharacterRange:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_contentViewAtIndex_effectiveCharacterRange_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKWebView',
        'contentViewAtIndex:effectiveCharacterRange:',
      );
    }
    final $ret = _objc_msgSend_1776v9k(
      object$.ref.pointer,
      _sel_contentViewAtIndex_effectiveCharacterRange_,
      index,
      effectiveCharacterRange,
    );
    return NSView.fromPointer($ret, retain: true, release: true);
  }

  /// didReplaceCharacters
  void didReplaceCharacters() {
    objc.checkOsVersionInternal(
      'WKWebView.didReplaceCharacters',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_didReplaceCharacters,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKWebView',
        'didReplaceCharacters',
      );
    }
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_didReplaceCharacters);
  }

  /// drawCharactersInRange:forContentView:
  void drawCharactersInRange(
    objc.NSRange range, {
    required NSView forContentView,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.drawCharactersInRange:forContentView:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_drawCharactersInRange_forContentView_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKWebView',
        'drawCharactersInRange:forContentView:',
      );
    }
    _objc_msgSend_1tv4uax(
      object$.ref.pointer,
      _sel_drawCharactersInRange_forContentView_,
      range,
      forContentView.ref.pointer,
    );
  }

  /// firstSelectedRange
  objc.NSRange get firstSelectedRange {
    objc.checkOsVersionInternal(
      'WKWebView.firstSelectedRange',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_firstSelectedRange,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKWebView',
        'firstSelectedRange',
      );
    }
    final $ptr = pkg_ffi.calloc<objc.NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1u11dbbStret(
            $ptr,
            object$.ref.pointer,
            _sel_firstSelectedRange,
          )
        : $ptr.ref = _objc_msgSend_1u11dbb(
            object$.ref.pointer,
            _sel_firstSelectedRange,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.NSRange>($finalizable);
  }

  /// isEditable
  bool get isEditable {
    objc.checkOsVersionInternal('WKWebView.isEditable', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_isEditable)) {
      throw objc.UnimplementedOptionalMethodException(
        'WKWebView',
        'isEditable',
      );
    }
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isEditable);
  }

  /// isSelectable
  bool get isSelectable {
    objc.checkOsVersionInternal('WKWebView.isSelectable', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_isSelectable)) {
      throw objc.UnimplementedOptionalMethodException(
        'WKWebView',
        'isSelectable',
      );
    }
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isSelectable);
  }

  /// rectsForCharacterRange:
  objc.NSArray? rectsForCharacterRange(objc.NSRange range) {
    objc.checkOsVersionInternal(
      'WKWebView.rectsForCharacterRange:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_rectsForCharacterRange_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKWebView',
        'rectsForCharacterRange:',
      );
    }
    final $ret = _objc_msgSend_1k1o1s7(
      object$.ref.pointer,
      _sel_rectsForCharacterRange_,
      range,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// replaceCharactersInRange:withString:
  void replaceCharactersInRange(
    objc.NSRange range, {
    required objc.NSString withString,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.replaceCharactersInRange:withString:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_replaceCharactersInRange_withString_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKWebView',
        'replaceCharactersInRange:withString:',
      );
    }
    _objc_msgSend_1tv4uax(
      object$.ref.pointer,
      _sel_replaceCharactersInRange_withString_,
      range,
      withString.ref.pointer,
    );
  }

  /// scrollRangeToVisible:
  void scrollRangeToVisible(objc.NSRange range) {
    objc.checkOsVersionInternal(
      'WKWebView.scrollRangeToVisible:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_scrollRangeToVisible_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKWebView',
        'scrollRangeToVisible:',
      );
    }
    _objc_msgSend_1e3pm0z(
      object$.ref.pointer,
      _sel_scrollRangeToVisible_,
      range,
    );
  }

  /// selectedRanges
  objc.NSArray get selectedRanges {
    objc.checkOsVersionInternal('WKWebView.selectedRanges', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_selectedRanges)) {
      throw objc.UnimplementedOptionalMethodException(
        'WKWebView',
        'selectedRanges',
      );
    }
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_selectedRanges,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// setSelectedRanges:
  set selectedRanges(objc.NSArray value) {
    objc.checkOsVersionInternal(
      'WKWebView.setSelectedRanges:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_setSelectedRanges_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKWebView',
        'setSelectedRanges:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setSelectedRanges_,
      value.ref.pointer,
    );
  }

  /// shouldReplaceCharactersInRanges:withStrings:
  bool shouldReplaceCharactersInRanges(
    objc.NSArray ranges, {
    required objc.NSArray withStrings,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.shouldReplaceCharactersInRanges:withStrings:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_shouldReplaceCharactersInRanges_withStrings_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKWebView',
        'shouldReplaceCharactersInRanges:withStrings:',
      );
    }
    return _objc_msgSend_1lsax7n(
      object$.ref.pointer,
      _sel_shouldReplaceCharactersInRanges_withStrings_,
      ranges.ref.pointer,
      withStrings.ref.pointer,
    );
  }

  /// string
  objc.NSString get string {
    objc.checkOsVersionInternal('WKWebView.string', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_string)) {
      throw objc.UnimplementedOptionalMethodException('WKWebView', 'string');
    }
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_string);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// stringAtIndex:effectiveRange:endsWithSearchBoundary:
  objc.NSString stringAtIndex(
    int characterIndex, {
    required ffi.Pointer<objc.NSRange> effectiveRange,
    required ffi.Pointer<ffi.Bool> endsWithSearchBoundary,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.stringAtIndex:effectiveRange:endsWithSearchBoundary:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_stringAtIndex_effectiveRange_endsWithSearchBoundary_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKWebView',
        'stringAtIndex:effectiveRange:endsWithSearchBoundary:',
      );
    }
    final $ret = _objc_msgSend_1evadvq(
      object$.ref.pointer,
      _sel_stringAtIndex_effectiveRange_endsWithSearchBoundary_,
      characterIndex,
      effectiveRange,
      endsWithSearchBoundary,
    );
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// stringLength
  int stringLength() {
    objc.checkOsVersionInternal('WKWebView.stringLength', iOS: (true, null));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_stringLength)) {
      throw objc.UnimplementedOptionalMethodException(
        'WKWebView',
        'stringLength',
      );
    }
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_stringLength);
  }

  /// visibleCharacterRanges
  objc.NSArray get visibleCharacterRanges {
    objc.checkOsVersionInternal(
      'WKWebView.visibleCharacterRanges',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_visibleCharacterRanges,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKWebView',
        'visibleCharacterRanges',
      );
    }
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_visibleCharacterRanges,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_certificateChain = objc.registerName("certificateChain");

/// WKDeprecated
extension WKDeprecated on WKWebView {
  /// certificateChain
  objc.NSArray get certificateChain {
    objc.checkOsVersionInternal(
      'WKWebView.certificateChain',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_certificateChain,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
}

/// WKWebView
extension type WKWebView._(objc.ObjCObject object$)
    implements objc.ObjCObject, NSView {
  /// Constructs a [WKWebView] that points to the same underlying object as [other].
  WKWebView.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKWebView',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [WKWebView] that wraps the given raw object pointer.
  WKWebView.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKWebView',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [WKWebView].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_WKWebView,
  );

  /// alloc
  static WKWebView alloc() {
    final $ret = _objc_msgSend_151sglz(_class_WKWebView, _sel_alloc);
    return WKWebView.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static WKWebView allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_WKWebView,
      _sel_allocWithZone_,
      zone,
    );
    return WKWebView.fromPointer($ret, retain: false, release: true);
  }

  /// defaultAnimationForKey:
  static objc.ObjCObject? defaultAnimationForKey(objc.NSString key) {
    objc.checkOsVersionInternal(
      'WKWebView.defaultAnimationForKey:',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_WKWebView,
      _sel_defaultAnimationForKey_,
      key.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// defaultMenu
  static NSMenu? getDefaultMenu() {
    objc.checkOsVersionInternal('WKWebView.defaultMenu', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(_class_WKWebView, _sel_defaultMenu);
    return $ret.address == 0
        ? null
        : NSMenu.fromPointer($ret, retain: true, release: true);
  }

  /// focusView
  static NSView? getFocusView() {
    objc.checkOsVersionInternal('WKWebView.focusView', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(_class_WKWebView, _sel_focusView);
    return $ret.address == 0
        ? null
        : NSView.fromPointer($ret, retain: true, release: true);
  }

  /// handlesURLScheme:
  static bool handlesURLScheme(objc.NSString urlScheme) {
    objc.checkOsVersionInternal(
      'WKWebView.handlesURLScheme:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    return _objc_msgSend_19nvye5(
      _class_WKWebView,
      _sel_handlesURLScheme_,
      urlScheme.ref.pointer,
    );
  }

  /// isCompatibleWithResponsiveScrolling
  static bool getIsCompatibleWithResponsiveScrolling() {
    objc.checkOsVersionInternal(
      'WKWebView.isCompatibleWithResponsiveScrolling',
      iOS: (true, null),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_91o635(
      _class_WKWebView,
      _sel_isCompatibleWithResponsiveScrolling,
    );
  }

  /// new
  static WKWebView new$() {
    final $ret = _objc_msgSend_151sglz(_class_WKWebView, _sel_new);
    return WKWebView.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of WKWebView constructed with the default `new` method.
  WKWebView() : this.as(new$().object$);
}

extension WKWebView$Methods on WKWebView {
  /// UIDelegate
  WKUIDelegate? get UIDelegate {
    objc.checkOsVersionInternal(
      'WKWebView.UIDelegate',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_UIDelegate);
    return $ret.address == 0
        ? null
        : WKUIDelegate.fromPointer($ret, retain: true, release: true);
  }

  /// URL
  objc.NSURL? get URL {
    objc.checkOsVersionInternal(
      'WKWebView.URL',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_URL);
    return $ret.address == 0
        ? null
        : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }

  /// allowsBackForwardNavigationGestures
  bool get allowsBackForwardNavigationGestures {
    objc.checkOsVersionInternal(
      'WKWebView.allowsBackForwardNavigationGestures',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowsBackForwardNavigationGestures,
    );
  }

  /// allowsLinkPreview
  bool get allowsLinkPreview {
    objc.checkOsVersionInternal(
      'WKWebView.allowsLinkPreview',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_allowsLinkPreview);
  }

  /// allowsMagnification
  bool get allowsMagnification {
    objc.checkOsVersionInternal(
      'WKWebView.allowsMagnification',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_allowsMagnification);
  }

  /// animator
  WKWebView animator() {
    objc.checkOsVersionInternal(
      'WKWebView.animator',
      iOS: (true, null),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_animator);
    return WKWebView.fromPointer($ret, retain: true, release: true);
  }

  /// backForwardList
  WKBackForwardList get backForwardList {
    objc.checkOsVersionInternal(
      'WKWebView.backForwardList',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_backForwardList,
    );
    return WKBackForwardList.fromPointer($ret, retain: true, release: true);
  }

  /// callAsyncJavaScript:arguments:inFrame:inContentWorld:completionHandler:
  void callAsyncJavaScript(
    objc.NSString functionBody, {
    objc.NSDictionary? arguments,
    WKFrameInfo? inFrame,
    required WKContentWorld inContentWorld,
    objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
    >?
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.callAsyncJavaScript:arguments:inFrame:inContentWorld:completionHandler:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_e1wgee(
      object$.ref.pointer,
      _sel_callAsyncJavaScript_arguments_inFrame_inContentWorld_completionHandler_,
      functionBody.ref.pointer,
      arguments?.ref.pointer ?? ffi.nullptr,
      inFrame?.ref.pointer ?? ffi.nullptr,
      inContentWorld.ref.pointer,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// cameraCaptureState
  WKMediaCaptureState get cameraCaptureState {
    objc.checkOsVersionInternal(
      'WKWebView.cameraCaptureState',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_1s3s7ey(
      object$.ref.pointer,
      _sel_cameraCaptureState,
    );
    return WKMediaCaptureState.fromValue($ret);
  }

  /// canGoBack
  bool get canGoBack {
    objc.checkOsVersionInternal(
      'WKWebView.canGoBack',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_canGoBack);
  }

  /// canGoForward
  bool get canGoForward {
    objc.checkOsVersionInternal(
      'WKWebView.canGoForward',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_canGoForward);
  }

  /// closeAllMediaPresentations
  void closeAllMediaPresentations() {
    objc.checkOsVersionInternal(
      'WKWebView.closeAllMediaPresentations',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_closeAllMediaPresentations);
  }

  /// closeAllMediaPresentationsWithCompletionHandler:
  void closeAllMediaPresentationsWithCompletionHandler(
    objc.ObjCBlock<ffi.Void Function()>? completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'WKWebView.closeAllMediaPresentationsWithCompletionHandler:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_closeAllMediaPresentationsWithCompletionHandler_,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// configuration
  WKWebViewConfiguration get configuration {
    objc.checkOsVersionInternal(
      'WKWebView.configuration',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_configuration);
    return WKWebViewConfiguration.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// createPDFWithConfiguration:completionHandler:
  void createPDFWithConfiguration(
    WKPDFConfiguration? pdfConfiguration, {
    required objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.createPDFWithConfiguration:completionHandler:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_o762yo(
      object$.ref.pointer,
      _sel_createPDFWithConfiguration_completionHandler_,
      pdfConfiguration?.ref.pointer ?? ffi.nullptr,
      completionHandler.ref.pointer,
    );
  }

  /// createWebArchiveDataWithCompletionHandler:
  void createWebArchiveDataWithCompletionHandler(
    objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
    completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'WKWebView.createWebArchiveDataWithCompletionHandler:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_createWebArchiveDataWithCompletionHandler_,
      completionHandler.ref.pointer,
    );
  }

  /// customUserAgent
  objc.NSString? get customUserAgent {
    objc.checkOsVersionInternal(
      'WKWebView.customUserAgent',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_customUserAgent,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// estimatedProgress
  double get estimatedProgress {
    objc.checkOsVersionInternal(
      'WKWebView.estimatedProgress',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            object$.ref.pointer,
            _sel_estimatedProgress,
          )
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_estimatedProgress);
  }

  /// evaluateJavaScript:completionHandler:
  void evaluateJavaScript(
    objc.NSString javaScriptString, {
    objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
    >?
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.evaluateJavaScript:completionHandler:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_o762yo(
      object$.ref.pointer,
      _sel_evaluateJavaScript_completionHandler_,
      javaScriptString.ref.pointer,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// evaluateJavaScript:inFrame:inContentWorld:completionHandler:
  void evaluateJavaScript$1(
    objc.NSString javaScriptString, {
    WKFrameInfo? inFrame,
    required WKContentWorld inContentWorld,
    objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
    >?
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.evaluateJavaScript:inFrame:inContentWorld:completionHandler:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_m7tls4(
      object$.ref.pointer,
      _sel_evaluateJavaScript_inFrame_inContentWorld_completionHandler_,
      javaScriptString.ref.pointer,
      inFrame?.ref.pointer ?? ffi.nullptr,
      inContentWorld.ref.pointer,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// fetchDataOfTypes:completionHandler:
  void fetchDataOfTypes(
    int dataTypes, {
    required objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.fetchDataOfTypes:completionHandler:',
      iOS: (false, (26, 0, 0)),
      macOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_13b1z7j(
      object$.ref.pointer,
      _sel_fetchDataOfTypes_completionHandler_,
      dataTypes,
      completionHandler.ref.pointer,
    );
  }

  /// findString:withConfiguration:completionHandler:
  void findString(
    objc.NSString string, {
    WKFindConfiguration? withConfiguration,
    required objc.ObjCBlock<ffi.Void Function(WKFindResult)> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.findString:withConfiguration:completionHandler:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_findString_withConfiguration_completionHandler_,
      string.ref.pointer,
      withConfiguration?.ref.pointer ?? ffi.nullptr,
      completionHandler.ref.pointer,
    );
  }

  /// fullscreenState
  WKFullscreenState get fullscreenState {
    objc.checkOsVersionInternal(
      'WKWebView.fullscreenState',
      iOS: (false, (16, 0, 0)),
      macOS: (false, (13, 0, 0)),
    );
    final $ret = _objc_msgSend_lnv78v(
      object$.ref.pointer,
      _sel_fullscreenState,
    );
    return WKFullscreenState.fromValue($ret);
  }

  /// goBack
  WKNavigation? goBack() {
    objc.checkOsVersionInternal(
      'WKWebView.goBack',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_goBack);
    return $ret.address == 0
        ? null
        : WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// goForward
  WKNavigation? goForward() {
    objc.checkOsVersionInternal(
      'WKWebView.goForward',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_goForward);
    return $ret.address == 0
        ? null
        : WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// goToBackForwardListItem:
  WKNavigation? goToBackForwardListItem(WKBackForwardListItem item) {
    objc.checkOsVersionInternal(
      'WKWebView.goToBackForwardListItem:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_goToBackForwardListItem_,
      item.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// hasOnlySecureContent
  bool get hasOnlySecureContent {
    objc.checkOsVersionInternal(
      'WKWebView.hasOnlySecureContent',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_hasOnlySecureContent);
  }

  /// init
  WKWebView init() {
    objc.checkOsVersionInternal(
      'WKWebView.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return WKWebView.fromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  WKWebView? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : WKWebView.fromPointer($ret, retain: false, release: true);
  }

  /// initWithFrame:
  WKWebView initWithFrame(objc.CGRect frameRect) {
    objc.checkOsVersionInternal('WKWebView.initWithFrame:', iOS: (true, null));
    final $ret = _objc_msgSend_15yz4e6(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithFrame_,
      frameRect,
    );
    return WKWebView.fromPointer($ret, retain: false, release: true);
  }

  /// initWithFrame:configuration:
  WKWebView initWithFrame$1(
    objc.CGRect frame, {
    required WKWebViewConfiguration configuration,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.initWithFrame:configuration:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_gxusyk(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithFrame_configuration_,
      frame,
      configuration.ref.pointer,
    );
    return WKWebView.fromPointer($ret, retain: false, release: true);
  }

  /// interactionState
  objc.ObjCObject? get interactionState {
    objc.checkOsVersionInternal(
      'WKWebView.interactionState',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_interactionState,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// isBlockedByScreenTime
  bool get isBlockedByScreenTime {
    objc.checkOsVersionInternal(
      'WKWebView.isBlockedByScreenTime',
      iOS: (false, (26, 0, 0)),
      macOS: (false, (26, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isBlockedByScreenTime,
    );
  }

  /// isInspectable
  bool get isInspectable {
    objc.checkOsVersionInternal(
      'WKWebView.isInspectable',
      iOS: (false, (16, 4, 0)),
      macOS: (false, (13, 3, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isInspectable);
  }

  /// isLoading
  bool get isLoading {
    objc.checkOsVersionInternal(
      'WKWebView.isLoading',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isLoading);
  }

  /// isWritingToolsActive
  bool get isWritingToolsActive {
    objc.checkOsVersionInternal(
      'WKWebView.isWritingToolsActive',
      iOS: (false, (18, 0, 0)),
      macOS: (false, (15, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isWritingToolsActive);
  }

  /// loadData:MIMEType:characterEncodingName:baseURL:
  WKNavigation? loadData(
    objc.NSData data, {
    required objc.NSString MIMEType,
    required objc.NSString characterEncodingName,
    required objc.NSURL baseURL,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.loadData:MIMEType:characterEncodingName:baseURL:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_s92gih(
      object$.ref.pointer,
      _sel_loadData_MIMEType_characterEncodingName_baseURL_,
      data.ref.pointer,
      MIMEType.ref.pointer,
      characterEncodingName.ref.pointer,
      baseURL.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// loadFileRequest:allowingReadAccessToURL:
  WKNavigation loadFileRequest(
    NSURLRequest request, {
    required objc.NSURL allowingReadAccessToURL,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.loadFileRequest:allowingReadAccessToURL:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_loadFileRequest_allowingReadAccessToURL_,
      request.ref.pointer,
      allowingReadAccessToURL.ref.pointer,
    );
    return WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// loadFileURL:allowingReadAccessToURL:
  WKNavigation? loadFileURL(
    objc.NSURL URL, {
    required objc.NSURL allowingReadAccessToURL,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.loadFileURL:allowingReadAccessToURL:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_loadFileURL_allowingReadAccessToURL_,
      URL.ref.pointer,
      allowingReadAccessToURL.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// loadHTMLString:baseURL:
  WKNavigation? loadHTMLString(objc.NSString string, {objc.NSURL? baseURL}) {
    objc.checkOsVersionInternal(
      'WKWebView.loadHTMLString:baseURL:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_loadHTMLString_baseURL_,
      string.ref.pointer,
      baseURL?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0
        ? null
        : WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// loadRequest:
  WKNavigation? loadRequest(NSURLRequest request) {
    objc.checkOsVersionInternal(
      'WKWebView.loadRequest:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_loadRequest_,
      request.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// loadSimulatedRequest:response:responseData:
  WKNavigation loadSimulatedRequest(
    NSURLRequest request, {
    required NSURLResponse response,
    required objc.NSData responseData,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.loadSimulatedRequest:response:responseData:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      object$.ref.pointer,
      _sel_loadSimulatedRequest_response_responseData_,
      request.ref.pointer,
      response.ref.pointer,
      responseData.ref.pointer,
    );
    return WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// loadSimulatedRequest:responseHTMLString:
  WKNavigation loadSimulatedRequest$1(
    NSURLRequest request, {
    required objc.NSString responseHTMLString,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.loadSimulatedRequest:responseHTMLString:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_loadSimulatedRequest_responseHTMLString_,
      request.ref.pointer,
      responseHTMLString.ref.pointer,
    );
    return WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// loadSimulatedRequest:withResponse:responseData:
  WKNavigation loadSimulatedRequest$2(
    NSURLRequest request, {
    required NSURLResponse withResponse,
    required objc.NSData responseData,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.loadSimulatedRequest:withResponse:responseData:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      object$.ref.pointer,
      _sel_loadSimulatedRequest_withResponse_responseData_,
      request.ref.pointer,
      withResponse.ref.pointer,
      responseData.ref.pointer,
    );
    return WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// loadSimulatedRequest:withResponseHTMLString:
  WKNavigation loadSimulatedRequest$3(
    NSURLRequest request, {
    required objc.NSString withResponseHTMLString,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.loadSimulatedRequest:withResponseHTMLString:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_loadSimulatedRequest_withResponseHTMLString_,
      request.ref.pointer,
      withResponseHTMLString.ref.pointer,
    );
    return WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// magnification
  double get magnification {
    objc.checkOsVersionInternal(
      'WKWebView.magnification',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_magnification)
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_magnification);
  }

  /// maximumViewportInset
  objc.NSEdgeInsets get maximumViewportInset {
    objc.checkOsVersionInternal(
      'WKWebView.maximumViewportInset',
      macOS: (false, (13, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.NSEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_sl0cgwStret(
            $ptr,
            object$.ref.pointer,
            _sel_maximumViewportInset,
          )
        : $ptr.ref = _objc_msgSend_sl0cgw(
            object$.ref.pointer,
            _sel_maximumViewportInset,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.NSEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.NSEdgeInsets>($finalizable);
  }

  /// mediaType
  objc.NSString? get mediaType {
    objc.checkOsVersionInternal(
      'WKWebView.mediaType',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_mediaType);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// microphoneCaptureState
  WKMediaCaptureState get microphoneCaptureState {
    objc.checkOsVersionInternal(
      'WKWebView.microphoneCaptureState',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_1s3s7ey(
      object$.ref.pointer,
      _sel_microphoneCaptureState,
    );
    return WKMediaCaptureState.fromValue($ret);
  }

  /// minimumViewportInset
  objc.NSEdgeInsets get minimumViewportInset {
    objc.checkOsVersionInternal(
      'WKWebView.minimumViewportInset',
      macOS: (false, (13, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.NSEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_sl0cgwStret(
            $ptr,
            object$.ref.pointer,
            _sel_minimumViewportInset,
          )
        : $ptr.ref = _objc_msgSend_sl0cgw(
            object$.ref.pointer,
            _sel_minimumViewportInset,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.NSEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.NSEdgeInsets>($finalizable);
  }

  /// navigationDelegate
  WKNavigationDelegate? get navigationDelegate {
    objc.checkOsVersionInternal(
      'WKWebView.navigationDelegate',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_navigationDelegate,
    );
    return $ret.address == 0
        ? null
        : WKNavigationDelegate.fromPointer($ret, retain: true, release: true);
  }

  /// obscuredContentInsets
  objc.NSEdgeInsets get obscuredContentInsets {
    objc.checkOsVersionInternal(
      'WKWebView.obscuredContentInsets',
      macOS: (false, (26, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.NSEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_sl0cgwStret(
            $ptr,
            object$.ref.pointer,
            _sel_obscuredContentInsets,
          )
        : $ptr.ref = _objc_msgSend_sl0cgw(
            object$.ref.pointer,
            _sel_obscuredContentInsets,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.NSEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.NSEdgeInsets>($finalizable);
  }

  /// pageZoom
  double get pageZoom {
    objc.checkOsVersionInternal(
      'WKWebView.pageZoom',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_pageZoom)
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_pageZoom);
  }

  /// pauseAllMediaPlayback:
  void pauseAllMediaPlayback(
    objc.ObjCBlock<ffi.Void Function()>? completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'WKWebView.pauseAllMediaPlayback:',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_pauseAllMediaPlayback_,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// pauseAllMediaPlaybackWithCompletionHandler:
  void pauseAllMediaPlaybackWithCompletionHandler(
    objc.ObjCBlock<ffi.Void Function()>? completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'WKWebView.pauseAllMediaPlaybackWithCompletionHandler:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_pauseAllMediaPlaybackWithCompletionHandler_,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// printOperationWithPrintInfo:
  NSPrintOperation printOperationWithPrintInfo(NSPrintInfo printInfo) {
    objc.checkOsVersionInternal(
      'WKWebView.printOperationWithPrintInfo:',
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_printOperationWithPrintInfo_,
      printInfo.ref.pointer,
    );
    return NSPrintOperation.fromPointer($ret, retain: true, release: true);
  }

  /// reload
  WKNavigation? reload() {
    objc.checkOsVersionInternal(
      'WKWebView.reload',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_reload);
    return $ret.address == 0
        ? null
        : WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// reloadFromOrigin
  WKNavigation? reloadFromOrigin() {
    objc.checkOsVersionInternal(
      'WKWebView.reloadFromOrigin',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_reloadFromOrigin,
    );
    return $ret.address == 0
        ? null
        : WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// requestMediaPlaybackState:
  void requestMediaPlaybackState(
    objc.ObjCBlock<ffi.Void Function(ffi.Long)> completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'WKWebView.requestMediaPlaybackState:',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_requestMediaPlaybackState_,
      completionHandler.ref.pointer,
    );
  }

  /// requestMediaPlaybackStateWithCompletionHandler:
  void requestMediaPlaybackStateWithCompletionHandler(
    objc.ObjCBlock<ffi.Void Function(ffi.Long)> completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'WKWebView.requestMediaPlaybackStateWithCompletionHandler:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_requestMediaPlaybackStateWithCompletionHandler_,
      completionHandler.ref.pointer,
    );
  }

  /// restoreData:completionHandler:
  void restoreData(
    objc.NSData data, {
    required objc.ObjCBlock<ffi.Void Function(objc.NSError?)> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.restoreData:completionHandler:',
      iOS: (false, (26, 0, 0)),
      macOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_o762yo(
      object$.ref.pointer,
      _sel_restoreData_completionHandler_,
      data.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// resumeAllMediaPlayback:
  void resumeAllMediaPlayback(
    objc.ObjCBlock<ffi.Void Function()>? completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'WKWebView.resumeAllMediaPlayback:',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_resumeAllMediaPlayback_,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// resumeDownloadFromResumeData:completionHandler:
  void resumeDownloadFromResumeData(
    objc.NSData resumeData, {
    required objc.ObjCBlock<ffi.Void Function(WKDownload)> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.resumeDownloadFromResumeData:completionHandler:',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    _objc_msgSend_o762yo(
      object$.ref.pointer,
      _sel_resumeDownloadFromResumeData_completionHandler_,
      resumeData.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// serverTrust
  ffi.Pointer<__SecTrust> get serverTrust {
    objc.checkOsVersionInternal(
      'WKWebView.serverTrust',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
    return _objc_msgSend_1ommad9(object$.ref.pointer, _sel_serverTrust);
  }

  /// setAllMediaPlaybackSuspended:completionHandler:
  void setAllMediaPlaybackSuspended(
    bool suspended, {
    objc.ObjCBlock<ffi.Void Function()>? completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.setAllMediaPlaybackSuspended:completionHandler:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    _objc_msgSend_1ocak7a(
      object$.ref.pointer,
      _sel_setAllMediaPlaybackSuspended_completionHandler_,
      suspended,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAllowsBackForwardNavigationGestures:
  set allowsBackForwardNavigationGestures(bool value) {
    objc.checkOsVersionInternal(
      'WKWebView.setAllowsBackForwardNavigationGestures:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAllowsBackForwardNavigationGestures_,
      value,
    );
  }

  /// setAllowsLinkPreview:
  set allowsLinkPreview(bool value) {
    objc.checkOsVersionInternal(
      'WKWebView.setAllowsLinkPreview:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAllowsLinkPreview_,
      value,
    );
  }

  /// setAllowsMagnification:
  set allowsMagnification(bool value) {
    objc.checkOsVersionInternal(
      'WKWebView.setAllowsMagnification:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAllowsMagnification_,
      value,
    );
  }

  /// setCameraCaptureState:completionHandler:
  void setCameraCaptureState(
    WKMediaCaptureState state, {
    objc.ObjCBlock<ffi.Void Function()>? completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.setCameraCaptureState:completionHandler:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    _objc_msgSend_dhyh3z(
      object$.ref.pointer,
      _sel_setCameraCaptureState_completionHandler_,
      state.value,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setCustomUserAgent:
  set customUserAgent(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'WKWebView.setCustomUserAgent:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setCustomUserAgent_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setInspectable:
  set isInspectable(bool value) {
    objc.checkOsVersionInternal(
      'WKWebView.setInspectable:',
      iOS: (false, (16, 4, 0)),
      macOS: (false, (13, 3, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setInspectable_, value);
  }

  /// setInteractionState:
  set interactionState(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'WKWebView.setInteractionState:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setInteractionState_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setMagnification:
  set magnification(double value) {
    objc.checkOsVersionInternal(
      'WKWebView.setMagnification:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setMagnification_, value);
  }

  /// setMagnification:centeredAtPoint:
  void setMagnification(
    double magnification, {
    required objc.CGPoint centeredAtPoint,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.setMagnification:centeredAtPoint:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1dt5h8l(
      object$.ref.pointer,
      _sel_setMagnification_centeredAtPoint_,
      magnification,
      centeredAtPoint,
    );
  }

  /// setMediaType:
  set mediaType(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'WKWebView.setMediaType:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMediaType_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setMicrophoneCaptureState:completionHandler:
  void setMicrophoneCaptureState(
    WKMediaCaptureState state, {
    objc.ObjCBlock<ffi.Void Function()>? completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.setMicrophoneCaptureState:completionHandler:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    _objc_msgSend_dhyh3z(
      object$.ref.pointer,
      _sel_setMicrophoneCaptureState_completionHandler_,
      state.value,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setMinimumViewportInset:maximumViewportInset:
  void setMinimumViewportInset(
    objc.NSEdgeInsets minimumViewportInset, {
    required objc.NSEdgeInsets maximumViewportInset,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.setMinimumViewportInset:maximumViewportInset:',
      macOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_n6tx5n(
      object$.ref.pointer,
      _sel_setMinimumViewportInset_maximumViewportInset_,
      minimumViewportInset,
      maximumViewportInset,
    );
  }

  /// setNavigationDelegate:
  set navigationDelegate(WKNavigationDelegate? value) {
    objc.checkOsVersionInternal(
      'WKWebView.setNavigationDelegate:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setNavigationDelegate_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setObscuredContentInsets:
  set obscuredContentInsets(objc.NSEdgeInsets value) {
    objc.checkOsVersionInternal(
      'WKWebView.setObscuredContentInsets:',
      macOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_1ug163q(
      object$.ref.pointer,
      _sel_setObscuredContentInsets_,
      value,
    );
  }

  /// setPageZoom:
  set pageZoom(double value) {
    objc.checkOsVersionInternal(
      'WKWebView.setPageZoom:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setPageZoom_, value);
  }

  /// setUIDelegate:
  set UIDelegate(WKUIDelegate? value) {
    objc.checkOsVersionInternal(
      'WKWebView.setUIDelegate:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setUIDelegate_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setUnderPageBackgroundColor:
  set underPageBackgroundColor(NSColor value) {
    objc.checkOsVersionInternal(
      'WKWebView.setUnderPageBackgroundColor:',
      macOS: (false, (12, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setUnderPageBackgroundColor_,
      value.ref.pointer,
    );
  }

  /// startDownloadUsingRequest:completionHandler:
  void startDownloadUsingRequest(
    NSURLRequest request, {
    required objc.ObjCBlock<ffi.Void Function(WKDownload)> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.startDownloadUsingRequest:completionHandler:',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    _objc_msgSend_o762yo(
      object$.ref.pointer,
      _sel_startDownloadUsingRequest_completionHandler_,
      request.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// stopLoading
  void stopLoading() {
    objc.checkOsVersionInternal(
      'WKWebView.stopLoading',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_stopLoading);
  }

  /// suspendAllMediaPlayback:
  void suspendAllMediaPlayback(
    objc.ObjCBlock<ffi.Void Function()>? completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'WKWebView.suspendAllMediaPlayback:',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_suspendAllMediaPlayback_,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// takeSnapshotWithConfiguration:completionHandler:
  void takeSnapshotWithConfiguration(
    WKSnapshotConfiguration? snapshotConfiguration, {
    required objc.ObjCBlock<ffi.Void Function(NSImage?, objc.NSError?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.takeSnapshotWithConfiguration:completionHandler:',
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_o762yo(
      object$.ref.pointer,
      _sel_takeSnapshotWithConfiguration_completionHandler_,
      snapshotConfiguration?.ref.pointer ?? ffi.nullptr,
      completionHandler.ref.pointer,
    );
  }

  /// themeColor
  NSColor? get themeColor {
    objc.checkOsVersionInternal(
      'WKWebView.themeColor',
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_themeColor);
    return $ret.address == 0
        ? null
        : NSColor.fromPointer($ret, retain: true, release: true);
  }

  /// title
  objc.NSString? get title {
    objc.checkOsVersionInternal(
      'WKWebView.title',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_title);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// underPageBackgroundColor
  NSColor get underPageBackgroundColor {
    objc.checkOsVersionInternal(
      'WKWebView.underPageBackgroundColor',
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_underPageBackgroundColor,
    );
    return NSColor.fromPointer($ret, retain: true, release: true);
  }
}

enum WKCookiePolicy {
  WKCookiePolicyAllow(0),
  WKCookiePolicyDisallow(1);

  final int value;
  const WKCookiePolicy(this.value);

  static WKCookiePolicy fromValue(int value) => switch (value) {
    0 => WKCookiePolicyAllow,
    1 => WKCookiePolicyDisallow,
    _ => throw ArgumentError('Unknown value for WKCookiePolicy: $value'),
  };
}

enum WKContentMode {
  WKContentModeRecommended(0),
  WKContentModeMobile(1),
  WKContentModeDesktop(2);

  final int value;
  const WKContentMode(this.value);

  static WKContentMode fromValue(int value) => switch (value) {
    0 => WKContentModeRecommended,
    1 => WKContentModeMobile,
    2 => WKContentModeDesktop,
    _ => throw ArgumentError('Unknown value for WKContentMode: $value'),
  };
}

enum WKWebpagePreferencesUpgradeToHTTPSPolicy {
  WKWebpagePreferencesUpgradeToHTTPSPolicyKeepAsRequested(0),
  WKWebpagePreferencesUpgradeToHTTPSPolicyAutomaticFallbackToHTTP(1),
  WKWebpagePreferencesUpgradeToHTTPSPolicyUserMediatedFallbackToHTTP(2),
  WKWebpagePreferencesUpgradeToHTTPSPolicyErrorOnFailure(3);

  final int value;
  const WKWebpagePreferencesUpgradeToHTTPSPolicy(this.value);

  static WKWebpagePreferencesUpgradeToHTTPSPolicy fromValue(int value) =>
      switch (value) {
        0 => WKWebpagePreferencesUpgradeToHTTPSPolicyKeepAsRequested,
        1 => WKWebpagePreferencesUpgradeToHTTPSPolicyAutomaticFallbackToHTTP,
        2 => WKWebpagePreferencesUpgradeToHTTPSPolicyUserMediatedFallbackToHTTP,
        3 => WKWebpagePreferencesUpgradeToHTTPSPolicyErrorOnFailure,
        _ => throw ArgumentError(
          'Unknown value for WKWebpagePreferencesUpgradeToHTTPSPolicy: $value',
        ),
      };
}

enum WKNavigationType {
  WKNavigationTypeLinkActivated(0),
  WKNavigationTypeFormSubmitted(1),
  WKNavigationTypeBackForward(2),
  WKNavigationTypeReload(3),
  WKNavigationTypeFormResubmitted(4),
  WKNavigationTypeOther(-1);

  final int value;
  const WKNavigationType(this.value);

  static WKNavigationType fromValue(int value) => switch (value) {
    0 => WKNavigationTypeLinkActivated,
    1 => WKNavigationTypeFormSubmitted,
    2 => WKNavigationTypeBackForward,
    3 => WKNavigationTypeReload,
    4 => WKNavigationTypeFormResubmitted,
    -1 => WKNavigationTypeOther,
    _ => throw ArgumentError('Unknown value for WKNavigationType: $value'),
  };
}

enum WKInactiveSchedulingPolicy {
  WKInactiveSchedulingPolicySuspend(0),
  WKInactiveSchedulingPolicyThrottle(1),
  WKInactiveSchedulingPolicyNone(2);

  final int value;
  const WKInactiveSchedulingPolicy(this.value);

  static WKInactiveSchedulingPolicy fromValue(int value) => switch (value) {
    0 => WKInactiveSchedulingPolicySuspend,
    1 => WKInactiveSchedulingPolicyThrottle,
    2 => WKInactiveSchedulingPolicyNone,
    _ => throw ArgumentError(
      'Unknown value for WKInactiveSchedulingPolicy: $value',
    ),
  };
}

enum WKPermissionDecision {
  WKPermissionDecisionPrompt(0),
  WKPermissionDecisionGrant(1),
  WKPermissionDecisionDeny(2);

  final int value;
  const WKPermissionDecision(this.value);

  static WKPermissionDecision fromValue(int value) => switch (value) {
    0 => WKPermissionDecisionPrompt,
    1 => WKPermissionDecisionGrant,
    2 => WKPermissionDecisionDeny,
    _ => throw ArgumentError('Unknown value for WKPermissionDecision: $value'),
  };
}

enum WKMediaCaptureType {
  WKMediaCaptureTypeCamera(0),
  WKMediaCaptureTypeMicrophone(1),
  WKMediaCaptureTypeCameraAndMicrophone(2);

  final int value;
  const WKMediaCaptureType(this.value);

  static WKMediaCaptureType fromValue(int value) => switch (value) {
    0 => WKMediaCaptureTypeCamera,
    1 => WKMediaCaptureTypeMicrophone,
    2 => WKMediaCaptureTypeCameraAndMicrophone,
    _ => throw ArgumentError('Unknown value for WKMediaCaptureType: $value'),
  };
}

enum WKUserScriptInjectionTime {
  WKUserScriptInjectionTimeAtDocumentStart(0),
  WKUserScriptInjectionTimeAtDocumentEnd(1);

  final int value;
  const WKUserScriptInjectionTime(this.value);

  static WKUserScriptInjectionTime fromValue(int value) => switch (value) {
    0 => WKUserScriptInjectionTimeAtDocumentStart,
    1 => WKUserScriptInjectionTimeAtDocumentEnd,
    _ => throw ArgumentError(
      'Unknown value for WKUserScriptInjectionTime: $value',
    ),
  };
}

sealed class WKWebExtensionMatchPatternOptions {
  static const WKWebExtensionMatchPatternOptionsNone = 0;
  static const WKWebExtensionMatchPatternOptionsIgnoreSchemes = 1;
  static const WKWebExtensionMatchPatternOptionsIgnorePaths = 2;
  static const WKWebExtensionMatchPatternOptionsMatchBidirectionally = 4;
}

sealed class WKWebExtensionTabChangedProperties {
  static const WKWebExtensionTabChangedPropertiesNone = 0;
  static const WKWebExtensionTabChangedPropertiesLoading = 2;
  static const WKWebExtensionTabChangedPropertiesMuted = 4;
  static const WKWebExtensionTabChangedPropertiesPinned = 8;
  static const WKWebExtensionTabChangedPropertiesPlayingAudio = 16;
  static const WKWebExtensionTabChangedPropertiesReaderMode = 32;
  static const WKWebExtensionTabChangedPropertiesSize = 64;
  static const WKWebExtensionTabChangedPropertiesTitle = 128;
  static const WKWebExtensionTabChangedPropertiesURL = 256;
  static const WKWebExtensionTabChangedPropertiesZoomFactor = 512;
}

enum WKWebExtensionContextPermissionStatus {
  WKWebExtensionContextPermissionStatusDeniedExplicitly(-3),
  WKWebExtensionContextPermissionStatusDeniedImplicitly(-2),
  WKWebExtensionContextPermissionStatusRequestedImplicitly(-1),
  WKWebExtensionContextPermissionStatusUnknown(0),
  WKWebExtensionContextPermissionStatusRequestedExplicitly(1),
  WKWebExtensionContextPermissionStatusGrantedImplicitly(2),
  WKWebExtensionContextPermissionStatusGrantedExplicitly(3);

  final int value;
  const WKWebExtensionContextPermissionStatus(this.value);

  static WKWebExtensionContextPermissionStatus fromValue(int value) =>
      switch (value) {
        -3 => WKWebExtensionContextPermissionStatusDeniedExplicitly,
        -2 => WKWebExtensionContextPermissionStatusDeniedImplicitly,
        -1 => WKWebExtensionContextPermissionStatusRequestedImplicitly,
        0 => WKWebExtensionContextPermissionStatusUnknown,
        1 => WKWebExtensionContextPermissionStatusRequestedExplicitly,
        2 => WKWebExtensionContextPermissionStatusGrantedImplicitly,
        3 => WKWebExtensionContextPermissionStatusGrantedExplicitly,
        _ => throw ArgumentError(
          'Unknown value for WKWebExtensionContextPermissionStatus: $value',
        ),
      };
}

enum WKWebExtensionWindowType {
  WKWebExtensionWindowTypeNormal(0),
  WKWebExtensionWindowTypePopup(1);

  final int value;
  const WKWebExtensionWindowType(this.value);

  static WKWebExtensionWindowType fromValue(int value) => switch (value) {
    0 => WKWebExtensionWindowTypeNormal,
    1 => WKWebExtensionWindowTypePopup,
    _ => throw ArgumentError(
      'Unknown value for WKWebExtensionWindowType: $value',
    ),
  };
}

enum WKWebExtensionWindowState {
  WKWebExtensionWindowStateNormal(0),
  WKWebExtensionWindowStateMinimized(1),
  WKWebExtensionWindowStateMaximized(2),
  WKWebExtensionWindowStateFullscreen(3);

  final int value;
  const WKWebExtensionWindowState(this.value);

  static WKWebExtensionWindowState fromValue(int value) => switch (value) {
    0 => WKWebExtensionWindowStateNormal,
    1 => WKWebExtensionWindowStateMinimized,
    2 => WKWebExtensionWindowStateMaximized,
    3 => WKWebExtensionWindowStateFullscreen,
    _ => throw ArgumentError(
      'Unknown value for WKWebExtensionWindowState: $value',
    ),
  };
}
