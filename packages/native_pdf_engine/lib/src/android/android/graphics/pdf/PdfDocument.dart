// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// Generated by jnigen. Do not edit.

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import '../Canvas.dart' as canvas$_;

/// from: `android.graphics.pdf.PdfDocument$Page`
class PdfDocument$Page extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<PdfDocument$Page> $type;

  @jni$_.internal
  PdfDocument$Page.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/graphics/pdf/PdfDocument$Page',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<PdfDocument$Page?> nullableType =
      $PdfDocument$Page$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<PdfDocument$Page> type = $PdfDocument$Page$Type$();
  static final _id_getCanvas = _class.instanceMethodId(
    r'getCanvas',
    r'()Landroid/graphics/Canvas;',
  );

  static final _getCanvas =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.Canvas getCanvas()`
  /// The returned object must be released after use, by calling the [release] method.
  canvas$_.Canvas? getCanvas() {
    return _getCanvas(
      reference.pointer,
      _id_getCanvas as jni$_.JMethodIDPtr,
    ).object<canvas$_.Canvas?>(const canvas$_.$Canvas$NullableType$());
  }

  static final _id_getInfo = _class.instanceMethodId(
    r'getInfo',
    r'()Landroid/graphics/pdf/PdfDocument$PageInfo;',
  );

  static final _getInfo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.pdf.PdfDocument$PageInfo getInfo()`
  /// The returned object must be released after use, by calling the [release] method.
  PdfDocument$PageInfo? getInfo() {
    return _getInfo(
      reference.pointer,
      _id_getInfo as jni$_.JMethodIDPtr,
    ).object<PdfDocument$PageInfo?>(
      const $PdfDocument$PageInfo$NullableType$(),
    );
  }
}

final class $PdfDocument$Page$NullableType$
    extends jni$_.JType<PdfDocument$Page?> {
  @jni$_.internal
  const $PdfDocument$Page$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/pdf/PdfDocument$Page;';

  @jni$_.internal
  @core$_.override
  PdfDocument$Page? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PdfDocument$Page.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<PdfDocument$Page?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PdfDocument$Page$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PdfDocument$Page$NullableType$) &&
        other is $PdfDocument$Page$NullableType$;
  }
}

final class $PdfDocument$Page$Type$ extends jni$_.JType<PdfDocument$Page> {
  @jni$_.internal
  const $PdfDocument$Page$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/pdf/PdfDocument$Page;';

  @jni$_.internal
  @core$_.override
  PdfDocument$Page fromReference(jni$_.JReference reference) =>
      PdfDocument$Page.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<PdfDocument$Page?> get nullableType =>
      const $PdfDocument$Page$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PdfDocument$Page$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PdfDocument$Page$Type$) &&
        other is $PdfDocument$Page$Type$;
  }
}

/// from: `android.graphics.pdf.PdfDocument$PageInfo$Builder`
class PdfDocument$PageInfo$Builder extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<PdfDocument$PageInfo$Builder> $type;

  @jni$_.internal
  PdfDocument$PageInfo$Builder.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/graphics/pdf/PdfDocument$PageInfo$Builder',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<PdfDocument$PageInfo$Builder?> nullableType =
      $PdfDocument$PageInfo$Builder$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<PdfDocument$PageInfo$Builder> type =
      $PdfDocument$PageInfo$Builder$Type$();
  static final _id_new$ = _class.constructorId(r'(III)V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
            )
          >();

  /// from: `public void <init>(int i, int i1, int i2)`
  /// The returned object must be released after use, by calling the [release] method.
  factory PdfDocument$PageInfo$Builder(int i, int i1, int i2) {
    return PdfDocument$PageInfo$Builder.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        i,
        i1,
        i2,
      ).reference,
    );
  }

  static final _id_create = _class.instanceMethodId(
    r'create',
    r'()Landroid/graphics/pdf/PdfDocument$PageInfo;',
  );

  static final _create =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.pdf.PdfDocument$PageInfo create()`
  /// The returned object must be released after use, by calling the [release] method.
  PdfDocument$PageInfo? create() {
    return _create(
      reference.pointer,
      _id_create as jni$_.JMethodIDPtr,
    ).object<PdfDocument$PageInfo?>(
      const $PdfDocument$PageInfo$NullableType$(),
    );
  }

  static final _id_setContentRect = _class.instanceMethodId(
    r'setContentRect',
    r'(Landroid/graphics/Rect;)Landroid/graphics/pdf/PdfDocument$PageInfo$Builder;',
  );

  static final _setContentRect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.graphics.pdf.PdfDocument$PageInfo$Builder setContentRect(android.graphics.Rect rect)`
  /// The returned object must be released after use, by calling the [release] method.
  PdfDocument$PageInfo$Builder? setContentRect(jni$_.JObject? rect) {
    final _$rect = rect?.reference ?? jni$_.jNullReference;
    return _setContentRect(
      reference.pointer,
      _id_setContentRect as jni$_.JMethodIDPtr,
      _$rect.pointer,
    ).object<PdfDocument$PageInfo$Builder?>(
      const $PdfDocument$PageInfo$Builder$NullableType$(),
    );
  }
}

final class $PdfDocument$PageInfo$Builder$NullableType$
    extends jni$_.JType<PdfDocument$PageInfo$Builder?> {
  @jni$_.internal
  const $PdfDocument$PageInfo$Builder$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/graphics/pdf/PdfDocument$PageInfo$Builder;';

  @jni$_.internal
  @core$_.override
  PdfDocument$PageInfo$Builder? fromReference(jni$_.JReference reference) =>
      reference.isNull
      ? null
      : PdfDocument$PageInfo$Builder.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<PdfDocument$PageInfo$Builder?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PdfDocument$PageInfo$Builder$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PdfDocument$PageInfo$Builder$NullableType$) &&
        other is $PdfDocument$PageInfo$Builder$NullableType$;
  }
}

final class $PdfDocument$PageInfo$Builder$Type$
    extends jni$_.JType<PdfDocument$PageInfo$Builder> {
  @jni$_.internal
  const $PdfDocument$PageInfo$Builder$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Landroid/graphics/pdf/PdfDocument$PageInfo$Builder;';

  @jni$_.internal
  @core$_.override
  PdfDocument$PageInfo$Builder fromReference(jni$_.JReference reference) =>
      PdfDocument$PageInfo$Builder.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<PdfDocument$PageInfo$Builder?> get nullableType =>
      const $PdfDocument$PageInfo$Builder$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PdfDocument$PageInfo$Builder$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PdfDocument$PageInfo$Builder$Type$) &&
        other is $PdfDocument$PageInfo$Builder$Type$;
  }
}

/// from: `android.graphics.pdf.PdfDocument$PageInfo`
class PdfDocument$PageInfo extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<PdfDocument$PageInfo> $type;

  @jni$_.internal
  PdfDocument$PageInfo.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/graphics/pdf/PdfDocument$PageInfo',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<PdfDocument$PageInfo?> nullableType =
      $PdfDocument$PageInfo$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<PdfDocument$PageInfo> type =
      $PdfDocument$PageInfo$Type$();
  static final _id_getContentRect = _class.instanceMethodId(
    r'getContentRect',
    r'()Landroid/graphics/Rect;',
  );

  static final _getContentRect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.Rect getContentRect()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getContentRect() {
    return _getContentRect(
      reference.pointer,
      _id_getContentRect as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getPageHeight = _class.instanceMethodId(
    r'getPageHeight',
    r'()I',
  );

  static final _getPageHeight =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getPageHeight()`
  int getPageHeight() {
    return _getPageHeight(
      reference.pointer,
      _id_getPageHeight as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getPageNumber = _class.instanceMethodId(
    r'getPageNumber',
    r'()I',
  );

  static final _getPageNumber =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getPageNumber()`
  int getPageNumber() {
    return _getPageNumber(
      reference.pointer,
      _id_getPageNumber as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getPageWidth = _class.instanceMethodId(
    r'getPageWidth',
    r'()I',
  );

  static final _getPageWidth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getPageWidth()`
  int getPageWidth() {
    return _getPageWidth(
      reference.pointer,
      _id_getPageWidth as jni$_.JMethodIDPtr,
    ).integer;
  }
}

final class $PdfDocument$PageInfo$NullableType$
    extends jni$_.JType<PdfDocument$PageInfo?> {
  @jni$_.internal
  const $PdfDocument$PageInfo$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/pdf/PdfDocument$PageInfo;';

  @jni$_.internal
  @core$_.override
  PdfDocument$PageInfo? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PdfDocument$PageInfo.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<PdfDocument$PageInfo?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PdfDocument$PageInfo$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PdfDocument$PageInfo$NullableType$) &&
        other is $PdfDocument$PageInfo$NullableType$;
  }
}

final class $PdfDocument$PageInfo$Type$
    extends jni$_.JType<PdfDocument$PageInfo> {
  @jni$_.internal
  const $PdfDocument$PageInfo$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/pdf/PdfDocument$PageInfo;';

  @jni$_.internal
  @core$_.override
  PdfDocument$PageInfo fromReference(jni$_.JReference reference) =>
      PdfDocument$PageInfo.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<PdfDocument$PageInfo?> get nullableType =>
      const $PdfDocument$PageInfo$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PdfDocument$PageInfo$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PdfDocument$PageInfo$Type$) &&
        other is $PdfDocument$PageInfo$Type$;
  }
}

/// from: `android.graphics.pdf.PdfDocument`
class PdfDocument extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<PdfDocument> $type;

  @jni$_.internal
  PdfDocument.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/graphics/pdf/PdfDocument',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<PdfDocument?> nullableType =
      $PdfDocument$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<PdfDocument> type = $PdfDocument$Type$();
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory PdfDocument() {
    return PdfDocument.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_close = _class.instanceMethodId(r'close', r'()V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close() {
    _close(reference.pointer, _id_close as jni$_.JMethodIDPtr).check();
  }

  static final _id_finishPage = _class.instanceMethodId(
    r'finishPage',
    r'(Landroid/graphics/pdf/PdfDocument$Page;)V',
  );

  static final _finishPage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void finishPage(android.graphics.pdf.PdfDocument$Page page)`
  void finishPage(PdfDocument$Page? page) {
    final _$page = page?.reference ?? jni$_.jNullReference;
    _finishPage(
      reference.pointer,
      _id_finishPage as jni$_.JMethodIDPtr,
      _$page.pointer,
    ).check();
  }

  static final _id_getPages = _class.instanceMethodId(
    r'getPages',
    r'()Ljava/util/List;',
  );

  static final _getPages =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<android.graphics.pdf.PdfDocument$PageInfo> getPages()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<PdfDocument$PageInfo?>? getPages() {
    return _getPages(
      reference.pointer,
      _id_getPages as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<PdfDocument$PageInfo?>?>(
      const jni$_.$JList$NullableType$<PdfDocument$PageInfo?>(
        $PdfDocument$PageInfo$NullableType$(),
      ),
    );
  }

  static final _id_startPage = _class.instanceMethodId(
    r'startPage',
    r'(Landroid/graphics/pdf/PdfDocument$PageInfo;)Landroid/graphics/pdf/PdfDocument$Page;',
  );

  static final _startPage =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.graphics.pdf.PdfDocument$Page startPage(android.graphics.pdf.PdfDocument$PageInfo pageInfo)`
  /// The returned object must be released after use, by calling the [release] method.
  PdfDocument$Page? startPage(PdfDocument$PageInfo? pageInfo) {
    final _$pageInfo = pageInfo?.reference ?? jni$_.jNullReference;
    return _startPage(
      reference.pointer,
      _id_startPage as jni$_.JMethodIDPtr,
      _$pageInfo.pointer,
    ).object<PdfDocument$Page?>(const $PdfDocument$Page$NullableType$());
  }

  static final _id_writeTo = _class.instanceMethodId(
    r'writeTo',
    r'(Ljava/io/OutputStream;)V',
  );

  static final _writeTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void writeTo(java.io.OutputStream outputStream)`
  void writeTo(jni$_.JObject? outputStream) {
    final _$outputStream = outputStream?.reference ?? jni$_.jNullReference;
    _writeTo(
      reference.pointer,
      _id_writeTo as jni$_.JMethodIDPtr,
      _$outputStream.pointer,
    ).check();
  }
}

final class $PdfDocument$NullableType$ extends jni$_.JType<PdfDocument?> {
  @jni$_.internal
  const $PdfDocument$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/pdf/PdfDocument;';

  @jni$_.internal
  @core$_.override
  PdfDocument? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : PdfDocument.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<PdfDocument?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PdfDocument$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PdfDocument$NullableType$) &&
        other is $PdfDocument$NullableType$;
  }
}

final class $PdfDocument$Type$ extends jni$_.JType<PdfDocument> {
  @jni$_.internal
  const $PdfDocument$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/pdf/PdfDocument;';

  @jni$_.internal
  @core$_.override
  PdfDocument fromReference(jni$_.JReference reference) =>
      PdfDocument.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<PdfDocument?> get nullableType =>
      const $PdfDocument$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($PdfDocument$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($PdfDocument$Type$) &&
        other is $PdfDocument$Type$;
  }
}
