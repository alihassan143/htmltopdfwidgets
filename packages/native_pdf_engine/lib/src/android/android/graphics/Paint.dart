// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// Generated by jnigen. Do not edit.

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `android.graphics.Paint$Align`
class Paint$Align extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Paint$Align> $type;

  @jni$_.internal
  Paint$Align.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/graphics/Paint$Align');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Paint$Align?> nullableType =
      $Paint$Align$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Paint$Align> type = $Paint$Align$Type$();
  static final _id_CENTER = _class.staticFieldId(
    r'CENTER',
    r'Landroid/graphics/Paint$Align;',
  );

  /// from: `static public final android.graphics.Paint$Align CENTER`
  /// The returned object must be released after use, by calling the [release] method.
  static Paint$Align get CENTER =>
      _id_CENTER.get(_class, const $Paint$Align$Type$());

  static final _id_LEFT = _class.staticFieldId(
    r'LEFT',
    r'Landroid/graphics/Paint$Align;',
  );

  /// from: `static public final android.graphics.Paint$Align LEFT`
  /// The returned object must be released after use, by calling the [release] method.
  static Paint$Align get LEFT =>
      _id_LEFT.get(_class, const $Paint$Align$Type$());

  static final _id_RIGHT = _class.staticFieldId(
    r'RIGHT',
    r'Landroid/graphics/Paint$Align;',
  );

  /// from: `static public final android.graphics.Paint$Align RIGHT`
  /// The returned object must be released after use, by calling the [release] method.
  static Paint$Align get RIGHT =>
      _id_RIGHT.get(_class, const $Paint$Align$Type$());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Landroid/graphics/Paint$Align;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public android.graphics.Paint$Align[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Paint$Align?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<Paint$Align?>?>(
      const jni$_.$JArray$NullableType$<Paint$Align?>(
        $Paint$Align$NullableType$(),
      ),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Landroid/graphics/Paint$Align;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Paint$Align valueOf(java.lang.String synthetic)`
  /// The returned object must be released after use, by calling the [release] method.
  static Paint$Align? valueOf(jni$_.JString? synthetic) {
    final _$synthetic = synthetic?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$synthetic.pointer,
    ).object<Paint$Align?>(const $Paint$Align$NullableType$());
  }
}

final class $Paint$Align$NullableType$ extends jni$_.JType<Paint$Align?> {
  @jni$_.internal
  const $Paint$Align$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Paint$Align;';

  @jni$_.internal
  @core$_.override
  Paint$Align? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Paint$Align.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Paint$Align?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Paint$Align$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Paint$Align$NullableType$) &&
        other is $Paint$Align$NullableType$;
  }
}

final class $Paint$Align$Type$ extends jni$_.JType<Paint$Align> {
  @jni$_.internal
  const $Paint$Align$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Paint$Align;';

  @jni$_.internal
  @core$_.override
  Paint$Align fromReference(jni$_.JReference reference) =>
      Paint$Align.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Paint$Align?> get nullableType =>
      const $Paint$Align$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Paint$Align$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Paint$Align$Type$) &&
        other is $Paint$Align$Type$;
  }
}

/// from: `android.graphics.Paint$Cap`
class Paint$Cap extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Paint$Cap> $type;

  @jni$_.internal
  Paint$Cap.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/graphics/Paint$Cap');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Paint$Cap?> nullableType =
      $Paint$Cap$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Paint$Cap> type = $Paint$Cap$Type$();
  static final _id_BUTT = _class.staticFieldId(
    r'BUTT',
    r'Landroid/graphics/Paint$Cap;',
  );

  /// from: `static public final android.graphics.Paint$Cap BUTT`
  /// The returned object must be released after use, by calling the [release] method.
  static Paint$Cap get BUTT => _id_BUTT.get(_class, const $Paint$Cap$Type$());

  static final _id_ROUND = _class.staticFieldId(
    r'ROUND',
    r'Landroid/graphics/Paint$Cap;',
  );

  /// from: `static public final android.graphics.Paint$Cap ROUND`
  /// The returned object must be released after use, by calling the [release] method.
  static Paint$Cap get ROUND => _id_ROUND.get(_class, const $Paint$Cap$Type$());

  static final _id_SQUARE = _class.staticFieldId(
    r'SQUARE',
    r'Landroid/graphics/Paint$Cap;',
  );

  /// from: `static public final android.graphics.Paint$Cap SQUARE`
  /// The returned object must be released after use, by calling the [release] method.
  static Paint$Cap get SQUARE =>
      _id_SQUARE.get(_class, const $Paint$Cap$Type$());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Landroid/graphics/Paint$Cap;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public android.graphics.Paint$Cap[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Paint$Cap?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<Paint$Cap?>?>(
      const jni$_.$JArray$NullableType$<Paint$Cap?>($Paint$Cap$NullableType$()),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Landroid/graphics/Paint$Cap;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Paint$Cap valueOf(java.lang.String synthetic)`
  /// The returned object must be released after use, by calling the [release] method.
  static Paint$Cap? valueOf(jni$_.JString? synthetic) {
    final _$synthetic = synthetic?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$synthetic.pointer,
    ).object<Paint$Cap?>(const $Paint$Cap$NullableType$());
  }
}

final class $Paint$Cap$NullableType$ extends jni$_.JType<Paint$Cap?> {
  @jni$_.internal
  const $Paint$Cap$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Paint$Cap;';

  @jni$_.internal
  @core$_.override
  Paint$Cap? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Paint$Cap.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Paint$Cap?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Paint$Cap$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Paint$Cap$NullableType$) &&
        other is $Paint$Cap$NullableType$;
  }
}

final class $Paint$Cap$Type$ extends jni$_.JType<Paint$Cap> {
  @jni$_.internal
  const $Paint$Cap$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Paint$Cap;';

  @jni$_.internal
  @core$_.override
  Paint$Cap fromReference(jni$_.JReference reference) =>
      Paint$Cap.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Paint$Cap?> get nullableType => const $Paint$Cap$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Paint$Cap$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Paint$Cap$Type$) && other is $Paint$Cap$Type$;
  }
}

/// from: `android.graphics.Paint$FontMetrics`
class Paint$FontMetrics extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Paint$FontMetrics> $type;

  @jni$_.internal
  Paint$FontMetrics.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/graphics/Paint$FontMetrics',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Paint$FontMetrics?> nullableType =
      $Paint$FontMetrics$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Paint$FontMetrics> type = $Paint$FontMetrics$Type$();
  static final _id_ascent = _class.instanceFieldId(r'ascent', r'F');

  /// from: `public float ascent`
  double get ascent => _id_ascent.get(this, const jni$_.jfloatType());

  /// from: `public float ascent`
  set ascent(double value) =>
      _id_ascent.set(this, const jni$_.jfloatType(), value);

  static final _id_bottom = _class.instanceFieldId(r'bottom', r'F');

  /// from: `public float bottom`
  double get bottom => _id_bottom.get(this, const jni$_.jfloatType());

  /// from: `public float bottom`
  set bottom(double value) =>
      _id_bottom.set(this, const jni$_.jfloatType(), value);

  static final _id_descent = _class.instanceFieldId(r'descent', r'F');

  /// from: `public float descent`
  double get descent => _id_descent.get(this, const jni$_.jfloatType());

  /// from: `public float descent`
  set descent(double value) =>
      _id_descent.set(this, const jni$_.jfloatType(), value);

  static final _id_leading = _class.instanceFieldId(r'leading', r'F');

  /// from: `public float leading`
  double get leading => _id_leading.get(this, const jni$_.jfloatType());

  /// from: `public float leading`
  set leading(double value) =>
      _id_leading.set(this, const jni$_.jfloatType(), value);

  static final _id_top = _class.instanceFieldId(r'top', r'F');

  /// from: `public float top`
  double get top => _id_top.get(this, const jni$_.jfloatType());

  /// from: `public float top`
  set top(double value) => _id_top.set(this, const jni$_.jfloatType(), value);

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Paint$FontMetrics() {
    return Paint$FontMetrics.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }
}

final class $Paint$FontMetrics$NullableType$
    extends jni$_.JType<Paint$FontMetrics?> {
  @jni$_.internal
  const $Paint$FontMetrics$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Paint$FontMetrics;';

  @jni$_.internal
  @core$_.override
  Paint$FontMetrics? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Paint$FontMetrics.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Paint$FontMetrics?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Paint$FontMetrics$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Paint$FontMetrics$NullableType$) &&
        other is $Paint$FontMetrics$NullableType$;
  }
}

final class $Paint$FontMetrics$Type$ extends jni$_.JType<Paint$FontMetrics> {
  @jni$_.internal
  const $Paint$FontMetrics$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Paint$FontMetrics;';

  @jni$_.internal
  @core$_.override
  Paint$FontMetrics fromReference(jni$_.JReference reference) =>
      Paint$FontMetrics.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Paint$FontMetrics?> get nullableType =>
      const $Paint$FontMetrics$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Paint$FontMetrics$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Paint$FontMetrics$Type$) &&
        other is $Paint$FontMetrics$Type$;
  }
}

/// from: `android.graphics.Paint$FontMetricsInt`
class Paint$FontMetricsInt extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Paint$FontMetricsInt> $type;

  @jni$_.internal
  Paint$FontMetricsInt.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'android/graphics/Paint$FontMetricsInt',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Paint$FontMetricsInt?> nullableType =
      $Paint$FontMetricsInt$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Paint$FontMetricsInt> type =
      $Paint$FontMetricsInt$Type$();
  static final _id_ascent = _class.instanceFieldId(r'ascent', r'I');

  /// from: `public int ascent`
  int get ascent => _id_ascent.get(this, const jni$_.jintType());

  /// from: `public int ascent`
  set ascent(int value) => _id_ascent.set(this, const jni$_.jintType(), value);

  static final _id_bottom = _class.instanceFieldId(r'bottom', r'I');

  /// from: `public int bottom`
  int get bottom => _id_bottom.get(this, const jni$_.jintType());

  /// from: `public int bottom`
  set bottom(int value) => _id_bottom.set(this, const jni$_.jintType(), value);

  static final _id_descent = _class.instanceFieldId(r'descent', r'I');

  /// from: `public int descent`
  int get descent => _id_descent.get(this, const jni$_.jintType());

  /// from: `public int descent`
  set descent(int value) =>
      _id_descent.set(this, const jni$_.jintType(), value);

  static final _id_leading = _class.instanceFieldId(r'leading', r'I');

  /// from: `public int leading`
  int get leading => _id_leading.get(this, const jni$_.jintType());

  /// from: `public int leading`
  set leading(int value) =>
      _id_leading.set(this, const jni$_.jintType(), value);

  static final _id_top = _class.instanceFieldId(r'top', r'I');

  /// from: `public int top`
  int get top => _id_top.get(this, const jni$_.jintType());

  /// from: `public int top`
  set top(int value) => _id_top.set(this, const jni$_.jintType(), value);

  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Paint$FontMetricsInt() {
    return Paint$FontMetricsInt.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(jni$_.JObject? object) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$object.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_set = _class.instanceMethodId(
    r'set',
    r'(Landroid/graphics/Paint$FontMetrics;)V',
  );

  static final _set =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void set(android.graphics.Paint$FontMetrics fontMetrics)`
  void set(Paint$FontMetrics? fontMetrics) {
    final _$fontMetrics = fontMetrics?.reference ?? jni$_.jNullReference;
    _set(
      reference.pointer,
      _id_set as jni$_.JMethodIDPtr,
      _$fontMetrics.pointer,
    ).check();
  }

  static final _id_set$1 = _class.instanceMethodId(
    r'set',
    r'(Landroid/graphics/Paint$FontMetricsInt;)V',
  );

  static final _set$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void set(android.graphics.Paint$FontMetricsInt fontMetricsInt)`
  void set$1(Paint$FontMetricsInt? fontMetricsInt) {
    final _$fontMetricsInt = fontMetricsInt?.reference ?? jni$_.jNullReference;
    _set$1(
      reference.pointer,
      _id_set$1 as jni$_.JMethodIDPtr,
      _$fontMetricsInt.pointer,
    ).check();
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }
}

final class $Paint$FontMetricsInt$NullableType$
    extends jni$_.JType<Paint$FontMetricsInt?> {
  @jni$_.internal
  const $Paint$FontMetricsInt$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Paint$FontMetricsInt;';

  @jni$_.internal
  @core$_.override
  Paint$FontMetricsInt? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Paint$FontMetricsInt.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Paint$FontMetricsInt?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Paint$FontMetricsInt$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Paint$FontMetricsInt$NullableType$) &&
        other is $Paint$FontMetricsInt$NullableType$;
  }
}

final class $Paint$FontMetricsInt$Type$
    extends jni$_.JType<Paint$FontMetricsInt> {
  @jni$_.internal
  const $Paint$FontMetricsInt$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Paint$FontMetricsInt;';

  @jni$_.internal
  @core$_.override
  Paint$FontMetricsInt fromReference(jni$_.JReference reference) =>
      Paint$FontMetricsInt.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Paint$FontMetricsInt?> get nullableType =>
      const $Paint$FontMetricsInt$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Paint$FontMetricsInt$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Paint$FontMetricsInt$Type$) &&
        other is $Paint$FontMetricsInt$Type$;
  }
}

/// from: `android.graphics.Paint$Join`
class Paint$Join extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Paint$Join> $type;

  @jni$_.internal
  Paint$Join.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/graphics/Paint$Join');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Paint$Join?> nullableType =
      $Paint$Join$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Paint$Join> type = $Paint$Join$Type$();
  static final _id_BEVEL = _class.staticFieldId(
    r'BEVEL',
    r'Landroid/graphics/Paint$Join;',
  );

  /// from: `static public final android.graphics.Paint$Join BEVEL`
  /// The returned object must be released after use, by calling the [release] method.
  static Paint$Join get BEVEL =>
      _id_BEVEL.get(_class, const $Paint$Join$Type$());

  static final _id_MITER = _class.staticFieldId(
    r'MITER',
    r'Landroid/graphics/Paint$Join;',
  );

  /// from: `static public final android.graphics.Paint$Join MITER`
  /// The returned object must be released after use, by calling the [release] method.
  static Paint$Join get MITER =>
      _id_MITER.get(_class, const $Paint$Join$Type$());

  static final _id_ROUND = _class.staticFieldId(
    r'ROUND',
    r'Landroid/graphics/Paint$Join;',
  );

  /// from: `static public final android.graphics.Paint$Join ROUND`
  /// The returned object must be released after use, by calling the [release] method.
  static Paint$Join get ROUND =>
      _id_ROUND.get(_class, const $Paint$Join$Type$());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Landroid/graphics/Paint$Join;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public android.graphics.Paint$Join[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Paint$Join?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<Paint$Join?>?>(
      const jni$_.$JArray$NullableType$<Paint$Join?>(
        $Paint$Join$NullableType$(),
      ),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Landroid/graphics/Paint$Join;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Paint$Join valueOf(java.lang.String synthetic)`
  /// The returned object must be released after use, by calling the [release] method.
  static Paint$Join? valueOf(jni$_.JString? synthetic) {
    final _$synthetic = synthetic?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$synthetic.pointer,
    ).object<Paint$Join?>(const $Paint$Join$NullableType$());
  }
}

final class $Paint$Join$NullableType$ extends jni$_.JType<Paint$Join?> {
  @jni$_.internal
  const $Paint$Join$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Paint$Join;';

  @jni$_.internal
  @core$_.override
  Paint$Join? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Paint$Join.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Paint$Join?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Paint$Join$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Paint$Join$NullableType$) &&
        other is $Paint$Join$NullableType$;
  }
}

final class $Paint$Join$Type$ extends jni$_.JType<Paint$Join> {
  @jni$_.internal
  const $Paint$Join$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Paint$Join;';

  @jni$_.internal
  @core$_.override
  Paint$Join fromReference(jni$_.JReference reference) =>
      Paint$Join.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Paint$Join?> get nullableType =>
      const $Paint$Join$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Paint$Join$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Paint$Join$Type$) &&
        other is $Paint$Join$Type$;
  }
}

/// from: `android.graphics.Paint$Style`
class Paint$Style extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Paint$Style> $type;

  @jni$_.internal
  Paint$Style.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/graphics/Paint$Style');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Paint$Style?> nullableType =
      $Paint$Style$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Paint$Style> type = $Paint$Style$Type$();
  static final _id_FILL = _class.staticFieldId(
    r'FILL',
    r'Landroid/graphics/Paint$Style;',
  );

  /// from: `static public final android.graphics.Paint$Style FILL`
  /// The returned object must be released after use, by calling the [release] method.
  static Paint$Style get FILL =>
      _id_FILL.get(_class, const $Paint$Style$Type$());

  static final _id_FILL_AND_STROKE = _class.staticFieldId(
    r'FILL_AND_STROKE',
    r'Landroid/graphics/Paint$Style;',
  );

  /// from: `static public final android.graphics.Paint$Style FILL_AND_STROKE`
  /// The returned object must be released after use, by calling the [release] method.
  static Paint$Style get FILL_AND_STROKE =>
      _id_FILL_AND_STROKE.get(_class, const $Paint$Style$Type$());

  static final _id_STROKE = _class.staticFieldId(
    r'STROKE',
    r'Landroid/graphics/Paint$Style;',
  );

  /// from: `static public final android.graphics.Paint$Style STROKE`
  /// The returned object must be released after use, by calling the [release] method.
  static Paint$Style get STROKE =>
      _id_STROKE.get(_class, const $Paint$Style$Type$());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Landroid/graphics/Paint$Style;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public android.graphics.Paint$Style[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Paint$Style?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<Paint$Style?>?>(
      const jni$_.$JArray$NullableType$<Paint$Style?>(
        $Paint$Style$NullableType$(),
      ),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Landroid/graphics/Paint$Style;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public android.graphics.Paint$Style valueOf(java.lang.String synthetic)`
  /// The returned object must be released after use, by calling the [release] method.
  static Paint$Style? valueOf(jni$_.JString? synthetic) {
    final _$synthetic = synthetic?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$synthetic.pointer,
    ).object<Paint$Style?>(const $Paint$Style$NullableType$());
  }
}

final class $Paint$Style$NullableType$ extends jni$_.JType<Paint$Style?> {
  @jni$_.internal
  const $Paint$Style$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Paint$Style;';

  @jni$_.internal
  @core$_.override
  Paint$Style? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Paint$Style.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Paint$Style?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Paint$Style$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Paint$Style$NullableType$) &&
        other is $Paint$Style$NullableType$;
  }
}

final class $Paint$Style$Type$ extends jni$_.JType<Paint$Style> {
  @jni$_.internal
  const $Paint$Style$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Paint$Style;';

  @jni$_.internal
  @core$_.override
  Paint$Style fromReference(jni$_.JReference reference) =>
      Paint$Style.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Paint$Style?> get nullableType =>
      const $Paint$Style$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Paint$Style$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Paint$Style$Type$) &&
        other is $Paint$Style$Type$;
  }
}

/// from: `android.graphics.Paint`
class Paint extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Paint> $type;

  @jni$_.internal
  Paint.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'android/graphics/Paint');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Paint?> nullableType = $Paint$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Paint> type = $Paint$Type$();

  /// from: `static public final int ANTI_ALIAS_FLAG`
  static const ANTI_ALIAS_FLAG = 1;

  /// from: `static public final int CURSOR_AFTER`
  static const CURSOR_AFTER = 0;

  /// from: `static public final int CURSOR_AT`
  static const CURSOR_AT = 4;

  /// from: `static public final int CURSOR_AT_OR_AFTER`
  static const CURSOR_AT_OR_AFTER = 1;

  /// from: `static public final int CURSOR_AT_OR_BEFORE`
  static const CURSOR_AT_OR_BEFORE = 3;

  /// from: `static public final int CURSOR_BEFORE`
  static const CURSOR_BEFORE = 2;

  /// from: `static public final int DEV_KERN_TEXT_FLAG`
  static const DEV_KERN_TEXT_FLAG = 256;

  /// from: `static public final int DITHER_FLAG`
  static const DITHER_FLAG = 4;

  /// from: `static public final int EMBEDDED_BITMAP_TEXT_FLAG`
  static const EMBEDDED_BITMAP_TEXT_FLAG = 1024;

  /// from: `static public final int END_HYPHEN_EDIT_INSERT_ARMENIAN_HYPHEN`
  static const END_HYPHEN_EDIT_INSERT_ARMENIAN_HYPHEN = 3;

  /// from: `static public final int END_HYPHEN_EDIT_INSERT_HYPHEN`
  static const END_HYPHEN_EDIT_INSERT_HYPHEN = 2;

  /// from: `static public final int END_HYPHEN_EDIT_INSERT_MAQAF`
  static const END_HYPHEN_EDIT_INSERT_MAQAF = 4;

  /// from: `static public final int END_HYPHEN_EDIT_INSERT_UCAS_HYPHEN`
  static const END_HYPHEN_EDIT_INSERT_UCAS_HYPHEN = 5;

  /// from: `static public final int END_HYPHEN_EDIT_INSERT_ZWJ_AND_HYPHEN`
  static const END_HYPHEN_EDIT_INSERT_ZWJ_AND_HYPHEN = 6;

  /// from: `static public final int END_HYPHEN_EDIT_NO_EDIT`
  static const END_HYPHEN_EDIT_NO_EDIT = 0;

  /// from: `static public final int END_HYPHEN_EDIT_REPLACE_WITH_HYPHEN`
  static const END_HYPHEN_EDIT_REPLACE_WITH_HYPHEN = 1;

  /// from: `static public final int FAKE_BOLD_TEXT_FLAG`
  static const FAKE_BOLD_TEXT_FLAG = 32;

  /// from: `static public final int FILTER_BITMAP_FLAG`
  static const FILTER_BITMAP_FLAG = 2;

  /// from: `static public final int HINTING_OFF`
  static const HINTING_OFF = 0;

  /// from: `static public final int HINTING_ON`
  static const HINTING_ON = 1;

  /// from: `static public final int LINEAR_TEXT_FLAG`
  static const LINEAR_TEXT_FLAG = 64;

  /// from: `static public final int START_HYPHEN_EDIT_INSERT_HYPHEN`
  static const START_HYPHEN_EDIT_INSERT_HYPHEN = 1;

  /// from: `static public final int START_HYPHEN_EDIT_INSERT_ZWJ`
  static const START_HYPHEN_EDIT_INSERT_ZWJ = 2;

  /// from: `static public final int START_HYPHEN_EDIT_NO_EDIT`
  static const START_HYPHEN_EDIT_NO_EDIT = 0;

  /// from: `static public final int STRIKE_THRU_TEXT_FLAG`
  static const STRIKE_THRU_TEXT_FLAG = 16;

  /// from: `static public final int SUBPIXEL_TEXT_FLAG`
  static const SUBPIXEL_TEXT_FLAG = 128;

  /// from: `static public final int TEXT_RUN_FLAG_LEFT_EDGE`
  static const TEXT_RUN_FLAG_LEFT_EDGE = 8192;

  /// from: `static public final int TEXT_RUN_FLAG_RIGHT_EDGE`
  static const TEXT_RUN_FLAG_RIGHT_EDGE = 16384;

  /// from: `static public final int UNDERLINE_TEXT_FLAG`
  static const UNDERLINE_TEXT_FLAG = 8;

  /// from: `static public final int VERTICAL_TEXT_FLAG`
  static const VERTICAL_TEXT_FLAG = 4096;
  static final _id_new$ = _class.constructorId(r'()V');

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Paint() {
    return Paint.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(r'(Landroid/graphics/Paint;)V');

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(android.graphics.Paint paint)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Paint.new$1(Paint? paint) {
    final _$paint = paint?.reference ?? jni$_.jNullReference;
    return Paint.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$paint.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(r'(I)V');

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void <init>(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Paint.new$2(int i) {
    return Paint.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        i,
      ).reference,
    );
  }

  static final _id_ascent = _class.instanceMethodId(r'ascent', r'()F');

  static final _ascent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float ascent()`
  double ascent() {
    return _ascent(reference.pointer, _id_ascent as jni$_.JMethodIDPtr).float;
  }

  static final _id_breakText = _class.instanceMethodId(
    r'breakText',
    r'([CIIF[F)I',
  );

  static final _breakText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Double,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              double,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int breakText(char[] cs, int i, int i1, float f, float[] fs)`
  int breakText(
    jni$_.JCharArray? cs,
    int i,
    int i1,
    double f,
    jni$_.JFloatArray? fs,
  ) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    final _$fs = fs?.reference ?? jni$_.jNullReference;
    return _breakText(
      reference.pointer,
      _id_breakText as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
      f,
      _$fs.pointer,
    ).integer;
  }

  static final _id_breakText$1 = _class.instanceMethodId(
    r'breakText',
    r'(Ljava/lang/CharSequence;IIZF[F)I',
  );

  static final _breakText$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Double,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              double,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int breakText(java.lang.CharSequence charSequence, int i, int i1, boolean z, float f, float[] fs)`
  int breakText$1(
    jni$_.JObject? charSequence,
    int i,
    int i1,
    bool z,
    double f,
    jni$_.JFloatArray? fs,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$fs = fs?.reference ?? jni$_.jNullReference;
    return _breakText$1(
      reference.pointer,
      _id_breakText$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      i,
      i1,
      z ? 1 : 0,
      f,
      _$fs.pointer,
    ).integer;
  }

  static final _id_breakText$2 = _class.instanceMethodId(
    r'breakText',
    r'(Ljava/lang/String;ZF[F)I',
  );

  static final _breakText$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Double,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              double,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int breakText(java.lang.String string, boolean z, float f, float[] fs)`
  int breakText$2(
    jni$_.JString? string,
    bool z,
    double f,
    jni$_.JFloatArray? fs,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$fs = fs?.reference ?? jni$_.jNullReference;
    return _breakText$2(
      reference.pointer,
      _id_breakText$2 as jni$_.JMethodIDPtr,
      _$string.pointer,
      z ? 1 : 0,
      f,
      _$fs.pointer,
    ).integer;
  }

  static final _id_clearShadowLayer = _class.instanceMethodId(
    r'clearShadowLayer',
    r'()V',
  );

  static final _clearShadowLayer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void clearShadowLayer()`
  void clearShadowLayer() {
    _clearShadowLayer(
      reference.pointer,
      _id_clearShadowLayer as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_descent = _class.instanceMethodId(r'descent', r'()F');

  static final _descent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float descent()`
  double descent() {
    return _descent(reference.pointer, _id_descent as jni$_.JMethodIDPtr).float;
  }

  static final _id_equalsForTextMeasurement = _class.instanceMethodId(
    r'equalsForTextMeasurement',
    r'(Landroid/graphics/Paint;)Z',
  );

  static final _equalsForTextMeasurement =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equalsForTextMeasurement(android.graphics.Paint paint)`
  bool equalsForTextMeasurement(Paint? paint) {
    final _$paint = paint?.reference ?? jni$_.jNullReference;
    return _equalsForTextMeasurement(
      reference.pointer,
      _id_equalsForTextMeasurement as jni$_.JMethodIDPtr,
      _$paint.pointer,
    ).boolean;
  }

  static final _id_getAlpha = _class.instanceMethodId(r'getAlpha', r'()I');

  static final _getAlpha =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getAlpha()`
  int getAlpha() {
    return _getAlpha(
      reference.pointer,
      _id_getAlpha as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getBlendMode = _class.instanceMethodId(
    r'getBlendMode',
    r'()Landroid/graphics/BlendMode;',
  );

  static final _getBlendMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.BlendMode getBlendMode()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getBlendMode() {
    return _getBlendMode(
      reference.pointer,
      _id_getBlendMode as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getColor = _class.instanceMethodId(r'getColor', r'()I');

  static final _getColor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getColor()`
  int getColor() {
    return _getColor(
      reference.pointer,
      _id_getColor as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getColorFilter = _class.instanceMethodId(
    r'getColorFilter',
    r'()Landroid/graphics/ColorFilter;',
  );

  static final _getColorFilter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.ColorFilter getColorFilter()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getColorFilter() {
    return _getColorFilter(
      reference.pointer,
      _id_getColorFilter as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getColorLong = _class.instanceMethodId(
    r'getColorLong',
    r'()J',
  );

  static final _getColorLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getColorLong()`
  int getColorLong() {
    return _getColorLong(
      reference.pointer,
      _id_getColorLong as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_getEndHyphenEdit = _class.instanceMethodId(
    r'getEndHyphenEdit',
    r'()I',
  );

  static final _getEndHyphenEdit =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getEndHyphenEdit()`
  int getEndHyphenEdit() {
    return _getEndHyphenEdit(
      reference.pointer,
      _id_getEndHyphenEdit as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getFillPath = _class.instanceMethodId(
    r'getFillPath',
    r'(Landroid/graphics/Path;Landroid/graphics/Path;)Z',
  );

  static final _getFillPath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean getFillPath(android.graphics.Path path, android.graphics.Path path1)`
  bool getFillPath(jni$_.JObject? path, jni$_.JObject? path1) {
    final _$path = path?.reference ?? jni$_.jNullReference;
    final _$path1 = path1?.reference ?? jni$_.jNullReference;
    return _getFillPath(
      reference.pointer,
      _id_getFillPath as jni$_.JMethodIDPtr,
      _$path.pointer,
      _$path1.pointer,
    ).boolean;
  }

  static final _id_getFlags = _class.instanceMethodId(r'getFlags', r'()I');

  static final _getFlags =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getFlags()`
  int getFlags() {
    return _getFlags(
      reference.pointer,
      _id_getFlags as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getFontFeatureSettings = _class.instanceMethodId(
    r'getFontFeatureSettings',
    r'()Ljava/lang/String;',
  );

  static final _getFontFeatureSettings =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getFontFeatureSettings()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getFontFeatureSettings() {
    return _getFontFeatureSettings(
      reference.pointer,
      _id_getFontFeatureSettings as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getFontMetrics = _class.instanceMethodId(
    r'getFontMetrics',
    r'()Landroid/graphics/Paint$FontMetrics;',
  );

  static final _getFontMetrics =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.Paint$FontMetrics getFontMetrics()`
  /// The returned object must be released after use, by calling the [release] method.
  Paint$FontMetrics? getFontMetrics() {
    return _getFontMetrics(
      reference.pointer,
      _id_getFontMetrics as jni$_.JMethodIDPtr,
    ).object<Paint$FontMetrics?>(const $Paint$FontMetrics$NullableType$());
  }

  static final _id_getFontMetrics$1 = _class.instanceMethodId(
    r'getFontMetrics',
    r'(Landroid/graphics/Paint$FontMetrics;)F',
  );

  static final _getFontMetrics$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public float getFontMetrics(android.graphics.Paint$FontMetrics fontMetrics)`
  double getFontMetrics$1(Paint$FontMetrics? fontMetrics) {
    final _$fontMetrics = fontMetrics?.reference ?? jni$_.jNullReference;
    return _getFontMetrics$1(
      reference.pointer,
      _id_getFontMetrics$1 as jni$_.JMethodIDPtr,
      _$fontMetrics.pointer,
    ).float;
  }

  static final _id_getFontMetricsForLocale = _class.instanceMethodId(
    r'getFontMetricsForLocale',
    r'(Landroid/graphics/Paint$FontMetrics;)V',
  );

  static final _getFontMetricsForLocale =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void getFontMetricsForLocale(android.graphics.Paint$FontMetrics fontMetrics)`
  void getFontMetricsForLocale(Paint$FontMetrics? fontMetrics) {
    final _$fontMetrics = fontMetrics?.reference ?? jni$_.jNullReference;
    _getFontMetricsForLocale(
      reference.pointer,
      _id_getFontMetricsForLocale as jni$_.JMethodIDPtr,
      _$fontMetrics.pointer,
    ).check();
  }

  static final _id_getFontMetricsInt = _class.instanceMethodId(
    r'getFontMetricsInt',
    r'()Landroid/graphics/Paint$FontMetricsInt;',
  );

  static final _getFontMetricsInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.Paint$FontMetricsInt getFontMetricsInt()`
  /// The returned object must be released after use, by calling the [release] method.
  Paint$FontMetricsInt? getFontMetricsInt() {
    return _getFontMetricsInt(
      reference.pointer,
      _id_getFontMetricsInt as jni$_.JMethodIDPtr,
    ).object<Paint$FontMetricsInt?>(
      const $Paint$FontMetricsInt$NullableType$(),
    );
  }

  static final _id_getFontMetricsInt$1 = _class.instanceMethodId(
    r'getFontMetricsInt',
    r'(Landroid/graphics/Paint$FontMetricsInt;)I',
  );

  static final _getFontMetricsInt$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int getFontMetricsInt(android.graphics.Paint$FontMetricsInt fontMetricsInt)`
  int getFontMetricsInt$1(Paint$FontMetricsInt? fontMetricsInt) {
    final _$fontMetricsInt = fontMetricsInt?.reference ?? jni$_.jNullReference;
    return _getFontMetricsInt$1(
      reference.pointer,
      _id_getFontMetricsInt$1 as jni$_.JMethodIDPtr,
      _$fontMetricsInt.pointer,
    ).integer;
  }

  static final _id_getFontMetricsInt$2 = _class.instanceMethodId(
    r'getFontMetricsInt',
    r'([CIIIIZLandroid/graphics/Paint$FontMetricsInt;)V',
  );

  static final _getFontMetricsInt$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void getFontMetricsInt(char[] cs, int i, int i1, int i2, int i3, boolean z, android.graphics.Paint$FontMetricsInt fontMetricsInt)`
  void getFontMetricsInt$2(
    jni$_.JCharArray? cs,
    int i,
    int i1,
    int i2,
    int i3,
    bool z,
    Paint$FontMetricsInt? fontMetricsInt,
  ) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    final _$fontMetricsInt = fontMetricsInt?.reference ?? jni$_.jNullReference;
    _getFontMetricsInt$2(
      reference.pointer,
      _id_getFontMetricsInt$2 as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
      i2,
      i3,
      z ? 1 : 0,
      _$fontMetricsInt.pointer,
    ).check();
  }

  static final _id_getFontMetricsInt$3 = _class.instanceMethodId(
    r'getFontMetricsInt',
    r'(Ljava/lang/CharSequence;IIIIZLandroid/graphics/Paint$FontMetricsInt;)V',
  );

  static final _getFontMetricsInt$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void getFontMetricsInt(java.lang.CharSequence charSequence, int i, int i1, int i2, int i3, boolean z, android.graphics.Paint$FontMetricsInt fontMetricsInt)`
  void getFontMetricsInt$3(
    jni$_.JObject? charSequence,
    int i,
    int i1,
    int i2,
    int i3,
    bool z,
    Paint$FontMetricsInt? fontMetricsInt,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$fontMetricsInt = fontMetricsInt?.reference ?? jni$_.jNullReference;
    _getFontMetricsInt$3(
      reference.pointer,
      _id_getFontMetricsInt$3 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      i,
      i1,
      i2,
      i3,
      z ? 1 : 0,
      _$fontMetricsInt.pointer,
    ).check();
  }

  static final _id_getFontMetricsIntForLocale = _class.instanceMethodId(
    r'getFontMetricsIntForLocale',
    r'(Landroid/graphics/Paint$FontMetricsInt;)V',
  );

  static final _getFontMetricsIntForLocale =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void getFontMetricsIntForLocale(android.graphics.Paint$FontMetricsInt fontMetricsInt)`
  void getFontMetricsIntForLocale(Paint$FontMetricsInt? fontMetricsInt) {
    final _$fontMetricsInt = fontMetricsInt?.reference ?? jni$_.jNullReference;
    _getFontMetricsIntForLocale(
      reference.pointer,
      _id_getFontMetricsIntForLocale as jni$_.JMethodIDPtr,
      _$fontMetricsInt.pointer,
    ).check();
  }

  static final _id_getFontSpacing = _class.instanceMethodId(
    r'getFontSpacing',
    r'()F',
  );

  static final _getFontSpacing =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float getFontSpacing()`
  double getFontSpacing() {
    return _getFontSpacing(
      reference.pointer,
      _id_getFontSpacing as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_getFontVariationSettings = _class.instanceMethodId(
    r'getFontVariationSettings',
    r'()Ljava/lang/String;',
  );

  static final _getFontVariationSettings =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getFontVariationSettings()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getFontVariationSettings() {
    return _getFontVariationSettings(
      reference.pointer,
      _id_getFontVariationSettings as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getHinting = _class.instanceMethodId(r'getHinting', r'()I');

  static final _getHinting =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getHinting()`
  int getHinting() {
    return _getHinting(
      reference.pointer,
      _id_getHinting as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getLetterSpacing = _class.instanceMethodId(
    r'getLetterSpacing',
    r'()F',
  );

  static final _getLetterSpacing =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float getLetterSpacing()`
  double getLetterSpacing() {
    return _getLetterSpacing(
      reference.pointer,
      _id_getLetterSpacing as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_getMaskFilter = _class.instanceMethodId(
    r'getMaskFilter',
    r'()Landroid/graphics/MaskFilter;',
  );

  static final _getMaskFilter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.MaskFilter getMaskFilter()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getMaskFilter() {
    return _getMaskFilter(
      reference.pointer,
      _id_getMaskFilter as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getOffsetForAdvance = _class.instanceMethodId(
    r'getOffsetForAdvance',
    r'([CIIIIZF)I',
  );

  static final _getOffsetForAdvance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Double,
                  )
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
              double,
            )
          >();

  /// from: `public int getOffsetForAdvance(char[] cs, int i, int i1, int i2, int i3, boolean z, float f)`
  int getOffsetForAdvance(
    jni$_.JCharArray? cs,
    int i,
    int i1,
    int i2,
    int i3,
    bool z,
    double f,
  ) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _getOffsetForAdvance(
      reference.pointer,
      _id_getOffsetForAdvance as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
      i2,
      i3,
      z ? 1 : 0,
      f,
    ).integer;
  }

  static final _id_getOffsetForAdvance$1 = _class.instanceMethodId(
    r'getOffsetForAdvance',
    r'(Ljava/lang/CharSequence;IIIIZF)I',
  );

  static final _getOffsetForAdvance$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Double,
                  )
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
              double,
            )
          >();

  /// from: `public int getOffsetForAdvance(java.lang.CharSequence charSequence, int i, int i1, int i2, int i3, boolean z, float f)`
  int getOffsetForAdvance$1(
    jni$_.JObject? charSequence,
    int i,
    int i1,
    int i2,
    int i3,
    bool z,
    double f,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _getOffsetForAdvance$1(
      reference.pointer,
      _id_getOffsetForAdvance$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      i,
      i1,
      i2,
      i3,
      z ? 1 : 0,
      f,
    ).integer;
  }

  static final _id_getPathEffect = _class.instanceMethodId(
    r'getPathEffect',
    r'()Landroid/graphics/PathEffect;',
  );

  static final _getPathEffect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.PathEffect getPathEffect()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getPathEffect() {
    return _getPathEffect(
      reference.pointer,
      _id_getPathEffect as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getRunAdvance = _class.instanceMethodId(
    r'getRunAdvance',
    r'([CIIIIZI)F',
  );

  static final _getRunAdvance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `public float getRunAdvance(char[] cs, int i, int i1, int i2, int i3, boolean z, int i4)`
  double getRunAdvance(
    jni$_.JCharArray? cs,
    int i,
    int i1,
    int i2,
    int i3,
    bool z,
    int i4,
  ) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _getRunAdvance(
      reference.pointer,
      _id_getRunAdvance as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
      i2,
      i3,
      z ? 1 : 0,
      i4,
    ).float;
  }

  static final _id_getRunAdvance$1 = _class.instanceMethodId(
    r'getRunAdvance',
    r'(Ljava/lang/CharSequence;IIIIZI)F',
  );

  static final _getRunAdvance$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `public float getRunAdvance(java.lang.CharSequence charSequence, int i, int i1, int i2, int i3, boolean z, int i4)`
  double getRunAdvance$1(
    jni$_.JObject? charSequence,
    int i,
    int i1,
    int i2,
    int i3,
    bool z,
    int i4,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _getRunAdvance$1(
      reference.pointer,
      _id_getRunAdvance$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      i,
      i1,
      i2,
      i3,
      z ? 1 : 0,
      i4,
    ).float;
  }

  static final _id_getRunCharacterAdvance = _class.instanceMethodId(
    r'getRunCharacterAdvance',
    r'([CIIIIZI[FI)F',
  );

  static final _getRunCharacterAdvance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public float getRunCharacterAdvance(char[] cs, int i, int i1, int i2, int i3, boolean z, int i4, float[] fs, int i5)`
  double getRunCharacterAdvance(
    jni$_.JCharArray? cs,
    int i,
    int i1,
    int i2,
    int i3,
    bool z,
    int i4,
    jni$_.JFloatArray? fs,
    int i5,
  ) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    final _$fs = fs?.reference ?? jni$_.jNullReference;
    return _getRunCharacterAdvance(
      reference.pointer,
      _id_getRunCharacterAdvance as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
      i2,
      i3,
      z ? 1 : 0,
      i4,
      _$fs.pointer,
      i5,
    ).float;
  }

  static final _id_getRunCharacterAdvance$1 = _class.instanceMethodId(
    r'getRunCharacterAdvance',
    r'(Ljava/lang/CharSequence;IIIIZI[FI)F',
  );

  static final _getRunCharacterAdvance$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public float getRunCharacterAdvance(java.lang.CharSequence charSequence, int i, int i1, int i2, int i3, boolean z, int i4, float[] fs, int i5)`
  double getRunCharacterAdvance$1(
    jni$_.JObject? charSequence,
    int i,
    int i1,
    int i2,
    int i3,
    bool z,
    int i4,
    jni$_.JFloatArray? fs,
    int i5,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$fs = fs?.reference ?? jni$_.jNullReference;
    return _getRunCharacterAdvance$1(
      reference.pointer,
      _id_getRunCharacterAdvance$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      i,
      i1,
      i2,
      i3,
      z ? 1 : 0,
      i4,
      _$fs.pointer,
      i5,
    ).float;
  }

  static final _id_getShader = _class.instanceMethodId(
    r'getShader',
    r'()Landroid/graphics/Shader;',
  );

  static final _getShader =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.Shader getShader()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getShader() {
    return _getShader(
      reference.pointer,
      _id_getShader as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getShadowLayerColor = _class.instanceMethodId(
    r'getShadowLayerColor',
    r'()I',
  );

  static final _getShadowLayerColor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getShadowLayerColor()`
  int getShadowLayerColor() {
    return _getShadowLayerColor(
      reference.pointer,
      _id_getShadowLayerColor as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getShadowLayerColorLong = _class.instanceMethodId(
    r'getShadowLayerColorLong',
    r'()J',
  );

  static final _getShadowLayerColorLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getShadowLayerColorLong()`
  int getShadowLayerColorLong() {
    return _getShadowLayerColorLong(
      reference.pointer,
      _id_getShadowLayerColorLong as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_getShadowLayerDx = _class.instanceMethodId(
    r'getShadowLayerDx',
    r'()F',
  );

  static final _getShadowLayerDx =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float getShadowLayerDx()`
  double getShadowLayerDx() {
    return _getShadowLayerDx(
      reference.pointer,
      _id_getShadowLayerDx as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_getShadowLayerDy = _class.instanceMethodId(
    r'getShadowLayerDy',
    r'()F',
  );

  static final _getShadowLayerDy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float getShadowLayerDy()`
  double getShadowLayerDy() {
    return _getShadowLayerDy(
      reference.pointer,
      _id_getShadowLayerDy as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_getShadowLayerRadius = _class.instanceMethodId(
    r'getShadowLayerRadius',
    r'()F',
  );

  static final _getShadowLayerRadius =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float getShadowLayerRadius()`
  double getShadowLayerRadius() {
    return _getShadowLayerRadius(
      reference.pointer,
      _id_getShadowLayerRadius as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_getStartHyphenEdit = _class.instanceMethodId(
    r'getStartHyphenEdit',
    r'()I',
  );

  static final _getStartHyphenEdit =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int getStartHyphenEdit()`
  int getStartHyphenEdit() {
    return _getStartHyphenEdit(
      reference.pointer,
      _id_getStartHyphenEdit as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_getStrikeThruPosition = _class.instanceMethodId(
    r'getStrikeThruPosition',
    r'()F',
  );

  static final _getStrikeThruPosition =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float getStrikeThruPosition()`
  double getStrikeThruPosition() {
    return _getStrikeThruPosition(
      reference.pointer,
      _id_getStrikeThruPosition as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_getStrikeThruThickness = _class.instanceMethodId(
    r'getStrikeThruThickness',
    r'()F',
  );

  static final _getStrikeThruThickness =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float getStrikeThruThickness()`
  double getStrikeThruThickness() {
    return _getStrikeThruThickness(
      reference.pointer,
      _id_getStrikeThruThickness as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_getStrokeCap = _class.instanceMethodId(
    r'getStrokeCap',
    r'()Landroid/graphics/Paint$Cap;',
  );

  static final _getStrokeCap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.Paint$Cap getStrokeCap()`
  /// The returned object must be released after use, by calling the [release] method.
  Paint$Cap? getStrokeCap() {
    return _getStrokeCap(
      reference.pointer,
      _id_getStrokeCap as jni$_.JMethodIDPtr,
    ).object<Paint$Cap?>(const $Paint$Cap$NullableType$());
  }

  static final _id_getStrokeJoin = _class.instanceMethodId(
    r'getStrokeJoin',
    r'()Landroid/graphics/Paint$Join;',
  );

  static final _getStrokeJoin =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.Paint$Join getStrokeJoin()`
  /// The returned object must be released after use, by calling the [release] method.
  Paint$Join? getStrokeJoin() {
    return _getStrokeJoin(
      reference.pointer,
      _id_getStrokeJoin as jni$_.JMethodIDPtr,
    ).object<Paint$Join?>(const $Paint$Join$NullableType$());
  }

  static final _id_getStrokeMiter = _class.instanceMethodId(
    r'getStrokeMiter',
    r'()F',
  );

  static final _getStrokeMiter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float getStrokeMiter()`
  double getStrokeMiter() {
    return _getStrokeMiter(
      reference.pointer,
      _id_getStrokeMiter as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_getStrokeWidth = _class.instanceMethodId(
    r'getStrokeWidth',
    r'()F',
  );

  static final _getStrokeWidth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float getStrokeWidth()`
  double getStrokeWidth() {
    return _getStrokeWidth(
      reference.pointer,
      _id_getStrokeWidth as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_getStyle = _class.instanceMethodId(
    r'getStyle',
    r'()Landroid/graphics/Paint$Style;',
  );

  static final _getStyle =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.Paint$Style getStyle()`
  /// The returned object must be released after use, by calling the [release] method.
  Paint$Style? getStyle() {
    return _getStyle(
      reference.pointer,
      _id_getStyle as jni$_.JMethodIDPtr,
    ).object<Paint$Style?>(const $Paint$Style$NullableType$());
  }

  static final _id_getTextAlign = _class.instanceMethodId(
    r'getTextAlign',
    r'()Landroid/graphics/Paint$Align;',
  );

  static final _getTextAlign =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.Paint$Align getTextAlign()`
  /// The returned object must be released after use, by calling the [release] method.
  Paint$Align? getTextAlign() {
    return _getTextAlign(
      reference.pointer,
      _id_getTextAlign as jni$_.JMethodIDPtr,
    ).object<Paint$Align?>(const $Paint$Align$NullableType$());
  }

  static final _id_getTextBounds = _class.instanceMethodId(
    r'getTextBounds',
    r'([CIILandroid/graphics/Rect;)V',
  );

  static final _getTextBounds =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void getTextBounds(char[] cs, int i, int i1, android.graphics.Rect rect)`
  void getTextBounds(jni$_.JCharArray? cs, int i, int i1, jni$_.JObject? rect) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    final _$rect = rect?.reference ?? jni$_.jNullReference;
    _getTextBounds(
      reference.pointer,
      _id_getTextBounds as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
      _$rect.pointer,
    ).check();
  }

  static final _id_getTextBounds$1 = _class.instanceMethodId(
    r'getTextBounds',
    r'(Ljava/lang/CharSequence;IILandroid/graphics/Rect;)V',
  );

  static final _getTextBounds$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void getTextBounds(java.lang.CharSequence charSequence, int i, int i1, android.graphics.Rect rect)`
  void getTextBounds$1(
    jni$_.JObject? charSequence,
    int i,
    int i1,
    jni$_.JObject? rect,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$rect = rect?.reference ?? jni$_.jNullReference;
    _getTextBounds$1(
      reference.pointer,
      _id_getTextBounds$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      i,
      i1,
      _$rect.pointer,
    ).check();
  }

  static final _id_getTextBounds$2 = _class.instanceMethodId(
    r'getTextBounds',
    r'(Ljava/lang/String;IILandroid/graphics/Rect;)V',
  );

  static final _getTextBounds$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void getTextBounds(java.lang.String string, int i, int i1, android.graphics.Rect rect)`
  void getTextBounds$2(
    jni$_.JString? string,
    int i,
    int i1,
    jni$_.JObject? rect,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$rect = rect?.reference ?? jni$_.jNullReference;
    _getTextBounds$2(
      reference.pointer,
      _id_getTextBounds$2 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      i1,
      _$rect.pointer,
    ).check();
  }

  static final _id_getTextLocale = _class.instanceMethodId(
    r'getTextLocale',
    r'()Ljava/util/Locale;',
  );

  static final _getTextLocale =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Locale getTextLocale()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getTextLocale() {
    return _getTextLocale(
      reference.pointer,
      _id_getTextLocale as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getTextLocales = _class.instanceMethodId(
    r'getTextLocales',
    r'()Landroid/os/LocaleList;',
  );

  static final _getTextLocales =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.os.LocaleList getTextLocales()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getTextLocales() {
    return _getTextLocales(
      reference.pointer,
      _id_getTextLocales as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getTextPath = _class.instanceMethodId(
    r'getTextPath',
    r'([CIIFFLandroid/graphics/Path;)V',
  );

  static final _getTextPath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Double,
                    jni$_.Double,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              double,
              double,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void getTextPath(char[] cs, int i, int i1, float f, float f1, android.graphics.Path path)`
  void getTextPath(
    jni$_.JCharArray? cs,
    int i,
    int i1,
    double f,
    double f1,
    jni$_.JObject? path,
  ) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    final _$path = path?.reference ?? jni$_.jNullReference;
    _getTextPath(
      reference.pointer,
      _id_getTextPath as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
      f,
      f1,
      _$path.pointer,
    ).check();
  }

  static final _id_getTextPath$1 = _class.instanceMethodId(
    r'getTextPath',
    r'(Ljava/lang/String;IIFFLandroid/graphics/Path;)V',
  );

  static final _getTextPath$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Double,
                    jni$_.Double,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              double,
              double,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void getTextPath(java.lang.String string, int i, int i1, float f, float f1, android.graphics.Path path)`
  void getTextPath$1(
    jni$_.JString? string,
    int i,
    int i1,
    double f,
    double f1,
    jni$_.JObject? path,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$path = path?.reference ?? jni$_.jNullReference;
    _getTextPath$1(
      reference.pointer,
      _id_getTextPath$1 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      i1,
      f,
      f1,
      _$path.pointer,
    ).check();
  }

  static final _id_getTextRunAdvances = _class.instanceMethodId(
    r'getTextRunAdvances',
    r'([CIIIIZ[FI)F',
  );

  static final _getTextRunAdvances =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public float getTextRunAdvances(char[] cs, int i, int i1, int i2, int i3, boolean z, float[] fs, int i4)`
  double getTextRunAdvances(
    jni$_.JCharArray? cs,
    int i,
    int i1,
    int i2,
    int i3,
    bool z,
    jni$_.JFloatArray? fs,
    int i4,
  ) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    final _$fs = fs?.reference ?? jni$_.jNullReference;
    return _getTextRunAdvances(
      reference.pointer,
      _id_getTextRunAdvances as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
      i2,
      i3,
      z ? 1 : 0,
      _$fs.pointer,
      i4,
    ).float;
  }

  static final _id_getTextRunCursor = _class.instanceMethodId(
    r'getTextRunCursor',
    r'([CIIZII)I',
  );

  static final _getTextRunCursor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `public int getTextRunCursor(char[] cs, int i, int i1, boolean z, int i2, int i3)`
  int getTextRunCursor(
    jni$_.JCharArray? cs,
    int i,
    int i1,
    bool z,
    int i2,
    int i3,
  ) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _getTextRunCursor(
      reference.pointer,
      _id_getTextRunCursor as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
      z ? 1 : 0,
      i2,
      i3,
    ).integer;
  }

  static final _id_getTextRunCursor$1 = _class.instanceMethodId(
    r'getTextRunCursor',
    r'(Ljava/lang/CharSequence;IIZII)I',
  );

  static final _getTextRunCursor$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `public int getTextRunCursor(java.lang.CharSequence charSequence, int i, int i1, boolean z, int i2, int i3)`
  int getTextRunCursor$1(
    jni$_.JObject? charSequence,
    int i,
    int i1,
    bool z,
    int i2,
    int i3,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _getTextRunCursor$1(
      reference.pointer,
      _id_getTextRunCursor$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      i,
      i1,
      z ? 1 : 0,
      i2,
      i3,
    ).integer;
  }

  static final _id_getTextScaleX = _class.instanceMethodId(
    r'getTextScaleX',
    r'()F',
  );

  static final _getTextScaleX =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float getTextScaleX()`
  double getTextScaleX() {
    return _getTextScaleX(
      reference.pointer,
      _id_getTextScaleX as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_getTextSize = _class.instanceMethodId(
    r'getTextSize',
    r'()F',
  );

  static final _getTextSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float getTextSize()`
  double getTextSize() {
    return _getTextSize(
      reference.pointer,
      _id_getTextSize as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_getTextSkewX = _class.instanceMethodId(
    r'getTextSkewX',
    r'()F',
  );

  static final _getTextSkewX =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float getTextSkewX()`
  double getTextSkewX() {
    return _getTextSkewX(
      reference.pointer,
      _id_getTextSkewX as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_getTextWidths = _class.instanceMethodId(
    r'getTextWidths',
    r'([CII[F)I',
  );

  static final _getTextWidths =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int getTextWidths(char[] cs, int i, int i1, float[] fs)`
  int getTextWidths(
    jni$_.JCharArray? cs,
    int i,
    int i1,
    jni$_.JFloatArray? fs,
  ) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    final _$fs = fs?.reference ?? jni$_.jNullReference;
    return _getTextWidths(
      reference.pointer,
      _id_getTextWidths as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
      _$fs.pointer,
    ).integer;
  }

  static final _id_getTextWidths$1 = _class.instanceMethodId(
    r'getTextWidths',
    r'(Ljava/lang/CharSequence;II[F)I',
  );

  static final _getTextWidths$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int getTextWidths(java.lang.CharSequence charSequence, int i, int i1, float[] fs)`
  int getTextWidths$1(
    jni$_.JObject? charSequence,
    int i,
    int i1,
    jni$_.JFloatArray? fs,
  ) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    final _$fs = fs?.reference ?? jni$_.jNullReference;
    return _getTextWidths$1(
      reference.pointer,
      _id_getTextWidths$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      i,
      i1,
      _$fs.pointer,
    ).integer;
  }

  static final _id_getTextWidths$2 = _class.instanceMethodId(
    r'getTextWidths',
    r'(Ljava/lang/String;[F)I',
  );

  static final _getTextWidths$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int getTextWidths(java.lang.String string, float[] fs)`
  int getTextWidths$2(jni$_.JString? string, jni$_.JFloatArray? fs) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$fs = fs?.reference ?? jni$_.jNullReference;
    return _getTextWidths$2(
      reference.pointer,
      _id_getTextWidths$2 as jni$_.JMethodIDPtr,
      _$string.pointer,
      _$fs.pointer,
    ).integer;
  }

  static final _id_getTextWidths$3 = _class.instanceMethodId(
    r'getTextWidths',
    r'(Ljava/lang/String;II[F)I',
  );

  static final _getTextWidths$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public int getTextWidths(java.lang.String string, int i, int i1, float[] fs)`
  int getTextWidths$3(
    jni$_.JString? string,
    int i,
    int i1,
    jni$_.JFloatArray? fs,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$fs = fs?.reference ?? jni$_.jNullReference;
    return _getTextWidths$3(
      reference.pointer,
      _id_getTextWidths$3 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      i1,
      _$fs.pointer,
    ).integer;
  }

  static final _id_getTypeface = _class.instanceMethodId(
    r'getTypeface',
    r'()Landroid/graphics/Typeface;',
  );

  static final _getTypeface =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.Typeface getTypeface()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getTypeface() {
    return _getTypeface(
      reference.pointer,
      _id_getTypeface as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getUnderlinePosition = _class.instanceMethodId(
    r'getUnderlinePosition',
    r'()F',
  );

  static final _getUnderlinePosition =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float getUnderlinePosition()`
  double getUnderlinePosition() {
    return _getUnderlinePosition(
      reference.pointer,
      _id_getUnderlinePosition as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_getUnderlineThickness = _class.instanceMethodId(
    r'getUnderlineThickness',
    r'()F',
  );

  static final _getUnderlineThickness =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float getUnderlineThickness()`
  double getUnderlineThickness() {
    return _getUnderlineThickness(
      reference.pointer,
      _id_getUnderlineThickness as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_getWordSpacing = _class.instanceMethodId(
    r'getWordSpacing',
    r'()F',
  );

  static final _getWordSpacing =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float getWordSpacing()`
  double getWordSpacing() {
    return _getWordSpacing(
      reference.pointer,
      _id_getWordSpacing as jni$_.JMethodIDPtr,
    ).float;
  }

  static final _id_getXfermode = _class.instanceMethodId(
    r'getXfermode',
    r'()Landroid/graphics/Xfermode;',
  );

  static final _getXfermode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public android.graphics.Xfermode getXfermode()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getXfermode() {
    return _getXfermode(
      reference.pointer,
      _id_getXfermode as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_hasGlyph = _class.instanceMethodId(
    r'hasGlyph',
    r'(Ljava/lang/String;)Z',
  );

  static final _hasGlyph =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean hasGlyph(java.lang.String string)`
  bool hasGlyph(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _hasGlyph(
      reference.pointer,
      _id_hasGlyph as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).boolean;
  }

  static final _id_isAntiAlias = _class.instanceMethodId(
    r'isAntiAlias',
    r'()Z',
  );

  static final _isAntiAlias =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final boolean isAntiAlias()`
  bool isAntiAlias() {
    return _isAntiAlias(
      reference.pointer,
      _id_isAntiAlias as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isDither = _class.instanceMethodId(r'isDither', r'()Z');

  static final _isDither =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final boolean isDither()`
  bool isDither() {
    return _isDither(
      reference.pointer,
      _id_isDither as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isElegantTextHeight = _class.instanceMethodId(
    r'isElegantTextHeight',
    r'()Z',
  );

  static final _isElegantTextHeight =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isElegantTextHeight()`
  bool isElegantTextHeight() {
    return _isElegantTextHeight(
      reference.pointer,
      _id_isElegantTextHeight as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isFakeBoldText = _class.instanceMethodId(
    r'isFakeBoldText',
    r'()Z',
  );

  static final _isFakeBoldText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final boolean isFakeBoldText()`
  bool isFakeBoldText() {
    return _isFakeBoldText(
      reference.pointer,
      _id_isFakeBoldText as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isFilterBitmap = _class.instanceMethodId(
    r'isFilterBitmap',
    r'()Z',
  );

  static final _isFilterBitmap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final boolean isFilterBitmap()`
  bool isFilterBitmap() {
    return _isFilterBitmap(
      reference.pointer,
      _id_isFilterBitmap as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isLinearText = _class.instanceMethodId(
    r'isLinearText',
    r'()Z',
  );

  static final _isLinearText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final boolean isLinearText()`
  bool isLinearText() {
    return _isLinearText(
      reference.pointer,
      _id_isLinearText as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isStrikeThruText = _class.instanceMethodId(
    r'isStrikeThruText',
    r'()Z',
  );

  static final _isStrikeThruText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final boolean isStrikeThruText()`
  bool isStrikeThruText() {
    return _isStrikeThruText(
      reference.pointer,
      _id_isStrikeThruText as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isSubpixelText = _class.instanceMethodId(
    r'isSubpixelText',
    r'()Z',
  );

  static final _isSubpixelText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final boolean isSubpixelText()`
  bool isSubpixelText() {
    return _isSubpixelText(
      reference.pointer,
      _id_isSubpixelText as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isUnderlineText = _class.instanceMethodId(
    r'isUnderlineText',
    r'()Z',
  );

  static final _isUnderlineText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final boolean isUnderlineText()`
  bool isUnderlineText() {
    return _isUnderlineText(
      reference.pointer,
      _id_isUnderlineText as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_measureText = _class.instanceMethodId(
    r'measureText',
    r'([CII)F',
  );

  static final _measureText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public float measureText(char[] cs, int i, int i1)`
  double measureText(jni$_.JCharArray? cs, int i, int i1) {
    final _$cs = cs?.reference ?? jni$_.jNullReference;
    return _measureText(
      reference.pointer,
      _id_measureText as jni$_.JMethodIDPtr,
      _$cs.pointer,
      i,
      i1,
    ).float;
  }

  static final _id_measureText$1 = _class.instanceMethodId(
    r'measureText',
    r'(Ljava/lang/CharSequence;II)F',
  );

  static final _measureText$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public float measureText(java.lang.CharSequence charSequence, int i, int i1)`
  double measureText$1(jni$_.JObject? charSequence, int i, int i1) {
    final _$charSequence = charSequence?.reference ?? jni$_.jNullReference;
    return _measureText$1(
      reference.pointer,
      _id_measureText$1 as jni$_.JMethodIDPtr,
      _$charSequence.pointer,
      i,
      i1,
    ).float;
  }

  static final _id_measureText$2 = _class.instanceMethodId(
    r'measureText',
    r'(Ljava/lang/String;)F',
  );

  static final _measureText$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public float measureText(java.lang.String string)`
  double measureText$2(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _measureText$2(
      reference.pointer,
      _id_measureText$2 as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).float;
  }

  static final _id_measureText$3 = _class.instanceMethodId(
    r'measureText',
    r'(Ljava/lang/String;II)F',
  );

  static final _measureText$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public float measureText(java.lang.String string, int i, int i1)`
  double measureText$3(jni$_.JString? string, int i, int i1) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _measureText$3(
      reference.pointer,
      _id_measureText$3 as jni$_.JMethodIDPtr,
      _$string.pointer,
      i,
      i1,
    ).float;
  }

  static final _id_reset = _class.instanceMethodId(r'reset', r'()V');

  static final _reset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void reset()`
  void reset() {
    _reset(reference.pointer, _id_reset as jni$_.JMethodIDPtr).check();
  }

  static final _id_set = _class.instanceMethodId(
    r'set',
    r'(Landroid/graphics/Paint;)V',
  );

  static final _set =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void set(android.graphics.Paint paint)`
  void set(Paint? paint) {
    final _$paint = paint?.reference ?? jni$_.jNullReference;
    _set(
      reference.pointer,
      _id_set as jni$_.JMethodIDPtr,
      _$paint.pointer,
    ).check();
  }

  static final _id_setARGB = _class.instanceMethodId(r'setARGB', r'(IIII)V');

  static final _setARGB =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int32, jni$_.Int32, jni$_.Int32, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
            )
          >();

  /// from: `public void setARGB(int i, int i1, int i2, int i3)`
  void setARGB(int i, int i1, int i2, int i3) {
    _setARGB(
      reference.pointer,
      _id_setARGB as jni$_.JMethodIDPtr,
      i,
      i1,
      i2,
      i3,
    ).check();
  }

  static final _id_setAlpha = _class.instanceMethodId(r'setAlpha', r'(I)V');

  static final _setAlpha =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setAlpha(int i)`
  void setAlpha(int i) {
    _setAlpha(reference.pointer, _id_setAlpha as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_setAntiAlias = _class.instanceMethodId(
    r'setAntiAlias',
    r'(Z)V',
  );

  static final _setAntiAlias =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setAntiAlias(boolean z)`
  void setAntiAlias(bool z) {
    _setAntiAlias(
      reference.pointer,
      _id_setAntiAlias as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setBlendMode = _class.instanceMethodId(
    r'setBlendMode',
    r'(Landroid/graphics/BlendMode;)V',
  );

  static final _setBlendMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setBlendMode(android.graphics.BlendMode blendMode)`
  void setBlendMode(jni$_.JObject? blendMode) {
    final _$blendMode = blendMode?.reference ?? jni$_.jNullReference;
    _setBlendMode(
      reference.pointer,
      _id_setBlendMode as jni$_.JMethodIDPtr,
      _$blendMode.pointer,
    ).check();
  }

  static final _id_setColor = _class.instanceMethodId(r'setColor', r'(I)V');

  static final _setColor =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setColor(int i)`
  void setColor(int i) {
    _setColor(reference.pointer, _id_setColor as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_setColor$1 = _class.instanceMethodId(r'setColor', r'(J)V');

  static final _setColor$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setColor(long j)`
  void setColor$1(int j) {
    _setColor$1(
      reference.pointer,
      _id_setColor$1 as jni$_.JMethodIDPtr,
      j,
    ).check();
  }

  static final _id_setColorFilter = _class.instanceMethodId(
    r'setColorFilter',
    r'(Landroid/graphics/ColorFilter;)Landroid/graphics/ColorFilter;',
  );

  static final _setColorFilter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.graphics.ColorFilter setColorFilter(android.graphics.ColorFilter colorFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? setColorFilter(jni$_.JObject? colorFilter) {
    final _$colorFilter = colorFilter?.reference ?? jni$_.jNullReference;
    return _setColorFilter(
      reference.pointer,
      _id_setColorFilter as jni$_.JMethodIDPtr,
      _$colorFilter.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_setDither = _class.instanceMethodId(r'setDither', r'(Z)V');

  static final _setDither =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setDither(boolean z)`
  void setDither(bool z) {
    _setDither(
      reference.pointer,
      _id_setDither as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setElegantTextHeight = _class.instanceMethodId(
    r'setElegantTextHeight',
    r'(Z)V',
  );

  static final _setElegantTextHeight =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setElegantTextHeight(boolean z)`
  void setElegantTextHeight(bool z) {
    _setElegantTextHeight(
      reference.pointer,
      _id_setElegantTextHeight as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setEndHyphenEdit = _class.instanceMethodId(
    r'setEndHyphenEdit',
    r'(I)V',
  );

  static final _setEndHyphenEdit =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setEndHyphenEdit(int i)`
  void setEndHyphenEdit(int i) {
    _setEndHyphenEdit(
      reference.pointer,
      _id_setEndHyphenEdit as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setFakeBoldText = _class.instanceMethodId(
    r'setFakeBoldText',
    r'(Z)V',
  );

  static final _setFakeBoldText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setFakeBoldText(boolean z)`
  void setFakeBoldText(bool z) {
    _setFakeBoldText(
      reference.pointer,
      _id_setFakeBoldText as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setFilterBitmap = _class.instanceMethodId(
    r'setFilterBitmap',
    r'(Z)V',
  );

  static final _setFilterBitmap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setFilterBitmap(boolean z)`
  void setFilterBitmap(bool z) {
    _setFilterBitmap(
      reference.pointer,
      _id_setFilterBitmap as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setFlags = _class.instanceMethodId(r'setFlags', r'(I)V');

  static final _setFlags =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setFlags(int i)`
  void setFlags(int i) {
    _setFlags(reference.pointer, _id_setFlags as jni$_.JMethodIDPtr, i).check();
  }

  static final _id_setFontFeatureSettings = _class.instanceMethodId(
    r'setFontFeatureSettings',
    r'(Ljava/lang/String;)V',
  );

  static final _setFontFeatureSettings =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setFontFeatureSettings(java.lang.String string)`
  void setFontFeatureSettings(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _setFontFeatureSettings(
      reference.pointer,
      _id_setFontFeatureSettings as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).check();
  }

  static final _id_setFontVariationSettings = _class.instanceMethodId(
    r'setFontVariationSettings',
    r'(Ljava/lang/String;)Z',
  );

  static final _setFontVariationSettings =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean setFontVariationSettings(java.lang.String string)`
  bool setFontVariationSettings(jni$_.JString? string) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _setFontVariationSettings(
      reference.pointer,
      _id_setFontVariationSettings as jni$_.JMethodIDPtr,
      _$string.pointer,
    ).boolean;
  }

  static final _id_setHinting = _class.instanceMethodId(r'setHinting', r'(I)V');

  static final _setHinting =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setHinting(int i)`
  void setHinting(int i) {
    _setHinting(
      reference.pointer,
      _id_setHinting as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setLetterSpacing = _class.instanceMethodId(
    r'setLetterSpacing',
    r'(F)V',
  );

  static final _setLetterSpacing =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void setLetterSpacing(float f)`
  void setLetterSpacing(double f) {
    _setLetterSpacing(
      reference.pointer,
      _id_setLetterSpacing as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_setLinearText = _class.instanceMethodId(
    r'setLinearText',
    r'(Z)V',
  );

  static final _setLinearText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setLinearText(boolean z)`
  void setLinearText(bool z) {
    _setLinearText(
      reference.pointer,
      _id_setLinearText as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setMaskFilter = _class.instanceMethodId(
    r'setMaskFilter',
    r'(Landroid/graphics/MaskFilter;)Landroid/graphics/MaskFilter;',
  );

  static final _setMaskFilter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.graphics.MaskFilter setMaskFilter(android.graphics.MaskFilter maskFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? setMaskFilter(jni$_.JObject? maskFilter) {
    final _$maskFilter = maskFilter?.reference ?? jni$_.jNullReference;
    return _setMaskFilter(
      reference.pointer,
      _id_setMaskFilter as jni$_.JMethodIDPtr,
      _$maskFilter.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_setPathEffect = _class.instanceMethodId(
    r'setPathEffect',
    r'(Landroid/graphics/PathEffect;)Landroid/graphics/PathEffect;',
  );

  static final _setPathEffect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.graphics.PathEffect setPathEffect(android.graphics.PathEffect pathEffect)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? setPathEffect(jni$_.JObject? pathEffect) {
    final _$pathEffect = pathEffect?.reference ?? jni$_.jNullReference;
    return _setPathEffect(
      reference.pointer,
      _id_setPathEffect as jni$_.JMethodIDPtr,
      _$pathEffect.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_setShader = _class.instanceMethodId(
    r'setShader',
    r'(Landroid/graphics/Shader;)Landroid/graphics/Shader;',
  );

  static final _setShader =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.graphics.Shader setShader(android.graphics.Shader shader)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? setShader(jni$_.JObject? shader) {
    final _$shader = shader?.reference ?? jni$_.jNullReference;
    return _setShader(
      reference.pointer,
      _id_setShader as jni$_.JMethodIDPtr,
      _$shader.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_setShadowLayer = _class.instanceMethodId(
    r'setShadowLayer',
    r'(FFFI)V',
  );

  static final _setShadowLayer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Double, jni$_.Double, jni$_.Double, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
              double,
              double,
              int,
            )
          >();

  /// from: `public void setShadowLayer(float f, float f1, float f2, int i)`
  void setShadowLayer(double f, double f1, double f2, int i) {
    _setShadowLayer(
      reference.pointer,
      _id_setShadowLayer as jni$_.JMethodIDPtr,
      f,
      f1,
      f2,
      i,
    ).check();
  }

  static final _id_setShadowLayer$1 = _class.instanceMethodId(
    r'setShadowLayer',
    r'(FFFJ)V',
  );

  static final _setShadowLayer$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Double, jni$_.Double, jni$_.Double, jni$_.Int64)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
              double,
              double,
              int,
            )
          >();

  /// from: `public void setShadowLayer(float f, float f1, float f2, long j)`
  void setShadowLayer$1(double f, double f1, double f2, int j) {
    _setShadowLayer$1(
      reference.pointer,
      _id_setShadowLayer$1 as jni$_.JMethodIDPtr,
      f,
      f1,
      f2,
      j,
    ).check();
  }

  static final _id_setStartHyphenEdit = _class.instanceMethodId(
    r'setStartHyphenEdit',
    r'(I)V',
  );

  static final _setStartHyphenEdit =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setStartHyphenEdit(int i)`
  void setStartHyphenEdit(int i) {
    _setStartHyphenEdit(
      reference.pointer,
      _id_setStartHyphenEdit as jni$_.JMethodIDPtr,
      i,
    ).check();
  }

  static final _id_setStrikeThruText = _class.instanceMethodId(
    r'setStrikeThruText',
    r'(Z)V',
  );

  static final _setStrikeThruText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setStrikeThruText(boolean z)`
  void setStrikeThruText(bool z) {
    _setStrikeThruText(
      reference.pointer,
      _id_setStrikeThruText as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setStrokeCap = _class.instanceMethodId(
    r'setStrokeCap',
    r'(Landroid/graphics/Paint$Cap;)V',
  );

  static final _setStrokeCap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setStrokeCap(android.graphics.Paint$Cap cap)`
  void setStrokeCap(Paint$Cap? cap) {
    final _$cap = cap?.reference ?? jni$_.jNullReference;
    _setStrokeCap(
      reference.pointer,
      _id_setStrokeCap as jni$_.JMethodIDPtr,
      _$cap.pointer,
    ).check();
  }

  static final _id_setStrokeJoin = _class.instanceMethodId(
    r'setStrokeJoin',
    r'(Landroid/graphics/Paint$Join;)V',
  );

  static final _setStrokeJoin =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setStrokeJoin(android.graphics.Paint$Join join)`
  void setStrokeJoin(Paint$Join? join) {
    final _$join = join?.reference ?? jni$_.jNullReference;
    _setStrokeJoin(
      reference.pointer,
      _id_setStrokeJoin as jni$_.JMethodIDPtr,
      _$join.pointer,
    ).check();
  }

  static final _id_setStrokeMiter = _class.instanceMethodId(
    r'setStrokeMiter',
    r'(F)V',
  );

  static final _setStrokeMiter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void setStrokeMiter(float f)`
  void setStrokeMiter(double f) {
    _setStrokeMiter(
      reference.pointer,
      _id_setStrokeMiter as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_setStrokeWidth = _class.instanceMethodId(
    r'setStrokeWidth',
    r'(F)V',
  );

  static final _setStrokeWidth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void setStrokeWidth(float f)`
  void setStrokeWidth(double f) {
    _setStrokeWidth(
      reference.pointer,
      _id_setStrokeWidth as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_setStyle = _class.instanceMethodId(
    r'setStyle',
    r'(Landroid/graphics/Paint$Style;)V',
  );

  static final _setStyle =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setStyle(android.graphics.Paint$Style style)`
  void setStyle(Paint$Style? style) {
    final _$style = style?.reference ?? jni$_.jNullReference;
    _setStyle(
      reference.pointer,
      _id_setStyle as jni$_.JMethodIDPtr,
      _$style.pointer,
    ).check();
  }

  static final _id_setSubpixelText = _class.instanceMethodId(
    r'setSubpixelText',
    r'(Z)V',
  );

  static final _setSubpixelText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setSubpixelText(boolean z)`
  void setSubpixelText(bool z) {
    _setSubpixelText(
      reference.pointer,
      _id_setSubpixelText as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setTextAlign = _class.instanceMethodId(
    r'setTextAlign',
    r'(Landroid/graphics/Paint$Align;)V',
  );

  static final _setTextAlign =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setTextAlign(android.graphics.Paint$Align align)`
  void setTextAlign(Paint$Align? align) {
    final _$align = align?.reference ?? jni$_.jNullReference;
    _setTextAlign(
      reference.pointer,
      _id_setTextAlign as jni$_.JMethodIDPtr,
      _$align.pointer,
    ).check();
  }

  static final _id_setTextLocale = _class.instanceMethodId(
    r'setTextLocale',
    r'(Ljava/util/Locale;)V',
  );

  static final _setTextLocale =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setTextLocale(java.util.Locale locale)`
  void setTextLocale(jni$_.JObject? locale) {
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    _setTextLocale(
      reference.pointer,
      _id_setTextLocale as jni$_.JMethodIDPtr,
      _$locale.pointer,
    ).check();
  }

  static final _id_setTextLocales = _class.instanceMethodId(
    r'setTextLocales',
    r'(Landroid/os/LocaleList;)V',
  );

  static final _setTextLocales =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setTextLocales(android.os.LocaleList localeList)`
  void setTextLocales(jni$_.JObject? localeList) {
    final _$localeList = localeList?.reference ?? jni$_.jNullReference;
    _setTextLocales(
      reference.pointer,
      _id_setTextLocales as jni$_.JMethodIDPtr,
      _$localeList.pointer,
    ).check();
  }

  static final _id_setTextScaleX = _class.instanceMethodId(
    r'setTextScaleX',
    r'(F)V',
  );

  static final _setTextScaleX =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void setTextScaleX(float f)`
  void setTextScaleX(double f) {
    _setTextScaleX(
      reference.pointer,
      _id_setTextScaleX as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_setTextSize = _class.instanceMethodId(
    r'setTextSize',
    r'(F)V',
  );

  static final _setTextSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void setTextSize(float f)`
  void setTextSize(double f) {
    _setTextSize(
      reference.pointer,
      _id_setTextSize as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_setTextSkewX = _class.instanceMethodId(
    r'setTextSkewX',
    r'(F)V',
  );

  static final _setTextSkewX =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void setTextSkewX(float f)`
  void setTextSkewX(double f) {
    _setTextSkewX(
      reference.pointer,
      _id_setTextSkewX as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_setTypeface = _class.instanceMethodId(
    r'setTypeface',
    r'(Landroid/graphics/Typeface;)Landroid/graphics/Typeface;',
  );

  static final _setTypeface =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.graphics.Typeface setTypeface(android.graphics.Typeface typeface)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? setTypeface(jni$_.JObject? typeface) {
    final _$typeface = typeface?.reference ?? jni$_.jNullReference;
    return _setTypeface(
      reference.pointer,
      _id_setTypeface as jni$_.JMethodIDPtr,
      _$typeface.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_setUnderlineText = _class.instanceMethodId(
    r'setUnderlineText',
    r'(Z)V',
  );

  static final _setUnderlineText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void setUnderlineText(boolean z)`
  void setUnderlineText(bool z) {
    _setUnderlineText(
      reference.pointer,
      _id_setUnderlineText as jni$_.JMethodIDPtr,
      z ? 1 : 0,
    ).check();
  }

  static final _id_setWordSpacing = _class.instanceMethodId(
    r'setWordSpacing',
    r'(F)V',
  );

  static final _setWordSpacing =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Double,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              double,
            )
          >();

  /// from: `public void setWordSpacing(float f)`
  void setWordSpacing(double f) {
    _setWordSpacing(
      reference.pointer,
      _id_setWordSpacing as jni$_.JMethodIDPtr,
      f,
    ).check();
  }

  static final _id_setXfermode = _class.instanceMethodId(
    r'setXfermode',
    r'(Landroid/graphics/Xfermode;)Landroid/graphics/Xfermode;',
  );

  static final _setXfermode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public android.graphics.Xfermode setXfermode(android.graphics.Xfermode xfermode)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? setXfermode(jni$_.JObject? xfermode) {
    final _$xfermode = xfermode?.reference ?? jni$_.jNullReference;
    return _setXfermode(
      reference.pointer,
      _id_setXfermode as jni$_.JMethodIDPtr,
      _$xfermode.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }
}

final class $Paint$NullableType$ extends jni$_.JType<Paint?> {
  @jni$_.internal
  const $Paint$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Paint;';

  @jni$_.internal
  @core$_.override
  Paint? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Paint.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Paint?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Paint$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Paint$NullableType$) &&
        other is $Paint$NullableType$;
  }
}

final class $Paint$Type$ extends jni$_.JType<Paint> {
  @jni$_.internal
  const $Paint$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Landroid/graphics/Paint;';

  @jni$_.internal
  @core$_.override
  Paint fromReference(jni$_.JReference reference) =>
      Paint.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Paint?> get nullableType => const $Paint$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Paint$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Paint$Type$) && other is $Paint$Type$;
  }
}
