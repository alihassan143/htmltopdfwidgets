// Native PDF Engine - iOS WebKit bindings
// Generated by ffigen. Do not edit.

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;

@ffi.Native<
  ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external bool _NativeLibrary_protocolTrampoline_e3qsqz(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_18v1jvf(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external void _NativeLibrary_protocolTrampoline_18v1jvf(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<
  instancetype Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external instancetype _NativeLibrary_protocolTrampoline_xr62hr(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCObjectImpl> Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
  )
>()
external ffi.Pointer<objc.ObjCObjectImpl>
_NativeLibrary_protocolTrampoline_1mbt9g9(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1l4hxwm(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1l4hxwm(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_xtuoz7(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCBlockImpl>,
  )
>()
external void _NativeLibrary_protocolTrampoline_1l4hxwm(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCBlockImpl> arg1,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCObjectImpl> Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external ffi.Pointer<objc.ObjCObjectImpl>
_NativeLibrary_protocolTrampoline_zi5eed(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
);

@ffi.Native<
  objc.CGPoint Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external objc.CGPoint _NativeLibrary_protocolTrampoline_7ohnx8(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1bktu2(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1bktu2(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    objc.CGPoint,
  )
>()
external void _NativeLibrary_protocolTrampoline_1bktu2(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGPoint arg1,
);

@ffi.Native<
  objc.CGRect Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external objc.CGRect _NativeLibrary_protocolTrampoline_1c3uc0w(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  CGAffineTransform Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
  )
>()
external CGAffineTransform _NativeLibrary_protocolTrampoline_8o6he9(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1lznlw3(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1lznlw3(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    CGAffineTransform,
  )
>()
external void _NativeLibrary_protocolTrampoline_1lznlw3(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  CGAffineTransform arg1,
);

@ffi.Native<
  ffi.UnsignedLong Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
  )
>()
external int _NativeLibrary_protocolTrampoline_ku69ws(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  objc.CGPoint Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    objc.CGPoint,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external objc.CGPoint _NativeLibrary_protocolTrampoline_17ipln5(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGPoint arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
);

@ffi.Native<
  objc.CGRect Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    objc.CGRect,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external objc.CGRect _NativeLibrary_protocolTrampoline_1sh7l9z(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGRect arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
);

@ffi.Native<
  ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external int _NativeLibrary_protocolTrampoline_1qeotwu(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_ovsamd(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_ovsamd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external void _NativeLibrary_protocolTrampoline_ovsamd(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Bool Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external bool _NativeLibrary_protocolTrampoline_3su7tt(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_fjrv01(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_fjrv01(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external void _NativeLibrary_protocolTrampoline_fjrv01(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCObjectImpl> Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    objc.CGRect,
  )
>()
external ffi.Pointer<objc.ObjCObjectImpl>
_NativeLibrary_protocolTrampoline_12thpau(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGRect arg1,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_qvcerx(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_qvcerx(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<CGContext>,
  )
>()
external void _NativeLibrary_protocolTrampoline_qvcerx(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<CGContext> arg2,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1pl9qdv(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1pl9qdv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1s56lr9(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1s56lr9(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  UIEdgeInsets Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external UIEdgeInsets _NativeLibrary_protocolTrampoline_1rtilx3(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  objc.CGRect Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external objc.CGRect _NativeLibrary_protocolTrampoline_szn7s6(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_pfv6jd(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.UnsignedLong Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
  )
>()
external int _NativeLibrary_protocolTrampoline_1tmn9mr(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1lmpkp(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1lmpkp(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.UnsignedLong,
  )
>()
external void _NativeLibrary_protocolTrampoline_1lmpkp(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  int arg1,
);

@ffi.Native<
  ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external int _NativeLibrary_protocolTrampoline_gvl1rz(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1mm4s9d(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1mm4s9d(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Long,
  )
>()
external void _NativeLibrary_protocolTrampoline_1mm4s9d(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  int arg1,
);

@ffi.Native<
  ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external int _NativeLibrary_protocolTrampoline_1ctlj1n(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1wqrf61(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1wqrf61(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Long,
  )
>()
external void _NativeLibrary_protocolTrampoline_1wqrf61(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  int arg1,
);

@ffi.Native<
  ffi.Bool Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external bool _NativeLibrary_protocolTrampoline_2n06mv(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_6p7ndb(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_6p7ndb(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_13x5jor(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_13x5jor(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_108000h(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_108000h(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_bklti2(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_bklti2(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_n8yd09(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_n8yd09(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
  )
>()
external void _NativeLibrary_protocolTrampoline_bklti2(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ffi.Pointer<objc.ObjCBlockImpl> arg3,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_d2nojr(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_d2nojr(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_xx612k(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_xx612k(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1otpo83(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1otpo83(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
  )
>()
external void _NativeLibrary_protocolTrampoline_xx612k(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ffi.Pointer<objc.ObjCBlockImpl> arg4,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1a5qge(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1a5qge(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_1tz5yf(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_1tz5yf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external void _NativeLibrary_protocolTrampoline_1tz5yf(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ffi.Pointer<objc.ObjCObjectImpl> arg3,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_axwdf6(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_axwdf6(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Bool,
    ffi.Pointer<objc.ObjCBlockImpl>,
  )
>()
external void _NativeLibrary_protocolTrampoline_axwdf6(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
  bool arg3,
  ffi.Pointer<objc.ObjCBlockImpl> arg4,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapListenerBlock_19s8ne9(ffi.Pointer<objc.ObjCBlockImpl> block);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeLibrary_wrapBlockingBlock_19s8ne9(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

final class CGVector extends ffi.Struct {
  @ffi.Double()
  external double dx;

  @ffi.Double()
  external double dy;
}

final class CGAffineTransform extends ffi.Struct {
  @ffi.Double()
  external double a;

  @ffi.Double()
  external double b;

  @ffi.Double()
  external double c;

  @ffi.Double()
  external double d;

  @ffi.Double()
  external double tx;

  @ffi.Double()
  external double ty;
}

/// WARNING: NSProgressReporting is a stub. To generate bindings for this class, include
/// NSProgressReporting in your config's objc-protocols list.
///
/// NSProgressReporting
extension type NSProgressReporting._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [NSProgressReporting] that points to the same underlying object as [other].
  NSProgressReporting.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSProgressReporting] that wraps the given raw object pointer.
  NSProgressReporting.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

enum NSSearchPathDirectory {
  NSApplicationDirectory(1),
  NSDemoApplicationDirectory(2),
  NSDeveloperApplicationDirectory(3),
  NSAdminApplicationDirectory(4),
  NSLibraryDirectory(5),
  NSDeveloperDirectory(6),
  NSUserDirectory(7),
  NSDocumentationDirectory(8),
  NSDocumentDirectory(9),
  NSCoreServiceDirectory(10),
  NSAutosavedInformationDirectory(11),
  NSDesktopDirectory(12),
  NSCachesDirectory(13),
  NSApplicationSupportDirectory(14),
  NSDownloadsDirectory(15),
  NSInputMethodsDirectory(16),
  NSMoviesDirectory(17),
  NSMusicDirectory(18),
  NSPicturesDirectory(19),
  NSPrinterDescriptionDirectory(20),
  NSSharedPublicDirectory(21),
  NSPreferencePanesDirectory(22),
  NSApplicationScriptsDirectory(23),
  NSItemReplacementDirectory(99),
  NSAllApplicationsDirectory(100),
  NSAllLibrariesDirectory(101),
  NSTrashDirectory(102);

  final int value;
  const NSSearchPathDirectory(this.value);

  static NSSearchPathDirectory fromValue(int value) => switch (value) {
    1 => NSApplicationDirectory,
    2 => NSDemoApplicationDirectory,
    3 => NSDeveloperApplicationDirectory,
    4 => NSAdminApplicationDirectory,
    5 => NSLibraryDirectory,
    6 => NSDeveloperDirectory,
    7 => NSUserDirectory,
    8 => NSDocumentationDirectory,
    9 => NSDocumentDirectory,
    10 => NSCoreServiceDirectory,
    11 => NSAutosavedInformationDirectory,
    12 => NSDesktopDirectory,
    13 => NSCachesDirectory,
    14 => NSApplicationSupportDirectory,
    15 => NSDownloadsDirectory,
    16 => NSInputMethodsDirectory,
    17 => NSMoviesDirectory,
    18 => NSMusicDirectory,
    19 => NSPicturesDirectory,
    20 => NSPrinterDescriptionDirectory,
    21 => NSSharedPublicDirectory,
    22 => NSPreferencePanesDirectory,
    23 => NSApplicationScriptsDirectory,
    99 => NSItemReplacementDirectory,
    100 => NSAllApplicationsDirectory,
    101 => NSAllLibrariesDirectory,
    102 => NSTrashDirectory,
    _ => throw ArgumentError('Unknown value for NSSearchPathDirectory: $value'),
  };
}

sealed class NSSearchPathDomainMask {
  static const NSUserDomainMask = 1;
  static const NSLocalDomainMask = 2;
  static const NSNetworkDomainMask = 4;
  static const NSSystemDomainMask = 8;
  static const NSAllDomainsMask = 65535;
}

sealed class NSVolumeEnumerationOptions {
  static const NSVolumeEnumerationSkipHiddenVolumes = 2;
  static const NSVolumeEnumerationProduceFileReferenceURLs = 4;
}

sealed class NSDirectoryEnumerationOptions {
  static const NSDirectoryEnumerationSkipsSubdirectoryDescendants = 1;
  static const NSDirectoryEnumerationSkipsPackageDescendants = 2;
  static const NSDirectoryEnumerationSkipsHiddenFiles = 4;
  static const NSDirectoryEnumerationIncludesDirectoriesPostOrder = 8;
  static const NSDirectoryEnumerationProducesRelativePathURLs = 16;
}

sealed class NSFileManagerItemReplacementOptions {
  static const NSFileManagerItemReplacementUsingNewMetadataOnly = 1;
  static const NSFileManagerItemReplacementWithoutDeletingBackupItem = 2;
}

enum NSURLRelationship {
  NSURLRelationshipContains(0),
  NSURLRelationshipSame(1),
  NSURLRelationshipOther(2);

  final int value;
  const NSURLRelationship(this.value);

  static NSURLRelationship fromValue(int value) => switch (value) {
    0 => NSURLRelationshipContains,
    1 => NSURLRelationshipSame,
    2 => NSURLRelationshipOther,
    _ => throw ArgumentError('Unknown value for NSURLRelationship: $value'),
  };
}

sealed class NSFileManagerUnmountOptions {
  static const NSFileManagerUnmountAllPartitionsAndEjectDisk = 1;
  static const NSFileManagerUnmountWithoutUI = 2;
}

enum NSFileManagerResumeSyncBehavior {
  NSFileManagerResumeSyncBehaviorPreserveLocalChanges(0),
  NSFileManagerResumeSyncBehaviorAfterUploadWithFailOnConflict(1),
  NSFileManagerResumeSyncBehaviorDropLocalChanges(2);

  final int value;
  const NSFileManagerResumeSyncBehavior(this.value);

  static NSFileManagerResumeSyncBehavior fromValue(int value) =>
      switch (value) {
        0 => NSFileManagerResumeSyncBehaviorPreserveLocalChanges,
        1 => NSFileManagerResumeSyncBehaviorAfterUploadWithFailOnConflict,
        2 => NSFileManagerResumeSyncBehaviorDropLocalChanges,
        _ => throw ArgumentError(
          'Unknown value for NSFileManagerResumeSyncBehavior: $value',
        ),
      };
}

enum NSFileManagerUploadLocalVersionConflictPolicy {
  NSFileManagerUploadConflictPolicyDefault(0),
  NSFileManagerUploadConflictPolicyFailOnConflict(1);

  final int value;
  const NSFileManagerUploadLocalVersionConflictPolicy(this.value);

  static NSFileManagerUploadLocalVersionConflictPolicy fromValue(
    int value,
  ) => switch (value) {
    0 => NSFileManagerUploadConflictPolicyDefault,
    1 => NSFileManagerUploadConflictPolicyFailOnConflict,
    _ => throw ArgumentError(
      'Unknown value for NSFileManagerUploadLocalVersionConflictPolicy: $value',
    ),
  };
}

enum NSHTTPCookieAcceptPolicy {
  NSHTTPCookieAcceptPolicyAlways(0),
  NSHTTPCookieAcceptPolicyNever(1),
  NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain(2);

  final int value;
  const NSHTTPCookieAcceptPolicy(this.value);

  static NSHTTPCookieAcceptPolicy fromValue(int value) => switch (value) {
    0 => NSHTTPCookieAcceptPolicyAlways,
    1 => NSHTTPCookieAcceptPolicyNever,
    2 => NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain,
    _ => throw ArgumentError(
      'Unknown value for NSHTTPCookieAcceptPolicy: $value',
    ),
  };
}

enum NSOperationQueuePriority {
  NSOperationQueuePriorityVeryLow(-8),
  NSOperationQueuePriorityLow(-4),
  NSOperationQueuePriorityNormal(0),
  NSOperationQueuePriorityHigh(4),
  NSOperationQueuePriorityVeryHigh(8);

  final int value;
  const NSOperationQueuePriority(this.value);

  static NSOperationQueuePriority fromValue(int value) => switch (value) {
    -8 => NSOperationQueuePriorityVeryLow,
    -4 => NSOperationQueuePriorityLow,
    0 => NSOperationQueuePriorityNormal,
    4 => NSOperationQueuePriorityHigh,
    8 => NSOperationQueuePriorityVeryHigh,
    _ => throw ArgumentError(
      'Unknown value for NSOperationQueuePriority: $value',
    ),
  };
}

/// WARNING: NSURLAuthenticationChallenge is a stub. To generate bindings for this class, include
/// NSURLAuthenticationChallenge in your config's objc-interfaces list.
///
/// NSURLAuthenticationChallenge
extension type NSURLAuthenticationChallenge._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSSecureCoding {
  /// Constructs a [NSURLAuthenticationChallenge] that points to the same underlying object as [other].
  NSURLAuthenticationChallenge.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSURLAuthenticationChallenge',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
  }

  /// Constructs a [NSURLAuthenticationChallenge] that wraps the given raw object pointer.
  NSURLAuthenticationChallenge.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSURLAuthenticationChallenge',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
  }
}

enum NSURLCacheStoragePolicy {
  NSURLCacheStorageAllowed(0),
  NSURLCacheStorageAllowedInMemoryOnly(1),
  NSURLCacheStorageNotAllowed(2);

  final int value;
  const NSURLCacheStoragePolicy(this.value);

  static NSURLCacheStoragePolicy fromValue(int value) => switch (value) {
    0 => NSURLCacheStorageAllowed,
    1 => NSURLCacheStorageAllowedInMemoryOnly,
    2 => NSURLCacheStorageNotAllowed,
    _ => throw ArgumentError(
      'Unknown value for NSURLCacheStoragePolicy: $value',
    ),
  };
}

final class __SecIdentity extends ffi.Opaque {}

final class __SecTrust extends ffi.Opaque {}

enum tls_protocol_version_t {
  tls_protocol_version_TLSv10(769),
  tls_protocol_version_TLSv11(770),
  tls_protocol_version_TLSv12(771),
  tls_protocol_version_TLSv13(772),
  tls_protocol_version_DTLSv10(-257),
  tls_protocol_version_DTLSv12(-259);

  final int value;
  const tls_protocol_version_t(this.value);

  static tls_protocol_version_t fromValue(int value) => switch (value) {
    769 => tls_protocol_version_TLSv10,
    770 => tls_protocol_version_TLSv11,
    771 => tls_protocol_version_TLSv12,
    772 => tls_protocol_version_TLSv13,
    -257 => tls_protocol_version_DTLSv10,
    -259 => tls_protocol_version_DTLSv12,
    _ => throw ArgumentError(
      'Unknown value for tls_protocol_version_t: $value',
    ),
  };
}

enum SSLProtocol {
  kSSLProtocolUnknown(0),
  kTLSProtocol1(4),
  kTLSProtocol11(7),
  kTLSProtocol12(8),
  kDTLSProtocol1(9),
  kTLSProtocol13(10),
  kDTLSProtocol12(11),
  kTLSProtocolMaxSupported(999),
  kSSLProtocol2(1),
  kSSLProtocol3(2),
  kSSLProtocol3Only(3),
  kTLSProtocol1Only(5),
  kSSLProtocolAll(6);

  final int value;
  const SSLProtocol(this.value);

  static SSLProtocol fromValue(int value) => switch (value) {
    0 => kSSLProtocolUnknown,
    4 => kTLSProtocol1,
    7 => kTLSProtocol11,
    8 => kTLSProtocol12,
    9 => kDTLSProtocol1,
    10 => kTLSProtocol13,
    11 => kDTLSProtocol12,
    999 => kTLSProtocolMaxSupported,
    1 => kSSLProtocol2,
    2 => kSSLProtocol3,
    3 => kSSLProtocol3Only,
    5 => kTLSProtocol1Only,
    6 => kSSLProtocolAll,
    _ => throw ArgumentError('Unknown value for SSLProtocol: $value'),
  };
}

enum NSURLCredentialPersistence {
  NSURLCredentialPersistenceNone(0),
  NSURLCredentialPersistenceForSession(1),
  NSURLCredentialPersistencePermanent(2),
  NSURLCredentialPersistenceSynchronizable(3);

  final int value;
  const NSURLCredentialPersistence(this.value);

  static NSURLCredentialPersistence fromValue(int value) => switch (value) {
    0 => NSURLCredentialPersistenceNone,
    1 => NSURLCredentialPersistenceForSession,
    2 => NSURLCredentialPersistencePermanent,
    3 => NSURLCredentialPersistenceSynchronizable,
    _ => throw ArgumentError(
      'Unknown value for NSURLCredentialPersistence: $value',
    ),
  };
}

/// WARNING: NSURLCredential is a stub. To generate bindings for this class, include
/// NSURLCredential in your config's objc-interfaces list.
///
/// NSURLCredential
extension type NSURLCredential._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSSecureCoding,
        objc.NSCopying {
  /// Constructs a [NSURLCredential] that points to the same underlying object as [other].
  NSURLCredential.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSURLCredential',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
  }

  /// Constructs a [NSURLCredential] that wraps the given raw object pointer.
  NSURLCredential.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSURLCredential',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
  }
}

enum NSURLRequestCachePolicy {
  NSURLRequestUseProtocolCachePolicy(0),
  NSURLRequestReloadIgnoringLocalCacheData(1),
  NSURLRequestReloadIgnoringLocalAndRemoteCacheData(4),
  NSURLRequestReturnCacheDataElseLoad(2),
  NSURLRequestReturnCacheDataDontLoad(3),
  NSURLRequestReloadRevalidatingCacheData(5);

  static const NSURLRequestReloadIgnoringCacheData =
      NSURLRequestReloadIgnoringLocalCacheData;

  final int value;
  const NSURLRequestCachePolicy(this.value);

  static NSURLRequestCachePolicy fromValue(int value) => switch (value) {
    0 => NSURLRequestUseProtocolCachePolicy,
    1 => NSURLRequestReloadIgnoringLocalCacheData,
    4 => NSURLRequestReloadIgnoringLocalAndRemoteCacheData,
    2 => NSURLRequestReturnCacheDataElseLoad,
    3 => NSURLRequestReturnCacheDataDontLoad,
    5 => NSURLRequestReloadRevalidatingCacheData,
    _ => throw ArgumentError(
      'Unknown value for NSURLRequestCachePolicy: $value',
    ),
  };

  @override
  String toString() {
    if (this == NSURLRequestReloadIgnoringLocalCacheData)
      return "NSURLRequestCachePolicy.NSURLRequestReloadIgnoringLocalCacheData, NSURLRequestCachePolicy.NSURLRequestReloadIgnoringCacheData";
    return super.toString();
  }
}

enum NSURLRequestNetworkServiceType {
  NSURLNetworkServiceTypeDefault(0),
  NSURLNetworkServiceTypeVoIP(1),
  NSURLNetworkServiceTypeVideo(2),
  NSURLNetworkServiceTypeBackground(3),
  NSURLNetworkServiceTypeVoice(4),
  NSURLNetworkServiceTypeResponsiveData(6),
  NSURLNetworkServiceTypeAVStreaming(8),
  NSURLNetworkServiceTypeResponsiveAV(9),
  NSURLNetworkServiceTypeCallSignaling(11);

  final int value;
  const NSURLRequestNetworkServiceType(this.value);

  static NSURLRequestNetworkServiceType fromValue(int value) => switch (value) {
    0 => NSURLNetworkServiceTypeDefault,
    1 => NSURLNetworkServiceTypeVoIP,
    2 => NSURLNetworkServiceTypeVideo,
    3 => NSURLNetworkServiceTypeBackground,
    4 => NSURLNetworkServiceTypeVoice,
    6 => NSURLNetworkServiceTypeResponsiveData,
    8 => NSURLNetworkServiceTypeAVStreaming,
    9 => NSURLNetworkServiceTypeResponsiveAV,
    11 => NSURLNetworkServiceTypeCallSignaling,
    _ => throw ArgumentError(
      'Unknown value for NSURLRequestNetworkServiceType: $value',
    ),
  };
}

enum NSURLRequestAttribution {
  NSURLRequestAttributionDeveloper(0),
  NSURLRequestAttributionUser(1);

  final int value;
  const NSURLRequestAttribution(this.value);

  static NSURLRequestAttribution fromValue(int value) => switch (value) {
    0 => NSURLRequestAttributionDeveloper,
    1 => NSURLRequestAttributionUser,
    _ => throw ArgumentError(
      'Unknown value for NSURLRequestAttribution: $value',
    ),
  };
}

late final _class_NSURLRequest = objc.getClass("NSURLRequest");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
typedef instancetype = ffi.Pointer<objc.ObjCObjectImpl>;
typedef Dartinstancetype = objc.ObjCObject;
late final _sel_requestWithURL_ = objc.registerName("requestWithURL:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_supportsSecureCoding = objc.registerName(
  "supportsSecureCoding",
);
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_bool_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunction(
    bool Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<bool Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_bool_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> {
  bool call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
      >()(ref.pointer, arg0);
}

late final _sel_requestWithURL_cachePolicy_timeoutInterval_ = objc.registerName(
  "requestWithURL:cachePolicy:timeoutInterval:",
);
final _objc_msgSend_1ajs603 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.UnsignedLong,
          ffi.Double,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        double,
      )
    >();
late final _sel_initWithURL_ = objc.registerName("initWithURL:");
late final _sel_initWithURL_cachePolicy_timeoutInterval_ = objc.registerName(
  "initWithURL:cachePolicy:timeoutInterval:",
);
late final _sel_URL = objc.registerName("URL");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_cachePolicy = objc.registerName("cachePolicy");
final _objc_msgSend_8jm3uo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_timeoutInterval = objc.registerName("timeoutInterval");
final _objc_msgSend_1ukqyt8 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1ukqyt8Fpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_mainDocumentURL = objc.registerName("mainDocumentURL");
late final _sel_networkServiceType = objc.registerName("networkServiceType");
final _objc_msgSend_t4uaw1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_allowsCellularAccess = objc.registerName(
  "allowsCellularAccess",
);
late final _sel_allowsExpensiveNetworkAccess = objc.registerName(
  "allowsExpensiveNetworkAccess",
);
late final _sel_allowsConstrainedNetworkAccess = objc.registerName(
  "allowsConstrainedNetworkAccess",
);
late final _sel_allowsUltraConstrainedNetworkAccess = objc.registerName(
  "allowsUltraConstrainedNetworkAccess",
);
late final _sel_assumesHTTP3Capable = objc.registerName("assumesHTTP3Capable");
late final _sel_attribution = objc.registerName("attribution");
final _objc_msgSend_i3avs9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_requiresDNSSECValidation = objc.registerName(
  "requiresDNSSECValidation",
);
late final _sel_allowsPersistentDNS = objc.registerName("allowsPersistentDNS");
late final _sel_cookiePartitionIdentifier = objc.registerName(
  "cookiePartitionIdentifier",
);
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.NSZone>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.NSZone>,
      )
    >();
late final _sel_alloc = objc.registerName("alloc");
late final _sel_encodeWithCoder_ = objc.registerName("encodeWithCoder:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, objc.NSCoder.fromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSCoder.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSCoder.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSCoder.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSCoder$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_initWithCoder_ = objc.registerName("initWithCoder:");

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
      ffi.Pointer<ffi.Void>,
      objc.NSCoder,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSCoder,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
      ffi.Pointer<ffi.Void>,
      objc.NSCoder,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSCoder,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
      ffi.Pointer<ffi.Void>,
      objc.NSCoder,
    )
  >
  fromFunction(
    Dartinstancetype? Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSCoder,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                objc.NSCoder.fromPointer(arg1, retain: true, release: true),
              )?.ref.retainAndReturnPointer() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static instancetype _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          instancetype Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static instancetype _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as instancetype Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_instancetype_ffiVoid_NSCoder$CallExtension
    on
        objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
            ffi.Pointer<ffi.Void>,
            objc.NSCoder,
          )
        > {
  Dartinstancetype? call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer)
              .address ==
          0
      ? null
      : objc.ObjCObject(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer),
          retain: false,
          release: true,
        );
}

late final _sel_HTTPMethod = objc.registerName("HTTPMethod");
late final _sel_allHTTPHeaderFields = objc.registerName("allHTTPHeaderFields");
late final _sel_valueForHTTPHeaderField_ = objc.registerName(
  "valueForHTTPHeaderField:",
);
late final _sel_HTTPBody = objc.registerName("HTTPBody");
late final _sel_HTTPBodyStream = objc.registerName("HTTPBodyStream");
late final _sel_HTTPShouldHandleCookies = objc.registerName(
  "HTTPShouldHandleCookies",
);
late final _sel_HTTPShouldUsePipelining = objc.registerName(
  "HTTPShouldUsePipelining",
);

/// NSHTTPURLRequest
extension NSHTTPURLRequest on NSURLRequest {
  /// HTTPBody
  objc.NSData? get HTTPBody {
    objc.checkOsVersionInternal(
      'NSURLRequest.HTTPBody',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_HTTPBody);
    return $ret.address == 0
        ? null
        : objc.NSData.fromPointer($ret, retain: true, release: true);
  }

  /// HTTPBodyStream
  objc.NSInputStream? get HTTPBodyStream {
    objc.checkOsVersionInternal(
      'NSURLRequest.HTTPBodyStream',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_HTTPBodyStream,
    );
    return $ret.address == 0
        ? null
        : objc.NSInputStream.fromPointer($ret, retain: true, release: true);
  }

  /// HTTPMethod
  objc.NSString? get HTTPMethod {
    objc.checkOsVersionInternal(
      'NSURLRequest.HTTPMethod',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_HTTPMethod);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// HTTPShouldHandleCookies
  bool get HTTPShouldHandleCookies {
    objc.checkOsVersionInternal(
      'NSURLRequest.HTTPShouldHandleCookies',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_HTTPShouldHandleCookies,
    );
  }

  /// HTTPShouldUsePipelining
  bool get HTTPShouldUsePipelining {
    objc.checkOsVersionInternal(
      'NSURLRequest.HTTPShouldUsePipelining',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_HTTPShouldUsePipelining,
    );
  }

  /// allHTTPHeaderFields
  objc.NSDictionary? get allHTTPHeaderFields {
    objc.checkOsVersionInternal(
      'NSURLRequest.allHTTPHeaderFields',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_allHTTPHeaderFields,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// valueForHTTPHeaderField:
  objc.NSString? valueForHTTPHeaderField(objc.NSString field) {
    objc.checkOsVersionInternal(
      'NSURLRequest.valueForHTTPHeaderField:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_valueForHTTPHeaderField_,
      field.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }
}

/// NSURLRequest
extension type NSURLRequest._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSSecureCoding,
        objc.NSCopying,
        objc.NSMutableCopying {
  /// Constructs a [NSURLRequest] that points to the same underlying object as [other].
  NSURLRequest.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSURLRequest',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [NSURLRequest] that wraps the given raw object pointer.
  NSURLRequest.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSURLRequest',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NSURLRequest].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NSURLRequest,
  );

  /// alloc
  static NSURLRequest alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSURLRequest, _sel_alloc);
    return NSURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSURLRequest allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSURLRequest,
      _sel_allocWithZone_,
      zone,
    );
    return NSURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSURLRequest new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSURLRequest, _sel_new);
    return NSURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// requestWithURL:
  static NSURLRequest requestWithURL(objc.NSURL URL) {
    objc.checkOsVersionInternal(
      'NSURLRequest.requestWithURL:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSURLRequest,
      _sel_requestWithURL_,
      URL.ref.pointer,
    );
    return NSURLRequest.fromPointer($ret, retain: true, release: true);
  }

  /// requestWithURL:cachePolicy:timeoutInterval:
  static NSURLRequest requestWithURL$1(
    objc.NSURL URL, {
    required NSURLRequestCachePolicy cachePolicy,
    required double timeoutInterval,
  }) {
    objc.checkOsVersionInternal(
      'NSURLRequest.requestWithURL:cachePolicy:timeoutInterval:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_1ajs603(
      _class_NSURLRequest,
      _sel_requestWithURL_cachePolicy_timeoutInterval_,
      URL.ref.pointer,
      cachePolicy.value,
      timeoutInterval,
    );
    return NSURLRequest.fromPointer($ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSURLRequest, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of NSURLRequest constructed with the default `new` method.
  NSURLRequest() : this.as(new$().object$);
}

extension NSURLRequest$Methods on NSURLRequest {
  /// URL
  objc.NSURL? get URL {
    objc.checkOsVersionInternal(
      'NSURLRequest.URL',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_URL);
    return $ret.address == 0
        ? null
        : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }

  /// allowsCellularAccess
  bool get allowsCellularAccess {
    objc.checkOsVersionInternal(
      'NSURLRequest.allowsCellularAccess',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 8, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_allowsCellularAccess);
  }

  /// allowsConstrainedNetworkAccess
  bool get allowsConstrainedNetworkAccess {
    objc.checkOsVersionInternal(
      'NSURLRequest.allowsConstrainedNetworkAccess',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowsConstrainedNetworkAccess,
    );
  }

  /// allowsExpensiveNetworkAccess
  bool get allowsExpensiveNetworkAccess {
    objc.checkOsVersionInternal(
      'NSURLRequest.allowsExpensiveNetworkAccess',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowsExpensiveNetworkAccess,
    );
  }

  /// allowsPersistentDNS
  bool get allowsPersistentDNS {
    objc.checkOsVersionInternal(
      'NSURLRequest.allowsPersistentDNS',
      iOS: (false, (18, 0, 0)),
      macOS: (false, (15, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_allowsPersistentDNS);
  }

  /// allowsUltraConstrainedNetworkAccess
  bool get allowsUltraConstrainedNetworkAccess {
    objc.checkOsVersionInternal(
      'NSURLRequest.allowsUltraConstrainedNetworkAccess',
      iOS: (false, (26, 1, 0)),
      macOS: (false, (26, 1, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowsUltraConstrainedNetworkAccess,
    );
  }

  /// assumesHTTP3Capable
  bool get assumesHTTP3Capable {
    objc.checkOsVersionInternal(
      'NSURLRequest.assumesHTTP3Capable',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_assumesHTTP3Capable);
  }

  /// attribution
  NSURLRequestAttribution get attribution {
    objc.checkOsVersionInternal(
      'NSURLRequest.attribution',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_i3avs9(object$.ref.pointer, _sel_attribution);
    return NSURLRequestAttribution.fromValue($ret);
  }

  /// cachePolicy
  NSURLRequestCachePolicy get cachePolicy {
    objc.checkOsVersionInternal(
      'NSURLRequest.cachePolicy',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_8jm3uo(object$.ref.pointer, _sel_cachePolicy);
    return NSURLRequestCachePolicy.fromValue($ret);
  }

  /// cookiePartitionIdentifier
  objc.NSString? get cookiePartitionIdentifier {
    objc.checkOsVersionInternal(
      'NSURLRequest.cookiePartitionIdentifier',
      iOS: (false, (18, 2, 0)),
      macOS: (false, (15, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_cookiePartitionIdentifier,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// init
  NSURLRequest init() {
    objc.checkOsVersionInternal(
      'NSURLRequest.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSURLRequest? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// initWithURL:
  NSURLRequest initWithURL(objc.NSURL URL) {
    objc.checkOsVersionInternal(
      'NSURLRequest.initWithURL:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithURL_,
      URL.ref.pointer,
    );
    return NSURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// initWithURL:cachePolicy:timeoutInterval:
  NSURLRequest initWithURL$1(
    objc.NSURL URL, {
    required NSURLRequestCachePolicy cachePolicy,
    required double timeoutInterval,
  }) {
    objc.checkOsVersionInternal(
      'NSURLRequest.initWithURL:cachePolicy:timeoutInterval:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_1ajs603(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithURL_cachePolicy_timeoutInterval_,
      URL.ref.pointer,
      cachePolicy.value,
      timeoutInterval,
    );
    return NSURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// mainDocumentURL
  objc.NSURL? get mainDocumentURL {
    objc.checkOsVersionInternal(
      'NSURLRequest.mainDocumentURL',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_mainDocumentURL,
    );
    return $ret.address == 0
        ? null
        : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }

  /// networkServiceType
  NSURLRequestNetworkServiceType get networkServiceType {
    objc.checkOsVersionInternal(
      'NSURLRequest.networkServiceType',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_t4uaw1(
      object$.ref.pointer,
      _sel_networkServiceType,
    );
    return NSURLRequestNetworkServiceType.fromValue($ret);
  }

  /// requiresDNSSECValidation
  bool get requiresDNSSECValidation {
    objc.checkOsVersionInternal(
      'NSURLRequest.requiresDNSSECValidation',
      iOS: (false, (16, 1, 0)),
      macOS: (false, (13, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_requiresDNSSECValidation,
    );
  }

  /// timeoutInterval
  double get timeoutInterval {
    objc.checkOsVersionInternal(
      'NSURLRequest.timeoutInterval',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_timeoutInterval)
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_timeoutInterval);
  }
}

/// WARNING: NSURLResponse is a stub. To generate bindings for this class, include
/// NSURLResponse in your config's objc-interfaces list.
///
/// NSURLResponse
extension type NSURLResponse._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSSecureCoding,
        objc.NSCopying {
  /// Constructs a [NSURLResponse] that points to the same underlying object as [other].
  NSURLResponse.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSURLResponse',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
  }

  /// Constructs a [NSURLResponse] that wraps the given raw object pointer.
  NSURLResponse.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSURLResponse',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
  }
}

sealed class NSFileVersionAddingOptions {
  static const NSFileVersionAddingByMoving = 1;
}

sealed class NSFileVersionReplacingOptions {
  static const NSFileVersionReplacingByMoving = 1;
}

sealed class NSFileWrapperReadingOptions {
  static const NSFileWrapperReadingImmediate = 1;
  static const NSFileWrapperReadingWithoutMapping = 2;
}

sealed class NSFileWrapperWritingOptions {
  static const NSFileWrapperWritingAtomic = 1;
  static const NSFileWrapperWritingWithNameUpdating = 2;
}

sealed class NSNetServiceOptions {
  static const NSNetServiceNoAutoRename = 1;
  static const NSNetServiceListenForConnections = 2;
}

/// WARNING: NSUndoManager is a stub. To generate bindings for this class, include
/// NSUndoManager in your config's objc-interfaces list.
///
/// NSUndoManager
extension type NSUndoManager._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSUndoManager] that points to the same underlying object as [other].
  NSUndoManager.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSUndoManager',
      iOS: (false, (3, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
  }

  /// Constructs a [NSUndoManager] that wraps the given raw object pointer.
  NSUndoManager.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSUndoManager',
      iOS: (false, (3, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
  }
}

enum NSURLSessionTaskState {
  NSURLSessionTaskStateRunning(0),
  NSURLSessionTaskStateSuspended(1),
  NSURLSessionTaskStateCanceling(2),
  NSURLSessionTaskStateCompleted(3);

  final int value;
  const NSURLSessionTaskState(this.value);

  static NSURLSessionTaskState fromValue(int value) => switch (value) {
    0 => NSURLSessionTaskStateRunning,
    1 => NSURLSessionTaskStateSuspended,
    2 => NSURLSessionTaskStateCanceling,
    3 => NSURLSessionTaskStateCompleted,
    _ => throw ArgumentError('Unknown value for NSURLSessionTaskState: $value'),
  };
}

enum NSURLSessionWebSocketMessageType {
  NSURLSessionWebSocketMessageTypeData(0),
  NSURLSessionWebSocketMessageTypeString(1);

  final int value;
  const NSURLSessionWebSocketMessageType(this.value);

  static NSURLSessionWebSocketMessageType fromValue(int value) =>
      switch (value) {
        0 => NSURLSessionWebSocketMessageTypeData,
        1 => NSURLSessionWebSocketMessageTypeString,
        _ => throw ArgumentError(
          'Unknown value for NSURLSessionWebSocketMessageType: $value',
        ),
      };
}

enum NSURLSessionWebSocketCloseCode {
  NSURLSessionWebSocketCloseCodeInvalid(0),
  NSURLSessionWebSocketCloseCodeNormalClosure(1000),
  NSURLSessionWebSocketCloseCodeGoingAway(1001),
  NSURLSessionWebSocketCloseCodeProtocolError(1002),
  NSURLSessionWebSocketCloseCodeUnsupportedData(1003),
  NSURLSessionWebSocketCloseCodeNoStatusReceived(1005),
  NSURLSessionWebSocketCloseCodeAbnormalClosure(1006),
  NSURLSessionWebSocketCloseCodeInvalidFramePayloadData(1007),
  NSURLSessionWebSocketCloseCodePolicyViolation(1008),
  NSURLSessionWebSocketCloseCodeMessageTooBig(1009),
  NSURLSessionWebSocketCloseCodeMandatoryExtensionMissing(1010),
  NSURLSessionWebSocketCloseCodeInternalServerError(1011),
  NSURLSessionWebSocketCloseCodeTLSHandshakeFailure(1015);

  final int value;
  const NSURLSessionWebSocketCloseCode(this.value);

  static NSURLSessionWebSocketCloseCode fromValue(int value) => switch (value) {
    0 => NSURLSessionWebSocketCloseCodeInvalid,
    1000 => NSURLSessionWebSocketCloseCodeNormalClosure,
    1001 => NSURLSessionWebSocketCloseCodeGoingAway,
    1002 => NSURLSessionWebSocketCloseCodeProtocolError,
    1003 => NSURLSessionWebSocketCloseCodeUnsupportedData,
    1005 => NSURLSessionWebSocketCloseCodeNoStatusReceived,
    1006 => NSURLSessionWebSocketCloseCodeAbnormalClosure,
    1007 => NSURLSessionWebSocketCloseCodeInvalidFramePayloadData,
    1008 => NSURLSessionWebSocketCloseCodePolicyViolation,
    1009 => NSURLSessionWebSocketCloseCodeMessageTooBig,
    1010 => NSURLSessionWebSocketCloseCodeMandatoryExtensionMissing,
    1011 => NSURLSessionWebSocketCloseCodeInternalServerError,
    1015 => NSURLSessionWebSocketCloseCodeTLSHandshakeFailure,
    _ => throw ArgumentError(
      'Unknown value for NSURLSessionWebSocketCloseCode: $value',
    ),
  };
}

enum NSURLSessionMultipathServiceType {
  NSURLSessionMultipathServiceTypeNone(0),
  NSURLSessionMultipathServiceTypeHandover(1),
  NSURLSessionMultipathServiceTypeInteractive(2),
  NSURLSessionMultipathServiceTypeAggregate(3);

  final int value;
  const NSURLSessionMultipathServiceType(this.value);

  static NSURLSessionMultipathServiceType fromValue(int value) =>
      switch (value) {
        0 => NSURLSessionMultipathServiceTypeNone,
        1 => NSURLSessionMultipathServiceTypeHandover,
        2 => NSURLSessionMultipathServiceTypeInteractive,
        3 => NSURLSessionMultipathServiceTypeAggregate,
        _ => throw ArgumentError(
          'Unknown value for NSURLSessionMultipathServiceType: $value',
        ),
      };
}

enum NSURLSessionDelayedRequestDisposition {
  NSURLSessionDelayedRequestContinueLoading(0),
  NSURLSessionDelayedRequestUseNewRequest(1),
  NSURLSessionDelayedRequestCancel(2);

  final int value;
  const NSURLSessionDelayedRequestDisposition(this.value);

  static NSURLSessionDelayedRequestDisposition fromValue(int value) =>
      switch (value) {
        0 => NSURLSessionDelayedRequestContinueLoading,
        1 => NSURLSessionDelayedRequestUseNewRequest,
        2 => NSURLSessionDelayedRequestCancel,
        _ => throw ArgumentError(
          'Unknown value for NSURLSessionDelayedRequestDisposition: $value',
        ),
      };
}

enum NSURLSessionAuthChallengeDisposition {
  NSURLSessionAuthChallengeUseCredential(0),
  NSURLSessionAuthChallengePerformDefaultHandling(1),
  NSURLSessionAuthChallengeCancelAuthenticationChallenge(2),
  NSURLSessionAuthChallengeRejectProtectionSpace(3);

  final int value;
  const NSURLSessionAuthChallengeDisposition(this.value);

  static NSURLSessionAuthChallengeDisposition fromValue(int value) =>
      switch (value) {
        0 => NSURLSessionAuthChallengeUseCredential,
        1 => NSURLSessionAuthChallengePerformDefaultHandling,
        2 => NSURLSessionAuthChallengeCancelAuthenticationChallenge,
        3 => NSURLSessionAuthChallengeRejectProtectionSpace,
        _ => throw ArgumentError(
          'Unknown value for NSURLSessionAuthChallengeDisposition: $value',
        ),
      };
}

/// WARNING: NSUserActivity is a stub. To generate bindings for this class, include
/// NSUserActivity in your config's objc-interfaces list.
///
/// NSUserActivity
extension type NSUserActivity._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSUserActivity] that points to the same underlying object as [other].
  NSUserActivity.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSUserActivity',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }

  /// Constructs a [NSUserActivity] that wraps the given raw object pointer.
  NSUserActivity.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSUserActivity',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }
}

final class __IOSurface extends ffi.Opaque {}

final class CGContext extends ffi.Opaque {}

final class CGColor extends ffi.Opaque {}

final class CGColorSpace extends ffi.Opaque {}

final class CGImage extends ffi.Opaque {}

final class CGPath extends ffi.Opaque {}

enum CGLineJoin {
  kCGLineJoinMiter(0),
  kCGLineJoinRound(1),
  kCGLineJoinBevel(2);

  final int value;
  const CGLineJoin(this.value);

  static CGLineJoin fromValue(int value) => switch (value) {
    0 => kCGLineJoinMiter,
    1 => kCGLineJoinRound,
    2 => kCGLineJoinBevel,
    _ => throw ArgumentError('Unknown value for CGLineJoin: $value'),
  };
}

enum CGLineCap {
  kCGLineCapButt(0),
  kCGLineCapRound(1),
  kCGLineCapSquare(2);

  final int value;
  const CGLineCap(this.value);

  static CGLineCap fromValue(int value) => switch (value) {
    0 => kCGLineCapButt,
    1 => kCGLineCapRound,
    2 => kCGLineCapSquare,
    _ => throw ArgumentError('Unknown value for CGLineCap: $value'),
  };
}

enum CGBlendMode {
  kCGBlendModeNormal(0),
  kCGBlendModeMultiply(1),
  kCGBlendModeScreen(2),
  kCGBlendModeOverlay(3),
  kCGBlendModeDarken(4),
  kCGBlendModeLighten(5),
  kCGBlendModeColorDodge(6),
  kCGBlendModeColorBurn(7),
  kCGBlendModeSoftLight(8),
  kCGBlendModeHardLight(9),
  kCGBlendModeDifference(10),
  kCGBlendModeExclusion(11),
  kCGBlendModeHue(12),
  kCGBlendModeSaturation(13),
  kCGBlendModeColor(14),
  kCGBlendModeLuminosity(15),
  kCGBlendModeClear(16),
  kCGBlendModeCopy(17),
  kCGBlendModeSourceIn(18),
  kCGBlendModeSourceOut(19),
  kCGBlendModeSourceAtop(20),
  kCGBlendModeDestinationOver(21),
  kCGBlendModeDestinationIn(22),
  kCGBlendModeDestinationOut(23),
  kCGBlendModeDestinationAtop(24),
  kCGBlendModeXOR(25),
  kCGBlendModePlusDarker(26),
  kCGBlendModePlusLighter(27);

  final int value;
  const CGBlendMode(this.value);

  static CGBlendMode fromValue(int value) => switch (value) {
    0 => kCGBlendModeNormal,
    1 => kCGBlendModeMultiply,
    2 => kCGBlendModeScreen,
    3 => kCGBlendModeOverlay,
    4 => kCGBlendModeDarken,
    5 => kCGBlendModeLighten,
    6 => kCGBlendModeColorDodge,
    7 => kCGBlendModeColorBurn,
    8 => kCGBlendModeSoftLight,
    9 => kCGBlendModeHardLight,
    10 => kCGBlendModeDifference,
    11 => kCGBlendModeExclusion,
    12 => kCGBlendModeHue,
    13 => kCGBlendModeSaturation,
    14 => kCGBlendModeColor,
    15 => kCGBlendModeLuminosity,
    16 => kCGBlendModeClear,
    17 => kCGBlendModeCopy,
    18 => kCGBlendModeSourceIn,
    19 => kCGBlendModeSourceOut,
    20 => kCGBlendModeSourceAtop,
    21 => kCGBlendModeDestinationOver,
    22 => kCGBlendModeDestinationIn,
    23 => kCGBlendModeDestinationOut,
    24 => kCGBlendModeDestinationAtop,
    25 => kCGBlendModeXOR,
    26 => kCGBlendModePlusDarker,
    27 => kCGBlendModePlusLighter,
    _ => throw ArgumentError('Unknown value for CGBlendMode: $value'),
  };
}

final class CGLayer extends ffi.Opaque {}

sealed class UIRectEdge {
  static const UIRectEdgeNone = 0;
  static const UIRectEdgeTop = 1;
  static const UIRectEdgeLeft = 2;
  static const UIRectEdgeBottom = 4;
  static const UIRectEdgeRight = 8;
  static const UIRectEdgeAll = 15;
}

sealed class UIAxis {
  static const UIAxisNeither = 0;
  static const UIAxisHorizontal = 1;
  static const UIAxisVertical = 2;
  static const UIAxisBoth = 3;
}

final class UIEdgeInsets extends ffi.Struct {
  @ffi.Double()
  external double top;

  @ffi.Double()
  external double left;

  @ffi.Double()
  external double bottom;

  @ffi.Double()
  external double right;
}

final class NSDirectionalEdgeInsets extends ffi.Struct {
  @ffi.Double()
  external double top;

  @ffi.Double()
  external double leading;

  @ffi.Double()
  external double bottom;

  @ffi.Double()
  external double trailing;
}

final class UIOffset extends ffi.Struct {
  @ffi.Double()
  external double horizontal;

  @ffi.Double()
  external double vertical;
}

sealed class UIRectCorner {
  static const UIRectCornerTopLeft = 1;
  static const UIRectCornerTopRight = 2;
  static const UIRectCornerBottomLeft = 4;
  static const UIRectCornerBottomRight = 8;
  static const UIRectCornerAllCorners = -1;
}

sealed class NSDirectionalRectEdge {
  static const NSDirectionalRectEdgeNone = 0;
  static const NSDirectionalRectEdgeTop = 1;
  static const NSDirectionalRectEdgeLeading = 2;
  static const NSDirectionalRectEdgeBottom = 4;
  static const NSDirectionalRectEdgeTrailing = 8;
  static const NSDirectionalRectEdgeAll = 15;
}

/// WARNING: UIBezierPath is a stub. To generate bindings for this class, include
/// UIBezierPath in your config's objc-interfaces list.
///
/// UIBezierPath
extension type UIBezierPath._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSCopying,
        objc.NSSecureCoding {
  /// Constructs a [UIBezierPath] that points to the same underlying object as [other].
  UIBezierPath.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIBezierPath', iOS: (false, (3, 2, 0)));
  }

  /// Constructs a [UIBezierPath] that wraps the given raw object pointer.
  UIBezierPath.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIBezierPath', iOS: (false, (3, 2, 0)));
  }
}

final class __CVBuffer extends ffi.Opaque {}

final class CGImageSource extends ffi.Opaque {}

enum CGImagePropertyOrientation {
  kCGImagePropertyOrientationUp(1),
  kCGImagePropertyOrientationUpMirrored(2),
  kCGImagePropertyOrientationDown(3),
  kCGImagePropertyOrientationDownMirrored(4),
  kCGImagePropertyOrientationLeftMirrored(5),
  kCGImagePropertyOrientationRight(6),
  kCGImagePropertyOrientationRightMirrored(7),
  kCGImagePropertyOrientationLeft(8);

  final int value;
  const CGImagePropertyOrientation(this.value);

  static CGImagePropertyOrientation fromValue(int value) => switch (value) {
    1 => kCGImagePropertyOrientationUp,
    2 => kCGImagePropertyOrientationUpMirrored,
    3 => kCGImagePropertyOrientationDown,
    4 => kCGImagePropertyOrientationDownMirrored,
    5 => kCGImagePropertyOrientationLeftMirrored,
    6 => kCGImagePropertyOrientationRight,
    7 => kCGImagePropertyOrientationRightMirrored,
    8 => kCGImagePropertyOrientationLeft,
    _ => throw ArgumentError(
      'Unknown value for CGImagePropertyOrientation: $value',
    ),
  };
}

enum UIColorProminence {
  UIColorProminencePrimary(0),
  UIColorProminenceSecondary(1),
  UIColorProminenceTertiary(2),
  UIColorProminenceQuaternary(3);

  final int value;
  const UIColorProminence(this.value);

  static UIColorProminence fromValue(int value) => switch (value) {
    0 => UIColorProminencePrimary,
    1 => UIColorProminenceSecondary,
    2 => UIColorProminenceTertiary,
    3 => UIColorProminenceQuaternary,
    _ => throw ArgumentError('Unknown value for UIColorProminence: $value'),
  };
}

/// WARNING: UIColor is a stub. To generate bindings for this class, include
/// UIColor in your config's objc-interfaces list.
///
/// UIColor
extension type UIColor._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSSecureCoding,
        objc.NSCopying {
  /// Constructs a [UIColor] that points to the same underlying object as [other].
  UIColor.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIColor', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIColor] that wraps the given raw object pointer.
  UIColor.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIColor', iOS: (false, (2, 0, 0)));
  }
}

sealed class UIFontDescriptorSymbolicTraits {
  static const UIFontDescriptorTraitItalic = 1;
  static const UIFontDescriptorTraitBold = 2;
  static const UIFontDescriptorTraitExpanded = 32;
  static const UIFontDescriptorTraitCondensed = 64;
  static const UIFontDescriptorTraitMonoSpace = 1024;
  static const UIFontDescriptorTraitVertical = 2048;
  static const UIFontDescriptorTraitUIOptimized = 4096;
  static const UIFontDescriptorTraitTightLeading = 32768;
  static const UIFontDescriptorTraitLooseLeading = 65536;
  static const UIFontDescriptorClassMask = -268435456;
  static const UIFontDescriptorClassUnknown = 0;
  static const UIFontDescriptorClassOldStyleSerifs = 268435456;
  static const UIFontDescriptorClassTransitionalSerifs = 536870912;
  static const UIFontDescriptorClassModernSerifs = 805306368;
  static const UIFontDescriptorClassClarendonSerifs = 1073741824;
  static const UIFontDescriptorClassSlabSerifs = 1342177280;
  static const UIFontDescriptorClassFreeformSerifs = 1879048192;
  static const UIFontDescriptorClassSansSerif = -2147483648;
  static const UIFontDescriptorClassOrnamentals = -1879048192;
  static const UIFontDescriptorClassScripts = -1610612736;
  static const UIFontDescriptorClassSymbolic = -1073741824;
}

/// WARNING: UIFont is a stub. To generate bindings for this class, include
/// UIFont in your config's objc-interfaces list.
///
/// UIFont
extension type UIFont._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSCopying,
        objc.NSSecureCoding {
  /// Constructs a [UIFont] that points to the same underlying object as [other].
  UIFont.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIFont', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIFont] that wraps the given raw object pointer.
  UIFont.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIFont', iOS: (false, (2, 0, 0)));
  }
}

enum UIImageOrientation {
  UIImageOrientationUp(0),
  UIImageOrientationDown(1),
  UIImageOrientationLeft(2),
  UIImageOrientationRight(3),
  UIImageOrientationUpMirrored(4),
  UIImageOrientationDownMirrored(5),
  UIImageOrientationLeftMirrored(6),
  UIImageOrientationRightMirrored(7);

  final int value;
  const UIImageOrientation(this.value);

  static UIImageOrientation fromValue(int value) => switch (value) {
    0 => UIImageOrientationUp,
    1 => UIImageOrientationDown,
    2 => UIImageOrientationLeft,
    3 => UIImageOrientationRight,
    4 => UIImageOrientationUpMirrored,
    5 => UIImageOrientationDownMirrored,
    6 => UIImageOrientationLeftMirrored,
    7 => UIImageOrientationRightMirrored,
    _ => throw ArgumentError('Unknown value for UIImageOrientation: $value'),
  };
}

enum UIImageResizingMode {
  UIImageResizingModeTile(0),
  UIImageResizingModeStretch(1);

  final int value;
  const UIImageResizingMode(this.value);

  static UIImageResizingMode fromValue(int value) => switch (value) {
    0 => UIImageResizingModeTile,
    1 => UIImageResizingModeStretch,
    _ => throw ArgumentError('Unknown value for UIImageResizingMode: $value'),
  };
}

enum UIImageRenderingMode {
  UIImageRenderingModeAutomatic(0),
  UIImageRenderingModeAlwaysOriginal(1),
  UIImageRenderingModeAlwaysTemplate(2);

  final int value;
  const UIImageRenderingMode(this.value);

  static UIImageRenderingMode fromValue(int value) => switch (value) {
    0 => UIImageRenderingModeAutomatic,
    1 => UIImageRenderingModeAlwaysOriginal,
    2 => UIImageRenderingModeAlwaysTemplate,
    _ => throw ArgumentError('Unknown value for UIImageRenderingMode: $value'),
  };
}

/// WARNING: UIImage is a stub. To generate bindings for this class, include
/// UIImage in your config's objc-interfaces list.
///
/// UIImage
extension type UIImage._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSSecureCoding {
  /// Constructs a [UIImage] that points to the same underlying object as [other].
  UIImage.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIImage', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIImage] that wraps the given raw object pointer.
  UIImage.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIImage', iOS: (false, (2, 0, 0)));
  }
}

enum UIImageSymbolScale {
  UIImageSymbolScaleDefault(-1),
  UIImageSymbolScaleUnspecified(0),
  UIImageSymbolScaleSmall(1),
  UIImageSymbolScaleMedium(2),
  UIImageSymbolScaleLarge(3);

  final int value;
  const UIImageSymbolScale(this.value);

  static UIImageSymbolScale fromValue(int value) => switch (value) {
    -1 => UIImageSymbolScaleDefault,
    0 => UIImageSymbolScaleUnspecified,
    1 => UIImageSymbolScaleSmall,
    2 => UIImageSymbolScaleMedium,
    3 => UIImageSymbolScaleLarge,
    _ => throw ArgumentError('Unknown value for UIImageSymbolScale: $value'),
  };
}

enum UIImageSymbolWeight {
  UIImageSymbolWeightUnspecified(0),
  UIImageSymbolWeightUltraLight(1),
  UIImageSymbolWeightThin(2),
  UIImageSymbolWeightLight(3),
  UIImageSymbolWeightRegular(4),
  UIImageSymbolWeightMedium(5),
  UIImageSymbolWeightSemibold(6),
  UIImageSymbolWeightBold(7),
  UIImageSymbolWeightHeavy(8),
  UIImageSymbolWeightBlack(9);

  final int value;
  const UIImageSymbolWeight(this.value);

  static UIImageSymbolWeight fromValue(int value) => switch (value) {
    0 => UIImageSymbolWeightUnspecified,
    1 => UIImageSymbolWeightUltraLight,
    2 => UIImageSymbolWeightThin,
    3 => UIImageSymbolWeightLight,
    4 => UIImageSymbolWeightRegular,
    5 => UIImageSymbolWeightMedium,
    6 => UIImageSymbolWeightSemibold,
    7 => UIImageSymbolWeightBold,
    8 => UIImageSymbolWeightHeavy,
    9 => UIImageSymbolWeightBlack,
    _ => throw ArgumentError('Unknown value for UIImageSymbolWeight: $value'),
  };
}

enum UIImageSymbolVariableValueMode {
  UIImageSymbolVariableValueModeAutomatic(0),
  UIImageSymbolVariableValueModeColor(1),
  UIImageSymbolVariableValueModeDraw(2);

  final int value;
  const UIImageSymbolVariableValueMode(this.value);

  static UIImageSymbolVariableValueMode fromValue(int value) => switch (value) {
    0 => UIImageSymbolVariableValueModeAutomatic,
    1 => UIImageSymbolVariableValueModeColor,
    2 => UIImageSymbolVariableValueModeDraw,
    _ => throw ArgumentError(
      'Unknown value for UIImageSymbolVariableValueMode: $value',
    ),
  };
}

enum UIImageSymbolColorRenderingMode {
  UIImageSymbolColorRenderingModeAutomatic(0),
  UIImageSymbolColorRenderingModeFlat(1),
  UIImageSymbolColorRenderingModeGradient(2);

  final int value;
  const UIImageSymbolColorRenderingMode(this.value);

  static UIImageSymbolColorRenderingMode fromValue(int value) =>
      switch (value) {
        0 => UIImageSymbolColorRenderingModeAutomatic,
        1 => UIImageSymbolColorRenderingModeFlat,
        2 => UIImageSymbolColorRenderingModeGradient,
        _ => throw ArgumentError(
          'Unknown value for UIImageSymbolColorRenderingMode: $value',
        ),
      };
}

sealed class NSUnderlineStyle {
  static const NSUnderlineStyleNone = 0;
  static const NSUnderlineStyleSingle = 1;
  static const NSUnderlineStyleThick = 2;
  static const NSUnderlineStyleDouble = 9;
  static const NSUnderlineStylePatternSolid = 0;
  static const NSUnderlineStylePatternDot = 256;
  static const NSUnderlineStylePatternDash = 512;
  static const NSUnderlineStylePatternDashDot = 768;
  static const NSUnderlineStylePatternDashDotDot = 1024;
  static const NSUnderlineStyleByWord = 32768;
}

enum NSWritingDirection {
  NSWritingDirectionNatural(-1),
  NSWritingDirectionLeftToRight(0),
  NSWritingDirectionRightToLeft(1);

  final int value;
  const NSWritingDirection(this.value);

  static NSWritingDirection fromValue(int value) => switch (value) {
    -1 => NSWritingDirectionNatural,
    0 => NSWritingDirectionLeftToRight,
    1 => NSWritingDirectionRightToLeft,
    _ => throw ArgumentError('Unknown value for NSWritingDirection: $value'),
  };
}

enum NSTextAlignment {
  NSTextAlignmentLeft(0),
  NSTextAlignmentCenter(1),
  NSTextAlignmentRight(2),
  NSTextAlignmentJustified(3),
  NSTextAlignmentNatural(4);

  final int value;
  const NSTextAlignment(this.value);

  static NSTextAlignment fromValue(int value) => switch (value) {
    0 => NSTextAlignmentLeft,
    1 => NSTextAlignmentCenter,
    2 => NSTextAlignmentRight,
    3 => NSTextAlignmentJustified,
    4 => NSTextAlignmentNatural,
    _ => throw ArgumentError('Unknown value for NSTextAlignment: $value'),
  };
}

enum NSLineBreakMode {
  NSLineBreakByWordWrapping(0),
  NSLineBreakByCharWrapping(1),
  NSLineBreakByClipping(2),
  NSLineBreakByTruncatingHead(3),
  NSLineBreakByTruncatingTail(4),
  NSLineBreakByTruncatingMiddle(5);

  final int value;
  const NSLineBreakMode(this.value);

  static NSLineBreakMode fromValue(int value) => switch (value) {
    0 => NSLineBreakByWordWrapping,
    1 => NSLineBreakByCharWrapping,
    2 => NSLineBreakByClipping,
    3 => NSLineBreakByTruncatingHead,
    4 => NSLineBreakByTruncatingTail,
    5 => NSLineBreakByTruncatingMiddle,
    _ => throw ArgumentError('Unknown value for NSLineBreakMode: $value'),
  };
}

sealed class NSLineBreakStrategy {
  static const NSLineBreakStrategyNone = 0;
  static const NSLineBreakStrategyPushOut = 1;
  static const NSLineBreakStrategyHangulWordPriority = 2;
  static const NSLineBreakStrategyStandard = 65535;
}

final class CATransform3D extends ffi.Struct {
  @ffi.Double()
  external double m11;

  @ffi.Double()
  external double m12;

  @ffi.Double()
  external double m13;

  @ffi.Double()
  external double m14;

  @ffi.Double()
  external double m21;

  @ffi.Double()
  external double m22;

  @ffi.Double()
  external double m23;

  @ffi.Double()
  external double m24;

  @ffi.Double()
  external double m31;

  @ffi.Double()
  external double m32;

  @ffi.Double()
  external double m33;

  @ffi.Double()
  external double m34;

  @ffi.Double()
  external double m41;

  @ffi.Double()
  external double m42;

  @ffi.Double()
  external double m43;

  @ffi.Double()
  external double m44;
}

/// WARNING: CAMediaTiming is a stub. To generate bindings for this class, include
/// CAMediaTiming in your config's objc-protocols list.
///
/// CAMediaTiming
extension type CAMediaTiming._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol {
  /// Constructs a [CAMediaTiming] that points to the same underlying object as [other].
  CAMediaTiming.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [CAMediaTiming] that wraps the given raw object pointer.
  CAMediaTiming.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

sealed class CAAutoresizingMask {
  static const kCALayerNotSizable = 0;
  static const kCALayerMinXMargin = 1;
  static const kCALayerWidthSizable = 2;
  static const kCALayerMaxXMargin = 4;
  static const kCALayerMinYMargin = 8;
  static const kCALayerHeightSizable = 16;
  static const kCALayerMaxYMargin = 32;
}

sealed class CAEdgeAntialiasingMask {
  static const kCALayerLeftEdge = 1;
  static const kCALayerRightEdge = 2;
  static const kCALayerBottomEdge = 4;
  static const kCALayerTopEdge = 8;
}

sealed class CACornerMask {
  static const kCALayerMinXMinYCorner = 1;
  static const kCALayerMaxXMinYCorner = 2;
  static const kCALayerMinXMaxYCorner = 4;
  static const kCALayerMaxXMaxYCorner = 8;
}

/// WARNING: CALayer is a stub. To generate bindings for this class, include
/// CALayer in your config's objc-interfaces list.
///
/// CALayer
extension type CALayer._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSSecureCoding,
        CAMediaTiming {
  /// Constructs a [CALayer] that points to the same underlying object as [other].
  CALayer.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'CALayer',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
  }

  /// Constructs a [CALayer] that wraps the given raw object pointer.
  CALayer.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'CALayer',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
  }
}

/// WARNING: CAAction is a stub. To generate bindings for this class, include
/// CAAction in your config's objc-protocols list.
///
/// CAAction
extension type CAAction._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol {
  /// Constructs a [CAAction] that points to the same underlying object as [other].
  CAAction.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [CAAction] that wraps the given raw object pointer.
  CAAction.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// WARNING: CALayerDelegate is a stub. To generate bindings for this class, include
/// CALayerDelegate in your config's objc-protocols list.
///
/// CALayerDelegate
extension type CALayerDelegate._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [CALayerDelegate] that points to the same underlying object as [other].
  CALayerDelegate.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [CALayerDelegate] that wraps the given raw object pointer.
  CALayerDelegate.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

final class CAFrameRateRange extends ffi.Struct {
  @ffi.Float()
  external double minimum;

  @ffi.Float()
  external double maximum;

  @ffi.Float()
  external double preferred;
}

enum CAConstraintAttribute {
  kCAConstraintMinX(0),
  kCAConstraintMidX(1),
  kCAConstraintMaxX(2),
  kCAConstraintWidth(3),
  kCAConstraintMinY(4),
  kCAConstraintMidY(5),
  kCAConstraintMaxY(6),
  kCAConstraintHeight(7);

  final int value;
  const CAConstraintAttribute(this.value);

  static CAConstraintAttribute fromValue(int value) => switch (value) {
    0 => kCAConstraintMinX,
    1 => kCAConstraintMidX,
    2 => kCAConstraintMaxX,
    3 => kCAConstraintWidth,
    4 => kCAConstraintMinY,
    5 => kCAConstraintMidY,
    6 => kCAConstraintMaxY,
    7 => kCAConstraintHeight,
    _ => throw ArgumentError('Unknown value for CAConstraintAttribute: $value'),
  };
}

enum UIMenuElementState {
  UIMenuElementStateOff(0),
  UIMenuElementStateOn(1),
  UIMenuElementStateMixed(2);

  final int value;
  const UIMenuElementState(this.value);

  static UIMenuElementState fromValue(int value) => switch (value) {
    0 => UIMenuElementStateOff,
    1 => UIMenuElementStateOn,
    2 => UIMenuElementStateMixed,
    _ => throw ArgumentError('Unknown value for UIMenuElementState: $value'),
  };
}

sealed class UIMenuElementAttributes {
  static const UIMenuElementAttributesDisabled = 1;
  static const UIMenuElementAttributesDestructive = 2;
  static const UIMenuElementAttributesHidden = 4;
  static const UIMenuElementAttributesKeepsMenuPresented = 8;
}

enum UIMenuElementRepeatBehavior {
  UIMenuElementRepeatBehaviorAutomatic(0),
  UIMenuElementRepeatBehaviorRepeatable(1),
  UIMenuElementRepeatBehaviorNonRepeatable(2);

  final int value;
  const UIMenuElementRepeatBehavior(this.value);

  static UIMenuElementRepeatBehavior fromValue(int value) => switch (value) {
    0 => UIMenuElementRepeatBehaviorAutomatic,
    1 => UIMenuElementRepeatBehaviorRepeatable,
    2 => UIMenuElementRepeatBehaviorNonRepeatable,
    _ => throw ArgumentError(
      'Unknown value for UIMenuElementRepeatBehavior: $value',
    ),
  };
}

late final _class_UIMenuElement = objc.getClass("UIMenuElement");
late final _sel_title = objc.registerName("title");
late final _sel_subtitle = objc.registerName("subtitle");
late final _sel_setSubtitle_ = objc.registerName("setSubtitle:");
late final _sel_image = objc.registerName("image");
late final _sel_accessibilityIdentifier = objc.registerName(
  "accessibilityIdentifier",
);

/// Construction methods for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSString_ffiVoid$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    objc.NSString? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) =>
          fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSString_ffiVoid$1$CallExtension
    on objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>)> {
  objc.NSString? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : objc.NSString.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_setAccessibilityIdentifier_ = objc.registerName(
  "setAccessibilityIdentifier:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.NSString?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                arg1.address == 0
                    ? null
                    : objc.NSString.fromPointer(
                        arg1,
                        retain: true,
                        release: true,
                      ),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.NSString?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSString.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.NSString?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSString.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.NSString.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSString$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString?)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSString? arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

/// WARNING: UIAccessibilityIdentification is a stub. To generate bindings for this class, include
/// UIAccessibilityIdentification in your config's objc-protocols list.
///
/// UIAccessibilityIdentification
extension type UIAccessibilityIdentification._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIAccessibilityIdentification] that points to the same underlying object as [other].
  UIAccessibilityIdentification.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIAccessibilityIdentification] that wraps the given raw object pointer.
  UIAccessibilityIdentification.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// UIAccessibility
extension UIAccessibility$1 on UIMenuElement {
  /// accessibilityIdentifier
  objc.NSString? get accessibilityIdentifier {
    objc.checkOsVersionInternal(
      'UIMenuElement.accessibilityIdentifier',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityIdentifier,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// setAccessibilityIdentifier:
  set accessibilityIdentifier(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'UIMenuElement.setAccessibilityIdentifier:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityIdentifier_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }
}

/// UIMenuElement
extension type UIMenuElement._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSCopying,
        objc.NSSecureCoding {
  /// Constructs a [UIMenuElement] that points to the same underlying object as [other].
  UIMenuElement.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIMenuElement', iOS: (false, (13, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UIMenuElement] that wraps the given raw object pointer.
  UIMenuElement.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIMenuElement', iOS: (false, (13, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UIMenuElement].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_UIMenuElement,
  );

  /// alloc
  static UIMenuElement alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIMenuElement, _sel_alloc);
    return UIMenuElement.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIMenuElement allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_UIMenuElement,
      _sel_allocWithZone_,
      zone,
    );
    return UIMenuElement.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static UIMenuElement new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIMenuElement, _sel_new);
    return UIMenuElement.fromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
      _class_UIMenuElement,
      _sel_supportsSecureCoding,
    );
  }

  /// Returns a new instance of UIMenuElement constructed with the default `new` method.
  UIMenuElement() : this.as(new$().object$);
}

extension UIMenuElement$Methods on UIMenuElement {
  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// image
  UIImage? get image {
    objc.checkOsVersionInternal(
      'UIMenuElement.image',
      iOS: (false, (13, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_image);
    return $ret.address == 0
        ? null
        : UIImage.fromPointer($ret, retain: true, release: true);
  }

  /// init
  UIMenuElement init() {
    objc.checkOsVersionInternal(
      'UIMenuElement.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return UIMenuElement.fromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIMenuElement? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : UIMenuElement.fromPointer($ret, retain: false, release: true);
  }

  /// setSubtitle:
  set subtitle(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'UIMenuElement.setSubtitle:',
      iOS: (false, (15, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setSubtitle_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// subtitle
  objc.NSString? get subtitle {
    objc.checkOsVersionInternal(
      'UIMenuElement.subtitle',
      iOS: (false, (15, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_subtitle);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// title
  objc.NSString get title {
    objc.checkOsVersionInternal(
      'UIMenuElement.title',
      iOS: (false, (13, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_title);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }
}

/// WARNING: UIMenuDisplayPreferences is a stub. To generate bindings for this class, include
/// UIMenuDisplayPreferences in your config's objc-interfaces list.
///
/// UIMenuDisplayPreferences
extension type UIMenuDisplayPreferences._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSCopying,
        objc.NSSecureCoding {
  /// Constructs a [UIMenuDisplayPreferences] that points to the same underlying object as [other].
  UIMenuDisplayPreferences.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UIMenuDisplayPreferences',
      iOS: (false, (17, 4, 0)),
    );
  }

  /// Constructs a [UIMenuDisplayPreferences] that wraps the given raw object pointer.
  UIMenuDisplayPreferences.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UIMenuDisplayPreferences',
      iOS: (false, (17, 4, 0)),
    );
  }
}

sealed class UIMenuOptions {
  static const UIMenuOptionsDisplayInline = 1;
  static const UIMenuOptionsDestructive = 2;
  static const UIMenuOptionsSingleSelection = 32;
  static const UIMenuOptionsDisplayAsPalette = 128;
}

enum UIMenuElementSize {
  UIMenuElementSizeSmall(0),
  UIMenuElementSizeMedium(1),
  UIMenuElementSizeLarge(2),
  UIMenuElementSizeAutomatic(-1);

  final int value;
  const UIMenuElementSize(this.value);

  static UIMenuElementSize fromValue(int value) => switch (value) {
    0 => UIMenuElementSizeSmall,
    1 => UIMenuElementSizeMedium,
    2 => UIMenuElementSizeLarge,
    -1 => UIMenuElementSizeAutomatic,
    _ => throw ArgumentError('Unknown value for UIMenuElementSize: $value'),
  };
}

late final _class_UIMenu = objc.getClass("UIMenu");
late final _sel_identifier = objc.registerName("identifier");
late final _sel_options = objc.registerName("options");
final _objc_msgSend_1cz0z8u = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_preferredElementSize = objc.registerName(
  "preferredElementSize",
);
final _objc_msgSend_xjcq8x = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setPreferredElementSize_ = objc.registerName(
  "setPreferredElementSize:",
);
final _objc_msgSend_b88ef1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_children = objc.registerName("children");
late final _sel_selectedElements = objc.registerName("selectedElements");
late final _sel_displayPreferences = objc.registerName("displayPreferences");
late final _sel_setDisplayPreferences_ = objc.registerName(
  "setDisplayPreferences:",
);
late final _sel_menuWithChildren_ = objc.registerName("menuWithChildren:");
late final _sel_menuWithTitle_children_ = objc.registerName(
  "menuWithTitle:children:",
);
final _objc_msgSend_15qeuct = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_menuWithTitle_image_identifier_options_children_ = objc
    .registerName("menuWithTitle:image:identifier:options:children:");
final _objc_msgSend_zjuvxo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_menuByReplacingChildren_ = objc.registerName(
  "menuByReplacingChildren:",
);

/// UIMenu
extension type UIMenu._(objc.ObjCObject object$)
    implements objc.ObjCObject, UIMenuElement {
  /// Constructs a [UIMenu] that points to the same underlying object as [other].
  UIMenu.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIMenu', iOS: (false, (13, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UIMenu] that wraps the given raw object pointer.
  UIMenu.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIMenu', iOS: (false, (13, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UIMenu].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_UIMenu,
  );

  /// alloc
  static UIMenu alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIMenu, _sel_alloc);
    return UIMenu.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIMenu allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_UIMenu,
      _sel_allocWithZone_,
      zone,
    );
    return UIMenu.fromPointer($ret, retain: false, release: true);
  }

  /// menuWithChildren:
  static UIMenu menuWithChildren(objc.NSArray children) {
    objc.checkOsVersionInternal(
      'UIMenu.menuWithChildren:',
      iOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_UIMenu,
      _sel_menuWithChildren_,
      children.ref.pointer,
    );
    return UIMenu.fromPointer($ret, retain: true, release: true);
  }

  /// menuWithTitle:children:
  static UIMenu menuWithTitle(
    objc.NSString title, {
    required objc.NSArray children,
  }) {
    final $ret = _objc_msgSend_15qeuct(
      _class_UIMenu,
      _sel_menuWithTitle_children_,
      title.ref.pointer,
      children.ref.pointer,
    );
    return UIMenu.fromPointer($ret, retain: true, release: true);
  }

  /// menuWithTitle:image:identifier:options:children:
  static UIMenu menuWithTitle$1(
    objc.NSString title, {
    UIImage? image,
    objc.NSString? identifier,
    required int options,
    required objc.NSArray children,
  }) {
    final $ret = _objc_msgSend_zjuvxo(
      _class_UIMenu,
      _sel_menuWithTitle_image_identifier_options_children_,
      title.ref.pointer,
      image?.ref.pointer ?? ffi.nullptr,
      identifier?.ref.pointer ?? ffi.nullptr,
      options,
      children.ref.pointer,
    );
    return UIMenu.fromPointer($ret, retain: true, release: true);
  }

  /// new
  static UIMenu new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIMenu, _sel_new);
    return UIMenu.fromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UIMenu, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of UIMenu constructed with the default `new` method.
  UIMenu() : this.as(new$().object$);
}

extension UIMenu$Methods on UIMenu {
  /// children
  objc.NSArray get children {
    objc.checkOsVersionInternal('UIMenu.children', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_children);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// displayPreferences
  UIMenuDisplayPreferences? get displayPreferences {
    objc.checkOsVersionInternal(
      'UIMenu.displayPreferences',
      iOS: (false, (17, 4, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_displayPreferences,
    );
    return $ret.address == 0
        ? null
        : UIMenuDisplayPreferences.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// identifier
  objc.NSString get identifier {
    objc.checkOsVersionInternal('UIMenu.identifier', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_identifier);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// init
  UIMenu init() {
    objc.checkOsVersionInternal(
      'UIMenu.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return UIMenu.fromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIMenu? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : UIMenu.fromPointer($ret, retain: false, release: true);
  }

  /// menuByReplacingChildren:
  UIMenu menuByReplacingChildren(objc.NSArray newChildren) {
    objc.checkOsVersionInternal(
      'UIMenu.menuByReplacingChildren:',
      iOS: (false, (13, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_menuByReplacingChildren_,
      newChildren.ref.pointer,
    );
    return UIMenu.fromPointer($ret, retain: true, release: true);
  }

  /// options
  int get options {
    objc.checkOsVersionInternal('UIMenu.options', iOS: (false, (13, 0, 0)));
    return _objc_msgSend_1cz0z8u(object$.ref.pointer, _sel_options);
  }

  /// preferredElementSize
  UIMenuElementSize get preferredElementSize {
    objc.checkOsVersionInternal(
      'UIMenu.preferredElementSize',
      iOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_xjcq8x(
      object$.ref.pointer,
      _sel_preferredElementSize,
    );
    return UIMenuElementSize.fromValue($ret);
  }

  /// selectedElements
  objc.NSArray get selectedElements {
    objc.checkOsVersionInternal(
      'UIMenu.selectedElements',
      iOS: (false, (15, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_selectedElements,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// setDisplayPreferences:
  set displayPreferences(UIMenuDisplayPreferences? value) {
    objc.checkOsVersionInternal(
      'UIMenu.setDisplayPreferences:',
      iOS: (false, (17, 4, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setDisplayPreferences_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setPreferredElementSize:
  set preferredElementSize(UIMenuElementSize value) {
    objc.checkOsVersionInternal(
      'UIMenu.setPreferredElementSize:',
      iOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_b88ef1(
      object$.ref.pointer,
      _sel_setPreferredElementSize_,
      value.value,
    );
  }
}

/// WARNING: UIMenuLeaf is a stub. To generate bindings for this class, include
/// UIMenuLeaf in your config's objc-protocols list.
///
/// UIMenuLeaf
extension type UIMenuLeaf._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIMenuLeaf] that points to the same underlying object as [other].
  UIMenuLeaf.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIMenuLeaf] that wraps the given raw object pointer.
  UIMenuLeaf.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

sealed class UIKeyModifierFlags {
  static const UIKeyModifierAlphaShift = 65536;
  static const UIKeyModifierShift = 131072;
  static const UIKeyModifierControl = 262144;
  static const UIKeyModifierAlternate = 524288;
  static const UIKeyModifierCommand = 1048576;
  static const UIKeyModifierNumericPad = 2097152;
}

/// WARNING: UICommand is a stub. To generate bindings for this class, include
/// UICommand in your config's objc-interfaces list.
///
/// UICommand
extension type UICommand._(objc.ObjCObject object$)
    implements objc.ObjCObject, UIMenuElement, UIMenuLeaf {
  /// Constructs a [UICommand] that points to the same underlying object as [other].
  UICommand.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UICommand', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UICommand] that wraps the given raw object pointer.
  UICommand.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UICommand', iOS: (false, (13, 0, 0)));
  }
}

enum UIEventType {
  UIEventTypeTouches(0),
  UIEventTypeMotion(1),
  UIEventTypeRemoteControl(2),
  UIEventTypePresses(3),
  UIEventTypeScroll(10),
  UIEventTypeHover(11),
  UIEventTypeTransform(14);

  final int value;
  const UIEventType(this.value);

  static UIEventType fromValue(int value) => switch (value) {
    0 => UIEventTypeTouches,
    1 => UIEventTypeMotion,
    2 => UIEventTypeRemoteControl,
    3 => UIEventTypePresses,
    10 => UIEventTypeScroll,
    11 => UIEventTypeHover,
    14 => UIEventTypeTransform,
    _ => throw ArgumentError('Unknown value for UIEventType: $value'),
  };
}

enum UIEventSubtype {
  UIEventSubtypeNone(0),
  UIEventSubtypeMotionShake(1),
  UIEventSubtypeRemoteControlPlay(100),
  UIEventSubtypeRemoteControlPause(101),
  UIEventSubtypeRemoteControlStop(102),
  UIEventSubtypeRemoteControlTogglePlayPause(103),
  UIEventSubtypeRemoteControlNextTrack(104),
  UIEventSubtypeRemoteControlPreviousTrack(105),
  UIEventSubtypeRemoteControlBeginSeekingBackward(106),
  UIEventSubtypeRemoteControlEndSeekingBackward(107),
  UIEventSubtypeRemoteControlBeginSeekingForward(108),
  UIEventSubtypeRemoteControlEndSeekingForward(109);

  final int value;
  const UIEventSubtype(this.value);

  static UIEventSubtype fromValue(int value) => switch (value) {
    0 => UIEventSubtypeNone,
    1 => UIEventSubtypeMotionShake,
    100 => UIEventSubtypeRemoteControlPlay,
    101 => UIEventSubtypeRemoteControlPause,
    102 => UIEventSubtypeRemoteControlStop,
    103 => UIEventSubtypeRemoteControlTogglePlayPause,
    104 => UIEventSubtypeRemoteControlNextTrack,
    105 => UIEventSubtypeRemoteControlPreviousTrack,
    106 => UIEventSubtypeRemoteControlBeginSeekingBackward,
    107 => UIEventSubtypeRemoteControlEndSeekingBackward,
    108 => UIEventSubtypeRemoteControlBeginSeekingForward,
    109 => UIEventSubtypeRemoteControlEndSeekingForward,
    _ => throw ArgumentError('Unknown value for UIEventSubtype: $value'),
  };
}

sealed class UIEventButtonMask {
  static const UIEventButtonMaskPrimary = 1;
  static const UIEventButtonMaskSecondary = 2;
}

/// WARNING: UIEvent is a stub. To generate bindings for this class, include
/// UIEvent in your config's objc-interfaces list.
///
/// UIEvent
extension type UIEvent._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [UIEvent] that points to the same underlying object as [other].
  UIEvent.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIEvent', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIEvent] that wraps the given raw object pointer.
  UIEvent.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIEvent', iOS: (false, (2, 0, 0)));
  }
}

/// WARNING: UIPasteConfigurationSupporting$1 is a stub. To generate bindings for this class, include
/// UIPasteConfigurationSupporting in your config's objc-protocols list.
///
/// UIPasteConfigurationSupporting
extension type UIPasteConfigurationSupporting$1._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIPasteConfigurationSupporting$1] that points to the same underlying object as [other].
  UIPasteConfigurationSupporting$1.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIPasteConfigurationSupporting$1] that wraps the given raw object pointer.
  UIPasteConfigurationSupporting$1.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// WARNING: UIUserActivityRestoring is a stub. To generate bindings for this class, include
/// UIUserActivityRestoring in your config's objc-protocols list.
///
/// UIUserActivityRestoring
extension type UIUserActivityRestoring._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIUserActivityRestoring] that points to the same underlying object as [other].
  UIUserActivityRestoring.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIUserActivityRestoring] that wraps the given raw object pointer.
  UIUserActivityRestoring.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// Construction methods for `objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>`.
abstract final class ObjCBlock_NSDictionary_NSDictionary {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>
  fromFunction(
    objc.NSDictionary Function(objc.NSDictionary) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        objc.NSDictionary.fromPointer(arg0, retain: true, release: true),
      ).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>`.
extension ObjCBlock_NSDictionary_NSDictionary$CallExtension
    on objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> {
  objc.NSDictionary call(objc.NSDictionary arg0) =>
      objc.NSDictionary.fromPointer(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<objc.ObjCObjectImpl> arg0,
                )
              >
            >()
            .asFunction<
              ffi.Pointer<objc.ObjCObjectImpl> Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObjectImpl>,
              )
            >()(ref.pointer, arg0.ref.pointer),
        retain: true,
        release: true,
      );
}

enum UIEditingInteractionConfiguration {
  UIEditingInteractionConfigurationNone(0),
  UIEditingInteractionConfigurationDefault(1);

  final int value;
  const UIEditingInteractionConfiguration(this.value);

  static UIEditingInteractionConfiguration fromValue(int value) =>
      switch (value) {
        0 => UIEditingInteractionConfigurationNone,
        1 => UIEditingInteractionConfigurationDefault,
        _ => throw ArgumentError(
          'Unknown value for UIEditingInteractionConfiguration: $value',
        ),
      };
}

/// WARNING: UIResponderStandardEditActions is a stub. To generate bindings for this class, include
/// UIResponderStandardEditActions in your config's objc-protocols list.
///
/// UIResponderStandardEditActions
extension type UIResponderStandardEditActions._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIResponderStandardEditActions] that points to the same underlying object as [other].
  UIResponderStandardEditActions.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIResponderStandardEditActions] that wraps the given raw object pointer.
  UIResponderStandardEditActions.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _class_UIResponder = objc.getClass("UIResponder");
late final _sel_nextResponder = objc.registerName("nextResponder");
late final _sel_canBecomeFirstResponder = objc.registerName(
  "canBecomeFirstResponder",
);
late final _sel_becomeFirstResponder = objc.registerName(
  "becomeFirstResponder",
);
late final _sel_canResignFirstResponder = objc.registerName(
  "canResignFirstResponder",
);
late final _sel_resignFirstResponder = objc.registerName(
  "resignFirstResponder",
);
late final _sel_isFirstResponder = objc.registerName("isFirstResponder");
late final _sel_touchesBegan_withEvent_ = objc.registerName(
  "touchesBegan:withEvent:",
);
final _objc_msgSend_pfv6jd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_touchesMoved_withEvent_ = objc.registerName(
  "touchesMoved:withEvent:",
);
late final _sel_touchesEnded_withEvent_ = objc.registerName(
  "touchesEnded:withEvent:",
);
late final _sel_touchesCancelled_withEvent_ = objc.registerName(
  "touchesCancelled:withEvent:",
);
late final _sel_touchesEstimatedPropertiesUpdated_ = objc.registerName(
  "touchesEstimatedPropertiesUpdated:",
);

/// WARNING: UIPressesEvent is a stub. To generate bindings for this class, include
/// UIPressesEvent in your config's objc-interfaces list.
///
/// UIPressesEvent
extension type UIPressesEvent._(objc.ObjCObject object$)
    implements objc.ObjCObject, UIEvent {
  /// Constructs a [UIPressesEvent] that points to the same underlying object as [other].
  UIPressesEvent.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIPressesEvent', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UIPressesEvent] that wraps the given raw object pointer.
  UIPressesEvent.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIPressesEvent', iOS: (false, (9, 0, 0)));
  }
}

late final _sel_pressesBegan_withEvent_ = objc.registerName(
  "pressesBegan:withEvent:",
);
late final _sel_pressesChanged_withEvent_ = objc.registerName(
  "pressesChanged:withEvent:",
);
late final _sel_pressesEnded_withEvent_ = objc.registerName(
  "pressesEnded:withEvent:",
);
late final _sel_pressesCancelled_withEvent_ = objc.registerName(
  "pressesCancelled:withEvent:",
);
late final _sel_motionBegan_withEvent_ = objc.registerName(
  "motionBegan:withEvent:",
);
final _objc_msgSend_pov02z = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_motionEnded_withEvent_ = objc.registerName(
  "motionEnded:withEvent:",
);
late final _sel_motionCancelled_withEvent_ = objc.registerName(
  "motionCancelled:withEvent:",
);
late final _sel_remoteControlReceivedWithEvent_ = objc.registerName(
  "remoteControlReceivedWithEvent:",
);
late final _sel_canPerformAction_withSender_ = objc.registerName(
  "canPerformAction:withSender:",
);
final _objc_msgSend_1f04296 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_targetForAction_withSender_ = objc.registerName(
  "targetForAction:withSender:",
);
final _objc_msgSend_gx50so = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// WARNING: UIMenuBuilder is a stub. To generate bindings for this class, include
/// UIMenuBuilder in your config's objc-protocols list.
///
/// UIMenuBuilder
extension type UIMenuBuilder._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol {
  /// Constructs a [UIMenuBuilder] that points to the same underlying object as [other].
  UIMenuBuilder.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIMenuBuilder] that wraps the given raw object pointer.
  UIMenuBuilder.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_buildMenuWithBuilder_ = objc.registerName(
  "buildMenuWithBuilder:",
);
late final _sel_validateCommand_ = objc.registerName("validateCommand:");

/// WARNING: UIDeferredMenuElementProvider is a stub. To generate bindings for this class, include
/// UIDeferredMenuElementProvider in your config's objc-interfaces list.
///
/// UIDeferredMenuElementProvider
extension type UIDeferredMenuElementProvider._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [UIDeferredMenuElementProvider] that points to the same underlying object as [other].
  UIDeferredMenuElementProvider.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UIDeferredMenuElementProvider',
      iOS: (false, (26, 0, 0)),
    );
  }

  /// Constructs a [UIDeferredMenuElementProvider] that wraps the given raw object pointer.
  UIDeferredMenuElementProvider.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UIDeferredMenuElementProvider',
      iOS: (false, (26, 0, 0)),
    );
  }
}

/// WARNING: UIDeferredMenuElement is a stub. To generate bindings for this class, include
/// UIDeferredMenuElement in your config's objc-interfaces list.
///
/// UIDeferredMenuElement
extension type UIDeferredMenuElement._(objc.ObjCObject object$)
    implements objc.ObjCObject, UIMenuElement {
  /// Constructs a [UIDeferredMenuElement] that points to the same underlying object as [other].
  UIDeferredMenuElement.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UIDeferredMenuElement',
      iOS: (false, (14, 0, 0)),
    );
  }

  /// Constructs a [UIDeferredMenuElement] that wraps the given raw object pointer.
  UIDeferredMenuElement.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UIDeferredMenuElement',
      iOS: (false, (14, 0, 0)),
    );
  }
}

late final _sel_providerForDeferredMenuElement_ = objc.registerName(
  "providerForDeferredMenuElement:",
);
late final _sel_undoManager = objc.registerName("undoManager");
late final _sel_editingInteractionConfiguration = objc.registerName(
  "editingInteractionConfiguration",
);
final _objc_msgSend_15pfzxv = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_cut_ = objc.registerName("cut:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>?,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>?,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObject?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>?,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                arg1.address == 0
                    ? null
                    : objc.ObjCObject(arg1, retain: true, release: true),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObject?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.ObjCObject(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObjectImpl>?,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObject?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.ObjCObject(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.ObjCObject(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObjectImpl>?,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>?,
          )
        > {
  void call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObject? arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_copy_ = objc.registerName("copy:");

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.Retained<ffi.Void> Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>?,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Void> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>?,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.Retained<ffi.Void> Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>?,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Void> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>?,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.Retained<ffi.Void> Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>?,
    )
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObject?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Void> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>?,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                arg1.address == 0
                    ? null
                    : objc.ObjCObject(arg1, retain: true, release: true),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.Retained<ffi.Void> Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>?,
    )
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObject?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.ObjCObject(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      objc.Retained<ffi.Void> Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObjectImpl>?,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    objc.Retained<ffi.Void> Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>?,
    )
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObject?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.ObjCObject(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.ObjCObject(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      objc.Retained<ffi.Void> Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObjectImpl>?,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl$1$CallExtension
    on
        objc.ObjCBlock<
          objc.Retained<ffi.Void> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>?,
          )
        > {
  void call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObject? arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_paste_ = objc.registerName("paste:");
late final _sel_pasteAndMatchStyle_ = objc.registerName("pasteAndMatchStyle:");
late final _sel_pasteAndGo_ = objc.registerName("pasteAndGo:");
late final _sel_pasteAndSearch_ = objc.registerName("pasteAndSearch:");
late final _sel_newFromPasteboard_ = objc.registerName("newFromPasteboard:");
late final _sel_select_ = objc.registerName("select:");
late final _sel_selectAll_ = objc.registerName("selectAll:");
late final _sel_delete_ = objc.registerName("delete:");
late final _sel_makeTextWritingDirectionLeftToRight_ = objc.registerName(
  "makeTextWritingDirectionLeftToRight:",
);
late final _sel_makeTextWritingDirectionRightToLeft_ = objc.registerName(
  "makeTextWritingDirectionRightToLeft:",
);
late final _sel_toggleBoldface_ = objc.registerName("toggleBoldface:");
late final _sel_toggleItalics_ = objc.registerName("toggleItalics:");
late final _sel_toggleUnderline_ = objc.registerName("toggleUnderline:");
late final _sel_increaseSize_ = objc.registerName("increaseSize:");
late final _sel_decreaseSize_ = objc.registerName("decreaseSize:");
late final _sel_alignLeft_ = objc.registerName("alignLeft:");
late final _sel_alignCenter_ = objc.registerName("alignCenter:");
late final _sel_alignJustified_ = objc.registerName("alignJustified:");
late final _sel_alignRight_ = objc.registerName("alignRight:");
late final _sel_find_ = objc.registerName("find:");
late final _sel_findAndReplace_ = objc.registerName("findAndReplace:");
late final _sel_findNext_ = objc.registerName("findNext:");
late final _sel_findPrevious_ = objc.registerName("findPrevious:");
late final _sel_useSelectionForFind_ = objc.registerName(
  "useSelectionForFind:",
);
late final _sel_updateTextAttributesWithConversionHandler_ = objc.registerName(
  "updateTextAttributesWithConversionHandler:",
);
final _objc_msgSend_f167m6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromFunction(
    void Function(objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSError.fromPointer(arg0, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> listener(
    void Function(objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSError.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> blocking(
    void Function(objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSError.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSError.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSError?)> {
  void call(objc.NSError? arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCBlockImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) =>
              fn(
                arg0,
                ObjCBlock_NSDictionary_NSDictionary.fromPointer(
                  arg1,
                  retain: true,
                  release: true,
                ),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) => fn(
        arg0,
        ObjCBlock_NSDictionary_NSDictionary.fromPointer(
          arg1,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1l4hxwm(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) => fn(
        arg0,
        ObjCBlock_NSDictionary_NSDictionary.fromPointer(
          arg1,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) => fn(
        arg0,
        ObjCBlock_NSDictionary_NSDictionary.fromPointer(
          arg1,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1l4hxwm(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCBlockImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCBlockImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCBlockImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCBlockImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCBlockImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> arg1,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCBlockImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_print_ = objc.registerName("print:");
late final _sel_rename_ = objc.registerName("rename:");
late final _sel_duplicate_ = objc.registerName("duplicate:");
late final _sel_move_ = objc.registerName("move:");
late final _sel_export_ = objc.registerName("export:");
late final _sel_toggleSidebar_ = objc.registerName("toggleSidebar:");
late final _sel_toggleInspector_ = objc.registerName("toggleInspector:");
late final _sel_performClose_ = objc.registerName("performClose:");
late final _sel_showWritingTools_ = objc.registerName("showWritingTools:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl$2 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObject) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(arg0, objc.ObjCObject(arg1, retain: true, release: true)),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObject) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, objc.ObjCObject(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObject) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, objc.ObjCObject(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, objc.ObjCObject(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl$2$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        > {
  void call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObject arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_keyCommands = objc.registerName("keyCommands");

/// UIResponderKeyCommands
extension UIResponderKeyCommands on UIResponder {
  /// keyCommands
  objc.NSArray? get keyCommands {
    objc.checkOsVersionInternal(
      'UIResponder.keyCommands',
      iOS: (false, (7, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_keyCommands);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
}

late final _class_UIView = objc.getClass("UIView");
late final _sel_layerClass = objc.registerName("layerClass");
late final _sel_initWithFrame_ = objc.registerName("initWithFrame:");
final _objc_msgSend_15yz4e6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
      )
    >();
late final _sel_isUserInteractionEnabled = objc.registerName(
  "isUserInteractionEnabled",
);
late final _sel_setUserInteractionEnabled_ = objc.registerName(
  "setUserInteractionEnabled:",
);
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
      )
    >();
late final _sel_tag = objc.registerName("tag");
final _objc_msgSend_1hz7y9r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setTag_ = objc.registerName("setTag:");
final _objc_msgSend_4sp4xj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_layer = objc.registerName("layer");
late final _sel_canBecomeFocused = objc.registerName("canBecomeFocused");
late final _sel_isFocused = objc.registerName("isFocused");
late final _sel_focusGroupIdentifier = objc.registerName(
  "focusGroupIdentifier",
);
late final _sel_setFocusGroupIdentifier_ = objc.registerName(
  "setFocusGroupIdentifier:",
);
late final _sel_focusGroupPriority = objc.registerName("focusGroupPriority");
late final _sel_setFocusGroupPriority_ = objc.registerName(
  "setFocusGroupPriority:",
);

/// WARNING: UIFocusEffect is a stub. To generate bindings for this class, include
/// UIFocusEffect in your config's objc-interfaces list.
///
/// UIFocusEffect
extension type UIFocusEffect._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [UIFocusEffect] that points to the same underlying object as [other].
  UIFocusEffect.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIFocusEffect', iOS: (false, (15, 0, 0)));
  }

  /// Constructs a [UIFocusEffect] that wraps the given raw object pointer.
  UIFocusEffect.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIFocusEffect', iOS: (false, (15, 0, 0)));
  }
}

late final _sel_focusEffect = objc.registerName("focusEffect");
late final _sel_setFocusEffect_ = objc.registerName("setFocusEffect:");

enum UISemanticContentAttribute {
  UISemanticContentAttributeUnspecified(0),
  UISemanticContentAttributePlayback(1),
  UISemanticContentAttributeSpatial(2),
  UISemanticContentAttributeForceLeftToRight(3),
  UISemanticContentAttributeForceRightToLeft(4);

  final int value;
  const UISemanticContentAttribute(this.value);

  static UISemanticContentAttribute fromValue(int value) => switch (value) {
    0 => UISemanticContentAttributeUnspecified,
    1 => UISemanticContentAttributePlayback,
    2 => UISemanticContentAttributeSpatial,
    3 => UISemanticContentAttributeForceLeftToRight,
    4 => UISemanticContentAttributeForceRightToLeft,
    _ => throw ArgumentError(
      'Unknown value for UISemanticContentAttribute: $value',
    ),
  };
}

late final _sel_semanticContentAttribute = objc.registerName(
  "semanticContentAttribute",
);
final _objc_msgSend_i2u4x4 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setSemanticContentAttribute_ = objc.registerName(
  "setSemanticContentAttribute:",
);
final _objc_msgSend_162qwxu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

enum UIUserInterfaceLayoutDirection {
  UIUserInterfaceLayoutDirectionLeftToRight(0),
  UIUserInterfaceLayoutDirectionRightToLeft(1);

  final int value;
  const UIUserInterfaceLayoutDirection(this.value);

  static UIUserInterfaceLayoutDirection fromValue(int value) => switch (value) {
    0 => UIUserInterfaceLayoutDirectionLeftToRight,
    1 => UIUserInterfaceLayoutDirectionRightToLeft,
    _ => throw ArgumentError(
      'Unknown value for UIUserInterfaceLayoutDirection: $value',
    ),
  };
}

late final _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_ = objc
    .registerName("userInterfaceLayoutDirectionForSemanticContentAttribute:");
final _objc_msgSend_racczx = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_ =
    objc.registerName(
      "userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:",
    );
final _objc_msgSend_tz4p54 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        int,
      )
    >();
late final _sel_effectiveUserInterfaceLayoutDirection = objc.registerName(
  "effectiveUserInterfaceLayoutDirection",
);
final _objc_msgSend_qj4fey = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_appearance = objc.registerName("appearance");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_objcObjCObjectImpl_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
  >
  fromFunction(
    objc.ObjCObject Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_objcObjCObjectImpl_ffiVoid$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
        > {
  objc.ObjCObject call(ffi.Pointer<ffi.Void> arg0) => objc.ObjCObject(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >()(ref.pointer, arg0),
    retain: true,
    release: true,
  );
}

/// WARNING: UIAppearanceContainer is a stub. To generate bindings for this class, include
/// UIAppearanceContainer in your config's objc-protocols list.
///
/// UIAppearanceContainer
extension type UIAppearanceContainer._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIAppearanceContainer] that points to the same underlying object as [other].
  UIAppearanceContainer.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIAppearanceContainer] that wraps the given raw object pointer.
  UIAppearanceContainer.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_appearanceWhenContainedIn_ = objc.registerName(
  "appearanceWhenContainedIn:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>?,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>?,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>?,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>?,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>?,
    )
  >
  fromFunction(
    Dartinstancetype Function(ffi.Pointer<ffi.Void>, UIAppearanceContainer?)
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>?,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                arg1.address == 0
                    ? null
                    : UIAppearanceContainer.fromPointer(
                        arg1,
                        retain: true,
                        release: true,
                      ),
              ).ref.retainAndAutorelease(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static instancetype _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          instancetype Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static instancetype _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as instancetype Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
extension ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>?,
          )
        > {
  Dartinstancetype call(
    ffi.Pointer<ffi.Void> arg0,
    UIAppearanceContainer? arg1,
  ) => objc.ObjCObject(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
              ffi.Pointer<objc.ObjCObjectImpl> arg1,
            )
          >
        >()
        .asFunction<
          instancetype Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr),
    retain: true,
    release: true,
  );
}

late final _sel_appearanceWhenContainedInInstancesOfClasses_ = objc
    .registerName("appearanceWhenContainedInInstancesOfClasses:");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(
      ffi.Pointer<ffi.Void>,
      objc.NSArray,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSArray,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(
      ffi.Pointer<ffi.Void>,
      objc.NSArray,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSArray,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(
      ffi.Pointer<ffi.Void>,
      objc.NSArray,
    )
  >
  fromFunction(
    Dartinstancetype Function(ffi.Pointer<ffi.Void>, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSArray,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                objc.NSArray.fromPointer(arg1, retain: true, release: true),
              ).ref.retainAndAutorelease(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static instancetype _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          instancetype Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static instancetype _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as instancetype Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
extension ObjCBlock_instancetype_ffiVoid_NSArray$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void>,
            objc.NSArray,
          )
        > {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, objc.NSArray arg1) =>
      objc.ObjCObject(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0,
                  ffi.Pointer<objc.ObjCObjectImpl> arg1,
                )
              >
            >()
            .asFunction<
              instancetype Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObjectImpl>,
              )
            >()(ref.pointer, arg0, arg1.ref.pointer),
        retain: true,
        release: true,
      );
}

/// WARNING: UITraitCollection is a stub. To generate bindings for this class, include
/// UITraitCollection in your config's objc-interfaces list.
///
/// UITraitCollection
extension type UITraitCollection._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSCopying,
        objc.NSSecureCoding {
  /// Constructs a [UITraitCollection] that points to the same underlying object as [other].
  UITraitCollection.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UITraitCollection', iOS: (false, (8, 0, 0)));
  }

  /// Constructs a [UITraitCollection] that wraps the given raw object pointer.
  UITraitCollection.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITraitCollection', iOS: (false, (8, 0, 0)));
  }
}

late final _sel_appearanceForTraitCollection_ = objc.registerName(
  "appearanceForTraitCollection:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_UITraitCollection {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(
      ffi.Pointer<ffi.Void>,
      UITraitCollection,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          UITraitCollection,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(
      ffi.Pointer<ffi.Void>,
      UITraitCollection,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          UITraitCollection,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(
      ffi.Pointer<ffi.Void>,
      UITraitCollection,
    )
  >
  fromFunction(
    Dartinstancetype Function(ffi.Pointer<ffi.Void>, UITraitCollection) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          UITraitCollection,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                UITraitCollection.fromPointer(
                  arg1,
                  retain: true,
                  release: true,
                ),
              ).ref.retainAndAutorelease(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static instancetype _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          instancetype Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static instancetype _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as instancetype Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>`.
extension ObjCBlock_instancetype_ffiVoid_UITraitCollection$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void>,
            UITraitCollection,
          )
        > {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, UITraitCollection arg1) =>
      objc.ObjCObject(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0,
                  ffi.Pointer<objc.ObjCObjectImpl> arg1,
                )
              >
            >()
            .asFunction<
              instancetype Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObjectImpl>,
              )
            >()(ref.pointer, arg0, arg1.ref.pointer),
        retain: true,
        release: true,
      );
}

late final _sel_appearanceForTraitCollection_whenContainedIn_ = objc
    .registerName("appearanceForTraitCollection:whenContainedIn:");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(
      ffi.Pointer<ffi.Void>,
      UITraitCollection,
      ffi.Pointer<objc.ObjCObjectImpl>?,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          UITraitCollection,
          ffi.Pointer<objc.ObjCObjectImpl>?,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(
      ffi.Pointer<ffi.Void>,
      UITraitCollection,
      ffi.Pointer<objc.ObjCObjectImpl>?,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          UITraitCollection,
          ffi.Pointer<objc.ObjCObjectImpl>?,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(
      ffi.Pointer<ffi.Void>,
      UITraitCollection,
      ffi.Pointer<objc.ObjCObjectImpl>?,
    )
  >
  fromFunction(
    Dartinstancetype Function(
      ffi.Pointer<ffi.Void>,
      UITraitCollection,
      UIAppearanceContainer?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          UITraitCollection,
          ffi.Pointer<objc.ObjCObjectImpl>?,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0,
            UITraitCollection.fromPointer(arg1, retain: true, release: true),
            arg2.address == 0
                ? null
                : UIAppearanceContainer.fromPointer(
                    arg2,
                    retain: true,
                    release: true,
                  ),
          ).ref.retainAndAutorelease(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static instancetype _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          instancetype Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static instancetype _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as instancetype Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
extension ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void>,
            UITraitCollection,
            ffi.Pointer<objc.ObjCObjectImpl>?,
          )
        > {
  Dartinstancetype call(
    ffi.Pointer<ffi.Void> arg0,
    UITraitCollection arg1,
    UIAppearanceContainer? arg2,
  ) => objc.ObjCObject(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
              ffi.Pointer<objc.ObjCObjectImpl> arg1,
              ffi.Pointer<objc.ObjCObjectImpl> arg2,
            )
          >
        >()
        .asFunction<
          instancetype Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >()(
      ref.pointer,
      arg0,
      arg1.ref.pointer,
      arg2?.ref.pointer ?? ffi.nullptr,
    ),
    retain: true,
    release: true,
  );
}

late final _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_ =
    objc.registerName(
      "appearanceForTraitCollection:whenContainedInInstancesOfClasses:",
    );

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(
      ffi.Pointer<ffi.Void>,
      UITraitCollection,
      objc.NSArray,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          UITraitCollection,
          objc.NSArray,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(
      ffi.Pointer<ffi.Void>,
      UITraitCollection,
      objc.NSArray,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          UITraitCollection,
          objc.NSArray,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(
      ffi.Pointer<ffi.Void>,
      UITraitCollection,
      objc.NSArray,
    )
  >
  fromFunction(
    Dartinstancetype Function(
      ffi.Pointer<ffi.Void>,
      UITraitCollection,
      objc.NSArray,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          UITraitCollection,
          objc.NSArray,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0,
            UITraitCollection.fromPointer(arg1, retain: true, release: true),
            objc.NSArray.fromPointer(arg2, retain: true, release: true),
          ).ref.retainAndAutorelease(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static instancetype _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          instancetype Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static instancetype _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as instancetype Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>`.
extension ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void>,
            UITraitCollection,
            objc.NSArray,
          )
        > {
  Dartinstancetype call(
    ffi.Pointer<ffi.Void> arg0,
    UITraitCollection arg1,
    objc.NSArray arg2,
  ) => objc.ObjCObject(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
              ffi.Pointer<objc.ObjCObjectImpl> arg1,
              ffi.Pointer<objc.ObjCObjectImpl> arg2,
            )
          >
        >()
        .asFunction<
          instancetype Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer),
    retain: true,
    release: true,
  );
}

late final _sel_center = objc.registerName("center");
final _objc_msgSend_1uwdhlk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGPoint Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      objc.CGPoint Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1uwdhlkStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGPoint>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGPoint>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_CGPoint_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    objc.CGPoint Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static objc.CGPoint _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<ffi.Void> arg0)>
      >()
      .asFunction<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            objc.CGPoint Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static objc.CGPoint _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as objc.CGPoint Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            objc.CGPoint Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_CGPoint_ffiVoid$CallExtension
    on objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)> {
  objc.CGPoint call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          objc.CGPoint Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        objc.CGPoint Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
        )
      >()(ref.pointer, arg0);
}

late final _sel_setCenter_ = objc.registerName("setCenter:");
final _objc_msgSend_iy8iz6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CGPoint {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.CGPoint) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.CGPoint) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1bktu2(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.CGPoint) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1bktu2(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGPoint arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.Void>, objc.CGPoint))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      objc.CGPoint,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            objc.CGPoint,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGPoint arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, objc.CGPoint))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      objc.CGPoint,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            objc.CGPoint,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      objc.CGPoint,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            objc.CGPoint,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGPoint arg1,
  ) =>
      block.ref.target
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1)
            >
          >()
          .asFunction<void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>()(
        arg0,
        arg1,
      );
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGPoint,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGPoint arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, objc.CGPoint))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGPoint,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CGPoint$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.CGPoint arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          objc.CGPoint,
        )
      >()(ref.pointer, arg0, arg1);
}

late final _sel_bounds = objc.registerName("bounds");
final _objc_msgSend_bu1hbw = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_bu1hbwStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_CGRect_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    objc.CGRect Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static objc.CGRect _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<ffi.Void> arg0)>
      >()
      .asFunction<objc.CGRect Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            objc.CGRect Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static objc.CGRect _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as objc.CGRect Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            objc.CGRect Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_CGRect_ffiVoid$CallExtension
    on objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)> {
  objc.CGRect call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          objc.CGRect Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
        )
      >()(ref.pointer, arg0);
}

late final _sel_transform = objc.registerName("transform");
final _objc_msgSend_5qswvj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        CGAffineTransform Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      CGAffineTransform Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_5qswvjStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<CGAffineTransform>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<CGAffineTransform>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_CGAffineTransform_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<CGAffineTransform Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    CGAffineTransform Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static CGAffineTransform _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          CGAffineTransform Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            CGAffineTransform Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static CGAffineTransform _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as CGAffineTransform Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            CGAffineTransform Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_CGAffineTransform_ffiVoid$CallExtension
    on objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)> {
  CGAffineTransform call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          CGAffineTransform Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        CGAffineTransform Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
        )
      >()(ref.pointer, arg0);
}

late final _sel_setTransform_ = objc.registerName("setTransform:");
final _objc_msgSend_qgt66z = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          CGAffineTransform,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        CGAffineTransform,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, CGAffineTransform) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) =>
              fn(arg0, arg1),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, CGAffineTransform) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1lznlw3(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, CGAffineTransform) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1lznlw3(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    CGAffineTransform arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.Void>, CGAffineTransform))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      CGAffineTransform,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            CGAffineTransform,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    CGAffineTransform arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, CGAffineTransform))(
        arg0,
        arg1,
      );
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      CGAffineTransform,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            CGAffineTransform,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      CGAffineTransform,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            CGAffineTransform,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    CGAffineTransform arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1)
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              CGAffineTransform,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    CGAffineTransform arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, CGAffineTransform))(
        arg0,
        arg1,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              CGAffineTransform,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            CGAffineTransform arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          CGAffineTransform,
        )
      >()(ref.pointer, arg0, arg1);
}

enum UIDynamicItemCollisionBoundsType {
  UIDynamicItemCollisionBoundsTypeRectangle(0),
  UIDynamicItemCollisionBoundsTypeEllipse(1),
  UIDynamicItemCollisionBoundsTypePath(2);

  final int value;
  const UIDynamicItemCollisionBoundsType(this.value);

  static UIDynamicItemCollisionBoundsType fromValue(int value) =>
      switch (value) {
        0 => UIDynamicItemCollisionBoundsTypeRectangle,
        1 => UIDynamicItemCollisionBoundsTypeEllipse,
        2 => UIDynamicItemCollisionBoundsTypePath,
        _ => throw ArgumentError(
          'Unknown value for UIDynamicItemCollisionBoundsType: $value',
        ),
      };
}

late final _sel_collisionBoundsType = objc.registerName("collisionBoundsType");
final _objc_msgSend_k9iunc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    UIDynamicItemCollisionBoundsType Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).value,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static int _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.UnsignedLong Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline, 0)
          .cast();
  static int _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.UnsignedLong Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline, 0)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> {
  UIDynamicItemCollisionBoundsType call(ffi.Pointer<ffi.Void> arg0) =>
      UIDynamicItemCollisionBoundsType.fromValue(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                ffi.UnsignedLong Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0,
                )
              >
            >()
            .asFunction<
              int Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
              )
            >()(ref.pointer, arg0),
      );
}

late final _sel_collisionBoundingPath = objc.registerName(
  "collisionBoundingPath",
);

/// Construction methods for `objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIBezierPath_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    UIBezierPath Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIBezierPath_ffiVoid$CallExtension
    on objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)> {
  UIBezierPath call(ffi.Pointer<ffi.Void> arg0) => UIBezierPath.fromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >()(ref.pointer, arg0),
    retain: true,
    release: true,
  );
}

late final _sel_traitCollection = objc.registerName("traitCollection");

/// Construction methods for `objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UITraitCollection_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    UITraitCollection Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UITraitCollection_ffiVoid$CallExtension
    on objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)> {
  UITraitCollection call(ffi.Pointer<ffi.Void> arg0) =>
      UITraitCollection.fromPointer(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0,
                )
              >
            >()
            .asFunction<
              ffi.Pointer<objc.ObjCObjectImpl> Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
              )
            >()(ref.pointer, arg0),
        retain: true,
        release: true,
      );
}

late final _sel_traitCollectionDidChange_ = objc.registerName(
  "traitCollectionDidChange:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UITraitCollection {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, UITraitCollection?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                arg1.address == 0
                    ? null
                    : UITraitCollection.fromPointer(
                        arg1,
                        retain: true,
                        release: true,
                      ),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, UITraitCollection?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : UITraitCollection.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, UITraitCollection?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : UITraitCollection.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : UITraitCollection.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, UITraitCollection? arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

/// WARNING: UICoordinateSpace is a stub. To generate bindings for this class, include
/// UICoordinateSpace in your config's objc-protocols list.
///
/// UICoordinateSpace
extension type UICoordinateSpace._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UICoordinateSpace] that points to the same underlying object as [other].
  UICoordinateSpace.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UICoordinateSpace] that wraps the given raw object pointer.
  UICoordinateSpace.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_convertPoint_toCoordinateSpace_ = objc.registerName(
  "convertPoint:toCoordinateSpace:",
);
final _objc_msgSend_3l1tu1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGPoint Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      objc.CGPoint Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
final _objc_msgSend_3l1tu1Stret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGPoint>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGPoint>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObjectImpl>)>`.
abstract final class ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.CGPoint Function(
      ffi.Pointer<ffi.Void>,
      objc.CGPoint,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        objc.CGPoint Function(
          ffi.Pointer<ffi.Void>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.CGPoint Function(
      ffi.Pointer<ffi.Void>,
      objc.CGPoint,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        objc.CGPoint Function(
          ffi.Pointer<ffi.Void> arg0,
          objc.CGPoint arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.CGPoint Function(
          ffi.Pointer<ffi.Void>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.CGPoint Function(
      ffi.Pointer<ffi.Void>,
      objc.CGPoint,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  fromFunction(
    objc.CGPoint Function(
      ffi.Pointer<ffi.Void>,
      objc.CGPoint,
      UICoordinateSpace,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.CGPoint Function(
          ffi.Pointer<ffi.Void>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            objc.CGPoint arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0,
            arg1,
            UICoordinateSpace.fromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static objc.CGPoint _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGPoint arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          objc.CGPoint Function(
            ffi.Pointer<ffi.Void> arg0,
            objc.CGPoint arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        objc.CGPoint Function(
          ffi.Pointer<ffi.Void>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            objc.CGPoint Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGPoint,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static objc.CGPoint _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGPoint arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as objc.CGPoint Function(
            ffi.Pointer<ffi.Void>,
            objc.CGPoint,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            objc.CGPoint Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGPoint,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObjectImpl>)>`.
extension ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace$CallExtension
    on
        objc.ObjCBlock<
          objc.CGPoint Function(
            ffi.Pointer<ffi.Void>,
            objc.CGPoint,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        > {
  objc.CGPoint call(
    ffi.Pointer<ffi.Void> arg0,
    objc.CGPoint arg1,
    UICoordinateSpace arg2,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          objc.CGPoint Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.CGPoint arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        objc.CGPoint Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1, arg2.ref.pointer);
}

late final _sel_convertPoint_fromCoordinateSpace_ = objc.registerName(
  "convertPoint:fromCoordinateSpace:",
);
late final _sel_convertRect_toCoordinateSpace_ = objc.registerName(
  "convertRect:toCoordinateSpace:",
);
final _objc_msgSend_2olghr = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
final _objc_msgSend_2olghrStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObjectImpl>)>`.
abstract final class ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.CGRect Function(
      ffi.Pointer<ffi.Void>,
      objc.CGRect,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        objc.CGRect Function(
          ffi.Pointer<ffi.Void>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.CGRect Function(
      ffi.Pointer<ffi.Void>,
      objc.CGRect,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<ffi.Void> arg0,
          objc.CGRect arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.CGRect Function(
          ffi.Pointer<ffi.Void>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.CGRect Function(
      ffi.Pointer<ffi.Void>,
      objc.CGRect,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  fromFunction(
    objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, UICoordinateSpace)
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.CGRect Function(
          ffi.Pointer<ffi.Void>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            objc.CGRect arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0,
            arg1,
            UICoordinateSpace.fromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static objc.CGRect _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGRect arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          objc.CGRect Function(
            ffi.Pointer<ffi.Void> arg0,
            objc.CGRect arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        objc.CGRect Function(
          ffi.Pointer<ffi.Void>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            objc.CGRect Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGRect,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static objc.CGRect _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGRect arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as objc.CGRect Function(
            ffi.Pointer<ffi.Void>,
            objc.CGRect,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            objc.CGRect Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGRect,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObjectImpl>)>`.
extension ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace$CallExtension
    on
        objc.ObjCBlock<
          objc.CGRect Function(
            ffi.Pointer<ffi.Void>,
            objc.CGRect,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        > {
  objc.CGRect call(
    ffi.Pointer<ffi.Void> arg0,
    objc.CGRect arg1,
    UICoordinateSpace arg2,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          objc.CGRect Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.CGRect arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1, arg2.ref.pointer);
}

late final _sel_convertRect_fromCoordinateSpace_ = objc.registerName(
  "convertRect:fromCoordinateSpace:",
);
late final _sel_frame = objc.registerName("frame");

enum UIFocusItemDeferralMode {
  UIFocusItemDeferralModeAutomatic(0),
  UIFocusItemDeferralModeAlways(1),
  UIFocusItemDeferralModeNever(2);

  final int value;
  const UIFocusItemDeferralMode(this.value);

  static UIFocusItemDeferralMode fromValue(int value) => switch (value) {
    0 => UIFocusItemDeferralModeAutomatic,
    1 => UIFocusItemDeferralModeAlways,
    2 => UIFocusItemDeferralModeNever,
    _ => throw ArgumentError(
      'Unknown value for UIFocusItemDeferralMode: $value',
    ),
  };
}

late final _sel_focusItemDeferralMode = objc.registerName(
  "focusItemDeferralMode",
);
final _objc_msgSend_1lv2zxu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIFocusItemDeferralMode_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromFunction(
    UIFocusItemDeferralMode Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).value,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static int _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline, 0)
          .cast();
  static int _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline, 0)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIFocusItemDeferralMode_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> {
  UIFocusItemDeferralMode call(ffi.Pointer<ffi.Void> arg0) =>
      UIFocusItemDeferralMode.fromValue(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                ffi.Long Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0,
                )
              >
            >()
            .asFunction<
              int Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
              )
            >()(ref.pointer, arg0),
      );
}

late final _sel_isTransparentFocusItem = objc.registerName(
  "isTransparentFocusItem",
);

/// WARNING: UIFocusMovementHint is a stub. To generate bindings for this class, include
/// UIFocusMovementHint in your config's objc-interfaces list.
///
/// UIFocusMovementHint
extension type UIFocusMovementHint._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [UIFocusMovementHint] that points to the same underlying object as [other].
  UIFocusMovementHint.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UIFocusMovementHint',
      iOS: (false, (12, 0, 0)),
    );
  }

  /// Constructs a [UIFocusMovementHint] that wraps the given raw object pointer.
  UIFocusMovementHint.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UIFocusMovementHint',
      iOS: (false, (12, 0, 0)),
    );
  }
}

late final _sel_didHintFocusMovement_ = objc.registerName(
  "didHintFocusMovement:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                UIFocusMovementHint.fromPointer(
                  arg1,
                  retain: true,
                  release: true,
                ),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        UIFocusMovementHint.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        UIFocusMovementHint.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        UIFocusMovementHint.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, UIFocusMovementHint arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_preferredFocusEnvironments = objc.registerName(
  "preferredFocusEnvironments",
);

/// Construction methods for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSArray_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    objc.NSArray Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSArray_ffiVoid$CallExtension
    on objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> {
  objc.NSArray call(ffi.Pointer<ffi.Void> arg0) => objc.NSArray.fromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >()(ref.pointer, arg0),
    retain: true,
    release: true,
  );
}

/// WARNING: UIFocusEnvironment is a stub. To generate bindings for this class, include
/// UIFocusEnvironment in your config's objc-protocols list.
///
/// UIFocusEnvironment
extension type UIFocusEnvironment._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIFocusEnvironment] that points to the same underlying object as [other].
  UIFocusEnvironment.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIFocusEnvironment] that wraps the given raw object pointer.
  UIFocusEnvironment.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_parentFocusEnvironment = objc.registerName(
  "parentFocusEnvironment",
);

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUIFocusEnvironment_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
  >
  fromFunction(
    UIFocusEnvironment? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0) =>
              fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUIFocusEnvironment_ffiVoid$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
        > {
  UIFocusEnvironment? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIFocusEnvironment.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

/// WARNING: UIFocusItemContainer is a stub. To generate bindings for this class, include
/// UIFocusItemContainer in your config's objc-protocols list.
///
/// UIFocusItemContainer
extension type UIFocusItemContainer._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIFocusItemContainer] that points to the same underlying object as [other].
  UIFocusItemContainer.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIFocusItemContainer] that wraps the given raw object pointer.
  UIFocusItemContainer.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_focusItemContainer = objc.registerName("focusItemContainer");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUIFocusItemContainer_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
  >
  fromFunction(
    UIFocusItemContainer? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0) =>
              fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUIFocusItemContainer_ffiVoid$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
        > {
  UIFocusItemContainer? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIFocusItemContainer.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_setNeedsFocusUpdate = objc.registerName("setNeedsFocusUpdate");
final _objc_msgSend_1pl9qdv = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> listener(
    void Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_ovsamd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> blocking(
    void Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_ovsamd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_ffiVoid_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> {
  void call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
      >()(ref.pointer, arg0);
}

late final _sel_updateFocusIfNeeded = objc.registerName("updateFocusIfNeeded");

/// WARNING: UIFocusUpdateContext is a stub. To generate bindings for this class, include
/// UIFocusUpdateContext in your config's objc-interfaces list.
///
/// UIFocusUpdateContext
extension type UIFocusUpdateContext._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [UIFocusUpdateContext] that points to the same underlying object as [other].
  UIFocusUpdateContext.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UIFocusUpdateContext',
      iOS: (false, (9, 0, 0)),
    );
  }

  /// Constructs a [UIFocusUpdateContext] that wraps the given raw object pointer.
  UIFocusUpdateContext.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UIFocusUpdateContext',
      iOS: (false, (9, 0, 0)),
    );
  }
}

late final _sel_shouldUpdateFocusInContext_ = objc.registerName(
  "shouldUpdateFocusInContext:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>`.
abstract final class ObjCBlock_bool_ffiVoid_UIFocusUpdateContext {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)
  >
  fromFunction(
    bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                UIFocusUpdateContext.fromPointer(
                  arg1,
                  retain: true,
                  release: true,
                ),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as bool Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>`.
extension ObjCBlock_bool_ffiVoid_UIFocusUpdateContext$CallExtension
    on
        objc.ObjCBlock<
          ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)
        > {
  bool call(ffi.Pointer<ffi.Void> arg0, UIFocusUpdateContext arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// WARNING: UIFocusAnimationCoordinator is a stub. To generate bindings for this class, include
/// UIFocusAnimationCoordinator in your config's objc-interfaces list.
///
/// UIFocusAnimationCoordinator
extension type UIFocusAnimationCoordinator._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [UIFocusAnimationCoordinator] that points to the same underlying object as [other].
  UIFocusAnimationCoordinator.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UIFocusAnimationCoordinator',
      iOS: (false, (9, 0, 0)),
    );
  }

  /// Constructs a [UIFocusAnimationCoordinator] that wraps the given raw object pointer.
  UIFocusAnimationCoordinator.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UIFocusAnimationCoordinator',
      iOS: (false, (9, 0, 0)),
    );
  }
}

late final _sel_didUpdateFocusInContext_withAnimationCoordinator_ = objc
    .registerName("didUpdateFocusInContext:withAnimationCoordinator:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      UIFocusUpdateContext,
      UIFocusAnimationCoordinator,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          UIFocusUpdateContext,
          UIFocusAnimationCoordinator,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      UIFocusUpdateContext,
      UIFocusAnimationCoordinator,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          UIFocusUpdateContext,
          UIFocusAnimationCoordinator,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      UIFocusUpdateContext,
      UIFocusAnimationCoordinator,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      UIFocusUpdateContext,
      UIFocusAnimationCoordinator,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          UIFocusUpdateContext,
          UIFocusAnimationCoordinator,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0,
            UIFocusUpdateContext.fromPointer(arg1, retain: true, release: true),
            UIFocusAnimationCoordinator.fromPointer(
              arg2,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      UIFocusUpdateContext,
      UIFocusAnimationCoordinator,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      UIFocusUpdateContext,
      UIFocusAnimationCoordinator,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        UIFocusUpdateContext.fromPointer(arg1, retain: false, release: true),
        UIFocusAnimationCoordinator.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        UIFocusUpdateContext,
        UIFocusAnimationCoordinator,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      UIFocusUpdateContext,
      UIFocusAnimationCoordinator,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      UIFocusUpdateContext,
      UIFocusAnimationCoordinator,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        UIFocusUpdateContext.fromPointer(arg1, retain: false, release: true),
        UIFocusAnimationCoordinator.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        UIFocusUpdateContext.fromPointer(arg1, retain: false, release: true),
        UIFocusAnimationCoordinator.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_fjrv01(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        UIFocusUpdateContext,
        UIFocusAnimationCoordinator,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            UIFocusUpdateContext,
            UIFocusAnimationCoordinator,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    UIFocusUpdateContext arg1,
    UIFocusAnimationCoordinator arg2,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_soundIdentifierForFocusUpdateInContext_ = objc.registerName(
  "soundIdentifierForFocusUpdateInContext:",
);

/// Construction methods for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>`.
abstract final class ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)
  >
  fromFunction(
    objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                UIFocusUpdateContext.fromPointer(
                  arg1,
                  retain: true,
                  release: true,
                ),
              )?.ref.retainAndAutorelease() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>`.
extension ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext$CallExtension
    on
        objc.ObjCBlock<
          objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)
        > {
  objc.NSString? call(ffi.Pointer<ffi.Void> arg0, UIFocusUpdateContext arg1) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer)
              .address ==
          0
      ? null
      : objc.NSString.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer),
          retain: true,
          release: true,
        );
}

late final _sel_preferredFocusedView = objc.registerName(
  "preferredFocusedView",
);

/// Construction methods for `objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIView_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)> fromFunction(
    UIView? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) =>
          fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIView_ffiVoid$CallExtension
    on objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)> {
  UIView? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIView.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_coordinateSpace = objc.registerName("coordinateSpace");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUICoordinateSpace_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
  >
  fromFunction(
    UICoordinateSpace Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUICoordinateSpace_ffiVoid$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
        > {
  UICoordinateSpace call(ffi.Pointer<ffi.Void> arg0) =>
      UICoordinateSpace.fromPointer(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0,
                )
              >
            >()
            .asFunction<
              ffi.Pointer<objc.ObjCObjectImpl> Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
              )
            >()(ref.pointer, arg0),
        retain: true,
        release: true,
      );
}

late final _sel_focusItemsInRect_ = objc.registerName("focusItemsInRect:");

/// Construction methods for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>`.
abstract final class ObjCBlock_NSArray_ffiVoid_CGRect {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void> arg0,
          objc.CGRect arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)
  >
  fromFunction(
    objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1) =>
              fn(arg0, arg1).ref.retainAndAutorelease(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGRect arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void> arg0,
            objc.CGRect arg1,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          objc.CGRect,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGRect,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGRect arg1,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void>,
            objc.CGRect,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGRect,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>`.
extension ObjCBlock_NSArray_ffiVoid_CGRect$CallExtension
    on
        objc.ObjCBlock<
          objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)
        > {
  objc.NSArray call(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1) =>
      objc.NSArray.fromPointer(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0,
                  objc.CGRect arg1,
                )
              >
            >()
            .asFunction<
              ffi.Pointer<objc.ObjCObjectImpl> Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                objc.CGRect,
              )
            >()(ref.pointer, arg0, arg1),
        retain: true,
        release: true,
      );
}

late final _sel_displayLayer_ = objc.registerName("displayLayer:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CALayer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, CALayer) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, CALayer.fromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, CALayer) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, CALayer.fromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, CALayer) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, CALayer.fromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, CALayer.fromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CALayer$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)> {
  void call(ffi.Pointer<ffi.Void> arg0, CALayer arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_drawLayer_inContext_ = objc.registerName(
  "drawLayer:inContext:",
);
final _objc_msgSend_a4xp11 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<CGContext>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<CGContext>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CALayer,
          ffi.Pointer<CGContext>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<CGContext> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CALayer,
          ffi.Pointer<CGContext>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CALayer,
          ffi.Pointer<CGContext>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<CGContext> arg2,
          ) => fn(
            arg0,
            CALayer.fromPointer(arg1, retain: true, release: true),
            arg2,
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<CGContext> arg2,
      ) => fn(
        arg0,
        CALayer.fromPointer(arg1, retain: false, release: true),
        arg2,
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_qvcerx(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<CGContext> arg2,
      ) => fn(
        arg0,
        CALayer.fromPointer(arg1, retain: false, release: true),
        arg2,
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<CGContext> arg2,
      ) => fn(
        arg0,
        CALayer.fromPointer(arg1, retain: false, release: true),
        arg2,
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_qvcerx(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<CGContext> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<CGContext>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<CGContext>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<CGContext>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<CGContext> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<CGContext>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<CGContext>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<CGContext>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<CGContext>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<CGContext>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<CGContext> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<CGContext> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<CGContext>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<CGContext>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<CGContext> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<CGContext>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<CGContext>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            CALayer,
            ffi.Pointer<CGContext>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    CALayer arg1,
    ffi.Pointer<CGContext> arg2,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<CGContext> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<CGContext>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2);
}

late final _sel_layerWillDraw_ = objc.registerName("layerWillDraw:");
late final _sel_layoutSublayersOfLayer_ = objc.registerName(
  "layoutSublayersOfLayer:",
);
late final _sel_actionForLayer_forKey_ = objc.registerName(
  "actionForLayer:forKey:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>`.
abstract final class ObjCBlock_idCAAction_ffiVoid_CALayer_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(
      ffi.Pointer<ffi.Void>,
      CALayer,
      objc.NSString,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(
          ffi.Pointer<ffi.Void>,
          CALayer,
          objc.NSString,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(
      ffi.Pointer<ffi.Void>,
      CALayer,
      objc.NSString,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(
          ffi.Pointer<ffi.Void>,
          CALayer,
          objc.NSString,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(
      ffi.Pointer<ffi.Void>,
      CALayer,
      objc.NSString,
    )
  >
  fromFunction(
    CAAction? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(
          ffi.Pointer<ffi.Void>,
          CALayer,
          objc.NSString,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) =>
              fn(
                arg0,
                CALayer.fromPointer(arg1, retain: true, release: true),
                objc.NSString.fromPointer(arg2, retain: true, release: true),
              )?.ref.retainAndAutorelease() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>`.
extension ObjCBlock_idCAAction_ffiVoid_CALayer_NSString$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObjectImpl>? Function(
            ffi.Pointer<ffi.Void>,
            CALayer,
            objc.NSString,
          )
        > {
  CAAction? call(
    ffi.Pointer<ffi.Void> arg0,
    CALayer arg1,
    objc.NSString arg2,
  ) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                    ffi.Pointer<objc.ObjCObjectImpl> arg2,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer)
              .address ==
          0
      ? null
      : CAAction.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                    ffi.Pointer<objc.ObjCObjectImpl> arg2,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer),
          retain: true,
          release: true,
        );
}

/// WARNING: UITraitOverrides is a stub. To generate bindings for this class, include
/// UITraitOverrides in your config's objc-protocols list.
///
/// UITraitOverrides
extension type UITraitOverrides._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, UIMutableTraits {
  /// Constructs a [UITraitOverrides] that points to the same underlying object as [other].
  UITraitOverrides.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UITraitOverrides] that wraps the given raw object pointer.
  UITraitOverrides.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_traitOverrides = objc.registerName("traitOverrides");
late final _sel_updateTraitsIfNeeded = objc.registerName(
  "updateTraitsIfNeeded",
);
late final _sel_setFrame_ = objc.registerName("setFrame:");
final _objc_msgSend_1okkq16 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
      )
    >();
late final _sel_setBounds_ = objc.registerName("setBounds:");
late final _sel_transform3D = objc.registerName("transform3D");
final _objc_msgSend_5qlg3j = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        CATransform3D Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      CATransform3D Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_5qlg3jStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<CATransform3D>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<CATransform3D>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setTransform3D_ = objc.registerName("setTransform3D:");
final _objc_msgSend_1s50tpz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          CATransform3D,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        CATransform3D,
      )
    >();
late final _sel_contentScaleFactor = objc.registerName("contentScaleFactor");
late final _sel_setContentScaleFactor_ = objc.registerName(
  "setContentScaleFactor:",
);
final _objc_msgSend_hwm8nu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
      )
    >();
late final _sel_anchorPoint = objc.registerName("anchorPoint");
late final _sel_setAnchorPoint_ = objc.registerName("setAnchorPoint:");
late final _sel_isMultipleTouchEnabled = objc.registerName(
  "isMultipleTouchEnabled",
);
late final _sel_setMultipleTouchEnabled_ = objc.registerName(
  "setMultipleTouchEnabled:",
);
late final _sel_isExclusiveTouch = objc.registerName("isExclusiveTouch");
late final _sel_setExclusiveTouch_ = objc.registerName("setExclusiveTouch:");
late final _sel_hitTest_withEvent_ = objc.registerName("hitTest:withEvent:");
final _objc_msgSend_u7nfz8 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_pointInside_withEvent_ = objc.registerName(
  "pointInside:withEvent:",
);
final _objc_msgSend_yvwe5y = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_convertPoint_toView_ = objc.registerName(
  "convertPoint:toView:",
);
late final _sel_convertPoint_fromView_ = objc.registerName(
  "convertPoint:fromView:",
);
late final _sel_convertRect_toView_ = objc.registerName("convertRect:toView:");
late final _sel_convertRect_fromView_ = objc.registerName(
  "convertRect:fromView:",
);
late final _sel_autoresizesSubviews = objc.registerName("autoresizesSubviews");
late final _sel_setAutoresizesSubviews_ = objc.registerName(
  "setAutoresizesSubviews:",
);

sealed class UIViewAutoresizing {
  static const UIViewAutoresizingNone = 0;
  static const UIViewAutoresizingFlexibleLeftMargin = 1;
  static const UIViewAutoresizingFlexibleWidth = 2;
  static const UIViewAutoresizingFlexibleRightMargin = 4;
  static const UIViewAutoresizingFlexibleTopMargin = 8;
  static const UIViewAutoresizingFlexibleHeight = 16;
  static const UIViewAutoresizingFlexibleBottomMargin = 32;
}

late final _sel_autoresizingMask = objc.registerName("autoresizingMask");
final _objc_msgSend_sq30wq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setAutoresizingMask_ = objc.registerName(
  "setAutoresizingMask:",
);
final _objc_msgSend_qjq6uk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_sizeThatFits_ = objc.registerName("sizeThatFits:");
final _objc_msgSend_1owrp3b = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGSize Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGSize,
        )
      >
    >()
    .asFunction<
      objc.CGSize Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGSize,
      )
    >();
final _objc_msgSend_1owrp3bStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGSize>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGSize,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGSize>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGSize,
      )
    >();
late final _sel_sizeToFit = objc.registerName("sizeToFit");

/// UIViewGeometry
extension UIViewGeometry on UIView {
  /// anchorPoint
  objc.CGPoint get anchorPoint {
    objc.checkOsVersionInternal('UIView.anchorPoint', iOS: (false, (16, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret(
            $ptr,
            object$.ref.pointer,
            _sel_anchorPoint,
          )
        : $ptr.ref = _objc_msgSend_1uwdhlk(
            object$.ref.pointer,
            _sel_anchorPoint,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// autoresizesSubviews
  bool get autoresizesSubviews {
    objc.checkOsVersionInternal(
      'UIView.autoresizesSubviews',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_autoresizesSubviews);
  }

  /// autoresizingMask
  int get autoresizingMask {
    objc.checkOsVersionInternal(
      'UIView.autoresizingMask',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_sq30wq(object$.ref.pointer, _sel_autoresizingMask);
  }

  /// bounds
  objc.CGRect get bounds$1 {
    objc.checkOsVersionInternal('UIView.bounds', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_bounds)
        : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_bounds);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// center
  objc.CGPoint get center$1 {
    objc.checkOsVersionInternal('UIView.center', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret($ptr, object$.ref.pointer, _sel_center)
        : $ptr.ref = _objc_msgSend_1uwdhlk(object$.ref.pointer, _sel_center);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// contentScaleFactor
  double get contentScaleFactor {
    objc.checkOsVersionInternal(
      'UIView.contentScaleFactor',
      iOS: (false, (4, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            object$.ref.pointer,
            _sel_contentScaleFactor,
          )
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_contentScaleFactor);
  }

  /// convertPoint:fromView:
  objc.CGPoint convertPoint$2(objc.CGPoint point, {UIView? fromView}) {
    objc.checkOsVersionInternal(
      'UIView.convertPoint:fromView:',
      iOS: (false, (2, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            $ptr,
            object$.ref.pointer,
            _sel_convertPoint_fromView_,
            point,
            fromView?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_3l1tu1(
            object$.ref.pointer,
            _sel_convertPoint_fromView_,
            point,
            fromView?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// convertPoint:toView:
  objc.CGPoint convertPoint$3(objc.CGPoint point, {UIView? toView}) {
    objc.checkOsVersionInternal(
      'UIView.convertPoint:toView:',
      iOS: (false, (2, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            $ptr,
            object$.ref.pointer,
            _sel_convertPoint_toView_,
            point,
            toView?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_3l1tu1(
            object$.ref.pointer,
            _sel_convertPoint_toView_,
            point,
            toView?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// convertRect:fromView:
  objc.CGRect convertRect$2(objc.CGRect rect, {UIView? fromView}) {
    objc.checkOsVersionInternal(
      'UIView.convertRect:fromView:',
      iOS: (false, (2, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertRect_fromView_,
            rect,
            fromView?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_2olghr(
            object$.ref.pointer,
            _sel_convertRect_fromView_,
            rect,
            fromView?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// convertRect:toView:
  objc.CGRect convertRect$3(objc.CGRect rect, {UIView? toView}) {
    objc.checkOsVersionInternal(
      'UIView.convertRect:toView:',
      iOS: (false, (2, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertRect_toView_,
            rect,
            toView?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_2olghr(
            object$.ref.pointer,
            _sel_convertRect_toView_,
            rect,
            toView?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// frame
  objc.CGRect get frame$1 {
    objc.checkOsVersionInternal('UIView.frame', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_frame)
        : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_frame);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// hitTest:withEvent:
  UIView? hitTest(objc.CGPoint point, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal(
      'UIView.hitTest:withEvent:',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_u7nfz8(
      object$.ref.pointer,
      _sel_hitTest_withEvent_,
      point,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }

  /// isExclusiveTouch
  bool get isExclusiveTouch {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isExclusiveTouch);
  }

  /// isMultipleTouchEnabled
  bool get isMultipleTouchEnabled {
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isMultipleTouchEnabled,
    );
  }

  /// pointInside:withEvent:
  bool pointInside(objc.CGPoint point, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal(
      'UIView.pointInside:withEvent:',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_yvwe5y(
      object$.ref.pointer,
      _sel_pointInside_withEvent_,
      point,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAnchorPoint:
  set anchorPoint(objc.CGPoint value) {
    objc.checkOsVersionInternal(
      'UIView.setAnchorPoint:',
      iOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_iy8iz6(object$.ref.pointer, _sel_setAnchorPoint_, value);
  }

  /// setAutoresizesSubviews:
  set autoresizesSubviews(bool value) {
    objc.checkOsVersionInternal(
      'UIView.setAutoresizesSubviews:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAutoresizesSubviews_,
      value,
    );
  }

  /// setAutoresizingMask:
  set autoresizingMask(int value) {
    objc.checkOsVersionInternal(
      'UIView.setAutoresizingMask:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_qjq6uk(object$.ref.pointer, _sel_setAutoresizingMask_, value);
  }

  /// setBounds:
  set bounds$1(objc.CGRect value) {
    objc.checkOsVersionInternal('UIView.setBounds:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1okkq16(object$.ref.pointer, _sel_setBounds_, value);
  }

  /// setCenter:
  set center$1(objc.CGPoint value) {
    objc.checkOsVersionInternal('UIView.setCenter:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_iy8iz6(object$.ref.pointer, _sel_setCenter_, value);
  }

  /// setContentScaleFactor:
  set contentScaleFactor(double value) {
    objc.checkOsVersionInternal(
      'UIView.setContentScaleFactor:',
      iOS: (false, (4, 0, 0)),
    );
    _objc_msgSend_hwm8nu(
      object$.ref.pointer,
      _sel_setContentScaleFactor_,
      value,
    );
  }

  /// setExclusiveTouch:
  set isExclusiveTouch(bool value) {
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setExclusiveTouch_, value);
  }

  /// setFrame:
  set frame$1(objc.CGRect value) {
    objc.checkOsVersionInternal('UIView.setFrame:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1okkq16(object$.ref.pointer, _sel_setFrame_, value);
  }

  /// setMultipleTouchEnabled:
  set isMultipleTouchEnabled(bool value) {
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setMultipleTouchEnabled_,
      value,
    );
  }

  /// setTransform3D:
  set transform3D(CATransform3D value) {
    objc.checkOsVersionInternal(
      'UIView.setTransform3D:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_1s50tpz(object$.ref.pointer, _sel_setTransform3D_, value);
  }

  /// setTransform:
  set transform$1(CGAffineTransform value) {
    objc.checkOsVersionInternal(
      'UIView.setTransform:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_qgt66z(object$.ref.pointer, _sel_setTransform_, value);
  }

  /// sizeThatFits:
  objc.CGSize sizeThatFits(objc.CGSize size) {
    objc.checkOsVersionInternal(
      'UIView.sizeThatFits:',
      iOS: (false, (2, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1owrp3bStret(
            $ptr,
            object$.ref.pointer,
            _sel_sizeThatFits_,
            size,
          )
        : $ptr.ref = _objc_msgSend_1owrp3b(
            object$.ref.pointer,
            _sel_sizeThatFits_,
            size,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// sizeToFit
  void sizeToFit() {
    objc.checkOsVersionInternal('UIView.sizeToFit', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_sizeToFit);
  }

  /// transform
  CGAffineTransform get transform$1 {
    objc.checkOsVersionInternal('UIView.transform', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<CGAffineTransform>();
    objc.useMsgSendVariants
        ? _objc_msgSend_5qswvjStret($ptr, object$.ref.pointer, _sel_transform)
        : $ptr.ref = _objc_msgSend_5qswvj(object$.ref.pointer, _sel_transform);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<CGAffineTransform>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<CGAffineTransform>($finalizable);
  }

  /// transform3D
  CATransform3D get transform3D {
    objc.checkOsVersionInternal('UIView.transform3D', iOS: (false, (13, 0, 0)));
    final $ptr = pkg_ffi.calloc<CATransform3D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_5qlg3jStret($ptr, object$.ref.pointer, _sel_transform3D)
        : $ptr.ref = _objc_msgSend_5qlg3j(
            object$.ref.pointer,
            _sel_transform3D,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<CATransform3D>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<CATransform3D>($finalizable);
  }
}

late final _sel_superview = objc.registerName("superview");
late final _sel_subviews = objc.registerName("subviews");

/// WARNING: UIWindow is a stub. To generate bindings for this class, include
/// UIWindow in your config's objc-interfaces list.
///
/// UIWindow
extension type UIWindow._(objc.ObjCObject object$)
    implements objc.ObjCObject, UIView {
  /// Constructs a [UIWindow] that points to the same underlying object as [other].
  UIWindow.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIWindow', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIWindow] that wraps the given raw object pointer.
  UIWindow.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIWindow', iOS: (false, (2, 0, 0)));
  }
}

late final _sel_window = objc.registerName("window");
late final _sel_removeFromSuperview = objc.registerName("removeFromSuperview");
late final _sel_insertSubview_atIndex_ = objc.registerName(
  "insertSubview:atIndex:",
);
final _objc_msgSend_1nvl641 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
      )
    >();
late final _sel_exchangeSubviewAtIndex_withSubviewAtIndex_ = objc.registerName(
  "exchangeSubviewAtIndex:withSubviewAtIndex:",
);
final _objc_msgSend_1w5k0al = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        int,
      )
    >();
late final _sel_addSubview_ = objc.registerName("addSubview:");
late final _sel_insertSubview_belowSubview_ = objc.registerName(
  "insertSubview:belowSubview:",
);
late final _sel_insertSubview_aboveSubview_ = objc.registerName(
  "insertSubview:aboveSubview:",
);
late final _sel_bringSubviewToFront_ = objc.registerName(
  "bringSubviewToFront:",
);
late final _sel_sendSubviewToBack_ = objc.registerName("sendSubviewToBack:");
late final _sel_didAddSubview_ = objc.registerName("didAddSubview:");
late final _sel_willRemoveSubview_ = objc.registerName("willRemoveSubview:");
late final _sel_willMoveToSuperview_ = objc.registerName(
  "willMoveToSuperview:",
);
late final _sel_didMoveToSuperview = objc.registerName("didMoveToSuperview");
late final _sel_willMoveToWindow_ = objc.registerName("willMoveToWindow:");
late final _sel_didMoveToWindow = objc.registerName("didMoveToWindow");
late final _sel_isDescendantOfView_ = objc.registerName("isDescendantOfView:");
late final _sel_viewWithTag_ = objc.registerName("viewWithTag:");
final _objc_msgSend_qugqlf = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_setNeedsUpdateProperties = objc.registerName(
  "setNeedsUpdateProperties",
);
late final _sel_updateProperties = objc.registerName("updateProperties");
late final _sel_updatePropertiesIfNeeded = objc.registerName(
  "updatePropertiesIfNeeded",
);
late final _sel_setNeedsLayout = objc.registerName("setNeedsLayout");
late final _sel_layoutIfNeeded = objc.registerName("layoutIfNeeded");
late final _sel_layoutSubviews = objc.registerName("layoutSubviews");
late final _sel_layoutMargins = objc.registerName("layoutMargins");
final _objc_msgSend_ct4cu5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        UIEdgeInsets Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      UIEdgeInsets Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_ct4cu5Stret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<UIEdgeInsets>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<UIEdgeInsets>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setLayoutMargins_ = objc.registerName("setLayoutMargins:");
final _objc_msgSend_1g8fos5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          UIEdgeInsets,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        UIEdgeInsets,
      )
    >();
late final _sel_directionalLayoutMargins = objc.registerName(
  "directionalLayoutMargins",
);
final _objc_msgSend_12yjd2m = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        NSDirectionalEdgeInsets Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      NSDirectionalEdgeInsets Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_12yjd2mStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<NSDirectionalEdgeInsets>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<NSDirectionalEdgeInsets>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setDirectionalLayoutMargins_ = objc.registerName(
  "setDirectionalLayoutMargins:",
);
final _objc_msgSend_s0isf8 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          NSDirectionalEdgeInsets,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        NSDirectionalEdgeInsets,
      )
    >();
late final _sel_preservesSuperviewLayoutMargins = objc.registerName(
  "preservesSuperviewLayoutMargins",
);
late final _sel_setPreservesSuperviewLayoutMargins_ = objc.registerName(
  "setPreservesSuperviewLayoutMargins:",
);
late final _sel_insetsLayoutMarginsFromSafeArea = objc.registerName(
  "insetsLayoutMarginsFromSafeArea",
);
late final _sel_setInsetsLayoutMarginsFromSafeArea_ = objc.registerName(
  "setInsetsLayoutMarginsFromSafeArea:",
);
late final _sel_layoutMarginsDidChange = objc.registerName(
  "layoutMarginsDidChange",
);
late final _sel_safeAreaInsets = objc.registerName("safeAreaInsets");
late final _sel_safeAreaInsetsDidChange = objc.registerName(
  "safeAreaInsetsDidChange",
);

/// WARNING: UILayoutGuide is a stub. To generate bindings for this class, include
/// UILayoutGuide in your config's objc-interfaces list.
///
/// UILayoutGuide
extension type UILayoutGuide._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCoding {
  /// Constructs a [UILayoutGuide] that points to the same underlying object as [other].
  UILayoutGuide.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UILayoutGuide', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UILayoutGuide] that wraps the given raw object pointer.
  UILayoutGuide.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UILayoutGuide', iOS: (false, (9, 0, 0)));
  }
}

late final _sel_layoutMarginsGuide = objc.registerName("layoutMarginsGuide");
late final _sel_readableContentGuide = objc.registerName(
  "readableContentGuide",
);
late final _sel_safeAreaLayoutGuide = objc.registerName("safeAreaLayoutGuide");

/// WARNING: UIKeyboardLayoutGuide is a stub. To generate bindings for this class, include
/// UIKeyboardLayoutGuide in your config's objc-interfaces list.
///
/// UIKeyboardLayoutGuide
extension type UIKeyboardLayoutGuide._(objc.ObjCObject object$)
    implements objc.ObjCObject, UITrackingLayoutGuide {
  /// Constructs a [UIKeyboardLayoutGuide] that points to the same underlying object as [other].
  UIKeyboardLayoutGuide.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UIKeyboardLayoutGuide',
      iOS: (false, (15, 0, 0)),
    );
  }

  /// Constructs a [UIKeyboardLayoutGuide] that wraps the given raw object pointer.
  UIKeyboardLayoutGuide.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UIKeyboardLayoutGuide',
      iOS: (false, (15, 0, 0)),
    );
  }
}

late final _sel_keyboardLayoutGuide = objc.registerName("keyboardLayoutGuide");

/// UIViewHierarchy
extension UIViewHierarchy on UIView {
  /// addSubview:
  void addSubview(UIView view) {
    objc.checkOsVersionInternal('UIView.addSubview:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_addSubview_,
      view.ref.pointer,
    );
  }

  /// bringSubviewToFront:
  void bringSubviewToFront(UIView view) {
    objc.checkOsVersionInternal(
      'UIView.bringSubviewToFront:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_bringSubviewToFront_,
      view.ref.pointer,
    );
  }

  /// didAddSubview:
  void didAddSubview(UIView subview) {
    objc.checkOsVersionInternal(
      'UIView.didAddSubview:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_didAddSubview_,
      subview.ref.pointer,
    );
  }

  /// didMoveToSuperview
  void didMoveToSuperview() {
    objc.checkOsVersionInternal(
      'UIView.didMoveToSuperview',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_didMoveToSuperview);
  }

  /// didMoveToWindow
  void didMoveToWindow() {
    objc.checkOsVersionInternal(
      'UIView.didMoveToWindow',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_didMoveToWindow);
  }

  /// directionalLayoutMargins
  NSDirectionalEdgeInsets get directionalLayoutMargins {
    objc.checkOsVersionInternal(
      'UIView.directionalLayoutMargins',
      iOS: (false, (11, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<NSDirectionalEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_12yjd2mStret(
            $ptr,
            object$.ref.pointer,
            _sel_directionalLayoutMargins,
          )
        : $ptr.ref = _objc_msgSend_12yjd2m(
            object$.ref.pointer,
            _sel_directionalLayoutMargins,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<NSDirectionalEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<NSDirectionalEdgeInsets>($finalizable);
  }

  /// exchangeSubviewAtIndex:withSubviewAtIndex:
  void exchangeSubviewAtIndex(int index1, {required int withSubviewAtIndex}) {
    objc.checkOsVersionInternal(
      'UIView.exchangeSubviewAtIndex:withSubviewAtIndex:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1w5k0al(
      object$.ref.pointer,
      _sel_exchangeSubviewAtIndex_withSubviewAtIndex_,
      index1,
      withSubviewAtIndex,
    );
  }

  /// insertSubview:aboveSubview:
  void insertSubview(UIView view, {required UIView aboveSubview}) {
    objc.checkOsVersionInternal(
      'UIView.insertSubview:aboveSubview:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_insertSubview_aboveSubview_,
      view.ref.pointer,
      aboveSubview.ref.pointer,
    );
  }

  /// insertSubview:atIndex:
  void insertSubview$1(UIView view, {required int atIndex}) {
    objc.checkOsVersionInternal(
      'UIView.insertSubview:atIndex:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1nvl641(
      object$.ref.pointer,
      _sel_insertSubview_atIndex_,
      view.ref.pointer,
      atIndex,
    );
  }

  /// insertSubview:belowSubview:
  void insertSubview$2(UIView view, {required UIView belowSubview}) {
    objc.checkOsVersionInternal(
      'UIView.insertSubview:belowSubview:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_insertSubview_belowSubview_,
      view.ref.pointer,
      belowSubview.ref.pointer,
    );
  }

  /// insetsLayoutMarginsFromSafeArea
  bool get insetsLayoutMarginsFromSafeArea {
    objc.checkOsVersionInternal(
      'UIView.insetsLayoutMarginsFromSafeArea',
      iOS: (false, (11, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_insetsLayoutMarginsFromSafeArea,
    );
  }

  /// isDescendantOfView:
  bool isDescendantOfView(UIView view) {
    objc.checkOsVersionInternal(
      'UIView.isDescendantOfView:',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_isDescendantOfView_,
      view.ref.pointer,
    );
  }

  /// keyboardLayoutGuide
  UIKeyboardLayoutGuide get keyboardLayoutGuide {
    objc.checkOsVersionInternal(
      'UIView.keyboardLayoutGuide',
      iOS: (false, (15, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_keyboardLayoutGuide,
    );
    return UIKeyboardLayoutGuide.fromPointer($ret, retain: true, release: true);
  }

  /// layoutIfNeeded
  void layoutIfNeeded() {
    objc.checkOsVersionInternal(
      'UIView.layoutIfNeeded',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_layoutIfNeeded);
  }

  /// layoutMargins
  UIEdgeInsets get layoutMargins {
    objc.checkOsVersionInternal(
      'UIView.layoutMargins',
      iOS: (false, (8, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(
            $ptr,
            object$.ref.pointer,
            _sel_layoutMargins,
          )
        : $ptr.ref = _objc_msgSend_ct4cu5(
            object$.ref.pointer,
            _sel_layoutMargins,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// layoutMarginsDidChange
  void layoutMarginsDidChange() {
    objc.checkOsVersionInternal(
      'UIView.layoutMarginsDidChange',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_layoutMarginsDidChange);
  }

  /// layoutMarginsGuide
  UILayoutGuide get layoutMarginsGuide {
    objc.checkOsVersionInternal(
      'UIView.layoutMarginsGuide',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_layoutMarginsGuide,
    );
    return UILayoutGuide.fromPointer($ret, retain: true, release: true);
  }

  /// layoutSubviews
  void layoutSubviews() {
    objc.checkOsVersionInternal(
      'UIView.layoutSubviews',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_layoutSubviews);
  }

  /// preservesSuperviewLayoutMargins
  bool get preservesSuperviewLayoutMargins {
    objc.checkOsVersionInternal(
      'UIView.preservesSuperviewLayoutMargins',
      iOS: (false, (8, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_preservesSuperviewLayoutMargins,
    );
  }

  /// readableContentGuide
  UILayoutGuide get readableContentGuide {
    objc.checkOsVersionInternal(
      'UIView.readableContentGuide',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_readableContentGuide,
    );
    return UILayoutGuide.fromPointer($ret, retain: true, release: true);
  }

  /// removeFromSuperview
  void removeFromSuperview() {
    objc.checkOsVersionInternal(
      'UIView.removeFromSuperview',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_removeFromSuperview);
  }

  /// safeAreaInsets
  UIEdgeInsets get safeAreaInsets {
    objc.checkOsVersionInternal(
      'UIView.safeAreaInsets',
      iOS: (false, (11, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(
            $ptr,
            object$.ref.pointer,
            _sel_safeAreaInsets,
          )
        : $ptr.ref = _objc_msgSend_ct4cu5(
            object$.ref.pointer,
            _sel_safeAreaInsets,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// safeAreaInsetsDidChange
  void safeAreaInsetsDidChange() {
    objc.checkOsVersionInternal(
      'UIView.safeAreaInsetsDidChange',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_safeAreaInsetsDidChange);
  }

  /// safeAreaLayoutGuide
  UILayoutGuide get safeAreaLayoutGuide {
    objc.checkOsVersionInternal(
      'UIView.safeAreaLayoutGuide',
      iOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_safeAreaLayoutGuide,
    );
    return UILayoutGuide.fromPointer($ret, retain: true, release: true);
  }

  /// sendSubviewToBack:
  void sendSubviewToBack(UIView view) {
    objc.checkOsVersionInternal(
      'UIView.sendSubviewToBack:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_sendSubviewToBack_,
      view.ref.pointer,
    );
  }

  /// setDirectionalLayoutMargins:
  set directionalLayoutMargins(NSDirectionalEdgeInsets value) {
    objc.checkOsVersionInternal(
      'UIView.setDirectionalLayoutMargins:',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_s0isf8(
      object$.ref.pointer,
      _sel_setDirectionalLayoutMargins_,
      value,
    );
  }

  /// setInsetsLayoutMarginsFromSafeArea:
  set insetsLayoutMarginsFromSafeArea(bool value) {
    objc.checkOsVersionInternal(
      'UIView.setInsetsLayoutMarginsFromSafeArea:',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setInsetsLayoutMarginsFromSafeArea_,
      value,
    );
  }

  /// setLayoutMargins:
  set layoutMargins(UIEdgeInsets value) {
    objc.checkOsVersionInternal(
      'UIView.setLayoutMargins:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_1g8fos5(object$.ref.pointer, _sel_setLayoutMargins_, value);
  }

  /// setNeedsLayout
  void setNeedsLayout() {
    objc.checkOsVersionInternal(
      'UIView.setNeedsLayout',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_setNeedsLayout);
  }

  /// setNeedsUpdateProperties
  void setNeedsUpdateProperties() {
    objc.checkOsVersionInternal(
      'UIView.setNeedsUpdateProperties',
      iOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_setNeedsUpdateProperties);
  }

  /// setPreservesSuperviewLayoutMargins:
  set preservesSuperviewLayoutMargins(bool value) {
    objc.checkOsVersionInternal(
      'UIView.setPreservesSuperviewLayoutMargins:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setPreservesSuperviewLayoutMargins_,
      value,
    );
  }

  /// subviews
  objc.NSArray get subviews {
    objc.checkOsVersionInternal('UIView.subviews', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_subviews);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// superview
  UIView? get superview {
    objc.checkOsVersionInternal('UIView.superview', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_superview);
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }

  /// updateProperties
  void updateProperties() {
    objc.checkOsVersionInternal(
      'UIView.updateProperties',
      iOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_updateProperties);
  }

  /// updatePropertiesIfNeeded
  void updatePropertiesIfNeeded() {
    objc.checkOsVersionInternal(
      'UIView.updatePropertiesIfNeeded',
      iOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_updatePropertiesIfNeeded);
  }

  /// viewWithTag:
  UIView? viewWithTag(int tag) {
    objc.checkOsVersionInternal('UIView.viewWithTag:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_qugqlf(
      object$.ref.pointer,
      _sel_viewWithTag_,
      tag,
    );
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }

  /// willMoveToSuperview:
  void willMoveToSuperview(UIView? newSuperview) {
    objc.checkOsVersionInternal(
      'UIView.willMoveToSuperview:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_willMoveToSuperview_,
      newSuperview?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// willMoveToWindow:
  void willMoveToWindow(UIWindow? newWindow) {
    objc.checkOsVersionInternal(
      'UIView.willMoveToWindow:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_willMoveToWindow_,
      newWindow?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// willRemoveSubview:
  void willRemoveSubview(UIView subview) {
    objc.checkOsVersionInternal(
      'UIView.willRemoveSubview:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_willRemoveSubview_,
      subview.ref.pointer,
    );
  }

  /// window
  UIWindow? get window {
    objc.checkOsVersionInternal('UIView.window', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_window);
    return $ret.address == 0
        ? null
        : UIWindow.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_drawRect_ = objc.registerName("drawRect:");
late final _sel_setNeedsDisplay = objc.registerName("setNeedsDisplay");
late final _sel_setNeedsDisplayInRect_ = objc.registerName(
  "setNeedsDisplayInRect:",
);
late final _sel_clipsToBounds = objc.registerName("clipsToBounds");
late final _sel_setClipsToBounds_ = objc.registerName("setClipsToBounds:");
late final _sel_backgroundColor = objc.registerName("backgroundColor");
late final _sel_setBackgroundColor_ = objc.registerName("setBackgroundColor:");
late final _sel_alpha = objc.registerName("alpha");
late final _sel_setAlpha_ = objc.registerName("setAlpha:");
late final _sel_isOpaque = objc.registerName("isOpaque");
late final _sel_setOpaque_ = objc.registerName("setOpaque:");
late final _sel_clearsContextBeforeDrawing = objc.registerName(
  "clearsContextBeforeDrawing",
);
late final _sel_setClearsContextBeforeDrawing_ = objc.registerName(
  "setClearsContextBeforeDrawing:",
);
late final _sel_isHidden = objc.registerName("isHidden");
late final _sel_setHidden_ = objc.registerName("setHidden:");

enum UIViewContentMode {
  UIViewContentModeScaleToFill(0),
  UIViewContentModeScaleAspectFit(1),
  UIViewContentModeScaleAspectFill(2),
  UIViewContentModeRedraw(3),
  UIViewContentModeCenter(4),
  UIViewContentModeTop(5),
  UIViewContentModeBottom(6),
  UIViewContentModeLeft(7),
  UIViewContentModeRight(8),
  UIViewContentModeTopLeft(9),
  UIViewContentModeTopRight(10),
  UIViewContentModeBottomLeft(11),
  UIViewContentModeBottomRight(12);

  final int value;
  const UIViewContentMode(this.value);

  static UIViewContentMode fromValue(int value) => switch (value) {
    0 => UIViewContentModeScaleToFill,
    1 => UIViewContentModeScaleAspectFit,
    2 => UIViewContentModeScaleAspectFill,
    3 => UIViewContentModeRedraw,
    4 => UIViewContentModeCenter,
    5 => UIViewContentModeTop,
    6 => UIViewContentModeBottom,
    7 => UIViewContentModeLeft,
    8 => UIViewContentModeRight,
    9 => UIViewContentModeTopLeft,
    10 => UIViewContentModeTopRight,
    11 => UIViewContentModeBottomLeft,
    12 => UIViewContentModeBottomRight,
    _ => throw ArgumentError('Unknown value for UIViewContentMode: $value'),
  };
}

late final _sel_contentMode = objc.registerName("contentMode");
final _objc_msgSend_12r2l30 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setContentMode_ = objc.registerName("setContentMode:");
final _objc_msgSend_26z7iq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_contentStretch = objc.registerName("contentStretch");
late final _sel_setContentStretch_ = objc.registerName("setContentStretch:");
late final _sel_maskView = objc.registerName("maskView");
late final _sel_setMaskView_ = objc.registerName("setMaskView:");
late final _sel_tintColor = objc.registerName("tintColor");
late final _sel_setTintColor_ = objc.registerName("setTintColor:");

enum UIViewTintAdjustmentMode {
  UIViewTintAdjustmentModeAutomatic(0),
  UIViewTintAdjustmentModeNormal(1),
  UIViewTintAdjustmentModeDimmed(2);

  final int value;
  const UIViewTintAdjustmentMode(this.value);

  static UIViewTintAdjustmentMode fromValue(int value) => switch (value) {
    0 => UIViewTintAdjustmentModeAutomatic,
    1 => UIViewTintAdjustmentModeNormal,
    2 => UIViewTintAdjustmentModeDimmed,
    _ => throw ArgumentError(
      'Unknown value for UIViewTintAdjustmentMode: $value',
    ),
  };
}

late final _sel_tintAdjustmentMode = objc.registerName("tintAdjustmentMode");
final _objc_msgSend_1tlsbkb = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setTintAdjustmentMode_ = objc.registerName(
  "setTintAdjustmentMode:",
);
final _objc_msgSend_15t6owj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_tintColorDidChange = objc.registerName("tintColorDidChange");

/// UIViewRendering
extension UIViewRendering on UIView {
  /// alpha
  double get alpha {
    objc.checkOsVersionInternal('UIView.alpha', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_alpha)
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_alpha);
  }

  /// backgroundColor
  UIColor? get backgroundColor {
    objc.checkOsVersionInternal(
      'UIView.backgroundColor',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_backgroundColor,
    );
    return $ret.address == 0
        ? null
        : UIColor.fromPointer($ret, retain: true, release: true);
  }

  /// clearsContextBeforeDrawing
  bool get clearsContextBeforeDrawing {
    objc.checkOsVersionInternal(
      'UIView.clearsContextBeforeDrawing',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_clearsContextBeforeDrawing,
    );
  }

  /// clipsToBounds
  bool get clipsToBounds {
    objc.checkOsVersionInternal(
      'UIView.clipsToBounds',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_clipsToBounds);
  }

  /// contentMode
  UIViewContentMode get contentMode {
    objc.checkOsVersionInternal('UIView.contentMode', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_12r2l30(object$.ref.pointer, _sel_contentMode);
    return UIViewContentMode.fromValue($ret);
  }

  /// contentStretch
  objc.CGRect get contentStretch {
    objc.checkOsVersionInternal(
      'UIView.contentStretch',
      iOS: (false, (3, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(
            $ptr,
            object$.ref.pointer,
            _sel_contentStretch,
          )
        : $ptr.ref = _objc_msgSend_bu1hbw(
            object$.ref.pointer,
            _sel_contentStretch,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// drawRect:
  void drawRect(objc.CGRect rect) {
    objc.checkOsVersionInternal('UIView.drawRect:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1okkq16(object$.ref.pointer, _sel_drawRect_, rect);
  }

  /// isHidden
  bool get isHidden {
    objc.checkOsVersionInternal('UIView.isHidden', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isHidden);
  }

  /// isOpaque
  bool get isOpaque {
    objc.checkOsVersionInternal('UIView.isOpaque', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isOpaque);
  }

  /// maskView
  UIView? get maskView {
    objc.checkOsVersionInternal('UIView.maskView', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_maskView);
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }

  /// setAlpha:
  set alpha(double value) {
    objc.checkOsVersionInternal('UIView.setAlpha:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setAlpha_, value);
  }

  /// setBackgroundColor:
  set backgroundColor(UIColor? value) {
    objc.checkOsVersionInternal(
      'UIView.setBackgroundColor:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setBackgroundColor_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setClearsContextBeforeDrawing:
  set clearsContextBeforeDrawing(bool value) {
    objc.checkOsVersionInternal(
      'UIView.setClearsContextBeforeDrawing:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setClearsContextBeforeDrawing_,
      value,
    );
  }

  /// setClipsToBounds:
  set clipsToBounds(bool value) {
    objc.checkOsVersionInternal(
      'UIView.setClipsToBounds:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setClipsToBounds_, value);
  }

  /// setContentMode:
  set contentMode(UIViewContentMode value) {
    objc.checkOsVersionInternal(
      'UIView.setContentMode:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_26z7iq(
      object$.ref.pointer,
      _sel_setContentMode_,
      value.value,
    );
  }

  /// setContentStretch:
  set contentStretch(objc.CGRect value) {
    objc.checkOsVersionInternal(
      'UIView.setContentStretch:',
      iOS: (false, (3, 0, 0)),
    );
    _objc_msgSend_1okkq16(object$.ref.pointer, _sel_setContentStretch_, value);
  }

  /// setHidden:
  set isHidden(bool value) {
    objc.checkOsVersionInternal('UIView.setHidden:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setHidden_, value);
  }

  /// setMaskView:
  set maskView(UIView? value) {
    objc.checkOsVersionInternal('UIView.setMaskView:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMaskView_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setNeedsDisplay
  void setNeedsDisplay() {
    objc.checkOsVersionInternal(
      'UIView.setNeedsDisplay',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_setNeedsDisplay);
  }

  /// setNeedsDisplayInRect:
  void setNeedsDisplayInRect(objc.CGRect rect) {
    objc.checkOsVersionInternal(
      'UIView.setNeedsDisplayInRect:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1okkq16(
      object$.ref.pointer,
      _sel_setNeedsDisplayInRect_,
      rect,
    );
  }

  /// setOpaque:
  set isOpaque(bool value) {
    objc.checkOsVersionInternal('UIView.setOpaque:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setOpaque_, value);
  }

  /// setTintAdjustmentMode:
  set tintAdjustmentMode(UIViewTintAdjustmentMode value) {
    objc.checkOsVersionInternal(
      'UIView.setTintAdjustmentMode:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_15t6owj(
      object$.ref.pointer,
      _sel_setTintAdjustmentMode_,
      value.value,
    );
  }

  /// setTintColor:
  set tintColor(UIColor value) {
    objc.checkOsVersionInternal(
      'UIView.setTintColor:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setTintColor_,
      value.ref.pointer,
    );
  }

  /// tintAdjustmentMode
  UIViewTintAdjustmentMode get tintAdjustmentMode {
    objc.checkOsVersionInternal(
      'UIView.tintAdjustmentMode',
      iOS: (false, (7, 0, 0)),
    );
    final $ret = _objc_msgSend_1tlsbkb(
      object$.ref.pointer,
      _sel_tintAdjustmentMode,
    );
    return UIViewTintAdjustmentMode.fromValue($ret);
  }

  /// tintColor
  UIColor get tintColor {
    objc.checkOsVersionInternal('UIView.tintColor', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_tintColor);
    return UIColor.fromPointer($ret, retain: true, release: true);
  }

  /// tintColorDidChange
  void tintColorDidChange() {
    objc.checkOsVersionInternal(
      'UIView.tintColorDidChange',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_tintColorDidChange);
  }
}

late final _sel_setAnimationsEnabled_ = objc.registerName(
  "setAnimationsEnabled:",
);
late final _sel_areAnimationsEnabled = objc.registerName(
  "areAnimationsEnabled",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function()>`.
abstract final class ObjCBlock_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function()> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function()>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function()> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function()>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> fromFunction(
    void Function() fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function()>(
    objc.newClosureBlock(_closureCallable, () => fn(), keepIsolateAlive),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> listener(
    void Function() fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1pl9qdv(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function()>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function()> blocking(
    void Function() fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1pl9qdv(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function()>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block) {
    (objc.getBlockClosure(block) as void Function())();
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function())();
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block) => block
      .ref
      .target
      .cast<ffi.NativeFunction<ffi.Void Function()>>()
      .asFunction<void Function()>()();
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block) =>
      (objc.getBlockClosure(block) as void Function())();
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function()>`.
extension ObjCBlock_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Void Function()> {
  void call() =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block)
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>)>()(
        ref.pointer,
      );
}

late final _sel_performWithoutAnimation_ = objc.registerName(
  "performWithoutAnimation:",
);
late final _sel_inheritedAnimationDuration = objc.registerName(
  "inheritedAnimationDuration",
);

/// UIViewAnimation
extension UIViewAnimation on UIView {
  /// areAnimationsEnabled
  static bool getAreAnimationsEnabled() {
    objc.checkOsVersionInternal(
      'UIView.areAnimationsEnabled',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_91o635(_class_UIView, _sel_areAnimationsEnabled);
  }

  /// inheritedAnimationDuration
  static double getInheritedAnimationDuration() {
    objc.checkOsVersionInternal(
      'UIView.inheritedAnimationDuration',
      iOS: (false, (9, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            _class_UIView,
            _sel_inheritedAnimationDuration,
          )
        : _objc_msgSend_1ukqyt8(_class_UIView, _sel_inheritedAnimationDuration);
  }

  /// performWithoutAnimation:
  static void performWithoutAnimation(
    objc.ObjCBlock<ffi.Void Function()> actionsWithoutAnimation,
  ) {
    objc.checkOsVersionInternal(
      'UIView.performWithoutAnimation:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_f167m6(
      _class_UIView,
      _sel_performWithoutAnimation_,
      actionsWithoutAnimation.ref.pointer,
    );
  }

  /// setAnimationsEnabled:
  static void setAnimationsEnabled(bool enabled) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationsEnabled:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1s56lr9(_class_UIView, _sel_setAnimationsEnabled_, enabled);
  }
}

sealed class UIViewAnimationOptions {
  static const UIViewAnimationOptionLayoutSubviews = 1;
  static const UIViewAnimationOptionAllowUserInteraction = 2;
  static const UIViewAnimationOptionBeginFromCurrentState = 4;
  static const UIViewAnimationOptionRepeat = 8;
  static const UIViewAnimationOptionAutoreverse = 16;
  static const UIViewAnimationOptionOverrideInheritedDuration = 32;
  static const UIViewAnimationOptionOverrideInheritedCurve = 64;
  static const UIViewAnimationOptionAllowAnimatedContent = 128;
  static const UIViewAnimationOptionShowHideTransitionViews = 256;
  static const UIViewAnimationOptionOverrideInheritedOptions = 512;
  static const UIViewAnimationOptionCurveEaseInOut = 0;
  static const UIViewAnimationOptionCurveEaseIn = 65536;
  static const UIViewAnimationOptionCurveEaseOut = 131072;
  static const UIViewAnimationOptionCurveLinear = 196608;
  static const UIViewAnimationOptionTransitionNone = 0;
  static const UIViewAnimationOptionTransitionFlipFromLeft = 1048576;
  static const UIViewAnimationOptionTransitionFlipFromRight = 2097152;
  static const UIViewAnimationOptionTransitionCurlUp = 3145728;
  static const UIViewAnimationOptionTransitionCurlDown = 4194304;
  static const UIViewAnimationOptionTransitionCrossDissolve = 5242880;
  static const UIViewAnimationOptionTransitionFlipFromTop = 6291456;
  static const UIViewAnimationOptionTransitionFlipFromBottom = 7340032;
  static const UIViewAnimationOptionPreferredFramesPerSecondDefault = 0;
  static const UIViewAnimationOptionPreferredFramesPerSecond60 = 50331648;
  static const UIViewAnimationOptionPreferredFramesPerSecond30 = 117440512;
  static const UIViewAnimationOptionFlushUpdates = 268435456;
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Bool)>`.
abstract final class ObjCBlock_ffiVoid_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> fromFunction(
    void Function(bool) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
    objc.newClosureBlock(
      _closureCallable,
      (bool arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> listener(
    void Function(bool) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (bool arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1s56lr9(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> blocking(
    void Function(bool) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (bool arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (bool arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1s56lr9(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    bool arg0,
  ) {
    (objc.getBlockClosure(block) as void Function(bool))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    bool arg0,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(bool))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Bool,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Bool,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Bool,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Bool,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    bool arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Bool arg0)>>()
      .asFunction<void Function(bool)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    bool arg0,
  ) => (objc.getBlockClosure(block) as void Function(bool))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Bool)>`.
extension ObjCBlock_ffiVoid_bool$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Bool)> {
  void call(bool arg0) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Bool arg0,
              )
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, bool)>()(
        ref.pointer,
        arg0,
      );
}

late final _sel_animateWithDuration_delay_options_animations_completion_ = objc
    .registerName("animateWithDuration:delay:options:animations:completion:");
final _objc_msgSend_1pforg = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        double,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_animateWithDuration_animations_completion_ = objc.registerName(
  "animateWithDuration:animations:completion:",
);
final _objc_msgSend_1isavsq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_animateWithDuration_animations_ = objc.registerName(
  "animateWithDuration:animations:",
);
final _objc_msgSend_16dy26p = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_animateWithSpringDuration_bounce_initialSpringVelocity_delay_options_animations_completion_ =
    objc.registerName(
      "animateWithSpringDuration:bounce:initialSpringVelocity:delay:options:animations:completion:",
    );
final _objc_msgSend_r4l13g = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Double,
          ffi.Double,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        double,
        double,
        double,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_animateWithDuration_delay_usingSpringWithDamping_initialSpringVelocity_options_animations_completion_ =
    objc.registerName(
      "animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:",
    );
late final _sel_transitionWithView_duration_options_animations_completion_ =
    objc.registerName(
      "transitionWithView:duration:options:animations:completion:",
    );
final _objc_msgSend_q6v4dl = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        double,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_transitionFromView_toView_duration_options_completion_ = objc
    .registerName("transitionFromView:toView:duration:options:completion:");
final _objc_msgSend_1eh0loo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        double,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

enum UISystemAnimation {
  UISystemAnimationDelete(0);

  final int value;
  const UISystemAnimation(this.value);

  static UISystemAnimation fromValue(int value) => switch (value) {
    0 => UISystemAnimationDelete,
    _ => throw ArgumentError('Unknown value for UISystemAnimation: $value'),
  };
}

late final _sel_performSystemAnimation_onViews_options_animations_completion_ =
    objc.registerName(
      "performSystemAnimation:onViews:options:animations:completion:",
    );
final _objc_msgSend_fqrtz5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_modifyAnimationsWithRepeatCount_autoreverses_animations_ = objc
    .registerName("modifyAnimationsWithRepeatCount:autoreverses:animations:");
final _objc_msgSend_nxk2e9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Bool,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        bool,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// UIViewAnimationWithBlocks
extension UIViewAnimationWithBlocks on UIView {
  /// animateWithDuration:animations:
  static void animateWithDuration(
    double duration, {
    required objc.ObjCBlock<ffi.Void Function()> animations,
  }) {
    objc.checkOsVersionInternal(
      'UIView.animateWithDuration:animations:',
      iOS: (false, (4, 0, 0)),
    );
    _objc_msgSend_16dy26p(
      _class_UIView,
      _sel_animateWithDuration_animations_,
      duration,
      animations.ref.pointer,
    );
  }

  /// animateWithDuration:animations:completion:
  static void animateWithDuration$1(
    double duration, {
    required objc.ObjCBlock<ffi.Void Function()> animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.animateWithDuration:animations:completion:',
      iOS: (false, (4, 0, 0)),
    );
    _objc_msgSend_1isavsq(
      _class_UIView,
      _sel_animateWithDuration_animations_completion_,
      duration,
      animations.ref.pointer,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// animateWithDuration:delay:options:animations:completion:
  static void animateWithDuration$2(
    double duration, {
    required double delay,
    required int options,
    required objc.ObjCBlock<ffi.Void Function()> animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.animateWithDuration:delay:options:animations:completion:',
      iOS: (false, (4, 0, 0)),
    );
    _objc_msgSend_1pforg(
      _class_UIView,
      _sel_animateWithDuration_delay_options_animations_completion_,
      duration,
      delay,
      options,
      animations.ref.pointer,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:
  static void animateWithDuration$3(
    double duration, {
    required double delay,
    required double usingSpringWithDamping,
    required double initialSpringVelocity,
    required int options,
    required objc.ObjCBlock<ffi.Void Function()> animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_r4l13g(
      _class_UIView,
      _sel_animateWithDuration_delay_usingSpringWithDamping_initialSpringVelocity_options_animations_completion_,
      duration,
      delay,
      usingSpringWithDamping,
      initialSpringVelocity,
      options,
      animations.ref.pointer,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// animateWithSpringDuration:bounce:initialSpringVelocity:delay:options:animations:completion:
  static void animateWithSpringDuration(
    double duration, {
    required double bounce,
    required double initialSpringVelocity,
    required double delay,
    required int options,
    required objc.ObjCBlock<ffi.Void Function()> animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.animateWithSpringDuration:bounce:initialSpringVelocity:delay:options:animations:completion:',
      iOS: (false, (17, 0, 0)),
    );
    _objc_msgSend_r4l13g(
      _class_UIView,
      _sel_animateWithSpringDuration_bounce_initialSpringVelocity_delay_options_animations_completion_,
      duration,
      bounce,
      initialSpringVelocity,
      delay,
      options,
      animations.ref.pointer,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// modifyAnimationsWithRepeatCount:autoreverses:animations:
  static void modifyAnimationsWithRepeatCount(
    double count, {
    required bool autoreverses,
    required objc.ObjCBlock<ffi.Void Function()> animations,
  }) {
    objc.checkOsVersionInternal(
      'UIView.modifyAnimationsWithRepeatCount:autoreverses:animations:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_nxk2e9(
      _class_UIView,
      _sel_modifyAnimationsWithRepeatCount_autoreverses_animations_,
      count,
      autoreverses,
      animations.ref.pointer,
    );
  }

  /// performSystemAnimation:onViews:options:animations:completion:
  static void performSystemAnimation(
    UISystemAnimation animation, {
    required objc.NSArray onViews,
    required int options,
    objc.ObjCBlock<ffi.Void Function()>? animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.performSystemAnimation:onViews:options:animations:completion:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_fqrtz5(
      _class_UIView,
      _sel_performSystemAnimation_onViews_options_animations_completion_,
      animation.value,
      onViews.ref.pointer,
      options,
      animations?.ref.pointer ?? ffi.nullptr,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// transitionFromView:toView:duration:options:completion:
  static void transitionFromView(
    UIView fromView, {
    required UIView toView,
    required double duration,
    required int options,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.transitionFromView:toView:duration:options:completion:',
      iOS: (false, (4, 0, 0)),
    );
    _objc_msgSend_1eh0loo(
      _class_UIView,
      _sel_transitionFromView_toView_duration_options_completion_,
      fromView.ref.pointer,
      toView.ref.pointer,
      duration,
      options,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// transitionWithView:duration:options:animations:completion:
  static void transitionWithView(
    UIView view, {
    required double duration,
    required int options,
    objc.ObjCBlock<ffi.Void Function()>? animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.transitionWithView:duration:options:animations:completion:',
      iOS: (false, (4, 0, 0)),
    );
    _objc_msgSend_q6v4dl(
      _class_UIView,
      _sel_transitionWithView_duration_options_animations_completion_,
      view.ref.pointer,
      duration,
      options,
      animations?.ref.pointer ?? ffi.nullptr,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }
}

sealed class UIViewKeyframeAnimationOptions {
  static const UIViewKeyframeAnimationOptionLayoutSubviews = 1;
  static const UIViewKeyframeAnimationOptionAllowUserInteraction = 2;
  static const UIViewKeyframeAnimationOptionBeginFromCurrentState = 4;
  static const UIViewKeyframeAnimationOptionRepeat = 8;
  static const UIViewKeyframeAnimationOptionAutoreverse = 16;
  static const UIViewKeyframeAnimationOptionOverrideInheritedDuration = 32;
  static const UIViewKeyframeAnimationOptionOverrideInheritedOptions = 512;
  static const UIViewKeyframeAnimationOptionCalculationModeLinear = 0;
  static const UIViewKeyframeAnimationOptionCalculationModeDiscrete = 1024;
  static const UIViewKeyframeAnimationOptionCalculationModePaced = 2048;
  static const UIViewKeyframeAnimationOptionCalculationModeCubic = 3072;
  static const UIViewKeyframeAnimationOptionCalculationModeCubicPaced = 4096;
}

late final _sel_animateKeyframesWithDuration_delay_options_animations_completion_ =
    objc.registerName(
      "animateKeyframesWithDuration:delay:options:animations:completion:",
    );
final _objc_msgSend_ciuhtc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        double,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_addKeyframeWithRelativeStartTime_relativeDuration_animations_ =
    objc.registerName(
      "addKeyframeWithRelativeStartTime:relativeDuration:animations:",
    );
final _objc_msgSend_6jt11a = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Double,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        double,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// UIViewKeyframeAnimations
extension UIViewKeyframeAnimations on UIView {
  /// addKeyframeWithRelativeStartTime:relativeDuration:animations:
  static void addKeyframeWithRelativeStartTime(
    double frameStartTime, {
    required double relativeDuration,
    required objc.ObjCBlock<ffi.Void Function()> animations,
  }) {
    objc.checkOsVersionInternal(
      'UIView.addKeyframeWithRelativeStartTime:relativeDuration:animations:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_6jt11a(
      _class_UIView,
      _sel_addKeyframeWithRelativeStartTime_relativeDuration_animations_,
      frameStartTime,
      relativeDuration,
      animations.ref.pointer,
    );
  }

  /// animateKeyframesWithDuration:delay:options:animations:completion:
  static void animateKeyframesWithDuration(
    double duration, {
    required double delay,
    required int options,
    required objc.ObjCBlock<ffi.Void Function()> animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.animateKeyframesWithDuration:delay:options:animations:completion:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_ciuhtc(
      _class_UIView,
      _sel_animateKeyframesWithDuration_delay_options_animations_completion_,
      duration,
      delay,
      options,
      animations.ref.pointer,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }
}

late final _sel_gestureRecognizers = objc.registerName("gestureRecognizers");
late final _sel_setGestureRecognizers_ = objc.registerName(
  "setGestureRecognizers:",
);

/// WARNING: UIGestureRecognizer is a stub. To generate bindings for this class, include
/// UIGestureRecognizer in your config's objc-interfaces list.
///
/// UIGestureRecognizer
extension type UIGestureRecognizer._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [UIGestureRecognizer] that points to the same underlying object as [other].
  UIGestureRecognizer.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIGestureRecognizer', iOS: (false, (3, 2, 0)));
  }

  /// Constructs a [UIGestureRecognizer] that wraps the given raw object pointer.
  UIGestureRecognizer.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIGestureRecognizer', iOS: (false, (3, 2, 0)));
  }
}

late final _sel_addGestureRecognizer_ = objc.registerName(
  "addGestureRecognizer:",
);
late final _sel_removeGestureRecognizer_ = objc.registerName(
  "removeGestureRecognizer:",
);
late final _sel_gestureRecognizerShouldBegin_ = objc.registerName(
  "gestureRecognizerShouldBegin:",
);

/// UIViewGestureRecognizers
extension UIViewGestureRecognizers on UIView {
  /// addGestureRecognizer:
  void addGestureRecognizer(UIGestureRecognizer gestureRecognizer) {
    objc.checkOsVersionInternal(
      'UIView.addGestureRecognizer:',
      iOS: (false, (3, 2, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_addGestureRecognizer_,
      gestureRecognizer.ref.pointer,
    );
  }

  /// gestureRecognizerShouldBegin:
  bool gestureRecognizerShouldBegin(UIGestureRecognizer gestureRecognizer) {
    objc.checkOsVersionInternal(
      'UIView.gestureRecognizerShouldBegin:',
      iOS: (false, (6, 0, 0)),
    );
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_gestureRecognizerShouldBegin_,
      gestureRecognizer.ref.pointer,
    );
  }

  /// gestureRecognizers
  objc.NSArray? get gestureRecognizers {
    objc.checkOsVersionInternal(
      'UIView.gestureRecognizers',
      iOS: (false, (3, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_gestureRecognizers,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// removeGestureRecognizer:
  void removeGestureRecognizer(UIGestureRecognizer gestureRecognizer) {
    objc.checkOsVersionInternal(
      'UIView.removeGestureRecognizer:',
      iOS: (false, (3, 2, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_removeGestureRecognizer_,
      gestureRecognizer.ref.pointer,
    );
  }

  /// setGestureRecognizers:
  set gestureRecognizers(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'UIView.setGestureRecognizers:',
      iOS: (false, (3, 2, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setGestureRecognizers_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }
}

/// WARNING: UIMotionEffect is a stub. To generate bindings for this class, include
/// UIMotionEffect in your config's objc-interfaces list.
///
/// UIMotionEffect
extension type UIMotionEffect._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying, objc.NSCoding {
  /// Constructs a [UIMotionEffect] that points to the same underlying object as [other].
  UIMotionEffect.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIMotionEffect', iOS: (false, (7, 0, 0)));
  }

  /// Constructs a [UIMotionEffect] that wraps the given raw object pointer.
  UIMotionEffect.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIMotionEffect', iOS: (false, (7, 0, 0)));
  }
}

late final _sel_addMotionEffect_ = objc.registerName("addMotionEffect:");
late final _sel_removeMotionEffect_ = objc.registerName("removeMotionEffect:");
late final _sel_motionEffects = objc.registerName("motionEffects");
late final _sel_setMotionEffects_ = objc.registerName("setMotionEffects:");

/// UIViewMotionEffects
extension UIViewMotionEffects on UIView {
  /// addMotionEffect:
  void addMotionEffect(UIMotionEffect effect) {
    objc.checkOsVersionInternal(
      'UIView.addMotionEffect:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_addMotionEffect_,
      effect.ref.pointer,
    );
  }

  /// motionEffects
  objc.NSArray get motionEffects {
    objc.checkOsVersionInternal(
      'UIView.motionEffects',
      iOS: (false, (7, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_motionEffects);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// removeMotionEffect:
  void removeMotionEffect(UIMotionEffect effect) {
    objc.checkOsVersionInternal(
      'UIView.removeMotionEffect:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_removeMotionEffect_,
      effect.ref.pointer,
    );
  }

  /// setMotionEffects:
  set motionEffects(objc.NSArray value) {
    objc.checkOsVersionInternal(
      'UIView.setMotionEffects:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMotionEffects_,
      value.ref.pointer,
    );
  }
}

late final _sel_constraints = objc.registerName("constraints");

/// WARNING: NSLayoutConstraint is a stub. To generate bindings for this class, include
/// NSLayoutConstraint in your config's objc-interfaces list.
///
/// NSLayoutConstraint
extension type NSLayoutConstraint._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSLayoutConstraint] that points to the same underlying object as [other].
  NSLayoutConstraint.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSLayoutConstraint',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
  }

  /// Constructs a [NSLayoutConstraint] that wraps the given raw object pointer.
  NSLayoutConstraint.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSLayoutConstraint',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
  }
}

late final _sel_addConstraint_ = objc.registerName("addConstraint:");
late final _sel_addConstraints_ = objc.registerName("addConstraints:");
late final _sel_removeConstraint_ = objc.registerName("removeConstraint:");
late final _sel_removeConstraints_ = objc.registerName("removeConstraints:");

/// UIConstraintBasedLayoutInstallingConstraints
extension UIConstraintBasedLayoutInstallingConstraints on UIView {
  /// addConstraint:
  void addConstraint(NSLayoutConstraint constraint) {
    objc.checkOsVersionInternal(
      'UIView.addConstraint:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_addConstraint_,
      constraint.ref.pointer,
    );
  }

  /// addConstraints:
  void addConstraints(objc.NSArray constraints) {
    objc.checkOsVersionInternal(
      'UIView.addConstraints:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_addConstraints_,
      constraints.ref.pointer,
    );
  }

  /// constraints
  objc.NSArray get constraints {
    objc.checkOsVersionInternal('UIView.constraints', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_constraints);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// removeConstraint:
  void removeConstraint(NSLayoutConstraint constraint) {
    objc.checkOsVersionInternal(
      'UIView.removeConstraint:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_removeConstraint_,
      constraint.ref.pointer,
    );
  }

  /// removeConstraints:
  void removeConstraints(objc.NSArray constraints) {
    objc.checkOsVersionInternal(
      'UIView.removeConstraints:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_removeConstraints_,
      constraints.ref.pointer,
    );
  }
}

late final _sel_updateConstraintsIfNeeded = objc.registerName(
  "updateConstraintsIfNeeded",
);
late final _sel_updateConstraints = objc.registerName("updateConstraints");
late final _sel_needsUpdateConstraints = objc.registerName(
  "needsUpdateConstraints",
);
late final _sel_setNeedsUpdateConstraints = objc.registerName(
  "setNeedsUpdateConstraints",
);

/// UIConstraintBasedLayoutCoreMethods
extension UIConstraintBasedLayoutCoreMethods on UIView {
  /// needsUpdateConstraints
  bool needsUpdateConstraints() {
    objc.checkOsVersionInternal(
      'UIView.needsUpdateConstraints',
      iOS: (false, (6, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_needsUpdateConstraints,
    );
  }

  /// setNeedsUpdateConstraints
  void setNeedsUpdateConstraints() {
    objc.checkOsVersionInternal(
      'UIView.setNeedsUpdateConstraints',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_setNeedsUpdateConstraints);
  }

  /// updateConstraints
  void updateConstraints() {
    objc.checkOsVersionInternal(
      'UIView.updateConstraints',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_updateConstraints);
  }

  /// updateConstraintsIfNeeded
  void updateConstraintsIfNeeded() {
    objc.checkOsVersionInternal(
      'UIView.updateConstraintsIfNeeded',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_updateConstraintsIfNeeded);
  }
}

late final _sel_translatesAutoresizingMaskIntoConstraints = objc.registerName(
  "translatesAutoresizingMaskIntoConstraints",
);
late final _sel_setTranslatesAutoresizingMaskIntoConstraints_ = objc
    .registerName("setTranslatesAutoresizingMaskIntoConstraints:");
late final _sel_requiresConstraintBasedLayout = objc.registerName(
  "requiresConstraintBasedLayout",
);

/// UIConstraintBasedCompatibility
extension UIConstraintBasedCompatibility on UIView {
  /// setTranslatesAutoresizingMaskIntoConstraints:
  set translatesAutoresizingMaskIntoConstraints(bool value) {
    objc.checkOsVersionInternal(
      'UIView.setTranslatesAutoresizingMaskIntoConstraints:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setTranslatesAutoresizingMaskIntoConstraints_,
      value,
    );
  }

  /// translatesAutoresizingMaskIntoConstraints
  bool get translatesAutoresizingMaskIntoConstraints {
    objc.checkOsVersionInternal(
      'UIView.translatesAutoresizingMaskIntoConstraints',
      iOS: (false, (6, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_translatesAutoresizingMaskIntoConstraints,
    );
  }

  /// requiresConstraintBasedLayout
  static bool getRequiresConstraintBasedLayout() {
    objc.checkOsVersionInternal(
      'UIView.requiresConstraintBasedLayout',
      iOS: (false, (6, 0, 0)),
    );
    return _objc_msgSend_91o635(
      _class_UIView,
      _sel_requiresConstraintBasedLayout,
    );
  }
}

late final _sel_alignmentRectForFrame_ = objc.registerName(
  "alignmentRectForFrame:",
);
final _objc_msgSend_1gn1s3d = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
      )
    >();
final _objc_msgSend_1gn1s3dStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
      )
    >();
late final _sel_frameForAlignmentRect_ = objc.registerName(
  "frameForAlignmentRect:",
);
late final _sel_alignmentRectInsets = objc.registerName("alignmentRectInsets");
late final _sel_viewForBaselineLayout = objc.registerName(
  "viewForBaselineLayout",
);
late final _sel_viewForFirstBaselineLayout = objc.registerName(
  "viewForFirstBaselineLayout",
);
late final _sel_viewForLastBaselineLayout = objc.registerName(
  "viewForLastBaselineLayout",
);
late final _sel_intrinsicContentSize = objc.registerName(
  "intrinsicContentSize",
);
final _objc_msgSend_1vdfken = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGSize Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      objc.CGSize Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1vdfkenStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGSize>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGSize>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_invalidateIntrinsicContentSize = objc.registerName(
  "invalidateIntrinsicContentSize",
);

enum UILayoutConstraintAxis {
  UILayoutConstraintAxisHorizontal(0),
  UILayoutConstraintAxisVertical(1);

  final int value;
  const UILayoutConstraintAxis(this.value);

  static UILayoutConstraintAxis fromValue(int value) => switch (value) {
    0 => UILayoutConstraintAxisHorizontal,
    1 => UILayoutConstraintAxisVertical,
    _ => throw ArgumentError(
      'Unknown value for UILayoutConstraintAxis: $value',
    ),
  };
}

late final _sel_contentHuggingPriorityForAxis_ = objc.registerName(
  "contentHuggingPriorityForAxis:",
);
final _objc_msgSend_qigf85 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Float Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_qigf85Fpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Float Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_setContentHuggingPriority_forAxis_ = objc.registerName(
  "setContentHuggingPriority:forAxis:",
);
final _objc_msgSend_wd7esz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Float,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        int,
      )
    >();
late final _sel_contentCompressionResistancePriorityForAxis_ = objc
    .registerName("contentCompressionResistancePriorityForAxis:");
late final _sel_setContentCompressionResistancePriority_forAxis_ = objc
    .registerName("setContentCompressionResistancePriority:forAxis:");

/// UIConstraintBasedLayoutLayering
extension UIConstraintBasedLayoutLayering on UIView {
  /// alignmentRectForFrame:
  objc.CGRect alignmentRectForFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal(
      'UIView.alignmentRectForFrame:',
      iOS: (false, (6, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1gn1s3dStret(
            $ptr,
            object$.ref.pointer,
            _sel_alignmentRectForFrame_,
            frame,
          )
        : $ptr.ref = _objc_msgSend_1gn1s3d(
            object$.ref.pointer,
            _sel_alignmentRectForFrame_,
            frame,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// alignmentRectInsets
  UIEdgeInsets get alignmentRectInsets {
    objc.checkOsVersionInternal(
      'UIView.alignmentRectInsets',
      iOS: (false, (6, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(
            $ptr,
            object$.ref.pointer,
            _sel_alignmentRectInsets,
          )
        : $ptr.ref = _objc_msgSend_ct4cu5(
            object$.ref.pointer,
            _sel_alignmentRectInsets,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// contentCompressionResistancePriorityForAxis:
  double contentCompressionResistancePriorityForAxis(
    UILayoutConstraintAxis axis,
  ) {
    objc.checkOsVersionInternal(
      'UIView.contentCompressionResistancePriorityForAxis:',
      iOS: (false, (6, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_qigf85Fpret(
            object$.ref.pointer,
            _sel_contentCompressionResistancePriorityForAxis_,
            axis.value,
          )
        : _objc_msgSend_qigf85(
            object$.ref.pointer,
            _sel_contentCompressionResistancePriorityForAxis_,
            axis.value,
          );
  }

  /// contentHuggingPriorityForAxis:
  double contentHuggingPriorityForAxis(UILayoutConstraintAxis axis) {
    objc.checkOsVersionInternal(
      'UIView.contentHuggingPriorityForAxis:',
      iOS: (false, (6, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_qigf85Fpret(
            object$.ref.pointer,
            _sel_contentHuggingPriorityForAxis_,
            axis.value,
          )
        : _objc_msgSend_qigf85(
            object$.ref.pointer,
            _sel_contentHuggingPriorityForAxis_,
            axis.value,
          );
  }

  /// frameForAlignmentRect:
  objc.CGRect frameForAlignmentRect(objc.CGRect alignmentRect) {
    objc.checkOsVersionInternal(
      'UIView.frameForAlignmentRect:',
      iOS: (false, (6, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1gn1s3dStret(
            $ptr,
            object$.ref.pointer,
            _sel_frameForAlignmentRect_,
            alignmentRect,
          )
        : $ptr.ref = _objc_msgSend_1gn1s3d(
            object$.ref.pointer,
            _sel_frameForAlignmentRect_,
            alignmentRect,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// intrinsicContentSize
  objc.CGSize get intrinsicContentSize {
    objc.checkOsVersionInternal(
      'UIView.intrinsicContentSize',
      iOS: (false, (6, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1vdfkenStret(
            $ptr,
            object$.ref.pointer,
            _sel_intrinsicContentSize,
          )
        : $ptr.ref = _objc_msgSend_1vdfken(
            object$.ref.pointer,
            _sel_intrinsicContentSize,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// invalidateIntrinsicContentSize
  void invalidateIntrinsicContentSize() {
    objc.checkOsVersionInternal(
      'UIView.invalidateIntrinsicContentSize',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(
      object$.ref.pointer,
      _sel_invalidateIntrinsicContentSize,
    );
  }

  /// setContentCompressionResistancePriority:forAxis:
  void setContentCompressionResistancePriority(
    double priority, {
    required UILayoutConstraintAxis forAxis,
  }) {
    objc.checkOsVersionInternal(
      'UIView.setContentCompressionResistancePriority:forAxis:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_wd7esz(
      object$.ref.pointer,
      _sel_setContentCompressionResistancePriority_forAxis_,
      priority,
      forAxis.value,
    );
  }

  /// setContentHuggingPriority:forAxis:
  void setContentHuggingPriority(
    double priority, {
    required UILayoutConstraintAxis forAxis,
  }) {
    objc.checkOsVersionInternal(
      'UIView.setContentHuggingPriority:forAxis:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_wd7esz(
      object$.ref.pointer,
      _sel_setContentHuggingPriority_forAxis_,
      priority,
      forAxis.value,
    );
  }

  /// viewForBaselineLayout
  UIView viewForBaselineLayout() {
    objc.checkOsVersionInternal(
      'UIView.viewForBaselineLayout',
      iOS: (false, (6, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_viewForBaselineLayout,
    );
    return UIView.fromPointer($ret, retain: true, release: true);
  }

  /// viewForFirstBaselineLayout
  UIView get viewForFirstBaselineLayout {
    objc.checkOsVersionInternal(
      'UIView.viewForFirstBaselineLayout',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_viewForFirstBaselineLayout,
    );
    return UIView.fromPointer($ret, retain: true, release: true);
  }

  /// viewForLastBaselineLayout
  UIView get viewForLastBaselineLayout {
    objc.checkOsVersionInternal(
      'UIView.viewForLastBaselineLayout',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_viewForLastBaselineLayout,
    );
    return UIView.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_systemLayoutSizeFittingSize_ = objc.registerName(
  "systemLayoutSizeFittingSize:",
);
late final _sel_systemLayoutSizeFittingSize_withHorizontalFittingPriority_verticalFittingPriority_ =
    objc.registerName(
      "systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority:",
    );
final _objc_msgSend_3fx2qn = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGSize Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGSize,
          ffi.Float,
          ffi.Float,
        )
      >
    >()
    .asFunction<
      objc.CGSize Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGSize,
        double,
        double,
      )
    >();
final _objc_msgSend_3fx2qnStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGSize>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGSize,
          ffi.Float,
          ffi.Float,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGSize>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGSize,
        double,
        double,
      )
    >();

/// UIConstraintBasedLayoutFittingSize
extension UIConstraintBasedLayoutFittingSize on UIView {
  /// systemLayoutSizeFittingSize:
  objc.CGSize systemLayoutSizeFittingSize(objc.CGSize targetSize) {
    objc.checkOsVersionInternal(
      'UIView.systemLayoutSizeFittingSize:',
      iOS: (false, (6, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1owrp3bStret(
            $ptr,
            object$.ref.pointer,
            _sel_systemLayoutSizeFittingSize_,
            targetSize,
          )
        : $ptr.ref = _objc_msgSend_1owrp3b(
            object$.ref.pointer,
            _sel_systemLayoutSizeFittingSize_,
            targetSize,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority:
  objc.CGSize systemLayoutSizeFittingSize$1(
    objc.CGSize targetSize, {
    required double withHorizontalFittingPriority,
    required double verticalFittingPriority,
  }) {
    objc.checkOsVersionInternal(
      'UIView.systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority:',
      iOS: (false, (8, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3fx2qnStret(
            $ptr,
            object$.ref.pointer,
            _sel_systemLayoutSizeFittingSize_withHorizontalFittingPriority_verticalFittingPriority_,
            targetSize,
            withHorizontalFittingPriority,
            verticalFittingPriority,
          )
        : $ptr.ref = _objc_msgSend_3fx2qn(
            object$.ref.pointer,
            _sel_systemLayoutSizeFittingSize_withHorizontalFittingPriority_verticalFittingPriority_,
            targetSize,
            withHorizontalFittingPriority,
            verticalFittingPriority,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }
}

late final _sel_layoutGuides = objc.registerName("layoutGuides");
late final _sel_addLayoutGuide_ = objc.registerName("addLayoutGuide:");
late final _sel_removeLayoutGuide_ = objc.registerName("removeLayoutGuide:");

/// UILayoutGuideSupport
extension UILayoutGuideSupport on UIView {
  /// addLayoutGuide:
  void addLayoutGuide(UILayoutGuide layoutGuide) {
    objc.checkOsVersionInternal(
      'UIView.addLayoutGuide:',
      iOS: (false, (9, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_addLayoutGuide_,
      layoutGuide.ref.pointer,
    );
  }

  /// layoutGuides
  objc.NSArray get layoutGuides {
    objc.checkOsVersionInternal('UIView.layoutGuides', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_layoutGuides);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// removeLayoutGuide:
  void removeLayoutGuide(UILayoutGuide layoutGuide) {
    objc.checkOsVersionInternal(
      'UIView.removeLayoutGuide:',
      iOS: (false, (9, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_removeLayoutGuide_,
      layoutGuide.ref.pointer,
    );
  }
}

/// WARNING: NSLayoutXAxisAnchor is a stub. To generate bindings for this class, include
/// NSLayoutXAxisAnchor in your config's objc-interfaces list.
///
/// NSLayoutXAxisAnchor
extension type NSLayoutXAxisAnchor._(objc.ObjCObject object$)
    implements objc.ObjCObject, NSLayoutAnchor {
  /// Constructs a [NSLayoutXAxisAnchor] that points to the same underlying object as [other].
  NSLayoutXAxisAnchor.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSLayoutXAxisAnchor',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }

  /// Constructs a [NSLayoutXAxisAnchor] that wraps the given raw object pointer.
  NSLayoutXAxisAnchor.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSLayoutXAxisAnchor',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }
}

late final _sel_leadingAnchor = objc.registerName("leadingAnchor");
late final _sel_trailingAnchor = objc.registerName("trailingAnchor");
late final _sel_leftAnchor = objc.registerName("leftAnchor");
late final _sel_rightAnchor = objc.registerName("rightAnchor");

/// WARNING: NSLayoutYAxisAnchor is a stub. To generate bindings for this class, include
/// NSLayoutYAxisAnchor in your config's objc-interfaces list.
///
/// NSLayoutYAxisAnchor
extension type NSLayoutYAxisAnchor._(objc.ObjCObject object$)
    implements objc.ObjCObject, NSLayoutAnchor {
  /// Constructs a [NSLayoutYAxisAnchor] that points to the same underlying object as [other].
  NSLayoutYAxisAnchor.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSLayoutYAxisAnchor',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }

  /// Constructs a [NSLayoutYAxisAnchor] that wraps the given raw object pointer.
  NSLayoutYAxisAnchor.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSLayoutYAxisAnchor',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }
}

late final _sel_topAnchor = objc.registerName("topAnchor");
late final _sel_bottomAnchor = objc.registerName("bottomAnchor");

/// WARNING: NSLayoutDimension is a stub. To generate bindings for this class, include
/// NSLayoutDimension in your config's objc-interfaces list.
///
/// NSLayoutDimension
extension type NSLayoutDimension._(objc.ObjCObject object$)
    implements objc.ObjCObject, NSLayoutAnchor {
  /// Constructs a [NSLayoutDimension] that points to the same underlying object as [other].
  NSLayoutDimension.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSLayoutDimension',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }

  /// Constructs a [NSLayoutDimension] that wraps the given raw object pointer.
  NSLayoutDimension.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSLayoutDimension',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }
}

late final _sel_widthAnchor = objc.registerName("widthAnchor");
late final _sel_heightAnchor = objc.registerName("heightAnchor");
late final _sel_centerXAnchor = objc.registerName("centerXAnchor");
late final _sel_centerYAnchor = objc.registerName("centerYAnchor");
late final _sel_firstBaselineAnchor = objc.registerName("firstBaselineAnchor");
late final _sel_lastBaselineAnchor = objc.registerName("lastBaselineAnchor");

/// UIViewLayoutConstraintCreation
extension UIViewLayoutConstraintCreation on UIView {
  /// bottomAnchor
  NSLayoutYAxisAnchor get bottomAnchor {
    objc.checkOsVersionInternal('UIView.bottomAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_bottomAnchor);
    return NSLayoutYAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// centerXAnchor
  NSLayoutXAxisAnchor get centerXAnchor {
    objc.checkOsVersionInternal(
      'UIView.centerXAnchor',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_centerXAnchor);
    return NSLayoutXAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// centerYAnchor
  NSLayoutYAxisAnchor get centerYAnchor {
    objc.checkOsVersionInternal(
      'UIView.centerYAnchor',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_centerYAnchor);
    return NSLayoutYAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// firstBaselineAnchor
  NSLayoutYAxisAnchor get firstBaselineAnchor {
    objc.checkOsVersionInternal(
      'UIView.firstBaselineAnchor',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_firstBaselineAnchor,
    );
    return NSLayoutYAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// heightAnchor
  NSLayoutDimension get heightAnchor {
    objc.checkOsVersionInternal('UIView.heightAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_heightAnchor);
    return NSLayoutDimension.fromPointer($ret, retain: true, release: true);
  }

  /// lastBaselineAnchor
  NSLayoutYAxisAnchor get lastBaselineAnchor {
    objc.checkOsVersionInternal(
      'UIView.lastBaselineAnchor',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_lastBaselineAnchor,
    );
    return NSLayoutYAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// leadingAnchor
  NSLayoutXAxisAnchor get leadingAnchor {
    objc.checkOsVersionInternal(
      'UIView.leadingAnchor',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_leadingAnchor);
    return NSLayoutXAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// leftAnchor
  NSLayoutXAxisAnchor get leftAnchor {
    objc.checkOsVersionInternal('UIView.leftAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_leftAnchor);
    return NSLayoutXAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// rightAnchor
  NSLayoutXAxisAnchor get rightAnchor {
    objc.checkOsVersionInternal('UIView.rightAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_rightAnchor);
    return NSLayoutXAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// topAnchor
  NSLayoutYAxisAnchor get topAnchor {
    objc.checkOsVersionInternal('UIView.topAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_topAnchor);
    return NSLayoutYAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// trailingAnchor
  NSLayoutXAxisAnchor get trailingAnchor {
    objc.checkOsVersionInternal(
      'UIView.trailingAnchor',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_trailingAnchor,
    );
    return NSLayoutXAxisAnchor.fromPointer($ret, retain: true, release: true);
  }

  /// widthAnchor
  NSLayoutDimension get widthAnchor {
    objc.checkOsVersionInternal('UIView.widthAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_widthAnchor);
    return NSLayoutDimension.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_constraintsAffectingLayoutForAxis_ = objc.registerName(
  "constraintsAffectingLayoutForAxis:",
);
final _objc_msgSend_5swr7b = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_hasAmbiguousLayout = objc.registerName("hasAmbiguousLayout");
late final _sel_exerciseAmbiguityInLayout = objc.registerName(
  "exerciseAmbiguityInLayout",
);

/// UIConstraintBasedLayoutDebugging
extension UIConstraintBasedLayoutDebugging on UIView {
  /// constraintsAffectingLayoutForAxis:
  objc.NSArray constraintsAffectingLayoutForAxis(UILayoutConstraintAxis axis) {
    objc.checkOsVersionInternal(
      'UIView.constraintsAffectingLayoutForAxis:',
      iOS: (false, (6, 0, 0)),
    );
    final $ret = _objc_msgSend_5swr7b(
      object$.ref.pointer,
      _sel_constraintsAffectingLayoutForAxis_,
      axis.value,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// exerciseAmbiguityInLayout
  void exerciseAmbiguityInLayout() {
    objc.checkOsVersionInternal(
      'UIView.exerciseAmbiguityInLayout',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_exerciseAmbiguityInLayout);
  }

  /// hasAmbiguousLayout
  bool get hasAmbiguousLayout {
    objc.checkOsVersionInternal(
      'UIView.hasAmbiguousLayout',
      iOS: (false, (6, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_hasAmbiguousLayout);
  }
}

late final _sel_restorationIdentifier = objc.registerName(
  "restorationIdentifier",
);
late final _sel_setRestorationIdentifier_ = objc.registerName(
  "setRestorationIdentifier:",
);
late final _sel_encodeRestorableStateWithCoder_ = objc.registerName(
  "encodeRestorableStateWithCoder:",
);
late final _sel_decodeRestorableStateWithCoder_ = objc.registerName(
  "decodeRestorableStateWithCoder:",
);

/// UIStateRestoration
extension UIStateRestoration on UIView {
  /// decodeRestorableStateWithCoder:
  void decodeRestorableStateWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal(
      'UIView.decodeRestorableStateWithCoder:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_decodeRestorableStateWithCoder_,
      coder.ref.pointer,
    );
  }

  /// encodeRestorableStateWithCoder:
  void encodeRestorableStateWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal(
      'UIView.encodeRestorableStateWithCoder:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_encodeRestorableStateWithCoder_,
      coder.ref.pointer,
    );
  }

  /// restorationIdentifier
  objc.NSString? get restorationIdentifier {
    objc.checkOsVersionInternal(
      'UIView.restorationIdentifier',
      iOS: (false, (6, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_restorationIdentifier,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// setRestorationIdentifier:
  set restorationIdentifier(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'UIView.setRestorationIdentifier:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setRestorationIdentifier_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }
}

late final _sel_snapshotViewAfterScreenUpdates_ = objc.registerName(
  "snapshotViewAfterScreenUpdates:",
);
final _objc_msgSend_1t6aok9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
      )
    >();
late final _sel_resizableSnapshotViewFromRect_afterScreenUpdates_withCapInsets_ =
    objc.registerName(
      "resizableSnapshotViewFromRect:afterScreenUpdates:withCapInsets:",
    );
final _objc_msgSend_qvletk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Bool,
          UIEdgeInsets,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        bool,
        UIEdgeInsets,
      )
    >();
late final _sel_drawViewHierarchyInRect_afterScreenUpdates_ = objc.registerName(
  "drawViewHierarchyInRect:afterScreenUpdates:",
);
final _objc_msgSend_19ljaqg = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        bool,
      )
    >();

/// UISnapshotting
extension UISnapshotting on UIView {
  /// drawViewHierarchyInRect:afterScreenUpdates:
  bool drawViewHierarchyInRect(
    objc.CGRect rect, {
    required bool afterScreenUpdates,
  }) {
    objc.checkOsVersionInternal(
      'UIView.drawViewHierarchyInRect:afterScreenUpdates:',
      iOS: (false, (7, 0, 0)),
    );
    return _objc_msgSend_19ljaqg(
      object$.ref.pointer,
      _sel_drawViewHierarchyInRect_afterScreenUpdates_,
      rect,
      afterScreenUpdates,
    );
  }

  /// resizableSnapshotViewFromRect:afterScreenUpdates:withCapInsets:
  UIView? resizableSnapshotViewFromRect(
    objc.CGRect rect, {
    required bool afterScreenUpdates,
    required UIEdgeInsets withCapInsets,
  }) {
    objc.checkOsVersionInternal(
      'UIView.resizableSnapshotViewFromRect:afterScreenUpdates:withCapInsets:',
      iOS: (false, (7, 0, 0)),
    );
    final $ret = _objc_msgSend_qvletk(
      object$.ref.pointer,
      _sel_resizableSnapshotViewFromRect_afterScreenUpdates_withCapInsets_,
      rect,
      afterScreenUpdates,
      withCapInsets,
    );
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }

  /// snapshotViewAfterScreenUpdates:
  UIView? snapshotViewAfterScreenUpdates(bool afterUpdates) {
    objc.checkOsVersionInternal(
      'UIView.snapshotViewAfterScreenUpdates:',
      iOS: (false, (7, 0, 0)),
    );
    final $ret = _objc_msgSend_1t6aok9(
      object$.ref.pointer,
      _sel_snapshotViewAfterScreenUpdates_,
      afterUpdates,
    );
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_beginAnimations_context_ = objc.registerName(
  "beginAnimations:context:",
);
final _objc_msgSend_1lzqwav = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<ffi.Void>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<ffi.Void>,
      )
    >();
late final _sel_commitAnimations = objc.registerName("commitAnimations");
late final _sel_setAnimationDelegate_ = objc.registerName(
  "setAnimationDelegate:",
);
late final _sel_setAnimationWillStartSelector_ = objc.registerName(
  "setAnimationWillStartSelector:",
);
final _objc_msgSend_1d9e4oe = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setAnimationDidStopSelector_ = objc.registerName(
  "setAnimationDidStopSelector:",
);
late final _sel_setAnimationDuration_ = objc.registerName(
  "setAnimationDuration:",
);
late final _sel_setAnimationDelay_ = objc.registerName("setAnimationDelay:");
late final _sel_setAnimationStartDate_ = objc.registerName(
  "setAnimationStartDate:",
);

enum UIViewAnimationCurve {
  UIViewAnimationCurveEaseInOut(0),
  UIViewAnimationCurveEaseIn(1),
  UIViewAnimationCurveEaseOut(2),
  UIViewAnimationCurveLinear(3);

  final int value;
  const UIViewAnimationCurve(this.value);

  static UIViewAnimationCurve fromValue(int value) => switch (value) {
    0 => UIViewAnimationCurveEaseInOut,
    1 => UIViewAnimationCurveEaseIn,
    2 => UIViewAnimationCurveEaseOut,
    3 => UIViewAnimationCurveLinear,
    _ => throw ArgumentError('Unknown value for UIViewAnimationCurve: $value'),
  };
}

late final _sel_setAnimationCurve_ = objc.registerName("setAnimationCurve:");
final _objc_msgSend_up32gn = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_setAnimationRepeatCount_ = objc.registerName(
  "setAnimationRepeatCount:",
);
final _objc_msgSend_v5hmet = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Float,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
      )
    >();
late final _sel_setAnimationRepeatAutoreverses_ = objc.registerName(
  "setAnimationRepeatAutoreverses:",
);
late final _sel_setAnimationBeginsFromCurrentState_ = objc.registerName(
  "setAnimationBeginsFromCurrentState:",
);

enum UIViewAnimationTransition {
  UIViewAnimationTransitionNone(0),
  UIViewAnimationTransitionFlipFromLeft(1),
  UIViewAnimationTransitionFlipFromRight(2),
  UIViewAnimationTransitionCurlUp(3),
  UIViewAnimationTransitionCurlDown(4);

  final int value;
  const UIViewAnimationTransition(this.value);

  static UIViewAnimationTransition fromValue(int value) => switch (value) {
    0 => UIViewAnimationTransitionNone,
    1 => UIViewAnimationTransitionFlipFromLeft,
    2 => UIViewAnimationTransitionFlipFromRight,
    3 => UIViewAnimationTransitionCurlUp,
    4 => UIViewAnimationTransitionCurlDown,
    _ => throw ArgumentError(
      'Unknown value for UIViewAnimationTransition: $value',
    ),
  };
}

late final _sel_setAnimationTransition_forView_cache_ = objc.registerName(
  "setAnimationTransition:forView:cache:",
);
final _objc_msgSend_1ftk3d5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
        bool,
      )
    >();

/// DeprecatedAnimations
extension DeprecatedAnimations on UIView {
  /// beginAnimations:context:
  static void beginAnimations(
    objc.NSString? animationID, {
    required ffi.Pointer<ffi.Void> context,
  }) {
    objc.checkOsVersionInternal(
      'UIView.beginAnimations:context:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1lzqwav(
      _class_UIView,
      _sel_beginAnimations_context_,
      animationID?.ref.pointer ?? ffi.nullptr,
      context,
    );
  }

  /// commitAnimations
  static void commitAnimations() {
    objc.checkOsVersionInternal(
      'UIView.commitAnimations',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(_class_UIView, _sel_commitAnimations);
  }

  /// setAnimationBeginsFromCurrentState:
  static void setAnimationBeginsFromCurrentState(bool fromCurrentState) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationBeginsFromCurrentState:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      _class_UIView,
      _sel_setAnimationBeginsFromCurrentState_,
      fromCurrentState,
    );
  }

  /// setAnimationCurve:
  static void setAnimationCurve(UIViewAnimationCurve curve) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationCurve:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_up32gn(_class_UIView, _sel_setAnimationCurve_, curve.value);
  }

  /// setAnimationDelay:
  static void setAnimationDelay(double delay) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationDelay:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_hwm8nu(_class_UIView, _sel_setAnimationDelay_, delay);
  }

  /// setAnimationDelegate:
  static void setAnimationDelegate(objc.ObjCObject? delegate) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationDelegate:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      _class_UIView,
      _sel_setAnimationDelegate_,
      delegate?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAnimationDidStopSelector:
  static void setAnimationDidStopSelector(
    ffi.Pointer<objc.ObjCSelector> selector,
  ) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationDidStopSelector:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1d9e4oe(
      _class_UIView,
      _sel_setAnimationDidStopSelector_,
      selector,
    );
  }

  /// setAnimationDuration:
  static void setAnimationDuration(double duration) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationDuration:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_hwm8nu(_class_UIView, _sel_setAnimationDuration_, duration);
  }

  /// setAnimationRepeatAutoreverses:
  static void setAnimationRepeatAutoreverses(bool repeatAutoreverses) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationRepeatAutoreverses:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      _class_UIView,
      _sel_setAnimationRepeatAutoreverses_,
      repeatAutoreverses,
    );
  }

  /// setAnimationRepeatCount:
  static void setAnimationRepeatCount(double repeatCount) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationRepeatCount:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_v5hmet(
      _class_UIView,
      _sel_setAnimationRepeatCount_,
      repeatCount,
    );
  }

  /// setAnimationStartDate:
  static void setAnimationStartDate(objc.NSDate startDate) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationStartDate:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      _class_UIView,
      _sel_setAnimationStartDate_,
      startDate.ref.pointer,
    );
  }

  /// setAnimationTransition:forView:cache:
  static void setAnimationTransition(
    UIViewAnimationTransition transition, {
    required UIView forView,
    required bool cache,
  }) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationTransition:forView:cache:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1ftk3d5(
      _class_UIView,
      _sel_setAnimationTransition_forView_cache_,
      transition.value,
      forView.ref.pointer,
      cache,
    );
  }

  /// setAnimationWillStartSelector:
  static void setAnimationWillStartSelector(
    ffi.Pointer<objc.ObjCSelector> selector,
  ) {
    objc.checkOsVersionInternal(
      'UIView.setAnimationWillStartSelector:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1d9e4oe(
      _class_UIView,
      _sel_setAnimationWillStartSelector_,
      selector,
    );
  }
}

enum UIUserInterfaceStyle {
  UIUserInterfaceStyleUnspecified(0),
  UIUserInterfaceStyleLight(1),
  UIUserInterfaceStyleDark(2);

  final int value;
  const UIUserInterfaceStyle(this.value);

  static UIUserInterfaceStyle fromValue(int value) => switch (value) {
    0 => UIUserInterfaceStyleUnspecified,
    1 => UIUserInterfaceStyleLight,
    2 => UIUserInterfaceStyleDark,
    _ => throw ArgumentError('Unknown value for UIUserInterfaceStyle: $value'),
  };
}

late final _sel_overrideUserInterfaceStyle = objc.registerName(
  "overrideUserInterfaceStyle",
);
final _objc_msgSend_2x5ago = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setOverrideUserInterfaceStyle_ = objc.registerName(
  "setOverrideUserInterfaceStyle:",
);
final _objc_msgSend_15dz1ky = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// UserInterfaceStyle
extension UserInterfaceStyle on UIView {
  /// overrideUserInterfaceStyle
  UIUserInterfaceStyle get overrideUserInterfaceStyle {
    objc.checkOsVersionInternal(
      'UIView.overrideUserInterfaceStyle',
      iOS: (false, (13, 0, 0)),
    );
    final $ret = _objc_msgSend_2x5ago(
      object$.ref.pointer,
      _sel_overrideUserInterfaceStyle,
    );
    return UIUserInterfaceStyle.fromValue($ret);
  }

  /// setOverrideUserInterfaceStyle:
  set overrideUserInterfaceStyle(UIUserInterfaceStyle value) {
    objc.checkOsVersionInternal(
      'UIView.setOverrideUserInterfaceStyle:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_15dz1ky(
      object$.ref.pointer,
      _sel_setOverrideUserInterfaceStyle_,
      value.value,
    );
  }
}

late final _sel_minimumContentSizeCategory = objc.registerName(
  "minimumContentSizeCategory",
);
late final _sel_setMinimumContentSizeCategory_ = objc.registerName(
  "setMinimumContentSizeCategory:",
);
late final _sel_maximumContentSizeCategory = objc.registerName(
  "maximumContentSizeCategory",
);
late final _sel_setMaximumContentSizeCategory_ = objc.registerName(
  "setMaximumContentSizeCategory:",
);
late final _sel_appliedContentSizeCategoryLimitsDescription = objc.registerName(
  "appliedContentSizeCategoryLimitsDescription",
);

/// UIContentSizeCategoryLimit
extension UIContentSizeCategoryLimit on UIView {
  /// appliedContentSizeCategoryLimitsDescription
  objc.NSString get appliedContentSizeCategoryLimitsDescription {
    objc.checkOsVersionInternal(
      'UIView.appliedContentSizeCategoryLimitsDescription',
      iOS: (false, (15, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_appliedContentSizeCategoryLimitsDescription,
    );
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// maximumContentSizeCategory
  objc.NSString? get maximumContentSizeCategory {
    objc.checkOsVersionInternal(
      'UIView.maximumContentSizeCategory',
      iOS: (false, (15, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_maximumContentSizeCategory,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// minimumContentSizeCategory
  objc.NSString? get minimumContentSizeCategory {
    objc.checkOsVersionInternal(
      'UIView.minimumContentSizeCategory',
      iOS: (false, (15, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_minimumContentSizeCategory,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// setMaximumContentSizeCategory:
  set maximumContentSizeCategory(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'UIView.setMaximumContentSizeCategory:',
      iOS: (false, (15, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMaximumContentSizeCategory_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setMinimumContentSizeCategory:
  set minimumContentSizeCategory(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'UIView.setMinimumContentSizeCategory:',
      iOS: (false, (15, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMinimumContentSizeCategory_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }
}

/// WARNING: UITraitChangeObservable is a stub. To generate bindings for this class, include
/// UITraitChangeObservable in your config's objc-protocols list.
///
/// UITraitChangeObservable
extension type UITraitChangeObservable._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol {
  /// Constructs a [UITraitChangeObservable] that points to the same underlying object as [other].
  UITraitChangeObservable.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UITraitChangeObservable] that wraps the given raw object pointer.
  UITraitChangeObservable.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

///
extension unnamed on UIView {}

/// WARNING: UIViewLayoutRegion is a stub. To generate bindings for this class, include
/// UIViewLayoutRegion in your config's objc-interfaces list.
///
/// UIViewLayoutRegion
extension type UIViewLayoutRegion._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [UIViewLayoutRegion] that points to the same underlying object as [other].
  UIViewLayoutRegion.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIViewLayoutRegion', iOS: (false, (26, 0, 0)));
  }

  /// Constructs a [UIViewLayoutRegion] that wraps the given raw object pointer.
  UIViewLayoutRegion.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIViewLayoutRegion', iOS: (false, (26, 0, 0)));
  }
}

late final _sel_layoutGuideForLayoutRegion_ = objc.registerName(
  "layoutGuideForLayoutRegion:",
);
late final _sel_edgeInsetsForLayoutRegion_ = objc.registerName(
  "edgeInsetsForLayoutRegion:",
);
final _objc_msgSend_16w06qx = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        UIEdgeInsets Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      UIEdgeInsets Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
final _objc_msgSend_16w06qxStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<UIEdgeInsets>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<UIEdgeInsets>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_directionalEdgeInsetsForLayoutRegion_ = objc.registerName(
  "directionalEdgeInsetsForLayoutRegion:",
);
final _objc_msgSend_wk01t0 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        NSDirectionalEdgeInsets Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      NSDirectionalEdgeInsets Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
final _objc_msgSend_wk01t0Stret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<NSDirectionalEdgeInsets>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<NSDirectionalEdgeInsets>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// LayoutRegions
extension LayoutRegions on UIView {
  /// directionalEdgeInsetsForLayoutRegion:
  NSDirectionalEdgeInsets directionalEdgeInsetsForLayoutRegion(
    UIViewLayoutRegion layoutRegion,
  ) {
    objc.checkOsVersionInternal(
      'UIView.directionalEdgeInsetsForLayoutRegion:',
      iOS: (false, (26, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<NSDirectionalEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_wk01t0Stret(
            $ptr,
            object$.ref.pointer,
            _sel_directionalEdgeInsetsForLayoutRegion_,
            layoutRegion.ref.pointer,
          )
        : $ptr.ref = _objc_msgSend_wk01t0(
            object$.ref.pointer,
            _sel_directionalEdgeInsetsForLayoutRegion_,
            layoutRegion.ref.pointer,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<NSDirectionalEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<NSDirectionalEdgeInsets>($finalizable);
  }

  /// edgeInsetsForLayoutRegion:
  UIEdgeInsets edgeInsetsForLayoutRegion(UIViewLayoutRegion layoutRegion) {
    objc.checkOsVersionInternal(
      'UIView.edgeInsetsForLayoutRegion:',
      iOS: (false, (26, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_16w06qxStret(
            $ptr,
            object$.ref.pointer,
            _sel_edgeInsetsForLayoutRegion_,
            layoutRegion.ref.pointer,
          )
        : $ptr.ref = _objc_msgSend_16w06qx(
            object$.ref.pointer,
            _sel_edgeInsetsForLayoutRegion_,
            layoutRegion.ref.pointer,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// layoutGuideForLayoutRegion:
  UILayoutGuide layoutGuideForLayoutRegion(UIViewLayoutRegion layoutRegion) {
    objc.checkOsVersionInternal(
      'UIView.layoutGuideForLayoutRegion:',
      iOS: (false, (26, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_layoutGuideForLayoutRegion_,
      layoutRegion.ref.pointer,
    );
    return UILayoutGuide.fromPointer($ret, retain: true, release: true);
  }
}

/// WARNING: UICornerConfiguration is a stub. To generate bindings for this class, include
/// UICornerConfiguration in your config's objc-interfaces list.
///
/// UICornerConfiguration
extension type UICornerConfiguration._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [UICornerConfiguration] that points to the same underlying object as [other].
  UICornerConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UICornerConfiguration',
      iOS: (false, (26, 0, 0)),
    );
  }

  /// Constructs a [UICornerConfiguration] that wraps the given raw object pointer.
  UICornerConfiguration.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UICornerConfiguration',
      iOS: (false, (26, 0, 0)),
    );
  }
}

late final _sel_cornerConfiguration = objc.registerName("cornerConfiguration");
late final _sel_setCornerConfiguration_ = objc.registerName(
  "setCornerConfiguration:",
);
late final _sel_effectiveRadiusForCorner_ = objc.registerName(
  "effectiveRadiusForCorner:",
);
final _objc_msgSend_8ud30b = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
final _objc_msgSend_8ud30bFpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// CornerConfiguration
extension CornerConfiguration on UIView {
  /// cornerConfiguration
  UICornerConfiguration get cornerConfiguration {
    objc.checkOsVersionInternal(
      'UIView.cornerConfiguration',
      iOS: (false, (26, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_cornerConfiguration,
    );
    return UICornerConfiguration.fromPointer($ret, retain: true, release: true);
  }

  /// effectiveRadiusForCorner:
  double effectiveRadiusForCorner(int corner) {
    objc.checkOsVersionInternal(
      'UIView.effectiveRadiusForCorner:',
      iOS: (false, (26, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_8ud30bFpret(
            object$.ref.pointer,
            _sel_effectiveRadiusForCorner_,
            corner,
          )
        : _objc_msgSend_8ud30b(
            object$.ref.pointer,
            _sel_effectiveRadiusForCorner_,
            corner,
          );
  }

  /// setCornerConfiguration:
  set cornerConfiguration(UICornerConfiguration value) {
    objc.checkOsVersionInternal(
      'UIView.setCornerConfiguration:',
      iOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setCornerConfiguration_,
      value.ref.pointer,
    );
  }
}

/// WARNING: UIInteraction is a stub. To generate bindings for this class, include
/// UIInteraction in your config's objc-protocols list.
///
/// UIInteraction
extension type UIInteraction._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIInteraction] that points to the same underlying object as [other].
  UIInteraction.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIInteraction] that wraps the given raw object pointer.
  UIInteraction.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_addInteraction_ = objc.registerName("addInteraction:");
late final _sel_removeInteraction_ = objc.registerName("removeInteraction:");
late final _sel_interactions = objc.registerName("interactions");
late final _sel_setInteractions_ = objc.registerName("setInteractions:");

/// Interactions
extension Interactions on UIView {
  /// addInteraction:
  void addInteraction(UIInteraction interaction) {
    objc.checkOsVersionInternal(
      'UIView.addInteraction:',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_addInteraction_,
      interaction.ref.pointer,
    );
  }

  /// interactions
  objc.NSArray get interactions {
    objc.checkOsVersionInternal(
      'UIView.interactions',
      iOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_interactions);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// removeInteraction:
  void removeInteraction(UIInteraction interaction) {
    objc.checkOsVersionInternal(
      'UIView.removeInteraction:',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_removeInteraction_,
      interaction.ref.pointer,
    );
  }

  /// setInteractions:
  set interactions(objc.NSArray value) {
    objc.checkOsVersionInternal(
      'UIView.setInteractions:',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setInteractions_,
      value.ref.pointer,
    );
  }
}

late final _sel_accessibilityIgnoresInvertColors = objc.registerName(
  "accessibilityIgnoresInvertColors",
);
late final _sel_setAccessibilityIgnoresInvertColors_ = objc.registerName(
  "setAccessibilityIgnoresInvertColors:",
);

/// UIAccessibilityInvertColors
extension UIAccessibilityInvertColors on UIView {
  /// accessibilityIgnoresInvertColors
  bool get accessibilityIgnoresInvertColors {
    objc.checkOsVersionInternal(
      'UIView.accessibilityIgnoresInvertColors',
      iOS: (false, (11, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_accessibilityIgnoresInvertColors,
    );
  }

  /// setAccessibilityIgnoresInvertColors:
  set accessibilityIgnoresInvertColors(bool value) {
    objc.checkOsVersionInternal(
      'UIView.setAccessibilityIgnoresInvertColors:',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAccessibilityIgnoresInvertColors_,
      value,
    );
  }
}

late final _sel_endEditing_ = objc.registerName("endEditing:");
final _objc_msgSend_41h7k3 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
      )
    >();

/// UITextField
extension UITextField on UIView {
  /// endEditing:
  bool endEditing(bool force) {
    objc.checkOsVersionInternal('UIView.endEditing:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_41h7k3(object$.ref.pointer, _sel_endEditing_, force);
  }
}

/// UIAccessibility
extension UIAccessibility on UIView {
  /// accessibilityIdentifier
  objc.NSString? get accessibilityIdentifier {
    objc.checkOsVersionInternal(
      'UIView.accessibilityIdentifier',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_accessibilityIdentifier,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// setAccessibilityIdentifier:
  set accessibilityIdentifier(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'UIView.setAccessibilityIdentifier:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessibilityIdentifier_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }
}

late final _sel_showsLargeContentViewer = objc.registerName(
  "showsLargeContentViewer",
);
late final _sel_setShowsLargeContentViewer_ = objc.registerName(
  "setShowsLargeContentViewer:",
);
late final _sel_largeContentTitle = objc.registerName("largeContentTitle");
late final _sel_setLargeContentTitle_ = objc.registerName(
  "setLargeContentTitle:",
);
late final _sel_largeContentImage = objc.registerName("largeContentImage");

/// Construction methods for `objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIImage_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)> fromFunction(
    UIImage? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) =>
          fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIImage_ffiVoid$CallExtension
    on objc.ObjCBlock<UIImage? Function(ffi.Pointer<ffi.Void>)> {
  UIImage? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIImage.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_setLargeContentImage_ = objc.registerName(
  "setLargeContentImage:",
);
late final _sel_scalesLargeContentImage = objc.registerName(
  "scalesLargeContentImage",
);
late final _sel_setScalesLargeContentImage_ = objc.registerName(
  "setScalesLargeContentImage:",
);
late final _sel_largeContentImageInsets = objc.registerName(
  "largeContentImageInsets",
);

/// Construction methods for `objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIEdgeInsets_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<UIEdgeInsets Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    UIEdgeInsets Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static UIEdgeInsets _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<UIEdgeInsets Function(ffi.Pointer<ffi.Void> arg0)>
      >()
      .asFunction<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            UIEdgeInsets Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static UIEdgeInsets _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as UIEdgeInsets Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            UIEdgeInsets Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIEdgeInsets_ffiVoid$CallExtension
    on objc.ObjCBlock<UIEdgeInsets Function(ffi.Pointer<ffi.Void>)> {
  UIEdgeInsets call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          UIEdgeInsets Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        UIEdgeInsets Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
        )
      >()(ref.pointer, arg0);
}

late final _sel_setLargeContentImageInsets_ = objc.registerName(
  "setLargeContentImageInsets:",
);

/// WARNING: UILargeContentViewerItem is a stub. To generate bindings for this class, include
/// UILargeContentViewerItem in your config's objc-protocols list.
///
/// UILargeContentViewerItem
extension type UILargeContentViewerItem._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UILargeContentViewerItem] that points to the same underlying object as [other].
  UILargeContentViewerItem.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UILargeContentViewerItem] that wraps the given raw object pointer.
  UILargeContentViewerItem.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// UILargeContentViewer
extension UILargeContentViewer on UIView {
  /// largeContentImage
  UIImage? get largeContentImage {
    objc.checkOsVersionInternal(
      'UIView.largeContentImage',
      iOS: (false, (13, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_largeContentImage,
    );
    return $ret.address == 0
        ? null
        : UIImage.fromPointer($ret, retain: true, release: true);
  }

  /// largeContentImageInsets
  UIEdgeInsets get largeContentImageInsets {
    objc.checkOsVersionInternal(
      'UIView.largeContentImageInsets',
      iOS: (false, (13, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(
            $ptr,
            object$.ref.pointer,
            _sel_largeContentImageInsets,
          )
        : $ptr.ref = _objc_msgSend_ct4cu5(
            object$.ref.pointer,
            _sel_largeContentImageInsets,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// largeContentTitle
  objc.NSString? get largeContentTitle {
    objc.checkOsVersionInternal(
      'UIView.largeContentTitle',
      iOS: (false, (13, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_largeContentTitle,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// scalesLargeContentImage
  bool get scalesLargeContentImage {
    objc.checkOsVersionInternal(
      'UIView.scalesLargeContentImage',
      iOS: (false, (13, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_scalesLargeContentImage,
    );
  }

  /// setLargeContentImage:
  set largeContentImage$1(UIImage? value) {
    objc.checkOsVersionInternal(
      'UIView.setLargeContentImage:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setLargeContentImage_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setLargeContentImageInsets:
  set largeContentImageInsets$1(UIEdgeInsets value) {
    objc.checkOsVersionInternal(
      'UIView.setLargeContentImageInsets:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_1g8fos5(
      object$.ref.pointer,
      _sel_setLargeContentImageInsets_,
      value,
    );
  }

  /// setLargeContentTitle:
  set largeContentTitle$1(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'UIView.setLargeContentTitle:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setLargeContentTitle_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setScalesLargeContentImage:
  set scalesLargeContentImage$1(bool value) {
    objc.checkOsVersionInternal(
      'UIView.setScalesLargeContentImage:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setScalesLargeContentImage_,
      value,
    );
  }

  /// setShowsLargeContentViewer:
  set showsLargeContentViewer(bool value) {
    objc.checkOsVersionInternal(
      'UIView.setShowsLargeContentViewer:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setShowsLargeContentViewer_,
      value,
    );
  }

  /// showsLargeContentViewer
  bool get showsLargeContentViewer$1 {
    objc.checkOsVersionInternal(
      'UIView.showsLargeContentViewer',
      iOS: (false, (13, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_showsLargeContentViewer,
    );
  }
}

/// WARNING: UIHoverStyle$1 is a stub. To generate bindings for this class, include
/// UIHoverStyle in your config's objc-interfaces list.
///
/// UIHoverStyle
extension type UIHoverStyle$1._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [UIHoverStyle$1] that points to the same underlying object as [other].
  UIHoverStyle$1.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIHoverStyle', iOS: (false, (17, 0, 0)));
  }

  /// Constructs a [UIHoverStyle$1] that wraps the given raw object pointer.
  UIHoverStyle$1.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIHoverStyle', iOS: (false, (17, 0, 0)));
  }
}

late final _sel_hoverStyle = objc.registerName("hoverStyle");
late final _sel_setHoverStyle_ = objc.registerName("setHoverStyle:");

/// UIHoverStyle
extension UIHoverStyle on UIView {
  /// hoverStyle
  UIHoverStyle$1? get hoverStyle {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_hoverStyle);
    return $ret.address == 0
        ? null
        : UIHoverStyle$1.fromPointer($ret, retain: true, release: true);
  }

  /// setHoverStyle:
  set hoverStyle(UIHoverStyle$1? value) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setHoverStyle_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }
}

late final _sel_frameInView_ = objc.registerName("frameInView:");
final _objc_msgSend_qrtfce = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
final _objc_msgSend_qrtfceStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>`.
abstract final class ObjCBlock_CGRect_ffiVoid_UIView {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>
  fromFunction(
    objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, UIView.fromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static objc.CGRect _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          objc.CGRect Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        objc.CGRect Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            objc.CGRect Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static objc.CGRect _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as objc.CGRect Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            objc.CGRect Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)>`.
extension ObjCBlock_CGRect_ffiVoid_UIView$CallExtension
    on objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, UIView)> {
  objc.CGRect call(ffi.Pointer<ffi.Void> arg0, UIView arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          objc.CGRect Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// WARNING: UIPopoverPresentationControllerSourceItem$1 is a stub. To generate bindings for this class, include
/// UIPopoverPresentationControllerSourceItem in your config's objc-protocols list.
///
/// UIPopoverPresentationControllerSourceItem
extension type UIPopoverPresentationControllerSourceItem$1._(
  objc.ObjCProtocol object$
)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIPopoverPresentationControllerSourceItem$1] that points to the same underlying object as [other].
  UIPopoverPresentationControllerSourceItem$1.as(objc.ObjCObject other)
    : object$ = other;

  /// Constructs a [UIPopoverPresentationControllerSourceItem$1] that wraps the given raw object pointer.
  UIPopoverPresentationControllerSourceItem$1.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// UIPopoverPresentationControllerSourceItem
extension UIPopoverPresentationControllerSourceItem on UIView {
  /// frameInView:
  objc.CGRect frameInView(UIView referenceView) {
    objc.checkOsVersionInternal(
      'UIView.frameInView:',
      iOS: (false, (17, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_qrtfceStret(
            $ptr,
            object$.ref.pointer,
            _sel_frameInView_,
            referenceView.ref.pointer,
          )
        : $ptr.ref = _objc_msgSend_qrtfce(
            object$.ref.pointer,
            _sel_frameInView_,
            referenceView.ref.pointer,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }
}

/// WARNING: UIViewPrintFormatter is a stub. To generate bindings for this class, include
/// UIViewPrintFormatter in your config's objc-interfaces list.
///
/// UIViewPrintFormatter
extension type UIViewPrintFormatter._(objc.ObjCObject object$)
    implements objc.ObjCObject, UIPrintFormatter$1 {
  /// Constructs a [UIViewPrintFormatter] that points to the same underlying object as [other].
  UIViewPrintFormatter.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UIViewPrintFormatter',
      iOS: (false, (4, 2, 0)),
    );
  }

  /// Constructs a [UIViewPrintFormatter] that wraps the given raw object pointer.
  UIViewPrintFormatter.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UIViewPrintFormatter',
      iOS: (false, (4, 2, 0)),
    );
  }
}

late final _sel_viewPrintFormatter = objc.registerName("viewPrintFormatter");
late final _sel_drawRect_forViewPrintFormatter_ = objc.registerName(
  "drawRect:forViewPrintFormatter:",
);
final _objc_msgSend_f227js = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// UIPrintFormatter
extension UIPrintFormatter on UIView {
  /// drawRect:forViewPrintFormatter:
  void drawRect(
    objc.CGRect rect, {
    required UIViewPrintFormatter forViewPrintFormatter,
  }) {
    _objc_msgSend_f227js(
      object$.ref.pointer,
      _sel_drawRect_forViewPrintFormatter_,
      rect,
      forViewPrintFormatter.ref.pointer,
    );
  }

  /// viewPrintFormatter
  UIViewPrintFormatter viewPrintFormatter() {
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_viewPrintFormatter,
    );
    return UIViewPrintFormatter.fromPointer($ret, retain: true, release: true);
  }
}

/// WARNING: UIAppearance is a stub. To generate bindings for this class, include
/// UIAppearance in your config's objc-protocols list.
///
/// UIAppearance
extension type UIAppearance._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIAppearance] that points to the same underlying object as [other].
  UIAppearance.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIAppearance] that wraps the given raw object pointer.
  UIAppearance.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// WARNING: UIDynamicItem is a stub. To generate bindings for this class, include
/// UIDynamicItem in your config's objc-protocols list.
///
/// UIDynamicItem
extension type UIDynamicItem._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIDynamicItem] that points to the same underlying object as [other].
  UIDynamicItem.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIDynamicItem] that wraps the given raw object pointer.
  UIDynamicItem.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// WARNING: UITraitEnvironment is a stub. To generate bindings for this class, include
/// UITraitEnvironment in your config's objc-protocols list.
///
/// UITraitEnvironment
extension type UITraitEnvironment._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UITraitEnvironment] that points to the same underlying object as [other].
  UITraitEnvironment.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UITraitEnvironment] that wraps the given raw object pointer.
  UITraitEnvironment.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// WARNING: UIFocusItem is a stub. To generate bindings for this class, include
/// UIFocusItem in your config's objc-protocols list.
///
/// UIFocusItem
extension type UIFocusItem._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, UIFocusEnvironment {
  /// Constructs a [UIFocusItem] that points to the same underlying object as [other].
  UIFocusItem.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIFocusItem] that wraps the given raw object pointer.
  UIFocusItem.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// UIView
extension type UIView._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        UIResponder,
        objc.NSCoding,
        UIAppearance,
        UIAppearanceContainer,
        UIDynamicItem,
        UITraitEnvironment,
        UICoordinateSpace,
        UIFocusItem,
        UIFocusItemContainer,
        CALayerDelegate {
  /// Constructs a [UIView] that points to the same underlying object as [other].
  UIView.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIView', iOS: (false, (2, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UIView] that wraps the given raw object pointer.
  UIView.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIView', iOS: (false, (2, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UIView].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_UIView,
  );

  /// alloc
  static UIView alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIView, _sel_alloc);
    return UIView.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIView allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_UIView,
      _sel_allocWithZone_,
      zone,
    );
    return UIView.fromPointer($ret, retain: false, release: true);
  }

  /// appearance
  static UIView appearance() {
    final $ret = _objc_msgSend_151sglz(_class_UIView, _sel_appearance);
    return UIView.fromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:
  static UIView appearanceForTraitCollection(UITraitCollection trait) {
    objc.checkOsVersionInternal(
      'UIView.appearanceForTraitCollection:',
      iOS: (false, (8, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_UIView,
      _sel_appearanceForTraitCollection_,
      trait.ref.pointer,
    );
    return UIView.fromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedIn:
  static UIView appearanceForTraitCollection$1(
    UITraitCollection trait, {
    UIAppearanceContainer? whenContainedIn,
  }) {
    objc.checkOsVersionInternal(
      'UIView.appearanceForTraitCollection:whenContainedIn:',
      iOS: (false, (8, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_UIView,
      _sel_appearanceForTraitCollection_whenContainedIn_,
      trait.ref.pointer,
      whenContainedIn?.ref.pointer ?? ffi.nullptr,
    );
    return UIView.fromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedInInstancesOfClasses:
  static UIView appearanceForTraitCollection$2(
    UITraitCollection trait, {
    required objc.NSArray whenContainedInInstancesOfClasses,
  }) {
    objc.checkOsVersionInternal(
      'UIView.appearanceForTraitCollection:whenContainedInInstancesOfClasses:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_UIView,
      _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_,
      trait.ref.pointer,
      whenContainedInInstancesOfClasses.ref.pointer,
    );
    return UIView.fromPointer($ret, retain: true, release: true);
  }

  /// appearanceWhenContainedIn:
  static UIView appearanceWhenContainedIn(
    UIAppearanceContainer? ContainerClass,
  ) {
    objc.checkOsVersionInternal(
      'UIView.appearanceWhenContainedIn:',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_UIView,
      _sel_appearanceWhenContainedIn_,
      ContainerClass?.ref.pointer ?? ffi.nullptr,
    );
    return UIView.fromPointer($ret, retain: true, release: true);
  }

  /// appearanceWhenContainedInInstancesOfClasses:
  static UIView appearanceWhenContainedInInstancesOfClasses(
    objc.NSArray containerTypes,
  ) {
    objc.checkOsVersionInternal(
      'UIView.appearanceWhenContainedInInstancesOfClasses:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_UIView,
      _sel_appearanceWhenContainedInInstancesOfClasses_,
      containerTypes.ref.pointer,
    );
    return UIView.fromPointer($ret, retain: true, release: true);
  }

  /// layerClass
  static objc.ObjCObject getLayerClass() {
    objc.checkOsVersionInternal('UIView.layerClass', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIView, _sel_layerClass);
    return objc.ObjCObject($ret, retain: true, release: true);
  }

  /// new
  static UIView new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIView, _sel_new);
    return UIView.fromPointer($ret, retain: false, release: true);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection
  userInterfaceLayoutDirectionForSemanticContentAttribute(
    UISemanticContentAttribute attribute,
  ) {
    objc.checkOsVersionInternal(
      'UIView.userInterfaceLayoutDirectionForSemanticContentAttribute:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_racczx(
      _class_UIView,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
      attribute.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection
  userInterfaceLayoutDirectionForSemanticContentAttribute$1(
    UISemanticContentAttribute semanticContentAttribute, {
    required UIUserInterfaceLayoutDirection relativeToLayoutDirection,
  }) {
    objc.checkOsVersionInternal(
      'UIView.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
      iOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_tz4p54(
      _class_UIView,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
      semanticContentAttribute.value,
      relativeToLayoutDirection.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }

  /// Returns a new instance of UIView constructed with the default `new` method.
  UIView() : this.as(new$().object$);
}

extension UIView$Methods on UIView {
  /// actionForLayer:forKey:
  CAAction? actionForLayer(CALayer layer, {required objc.NSString forKey}) {
    objc.checkOsVersionInternal(
      'UIView.actionForLayer:forKey:',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_actionForLayer_forKey_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UIView',
        'actionForLayer:forKey:',
      );
    }
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_actionForLayer_forKey_,
      layer.ref.pointer,
      forKey.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : CAAction.fromPointer($ret, retain: true, release: true);
  }

  /// bounds
  objc.CGRect get bounds {
    objc.checkOsVersionInternal('UIView.bounds', iOS: (false, (8, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_bounds)
        : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_bounds);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// canBecomeFocused
  bool get canBecomeFocused {
    objc.checkOsVersionInternal(
      'UIView.canBecomeFocused',
      iOS: (false, (10, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_canBecomeFocused);
  }

  /// center
  objc.CGPoint get center {
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret($ptr, object$.ref.pointer, _sel_center)
        : $ptr.ref = _objc_msgSend_1uwdhlk(object$.ref.pointer, _sel_center);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// collisionBoundingPath
  UIBezierPath get collisionBoundingPath {
    objc.checkOsVersionInternal(
      'UIView.collisionBoundingPath',
      iOS: (false, (9, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_collisionBoundingPath,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UIView',
        'collisionBoundingPath',
      );
    }
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_collisionBoundingPath,
    );
    return UIBezierPath.fromPointer($ret, retain: true, release: true);
  }

  /// collisionBoundsType
  UIDynamicItemCollisionBoundsType get collisionBoundsType {
    objc.checkOsVersionInternal(
      'UIView.collisionBoundsType',
      iOS: (false, (9, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_collisionBoundsType,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UIView',
        'collisionBoundsType',
      );
    }
    final $ret = _objc_msgSend_k9iunc(
      object$.ref.pointer,
      _sel_collisionBoundsType,
    );
    return UIDynamicItemCollisionBoundsType.fromValue($ret);
  }

  /// convertPoint:fromCoordinateSpace:
  objc.CGPoint convertPoint(
    objc.CGPoint point, {
    required UICoordinateSpace fromCoordinateSpace,
  }) {
    objc.checkOsVersionInternal(
      'UIView.convertPoint:fromCoordinateSpace:',
      iOS: (false, (8, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            $ptr,
            object$.ref.pointer,
            _sel_convertPoint_fromCoordinateSpace_,
            point,
            fromCoordinateSpace.ref.pointer,
          )
        : $ptr.ref = _objc_msgSend_3l1tu1(
            object$.ref.pointer,
            _sel_convertPoint_fromCoordinateSpace_,
            point,
            fromCoordinateSpace.ref.pointer,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// convertPoint:toCoordinateSpace:
  objc.CGPoint convertPoint$1(
    objc.CGPoint point, {
    required UICoordinateSpace toCoordinateSpace,
  }) {
    objc.checkOsVersionInternal(
      'UIView.convertPoint:toCoordinateSpace:',
      iOS: (false, (8, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            $ptr,
            object$.ref.pointer,
            _sel_convertPoint_toCoordinateSpace_,
            point,
            toCoordinateSpace.ref.pointer,
          )
        : $ptr.ref = _objc_msgSend_3l1tu1(
            object$.ref.pointer,
            _sel_convertPoint_toCoordinateSpace_,
            point,
            toCoordinateSpace.ref.pointer,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// convertRect:fromCoordinateSpace:
  objc.CGRect convertRect(
    objc.CGRect rect, {
    required UICoordinateSpace fromCoordinateSpace,
  }) {
    objc.checkOsVersionInternal(
      'UIView.convertRect:fromCoordinateSpace:',
      iOS: (false, (8, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertRect_fromCoordinateSpace_,
            rect,
            fromCoordinateSpace.ref.pointer,
          )
        : $ptr.ref = _objc_msgSend_2olghr(
            object$.ref.pointer,
            _sel_convertRect_fromCoordinateSpace_,
            rect,
            fromCoordinateSpace.ref.pointer,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// convertRect:toCoordinateSpace:
  objc.CGRect convertRect$1(
    objc.CGRect rect, {
    required UICoordinateSpace toCoordinateSpace,
  }) {
    objc.checkOsVersionInternal(
      'UIView.convertRect:toCoordinateSpace:',
      iOS: (false, (8, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            $ptr,
            object$.ref.pointer,
            _sel_convertRect_toCoordinateSpace_,
            rect,
            toCoordinateSpace.ref.pointer,
          )
        : $ptr.ref = _objc_msgSend_2olghr(
            object$.ref.pointer,
            _sel_convertRect_toCoordinateSpace_,
            rect,
            toCoordinateSpace.ref.pointer,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// coordinateSpace
  UICoordinateSpace get coordinateSpace {
    objc.checkOsVersionInternal(
      'UIView.coordinateSpace',
      iOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_coordinateSpace,
    );
    return UICoordinateSpace.fromPointer($ret, retain: true, release: true);
  }

  /// didHintFocusMovement:
  void didHintFocusMovement(UIFocusMovementHint hint) {
    objc.checkOsVersionInternal(
      'UIView.didHintFocusMovement:',
      iOS: (false, (12, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_didHintFocusMovement_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UIView',
        'didHintFocusMovement:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_didHintFocusMovement_,
      hint.ref.pointer,
    );
  }

  /// didUpdateFocusInContext:withAnimationCoordinator:
  void didUpdateFocusInContext(
    UIFocusUpdateContext context, {
    required UIFocusAnimationCoordinator withAnimationCoordinator,
  }) {
    objc.checkOsVersionInternal(
      'UIView.didUpdateFocusInContext:withAnimationCoordinator:',
      iOS: (false, (9, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_didUpdateFocusInContext_withAnimationCoordinator_,
      context.ref.pointer,
      withAnimationCoordinator.ref.pointer,
    );
  }

  /// displayLayer:
  void displayLayer(CALayer layer) {
    objc.checkOsVersionInternal(
      'UIView.displayLayer:',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_displayLayer_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIView',
        'displayLayer:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_displayLayer_,
      layer.ref.pointer,
    );
  }

  /// drawLayer:inContext:
  void drawLayer(CALayer layer, {required ffi.Pointer<CGContext> inContext}) {
    objc.checkOsVersionInternal(
      'UIView.drawLayer:inContext:',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_drawLayer_inContext_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UIView',
        'drawLayer:inContext:',
      );
    }
    _objc_msgSend_a4xp11(
      object$.ref.pointer,
      _sel_drawLayer_inContext_,
      layer.ref.pointer,
      inContext,
    );
  }

  /// effectiveUserInterfaceLayoutDirection
  UIUserInterfaceLayoutDirection get effectiveUserInterfaceLayoutDirection {
    objc.checkOsVersionInternal(
      'UIView.effectiveUserInterfaceLayoutDirection',
      iOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_qj4fey(
      object$.ref.pointer,
      _sel_effectiveUserInterfaceLayoutDirection,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// focusEffect
  UIFocusEffect? get focusEffect {
    objc.checkOsVersionInternal('UIView.focusEffect', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_focusEffect);
    return $ret.address == 0
        ? null
        : UIFocusEffect.fromPointer($ret, retain: true, release: true);
  }

  /// focusGroupIdentifier
  objc.NSString? get focusGroupIdentifier {
    objc.checkOsVersionInternal(
      'UIView.focusGroupIdentifier',
      iOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_focusGroupIdentifier,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// focusGroupPriority
  int get focusGroupPriority {
    objc.checkOsVersionInternal(
      'UIView.focusGroupPriority',
      iOS: (false, (15, 0, 0)),
    );
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_focusGroupPriority);
  }

  /// focusItemContainer
  UIFocusItemContainer? get focusItemContainer {
    objc.checkOsVersionInternal(
      'UIView.focusItemContainer',
      iOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_focusItemContainer,
    );
    return $ret.address == 0
        ? null
        : UIFocusItemContainer.fromPointer($ret, retain: true, release: true);
  }

  /// focusItemDeferralMode
  UIFocusItemDeferralMode get focusItemDeferralMode {
    objc.checkOsVersionInternal(
      'UIView.focusItemDeferralMode',
      iOS: (false, (10, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_focusItemDeferralMode,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UIView',
        'focusItemDeferralMode',
      );
    }
    final $ret = _objc_msgSend_1lv2zxu(
      object$.ref.pointer,
      _sel_focusItemDeferralMode,
    );
    return UIFocusItemDeferralMode.fromValue($ret);
  }

  /// focusItemsInRect:
  objc.NSArray focusItemsInRect(objc.CGRect rect) {
    objc.checkOsVersionInternal(
      'UIView.focusItemsInRect:',
      iOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_15yz4e6(
      object$.ref.pointer,
      _sel_focusItemsInRect_,
      rect,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// frame
  objc.CGRect get frame {
    objc.checkOsVersionInternal('UIView.frame', iOS: (false, (12, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_frame)
        : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_frame);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// init
  UIView init() {
    objc.checkOsVersionInternal(
      'UIView.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return UIView.fromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIView? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: false, release: true);
  }

  /// initWithFrame:
  UIView initWithFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal(
      'UIView.initWithFrame:',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_15yz4e6(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithFrame_,
      frame,
    );
    return UIView.fromPointer($ret, retain: false, release: true);
  }

  /// isFocused
  bool get isFocused {
    objc.checkOsVersionInternal('UIView.isFocused', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isFocused);
  }

  /// isTransparentFocusItem
  bool get isTransparentFocusItem {
    objc.checkOsVersionInternal(
      'UIView.isTransparentFocusItem',
      iOS: (false, (15, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_isTransparentFocusItem,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UIView',
        'isTransparentFocusItem',
      );
    }
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isTransparentFocusItem,
    );
  }

  /// isUserInteractionEnabled
  bool get isUserInteractionEnabled {
    objc.checkOsVersionInternal(
      'UIView.isUserInteractionEnabled',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isUserInteractionEnabled,
    );
  }

  /// layer
  CALayer get layer {
    objc.checkOsVersionInternal('UIView.layer', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_layer);
    return CALayer.fromPointer($ret, retain: true, release: true);
  }

  /// layerWillDraw:
  void layerWillDraw(CALayer layer) {
    objc.checkOsVersionInternal(
      'UIView.layerWillDraw:',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_layerWillDraw_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIView',
        'layerWillDraw:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_layerWillDraw_,
      layer.ref.pointer,
    );
  }

  /// layoutSublayersOfLayer:
  void layoutSublayersOfLayer(CALayer layer) {
    objc.checkOsVersionInternal(
      'UIView.layoutSublayersOfLayer:',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_layoutSublayersOfLayer_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UIView',
        'layoutSublayersOfLayer:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_layoutSublayersOfLayer_,
      layer.ref.pointer,
    );
  }

  /// parentFocusEnvironment
  UIFocusEnvironment? get parentFocusEnvironment {
    objc.checkOsVersionInternal(
      'UIView.parentFocusEnvironment',
      iOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_parentFocusEnvironment,
    );
    return $ret.address == 0
        ? null
        : UIFocusEnvironment.fromPointer($ret, retain: true, release: true);
  }

  /// preferredFocusEnvironments
  objc.NSArray get preferredFocusEnvironments {
    objc.checkOsVersionInternal(
      'UIView.preferredFocusEnvironments',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_preferredFocusEnvironments,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// preferredFocusedView
  UIView? get preferredFocusedView {
    objc.checkOsVersionInternal(
      'UIView.preferredFocusedView',
      iOS: (false, (9, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_preferredFocusedView,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UIView',
        'preferredFocusedView',
      );
    }
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_preferredFocusedView,
    );
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }

  /// semanticContentAttribute
  UISemanticContentAttribute get semanticContentAttribute {
    objc.checkOsVersionInternal(
      'UIView.semanticContentAttribute',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_i2u4x4(
      object$.ref.pointer,
      _sel_semanticContentAttribute,
    );
    return UISemanticContentAttribute.fromValue($ret);
  }

  /// setCenter:
  set center(objc.CGPoint value) {
    _objc_msgSend_iy8iz6(object$.ref.pointer, _sel_setCenter_, value);
  }

  /// setFocusEffect:
  set focusEffect(UIFocusEffect? value) {
    objc.checkOsVersionInternal(
      'UIView.setFocusEffect:',
      iOS: (false, (15, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setFocusEffect_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setFocusGroupIdentifier:
  set focusGroupIdentifier(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'UIView.setFocusGroupIdentifier:',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setFocusGroupIdentifier_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setFocusGroupPriority:
  set focusGroupPriority(int value) {
    objc.checkOsVersionInternal(
      'UIView.setFocusGroupPriority:',
      iOS: (false, (15, 0, 0)),
    );
    _objc_msgSend_4sp4xj(
      object$.ref.pointer,
      _sel_setFocusGroupPriority_,
      value,
    );
  }

  /// setNeedsFocusUpdate
  void setNeedsFocusUpdate() {
    objc.checkOsVersionInternal(
      'UIView.setNeedsFocusUpdate',
      iOS: (false, (9, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_setNeedsFocusUpdate);
  }

  /// setSemanticContentAttribute:
  set semanticContentAttribute(UISemanticContentAttribute value) {
    objc.checkOsVersionInternal(
      'UIView.setSemanticContentAttribute:',
      iOS: (false, (9, 0, 0)),
    );
    _objc_msgSend_162qwxu(
      object$.ref.pointer,
      _sel_setSemanticContentAttribute_,
      value.value,
    );
  }

  /// setTag:
  set tag(int value) {
    objc.checkOsVersionInternal('UIView.setTag:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_4sp4xj(object$.ref.pointer, _sel_setTag_, value);
  }

  /// setTransform:
  set transform(CGAffineTransform value) {
    _objc_msgSend_qgt66z(object$.ref.pointer, _sel_setTransform_, value);
  }

  /// setUserInteractionEnabled:
  set isUserInteractionEnabled(bool value) {
    objc.checkOsVersionInternal(
      'UIView.setUserInteractionEnabled:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setUserInteractionEnabled_,
      value,
    );
  }

  /// shouldUpdateFocusInContext:
  bool shouldUpdateFocusInContext(UIFocusUpdateContext context) {
    objc.checkOsVersionInternal(
      'UIView.shouldUpdateFocusInContext:',
      iOS: (false, (9, 0, 0)),
    );
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_shouldUpdateFocusInContext_,
      context.ref.pointer,
    );
  }

  /// soundIdentifierForFocusUpdateInContext:
  objc.NSString? soundIdentifierForFocusUpdateInContext(
    UIFocusUpdateContext context,
  ) {
    objc.checkOsVersionInternal(
      'UIView.soundIdentifierForFocusUpdateInContext:',
      iOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_soundIdentifierForFocusUpdateInContext_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UIView',
        'soundIdentifierForFocusUpdateInContext:',
      );
    }
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_soundIdentifierForFocusUpdateInContext_,
      context.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// tag
  int get tag {
    objc.checkOsVersionInternal('UIView.tag', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_tag);
  }

  /// traitCollection
  UITraitCollection get traitCollection {
    objc.checkOsVersionInternal(
      'UIView.traitCollection',
      iOS: (false, (8, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_traitCollection,
    );
    return UITraitCollection.fromPointer($ret, retain: true, release: true);
  }

  /// traitCollectionDidChange:
  void traitCollectionDidChange(UITraitCollection? previousTraitCollection) {
    objc.checkOsVersionInternal(
      'UIView.traitCollectionDidChange:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_traitCollectionDidChange_,
      previousTraitCollection?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// traitOverrides
  UITraitOverrides get traitOverrides {
    objc.checkOsVersionInternal(
      'UIView.traitOverrides',
      iOS: (false, (17, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_traitOverrides,
    );
    return UITraitOverrides.fromPointer($ret, retain: true, release: true);
  }

  /// transform
  CGAffineTransform get transform {
    final $ptr = pkg_ffi.calloc<CGAffineTransform>();
    objc.useMsgSendVariants
        ? _objc_msgSend_5qswvjStret($ptr, object$.ref.pointer, _sel_transform)
        : $ptr.ref = _objc_msgSend_5qswvj(object$.ref.pointer, _sel_transform);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<CGAffineTransform>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<CGAffineTransform>($finalizable);
  }

  /// updateFocusIfNeeded
  void updateFocusIfNeeded() {
    objc.checkOsVersionInternal(
      'UIView.updateFocusIfNeeded',
      iOS: (false, (9, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_updateFocusIfNeeded);
  }

  /// updateTraitsIfNeeded
  void updateTraitsIfNeeded() {
    objc.checkOsVersionInternal(
      'UIView.updateTraitsIfNeeded',
      iOS: (false, (17, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_updateTraitsIfNeeded);
  }
}

late final _sel_inputView = objc.registerName("inputView");
late final _sel_inputAccessoryView = objc.registerName("inputAccessoryView");

/// WARNING: UITextInputAssistantItem is a stub. To generate bindings for this class, include
/// UITextInputAssistantItem in your config's objc-interfaces list.
///
/// UITextInputAssistantItem
extension type UITextInputAssistantItem._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [UITextInputAssistantItem] that points to the same underlying object as [other].
  UITextInputAssistantItem.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UITextInputAssistantItem',
      iOS: (false, (9, 0, 0)),
    );
  }

  /// Constructs a [UITextInputAssistantItem] that wraps the given raw object pointer.
  UITextInputAssistantItem.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UITextInputAssistantItem',
      iOS: (false, (9, 0, 0)),
    );
  }
}

late final _sel_inputAssistantItem = objc.registerName("inputAssistantItem");

/// WARNING: UIInputViewController is a stub. To generate bindings for this class, include
/// UIInputViewController in your config's objc-interfaces list.
///
/// UIInputViewController
extension type UIInputViewController._(objc.ObjCObject object$)
    implements objc.ObjCObject, UIViewController, UITextInputDelegate {
  /// Constructs a [UIInputViewController] that points to the same underlying object as [other].
  UIInputViewController.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UIInputViewController',
      iOS: (false, (8, 0, 0)),
    );
  }

  /// Constructs a [UIInputViewController] that wraps the given raw object pointer.
  UIInputViewController.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UIInputViewController',
      iOS: (false, (8, 0, 0)),
    );
  }
}

late final _sel_inputViewController = objc.registerName("inputViewController");
late final _sel_inputAccessoryViewController = objc.registerName(
  "inputAccessoryViewController",
);

/// WARNING: UITextInputMode is a stub. To generate bindings for this class, include
/// UITextInputMode in your config's objc-interfaces list.
///
/// UITextInputMode
extension type UITextInputMode._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSSecureCoding {
  /// Constructs a [UITextInputMode] that points to the same underlying object as [other].
  UITextInputMode.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UITextInputMode', iOS: (false, (4, 2, 0)));
  }

  /// Constructs a [UITextInputMode] that wraps the given raw object pointer.
  UITextInputMode.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITextInputMode', iOS: (false, (4, 2, 0)));
  }
}

late final _sel_textInputMode = objc.registerName("textInputMode");
late final _sel_textInputContextIdentifier = objc.registerName(
  "textInputContextIdentifier",
);
late final _sel_clearTextInputContextIdentifier_ = objc.registerName(
  "clearTextInputContextIdentifier:",
);
late final _sel_reloadInputViews = objc.registerName("reloadInputViews");

/// UIResponderInputViewAdditions
extension UIResponderInputViewAdditions on UIResponder {
  /// inputAccessoryView
  UIView? get inputAccessoryView {
    objc.checkOsVersionInternal(
      'UIResponder.inputAccessoryView',
      iOS: (false, (3, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_inputAccessoryView,
    );
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }

  /// inputAccessoryViewController
  UIInputViewController? get inputAccessoryViewController {
    objc.checkOsVersionInternal(
      'UIResponder.inputAccessoryViewController',
      iOS: (false, (8, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_inputAccessoryViewController,
    );
    return $ret.address == 0
        ? null
        : UIInputViewController.fromPointer($ret, retain: true, release: true);
  }

  /// inputAssistantItem
  UITextInputAssistantItem get inputAssistantItem {
    objc.checkOsVersionInternal(
      'UIResponder.inputAssistantItem',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_inputAssistantItem,
    );
    return UITextInputAssistantItem.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// inputView
  UIView? get inputView {
    objc.checkOsVersionInternal(
      'UIResponder.inputView',
      iOS: (false, (3, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_inputView);
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }

  /// inputViewController
  UIInputViewController? get inputViewController {
    objc.checkOsVersionInternal(
      'UIResponder.inputViewController',
      iOS: (false, (8, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_inputViewController,
    );
    return $ret.address == 0
        ? null
        : UIInputViewController.fromPointer($ret, retain: true, release: true);
  }

  /// reloadInputViews
  void reloadInputViews() {
    objc.checkOsVersionInternal(
      'UIResponder.reloadInputViews',
      iOS: (false, (3, 2, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_reloadInputViews);
  }

  /// textInputContextIdentifier
  objc.NSString? get textInputContextIdentifier {
    objc.checkOsVersionInternal(
      'UIResponder.textInputContextIdentifier',
      iOS: (false, (7, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_textInputContextIdentifier,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// textInputMode
  UITextInputMode? get textInputMode {
    objc.checkOsVersionInternal(
      'UIResponder.textInputMode',
      iOS: (false, (7, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textInputMode);
    return $ret.address == 0
        ? null
        : UITextInputMode.fromPointer($ret, retain: true, release: true);
  }

  /// clearTextInputContextIdentifier:
  static void clearTextInputContextIdentifier(objc.NSString identifier) {
    objc.checkOsVersionInternal(
      'UIResponder.clearTextInputContextIdentifier:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      _class_UIResponder,
      _sel_clearTextInputContextIdentifier_,
      identifier.ref.pointer,
    );
  }
}

late final _sel_userActivity = objc.registerName("userActivity");
late final _sel_setUserActivity_ = objc.registerName("setUserActivity:");
late final _sel_updateUserActivityState_ = objc.registerName(
  "updateUserActivityState:",
);
late final _sel_restoreUserActivityState_ = objc.registerName(
  "restoreUserActivityState:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSUserActivity {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, NSUserActivity) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                NSUserActivity.fromPointer(arg1, retain: true, release: true),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, NSUserActivity) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        NSUserActivity.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, NSUserActivity) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        NSUserActivity.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        NSUserActivity.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSUserActivity$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, NSUserActivity arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// ActivityContinuation
extension ActivityContinuation on UIResponder {
  /// restoreUserActivityState:
  void restoreUserActivityState(NSUserActivity userActivity) {
    objc.checkOsVersionInternal(
      'UIResponder.restoreUserActivityState:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_restoreUserActivityState_,
      userActivity.ref.pointer,
    );
  }

  /// setUserActivity:
  set userActivity(NSUserActivity? value) {
    objc.checkOsVersionInternal(
      'UIResponder.setUserActivity:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setUserActivity_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// updateUserActivityState:
  void updateUserActivityState(NSUserActivity activity) {
    objc.checkOsVersionInternal(
      'UIResponder.updateUserActivityState:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_updateUserActivityState_,
      activity.ref.pointer,
    );
  }

  /// userActivity
  NSUserActivity? get userActivity {
    objc.checkOsVersionInternal(
      'UIResponder.userActivity',
      iOS: (false, (8, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_userActivity);
    return $ret.address == 0
        ? null
        : NSUserActivity.fromPointer($ret, retain: true, release: true);
  }
}

/// WARNING: UIPasteConfiguration is a stub. To generate bindings for this class, include
/// UIPasteConfiguration in your config's objc-interfaces list.
///
/// UIPasteConfiguration
extension type UIPasteConfiguration._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSSecureCoding,
        objc.NSCopying {
  /// Constructs a [UIPasteConfiguration] that points to the same underlying object as [other].
  UIPasteConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UIPasteConfiguration',
      iOS: (false, (11, 0, 0)),
    );
  }

  /// Constructs a [UIPasteConfiguration] that wraps the given raw object pointer.
  UIPasteConfiguration.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UIPasteConfiguration',
      iOS: (false, (11, 0, 0)),
    );
  }
}

late final _sel_pasteConfiguration = objc.registerName("pasteConfiguration");

/// Construction methods for `objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIPasteConfiguration_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) =>
          fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIPasteConfiguration_ffiVoid$CallExtension
    on objc.ObjCBlock<UIPasteConfiguration? Function(ffi.Pointer<ffi.Void>)> {
  UIPasteConfiguration? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIPasteConfiguration.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_setPasteConfiguration_ = objc.registerName(
  "setPasteConfiguration:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                arg1.address == 0
                    ? null
                    : UIPasteConfiguration.fromPointer(
                        arg1,
                        retain: true,
                        release: true,
                      ),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : UIPasteConfiguration.fromPointer(
                arg1,
                retain: false,
                release: true,
              ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : UIPasteConfiguration.fromPointer(
                arg1,
                retain: false,
                release: true,
              ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : UIPasteConfiguration.fromPointer(
                arg1,
                retain: false,
                release: true,
              ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIPasteConfiguration$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, UIPasteConfiguration?)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, UIPasteConfiguration? arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_pasteItemProviders_ = objc.registerName("pasteItemProviders:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, objc.NSArray.fromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSArray.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSArray.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSArray.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSArray$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSArray)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSArray arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_canPasteItemProviders_ = objc.registerName(
  "canPasteItemProviders:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
abstract final class ObjCBlock_bool_ffiVoid_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>
  fromFunction(
    bool Function(ffi.Pointer<ffi.Void>, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, objc.NSArray.fromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as bool Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
extension ObjCBlock_bool_ffiVoid_NSArray$CallExtension
    on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, objc.NSArray)> {
  bool call(ffi.Pointer<ffi.Void> arg0, objc.NSArray arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// UIPasteConfigurationSupporting
extension UIPasteConfigurationSupporting on UIResponder {
  /// canPasteItemProviders:
  bool canPasteItemProviders(objc.NSArray itemProviders) {
    objc.checkOsVersionInternal(
      'UIResponder.canPasteItemProviders:',
      iOS: (false, (11, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_canPasteItemProviders_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'canPasteItemProviders:',
      );
    }
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_canPasteItemProviders_,
      itemProviders.ref.pointer,
    );
  }

  /// pasteConfiguration
  UIPasteConfiguration? get pasteConfiguration {
    objc.checkOsVersionInternal(
      'UIResponder.pasteConfiguration',
      iOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_pasteConfiguration,
    );
    return $ret.address == 0
        ? null
        : UIPasteConfiguration.fromPointer($ret, retain: true, release: true);
  }

  /// pasteItemProviders:
  void pasteItemProviders(objc.NSArray itemProviders) {
    objc.checkOsVersionInternal(
      'UIResponder.pasteItemProviders:',
      iOS: (false, (11, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_pasteItemProviders_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'pasteItemProviders:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_pasteItemProviders_,
      itemProviders.ref.pointer,
    );
  }

  /// setPasteConfiguration:
  set pasteConfiguration(UIPasteConfiguration? value) {
    objc.checkOsVersionInternal(
      'UIResponder.setPasteConfiguration:',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setPasteConfiguration_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }
}

late final _sel_captureTextFromCamera_ = objc.registerName(
  "captureTextFromCamera:",
);

/// UICaptureTextFromCameraSupporting
extension UICaptureTextFromCameraSupporting on UIResponder {
  /// captureTextFromCamera:
  void captureTextFromCamera(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.captureTextFromCamera:',
      iOS: (false, (15, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_captureTextFromCamera_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }
}

/// WARNING: UIActivityItemsConfigurationReading is a stub. To generate bindings for this class, include
/// UIActivityItemsConfigurationReading in your config's objc-protocols list.
///
/// UIActivityItemsConfigurationReading
extension type UIActivityItemsConfigurationReading._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIActivityItemsConfigurationReading] that points to the same underlying object as [other].
  UIActivityItemsConfigurationReading.as(objc.ObjCObject other)
    : object$ = other;

  /// Constructs a [UIActivityItemsConfigurationReading] that wraps the given raw object pointer.
  UIActivityItemsConfigurationReading.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_activityItemsConfiguration = objc.registerName(
  "activityItemsConfiguration",
);

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUIActivityItemsConfigurationReading_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
  >
  fromFunction(
    UIActivityItemsConfigurationReading? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0) =>
              fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUIActivityItemsConfigurationReading_ffiVoid$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
        > {
  UIActivityItemsConfigurationReading? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIActivityItemsConfigurationReading.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_setActivityItemsConfiguration_ = objc.registerName(
  "setActivityItemsConfiguration:",
);

/// WARNING: UIActivityItemsConfigurationProviding is a stub. To generate bindings for this class, include
/// UIActivityItemsConfigurationProviding in your config's objc-protocols list.
///
/// UIActivityItemsConfigurationProviding
extension type UIActivityItemsConfigurationProviding._(
  objc.ObjCProtocol object$
)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIActivityItemsConfigurationProviding] that points to the same underlying object as [other].
  UIActivityItemsConfigurationProviding.as(objc.ObjCObject other)
    : object$ = other;

  /// Constructs a [UIActivityItemsConfigurationProviding] that wraps the given raw object pointer.
  UIActivityItemsConfigurationProviding.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// UIActivityItemsConfiguration
extension UIActivityItemsConfiguration on UIResponder {
  /// activityItemsConfiguration
  UIActivityItemsConfigurationReading? get activityItemsConfiguration {
    objc.checkOsVersionInternal(
      'UIResponder.activityItemsConfiguration',
      iOS: (false, (15, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_activityItemsConfiguration,
    );
    return $ret.address == 0
        ? null
        : UIActivityItemsConfigurationReading.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// setActivityItemsConfiguration:
  set activityItemsConfiguration$1(UIActivityItemsConfigurationReading? value) {
    objc.checkOsVersionInternal(
      'UIResponder.setActivityItemsConfiguration:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setActivityItemsConfiguration_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }
}

/// UIResponder
extension type UIResponder._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, UIResponderStandardEditActions {
  /// Constructs a [UIResponder] that points to the same underlying object as [other].
  UIResponder.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIResponder', iOS: (false, (2, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UIResponder] that wraps the given raw object pointer.
  UIResponder.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIResponder', iOS: (false, (2, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UIResponder].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_UIResponder,
  );

  /// alloc
  static UIResponder alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIResponder, _sel_alloc);
    return UIResponder.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIResponder allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_UIResponder,
      _sel_allocWithZone_,
      zone,
    );
    return UIResponder.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static UIResponder new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIResponder, _sel_new);
    return UIResponder.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of UIResponder constructed with the default `new` method.
  UIResponder() : this.as(new$().object$);
}

extension UIResponder$Methods on UIResponder {
  /// alignCenter:
  void alignCenter(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.alignCenter:',
      iOS: (false, (26, 0, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_alignCenter_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'alignCenter:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_alignCenter_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// alignJustified:
  void alignJustified(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.alignJustified:',
      iOS: (false, (26, 0, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_alignJustified_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'alignJustified:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_alignJustified_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// alignLeft:
  void alignLeft(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.alignLeft:',
      iOS: (false, (26, 0, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_alignLeft_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'alignLeft:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_alignLeft_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// alignRight:
  void alignRight(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.alignRight:',
      iOS: (false, (26, 0, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_alignRight_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'alignRight:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_alignRight_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// becomeFirstResponder
  bool becomeFirstResponder() {
    objc.checkOsVersionInternal(
      'UIResponder.becomeFirstResponder',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_becomeFirstResponder);
  }

  /// buildMenuWithBuilder:
  void buildMenuWithBuilder(UIMenuBuilder builder) {
    objc.checkOsVersionInternal(
      'UIResponder.buildMenuWithBuilder:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_buildMenuWithBuilder_,
      builder.ref.pointer,
    );
  }

  /// canBecomeFirstResponder
  bool get canBecomeFirstResponder {
    objc.checkOsVersionInternal(
      'UIResponder.canBecomeFirstResponder',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_canBecomeFirstResponder,
    );
  }

  /// canPerformAction:withSender:
  bool canPerformAction(
    ffi.Pointer<objc.ObjCSelector> action, {
    objc.ObjCObject? withSender,
  }) {
    objc.checkOsVersionInternal(
      'UIResponder.canPerformAction:withSender:',
      iOS: (false, (3, 0, 0)),
    );
    return _objc_msgSend_1f04296(
      object$.ref.pointer,
      _sel_canPerformAction_withSender_,
      action,
      withSender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// canResignFirstResponder
  bool get canResignFirstResponder {
    objc.checkOsVersionInternal(
      'UIResponder.canResignFirstResponder',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_canResignFirstResponder,
    );
  }

  /// copy:
  void copy$1(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('UIResponder.copy:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_copy_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'copy:');
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_copy_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// cut:
  void cut(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('UIResponder.cut:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_cut_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'cut:');
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_cut_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// decreaseSize:
  void decreaseSize(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.decreaseSize:',
      iOS: (false, (7, 0, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_decreaseSize_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'decreaseSize:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_decreaseSize_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// delete:
  void delete(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('UIResponder.delete:', iOS: (false, (3, 2, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_delete_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'delete:');
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_delete_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// duplicate:
  void duplicate(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.duplicate:',
      iOS: (false, (16, 0, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_duplicate_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'duplicate:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_duplicate_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// editingInteractionConfiguration
  UIEditingInteractionConfiguration get editingInteractionConfiguration {
    objc.checkOsVersionInternal(
      'UIResponder.editingInteractionConfiguration',
      iOS: (false, (13, 0, 0)),
    );
    final $ret = _objc_msgSend_15pfzxv(
      object$.ref.pointer,
      _sel_editingInteractionConfiguration,
    );
    return UIEditingInteractionConfiguration.fromValue($ret);
  }

  /// export:
  void export(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.export:',
      iOS: (false, (16, 0, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_export_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'export:');
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_export_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// find:
  void find(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('UIResponder.find:', iOS: (false, (16, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_find_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'find:');
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_find_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// findAndReplace:
  void findAndReplace(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.findAndReplace:',
      iOS: (false, (16, 0, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_findAndReplace_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'findAndReplace:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_findAndReplace_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// findNext:
  void findNext(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.findNext:',
      iOS: (false, (16, 0, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_findNext_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'findNext:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_findNext_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// findPrevious:
  void findPrevious(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.findPrevious:',
      iOS: (false, (16, 0, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_findPrevious_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'findPrevious:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_findPrevious_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// increaseSize:
  void increaseSize(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.increaseSize:',
      iOS: (false, (7, 0, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_increaseSize_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'increaseSize:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_increaseSize_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// init
  UIResponder init() {
    objc.checkOsVersionInternal(
      'UIResponder.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return UIResponder.fromPointer($ret, retain: false, release: true);
  }

  /// isFirstResponder
  bool get isFirstResponder {
    objc.checkOsVersionInternal(
      'UIResponder.isFirstResponder',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isFirstResponder);
  }

  /// makeTextWritingDirectionLeftToRight:
  void makeTextWritingDirectionLeftToRight(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.makeTextWritingDirectionLeftToRight:',
      iOS: (false, (5, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_makeTextWritingDirectionLeftToRight_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'makeTextWritingDirectionLeftToRight:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_makeTextWritingDirectionLeftToRight_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// makeTextWritingDirectionRightToLeft:
  void makeTextWritingDirectionRightToLeft(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.makeTextWritingDirectionRightToLeft:',
      iOS: (false, (5, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_makeTextWritingDirectionRightToLeft_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'makeTextWritingDirectionRightToLeft:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_makeTextWritingDirectionRightToLeft_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// motionBegan:withEvent:
  void motionBegan(UIEventSubtype motion, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal(
      'UIResponder.motionBegan:withEvent:',
      iOS: (false, (3, 0, 0)),
    );
    _objc_msgSend_pov02z(
      object$.ref.pointer,
      _sel_motionBegan_withEvent_,
      motion.value,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// motionCancelled:withEvent:
  void motionCancelled(UIEventSubtype motion, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal(
      'UIResponder.motionCancelled:withEvent:',
      iOS: (false, (3, 0, 0)),
    );
    _objc_msgSend_pov02z(
      object$.ref.pointer,
      _sel_motionCancelled_withEvent_,
      motion.value,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// motionEnded:withEvent:
  void motionEnded(UIEventSubtype motion, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal(
      'UIResponder.motionEnded:withEvent:',
      iOS: (false, (3, 0, 0)),
    );
    _objc_msgSend_pov02z(
      object$.ref.pointer,
      _sel_motionEnded_withEvent_,
      motion.value,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// move:
  void move(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('UIResponder.move:', iOS: (false, (16, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_move_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'move:');
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_move_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// newFromPasteboard:
  void newFromPasteboard(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.newFromPasteboard:',
      iOS: (false, (26, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_newFromPasteboard_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'newFromPasteboard:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_newFromPasteboard_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// nextResponder
  UIResponder? get nextResponder {
    objc.checkOsVersionInternal(
      'UIResponder.nextResponder',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_nextResponder);
    return $ret.address == 0
        ? null
        : UIResponder.fromPointer($ret, retain: true, release: true);
  }

  /// paste:
  void paste(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('UIResponder.paste:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_paste_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'paste:');
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_paste_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// pasteAndGo:
  void pasteAndGo(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.pasteAndGo:',
      iOS: (false, (15, 0, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_pasteAndGo_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'pasteAndGo:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_pasteAndGo_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// pasteAndMatchStyle:
  void pasteAndMatchStyle(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.pasteAndMatchStyle:',
      iOS: (false, (15, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_pasteAndMatchStyle_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'pasteAndMatchStyle:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_pasteAndMatchStyle_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// pasteAndSearch:
  void pasteAndSearch(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.pasteAndSearch:',
      iOS: (false, (15, 0, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_pasteAndSearch_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'pasteAndSearch:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_pasteAndSearch_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// performClose:
  void performClose(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.performClose:',
      iOS: (false, (26, 0, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_performClose_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'performClose:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_performClose_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// pressesBegan:withEvent:
  void pressesBegan(objc.NSSet presses, {UIPressesEvent? withEvent}) {
    objc.checkOsVersionInternal(
      'UIResponder.pressesBegan:withEvent:',
      iOS: (false, (9, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_pressesBegan_withEvent_,
      presses.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// pressesCancelled:withEvent:
  void pressesCancelled(objc.NSSet presses, {UIPressesEvent? withEvent}) {
    objc.checkOsVersionInternal(
      'UIResponder.pressesCancelled:withEvent:',
      iOS: (false, (9, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_pressesCancelled_withEvent_,
      presses.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// pressesChanged:withEvent:
  void pressesChanged(objc.NSSet presses, {UIPressesEvent? withEvent}) {
    objc.checkOsVersionInternal(
      'UIResponder.pressesChanged:withEvent:',
      iOS: (false, (9, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_pressesChanged_withEvent_,
      presses.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// pressesEnded:withEvent:
  void pressesEnded(objc.NSSet presses, {UIPressesEvent? withEvent}) {
    objc.checkOsVersionInternal(
      'UIResponder.pressesEnded:withEvent:',
      iOS: (false, (9, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_pressesEnded_withEvent_,
      presses.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// print:
  void print(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('UIResponder.print:', iOS: (false, (15, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_print_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'print:');
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_print_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// providerForDeferredMenuElement:
  UIDeferredMenuElementProvider? providerForDeferredMenuElement(
    UIDeferredMenuElement deferredElement,
  ) {
    objc.checkOsVersionInternal(
      'UIResponder.providerForDeferredMenuElement:',
      iOS: (false, (26, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_providerForDeferredMenuElement_,
      deferredElement.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : UIDeferredMenuElementProvider.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// remoteControlReceivedWithEvent:
  void remoteControlReceivedWithEvent(UIEvent? event) {
    objc.checkOsVersionInternal(
      'UIResponder.remoteControlReceivedWithEvent:',
      iOS: (false, (4, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_remoteControlReceivedWithEvent_,
      event?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// rename:
  void rename(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.rename:',
      iOS: (false, (16, 0, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_rename_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'rename:');
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_rename_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// resignFirstResponder
  bool resignFirstResponder() {
    objc.checkOsVersionInternal(
      'UIResponder.resignFirstResponder',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_resignFirstResponder);
  }

  /// select:
  void select(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal('UIResponder.select:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_select_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'select:');
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_select_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// selectAll:
  void selectAll(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.selectAll:',
      iOS: (false, (3, 0, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_selectAll_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'selectAll:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_selectAll_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// showWritingTools:
  void showWritingTools(objc.ObjCObject sender) {
    objc.checkOsVersionInternal(
      'UIResponder.showWritingTools:',
      iOS: (false, (18, 2, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_showWritingTools_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'showWritingTools:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_showWritingTools_,
      sender.ref.pointer,
    );
  }

  /// targetForAction:withSender:
  objc.ObjCObject? targetForAction(
    ffi.Pointer<objc.ObjCSelector> action, {
    objc.ObjCObject? withSender,
  }) {
    objc.checkOsVersionInternal(
      'UIResponder.targetForAction:withSender:',
      iOS: (false, (7, 0, 0)),
    );
    final $ret = _objc_msgSend_gx50so(
      object$.ref.pointer,
      _sel_targetForAction_withSender_,
      action,
      withSender?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// toggleBoldface:
  void toggleBoldface(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.toggleBoldface:',
      iOS: (false, (6, 0, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_toggleBoldface_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'toggleBoldface:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_toggleBoldface_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// toggleInspector:
  void toggleInspector(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.toggleInspector:',
      iOS: (false, (26, 0, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_toggleInspector_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'toggleInspector:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_toggleInspector_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// toggleItalics:
  void toggleItalics(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.toggleItalics:',
      iOS: (false, (6, 0, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_toggleItalics_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'toggleItalics:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_toggleItalics_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// toggleSidebar:
  void toggleSidebar(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.toggleSidebar:',
      iOS: (false, (15, 0, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_toggleSidebar_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'toggleSidebar:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_toggleSidebar_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// toggleUnderline:
  void toggleUnderline(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.toggleUnderline:',
      iOS: (false, (6, 0, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_toggleUnderline_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'toggleUnderline:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_toggleUnderline_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// touchesBegan:withEvent:
  void touchesBegan(objc.NSSet touches, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal(
      'UIResponder.touchesBegan:withEvent:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_touchesBegan_withEvent_,
      touches.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// touchesCancelled:withEvent:
  void touchesCancelled(objc.NSSet touches, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal(
      'UIResponder.touchesCancelled:withEvent:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_touchesCancelled_withEvent_,
      touches.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// touchesEnded:withEvent:
  void touchesEnded(objc.NSSet touches, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal(
      'UIResponder.touchesEnded:withEvent:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_touchesEnded_withEvent_,
      touches.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// touchesEstimatedPropertiesUpdated:
  void touchesEstimatedPropertiesUpdated(objc.NSSet touches) {
    objc.checkOsVersionInternal(
      'UIResponder.touchesEstimatedPropertiesUpdated:',
      iOS: (false, (9, 1, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_touchesEstimatedPropertiesUpdated_,
      touches.ref.pointer,
    );
  }

  /// touchesMoved:withEvent:
  void touchesMoved(objc.NSSet touches, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal(
      'UIResponder.touchesMoved:withEvent:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_touchesMoved_withEvent_,
      touches.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// undoManager
  NSUndoManager? get undoManager {
    objc.checkOsVersionInternal(
      'UIResponder.undoManager',
      iOS: (false, (3, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_undoManager);
    return $ret.address == 0
        ? null
        : NSUndoManager.fromPointer($ret, retain: true, release: true);
  }

  /// updateTextAttributesWithConversionHandler:
  void updateTextAttributesWithConversionHandler(
    objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>
    conversionHandler,
  ) {
    objc.checkOsVersionInternal(
      'UIResponder.updateTextAttributesWithConversionHandler:',
      iOS: (false, (13, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_updateTextAttributesWithConversionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'updateTextAttributesWithConversionHandler:',
      );
    }
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_updateTextAttributesWithConversionHandler_,
      conversionHandler.ref.pointer,
    );
  }

  /// useSelectionForFind:
  void useSelectionForFind(objc.ObjCObject? sender) {
    objc.checkOsVersionInternal(
      'UIResponder.useSelectionForFind:',
      iOS: (false, (16, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_useSelectionForFind_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UIResponder',
        'useSelectionForFind:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_useSelectionForFind_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// validateCommand:
  void validateCommand(UICommand command) {
    objc.checkOsVersionInternal(
      'UIResponder.validateCommand:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_validateCommand_,
      command.ref.pointer,
    );
  }
}

enum UIBarStyle {
  UIBarStyleDefault(0),
  UIBarStyleBlack(1),
  UIBarStyleBlackTranslucent(2);

  static const UIBarStyleBlackOpaque = UIBarStyleBlack;

  final int value;
  const UIBarStyle(this.value);

  static UIBarStyle fromValue(int value) => switch (value) {
    0 => UIBarStyleDefault,
    1 => UIBarStyleBlack,
    2 => UIBarStyleBlackTranslucent,
    _ => throw ArgumentError('Unknown value for UIBarStyle: $value'),
  };

  @override
  String toString() {
    if (this == UIBarStyleBlack)
      return "UIBarStyle.UIBarStyleBlack, UIBarStyle.UIBarStyleBlackOpaque";
    return super.toString();
  }
}

enum UIUserInterfaceSizeClass {
  UIUserInterfaceSizeClassUnspecified(0),
  UIUserInterfaceSizeClassCompact(1),
  UIUserInterfaceSizeClassRegular(2);

  final int value;
  const UIUserInterfaceSizeClass(this.value);

  static UIUserInterfaceSizeClass fromValue(int value) => switch (value) {
    0 => UIUserInterfaceSizeClassUnspecified,
    1 => UIUserInterfaceSizeClassCompact,
    2 => UIUserInterfaceSizeClassRegular,
    _ => throw ArgumentError(
      'Unknown value for UIUserInterfaceSizeClass: $value',
    ),
  };
}

enum UITraitEnvironmentLayoutDirection {
  UITraitEnvironmentLayoutDirectionUnspecified(-1),
  UITraitEnvironmentLayoutDirectionLeftToRight(0),
  UITraitEnvironmentLayoutDirectionRightToLeft(1);

  final int value;
  const UITraitEnvironmentLayoutDirection(this.value);

  static UITraitEnvironmentLayoutDirection fromValue(int value) =>
      switch (value) {
        -1 => UITraitEnvironmentLayoutDirectionUnspecified,
        0 => UITraitEnvironmentLayoutDirectionLeftToRight,
        1 => UITraitEnvironmentLayoutDirectionRightToLeft,
        _ => throw ArgumentError(
          'Unknown value for UITraitEnvironmentLayoutDirection: $value',
        ),
      };
}

enum UIDisplayGamut {
  UIDisplayGamutUnspecified(-1),
  UIDisplayGamutSRGB(0),
  UIDisplayGamutP3(1);

  final int value;
  const UIDisplayGamut(this.value);

  static UIDisplayGamut fromValue(int value) => switch (value) {
    -1 => UIDisplayGamutUnspecified,
    0 => UIDisplayGamutSRGB,
    1 => UIDisplayGamutP3,
    _ => throw ArgumentError('Unknown value for UIDisplayGamut: $value'),
  };
}

enum UIAccessibilityContrast {
  UIAccessibilityContrastUnspecified(-1),
  UIAccessibilityContrastNormal(0),
  UIAccessibilityContrastHigh(1);

  final int value;
  const UIAccessibilityContrast(this.value);

  static UIAccessibilityContrast fromValue(int value) => switch (value) {
    -1 => UIAccessibilityContrastUnspecified,
    0 => UIAccessibilityContrastNormal,
    1 => UIAccessibilityContrastHigh,
    _ => throw ArgumentError(
      'Unknown value for UIAccessibilityContrast: $value',
    ),
  };
}

enum UILegibilityWeight {
  UILegibilityWeightUnspecified(-1),
  UILegibilityWeightRegular(0),
  UILegibilityWeightBold(1);

  final int value;
  const UILegibilityWeight(this.value);

  static UILegibilityWeight fromValue(int value) => switch (value) {
    -1 => UILegibilityWeightUnspecified,
    0 => UILegibilityWeightRegular,
    1 => UILegibilityWeightBold,
    _ => throw ArgumentError('Unknown value for UILegibilityWeight: $value'),
  };
}

enum UIUserInterfaceLevel {
  UIUserInterfaceLevelUnspecified(-1),
  UIUserInterfaceLevelBase(0),
  UIUserInterfaceLevelElevated(1);

  final int value;
  const UIUserInterfaceLevel(this.value);

  static UIUserInterfaceLevel fromValue(int value) => switch (value) {
    -1 => UIUserInterfaceLevelUnspecified,
    0 => UIUserInterfaceLevelBase,
    1 => UIUserInterfaceLevelElevated,
    _ => throw ArgumentError('Unknown value for UIUserInterfaceLevel: $value'),
  };
}

enum UIUserInterfaceActiveAppearance {
  UIUserInterfaceActiveAppearanceUnspecified(-1),
  UIUserInterfaceActiveAppearanceInactive(0),
  UIUserInterfaceActiveAppearanceActive(1);

  final int value;
  const UIUserInterfaceActiveAppearance(this.value);

  static UIUserInterfaceActiveAppearance fromValue(int value) =>
      switch (value) {
        -1 => UIUserInterfaceActiveAppearanceUnspecified,
        0 => UIUserInterfaceActiveAppearanceInactive,
        1 => UIUserInterfaceActiveAppearanceActive,
        _ => throw ArgumentError(
          'Unknown value for UIUserInterfaceActiveAppearance: $value',
        ),
      };
}

enum UINSToolbarItemPresentationSize {
  UINSToolbarItemPresentationSizeUnspecified(-1),
  UINSToolbarItemPresentationSizeRegular(0),
  UINSToolbarItemPresentationSizeSmall(1),
  UINSToolbarItemPresentationSizeLarge(3);

  final int value;
  const UINSToolbarItemPresentationSize(this.value);

  static UINSToolbarItemPresentationSize fromValue(int value) =>
      switch (value) {
        -1 => UINSToolbarItemPresentationSizeUnspecified,
        0 => UINSToolbarItemPresentationSizeRegular,
        1 => UINSToolbarItemPresentationSizeSmall,
        3 => UINSToolbarItemPresentationSizeLarge,
        _ => throw ArgumentError(
          'Unknown value for UINSToolbarItemPresentationSize: $value',
        ),
      };
}

enum UIImageDynamicRange {
  UIImageDynamicRangeUnspecified(-1),
  UIImageDynamicRangeStandard(0),
  UIImageDynamicRangeConstrainedHigh(1),
  UIImageDynamicRangeHigh(2);

  final int value;
  const UIImageDynamicRange(this.value);

  static UIImageDynamicRange fromValue(int value) => switch (value) {
    -1 => UIImageDynamicRangeUnspecified,
    0 => UIImageDynamicRangeStandard,
    1 => UIImageDynamicRangeConstrainedHigh,
    2 => UIImageDynamicRangeHigh,
    _ => throw ArgumentError('Unknown value for UIImageDynamicRange: $value'),
  };
}

enum UIHDRHeadroomUsageLimit {
  UIHDRHeadroomUsageLimitUnspecified(-1),
  UIHDRHeadroomUsageLimitActive(0),
  UIHDRHeadroomUsageLimitInactive(1);

  final int value;
  const UIHDRHeadroomUsageLimit(this.value);

  static UIHDRHeadroomUsageLimit fromValue(int value) => switch (value) {
    -1 => UIHDRHeadroomUsageLimitUnspecified,
    0 => UIHDRHeadroomUsageLimitActive,
    1 => UIHDRHeadroomUsageLimitInactive,
    _ => throw ArgumentError(
      'Unknown value for UIHDRHeadroomUsageLimit: $value',
    ),
  };
}

enum NSLayoutRelation {
  NSLayoutRelationLessThanOrEqual(-1),
  NSLayoutRelationEqual(0),
  NSLayoutRelationGreaterThanOrEqual(1);

  final int value;
  const NSLayoutRelation(this.value);

  static NSLayoutRelation fromValue(int value) => switch (value) {
    -1 => NSLayoutRelationLessThanOrEqual,
    0 => NSLayoutRelationEqual,
    1 => NSLayoutRelationGreaterThanOrEqual,
    _ => throw ArgumentError('Unknown value for NSLayoutRelation: $value'),
  };
}

enum NSLayoutAttribute {
  NSLayoutAttributeLeft(1),
  NSLayoutAttributeRight(2),
  NSLayoutAttributeTop(3),
  NSLayoutAttributeBottom(4),
  NSLayoutAttributeLeading(5),
  NSLayoutAttributeTrailing(6),
  NSLayoutAttributeWidth(7),
  NSLayoutAttributeHeight(8),
  NSLayoutAttributeCenterX(9),
  NSLayoutAttributeCenterY(10),
  NSLayoutAttributeLastBaseline(11),
  NSLayoutAttributeFirstBaseline(12),
  NSLayoutAttributeLeftMargin(13),
  NSLayoutAttributeRightMargin(14),
  NSLayoutAttributeTopMargin(15),
  NSLayoutAttributeBottomMargin(16),
  NSLayoutAttributeLeadingMargin(17),
  NSLayoutAttributeTrailingMargin(18),
  NSLayoutAttributeCenterXWithinMargins(19),
  NSLayoutAttributeCenterYWithinMargins(20),
  NSLayoutAttributeNotAnAttribute(0);

  static const NSLayoutAttributeBaseline = NSLayoutAttributeLastBaseline;

  final int value;
  const NSLayoutAttribute(this.value);

  static NSLayoutAttribute fromValue(int value) => switch (value) {
    1 => NSLayoutAttributeLeft,
    2 => NSLayoutAttributeRight,
    3 => NSLayoutAttributeTop,
    4 => NSLayoutAttributeBottom,
    5 => NSLayoutAttributeLeading,
    6 => NSLayoutAttributeTrailing,
    7 => NSLayoutAttributeWidth,
    8 => NSLayoutAttributeHeight,
    9 => NSLayoutAttributeCenterX,
    10 => NSLayoutAttributeCenterY,
    11 => NSLayoutAttributeLastBaseline,
    12 => NSLayoutAttributeFirstBaseline,
    13 => NSLayoutAttributeLeftMargin,
    14 => NSLayoutAttributeRightMargin,
    15 => NSLayoutAttributeTopMargin,
    16 => NSLayoutAttributeBottomMargin,
    17 => NSLayoutAttributeLeadingMargin,
    18 => NSLayoutAttributeTrailingMargin,
    19 => NSLayoutAttributeCenterXWithinMargins,
    20 => NSLayoutAttributeCenterYWithinMargins,
    0 => NSLayoutAttributeNotAnAttribute,
    _ => throw ArgumentError('Unknown value for NSLayoutAttribute: $value'),
  };

  @override
  String toString() {
    if (this == NSLayoutAttributeLastBaseline)
      return "NSLayoutAttribute.NSLayoutAttributeLastBaseline, NSLayoutAttribute.NSLayoutAttributeBaseline";
    return super.toString();
  }
}

sealed class NSLayoutFormatOptions {
  static const NSLayoutFormatAlignAllLeft = 2;
  static const NSLayoutFormatAlignAllRight = 4;
  static const NSLayoutFormatAlignAllTop = 8;
  static const NSLayoutFormatAlignAllBottom = 16;
  static const NSLayoutFormatAlignAllLeading = 32;
  static const NSLayoutFormatAlignAllTrailing = 64;
  static const NSLayoutFormatAlignAllCenterX = 512;
  static const NSLayoutFormatAlignAllCenterY = 1024;
  static const NSLayoutFormatAlignAllLastBaseline = 2048;
  static const NSLayoutFormatAlignAllFirstBaseline = 4096;
  static const NSLayoutFormatAlignAllBaseline = 2048;
  static const NSLayoutFormatAlignmentMask = 65535;
  static const NSLayoutFormatDirectionLeadingToTrailing = 0;
  static const NSLayoutFormatDirectionLeftToRight = 65536;
  static const NSLayoutFormatDirectionRightToLeft = 131072;
  static const NSLayoutFormatDirectionMask = 196608;
  static const NSLayoutFormatSpacingEdgeToEdge = 0;
  static const NSLayoutFormatSpacingBaselineToBaseline = 524288;
  static const NSLayoutFormatSpacingMask = 524288;
}

enum UIInterfaceOrientation {
  UIInterfaceOrientationUnknown(0),
  UIInterfaceOrientationPortrait(1),
  UIInterfaceOrientationPortraitUpsideDown(2),
  UIInterfaceOrientationLandscapeLeft(4),
  UIInterfaceOrientationLandscapeRight(3);

  final int value;
  const UIInterfaceOrientation(this.value);

  static UIInterfaceOrientation fromValue(int value) => switch (value) {
    0 => UIInterfaceOrientationUnknown,
    1 => UIInterfaceOrientationPortrait,
    2 => UIInterfaceOrientationPortraitUpsideDown,
    4 => UIInterfaceOrientationLandscapeLeft,
    3 => UIInterfaceOrientationLandscapeRight,
    _ => throw ArgumentError(
      'Unknown value for UIInterfaceOrientation: $value',
    ),
  };
}

sealed class UIInterfaceOrientationMask {
  static const UIInterfaceOrientationMaskPortrait = 2;
  static const UIInterfaceOrientationMaskLandscapeLeft = 16;
  static const UIInterfaceOrientationMaskLandscapeRight = 8;
  static const UIInterfaceOrientationMaskPortraitUpsideDown = 4;
  static const UIInterfaceOrientationMaskLandscape = 24;
  static const UIInterfaceOrientationMaskAll = 30;
  static const UIInterfaceOrientationMaskAllButUpsideDown = 26;
}

enum UIUserInterfaceIdiom {
  UIUserInterfaceIdiomUnspecified(-1),
  UIUserInterfaceIdiomPhone(0),
  UIUserInterfaceIdiomPad(1),
  UIUserInterfaceIdiomTV(2),
  UIUserInterfaceIdiomCarPlay(3),
  UIUserInterfaceIdiomMac(5),
  UIUserInterfaceIdiomVision(6);

  final int value;
  const UIUserInterfaceIdiom(this.value);

  static UIUserInterfaceIdiom fromValue(int value) => switch (value) {
    -1 => UIUserInterfaceIdiomUnspecified,
    0 => UIUserInterfaceIdiomPhone,
    1 => UIUserInterfaceIdiomPad,
    2 => UIUserInterfaceIdiomTV,
    3 => UIUserInterfaceIdiomCarPlay,
    5 => UIUserInterfaceIdiomMac,
    6 => UIUserInterfaceIdiomVision,
    _ => throw ArgumentError('Unknown value for UIUserInterfaceIdiom: $value'),
  };
}

enum UITouchPhase {
  UITouchPhaseBegan(0),
  UITouchPhaseMoved(1),
  UITouchPhaseStationary(2),
  UITouchPhaseEnded(3),
  UITouchPhaseCancelled(4),
  UITouchPhaseRegionEntered(5),
  UITouchPhaseRegionMoved(6),
  UITouchPhaseRegionExited(7);

  final int value;
  const UITouchPhase(this.value);

  static UITouchPhase fromValue(int value) => switch (value) {
    0 => UITouchPhaseBegan,
    1 => UITouchPhaseMoved,
    2 => UITouchPhaseStationary,
    3 => UITouchPhaseEnded,
    4 => UITouchPhaseCancelled,
    5 => UITouchPhaseRegionEntered,
    6 => UITouchPhaseRegionMoved,
    7 => UITouchPhaseRegionExited,
    _ => throw ArgumentError('Unknown value for UITouchPhase: $value'),
  };
}

enum UIForceTouchCapability {
  UIForceTouchCapabilityUnknown(0),
  UIForceTouchCapabilityUnavailable(1),
  UIForceTouchCapabilityAvailable(2);

  final int value;
  const UIForceTouchCapability(this.value);

  static UIForceTouchCapability fromValue(int value) => switch (value) {
    0 => UIForceTouchCapabilityUnknown,
    1 => UIForceTouchCapabilityUnavailable,
    2 => UIForceTouchCapabilityAvailable,
    _ => throw ArgumentError(
      'Unknown value for UIForceTouchCapability: $value',
    ),
  };
}

enum UITouchType {
  UITouchTypeDirect(0),
  UITouchTypeIndirect(1),
  UITouchTypePencil(2),
  UITouchTypeIndirectPointer(3);

  static const UITouchTypeStylus = UITouchTypePencil;

  final int value;
  const UITouchType(this.value);

  static UITouchType fromValue(int value) => switch (value) {
    0 => UITouchTypeDirect,
    1 => UITouchTypeIndirect,
    2 => UITouchTypePencil,
    3 => UITouchTypeIndirectPointer,
    _ => throw ArgumentError('Unknown value for UITouchType: $value'),
  };

  @override
  String toString() {
    if (this == UITouchTypePencil)
      return "UITouchType.UITouchTypePencil, UITouchType.UITouchTypeStylus";
    return super.toString();
  }
}

sealed class UITouchProperties {
  static const UITouchPropertyForce = 1;
  static const UITouchPropertyAzimuth = 2;
  static const UITouchPropertyAltitude = 4;
  static const UITouchPropertyLocation = 8;
  static const UITouchPropertyRoll = 16;
}

/// WARNING: UITouch is a stub. To generate bindings for this class, include
/// UITouch in your config's objc-interfaces list.
///
/// UITouch
extension type UITouch._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [UITouch] that points to the same underlying object as [other].
  UITouch.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UITouch', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UITouch] that wraps the given raw object pointer.
  UITouch.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITouch', iOS: (false, (2, 0, 0)));
  }
}

enum UISceneActivationState {
  UISceneActivationStateUnattached(-1),
  UISceneActivationStateForegroundActive(0),
  UISceneActivationStateForegroundInactive(1),
  UISceneActivationStateBackground(2);

  final int value;
  const UISceneActivationState(this.value);

  static UISceneActivationState fromValue(int value) => switch (value) {
    -1 => UISceneActivationStateUnattached,
    0 => UISceneActivationStateForegroundActive,
    1 => UISceneActivationStateForegroundInactive,
    2 => UISceneActivationStateBackground,
    _ => throw ArgumentError(
      'Unknown value for UISceneActivationState: $value',
    ),
  };
}

enum UISceneCaptureState {
  UISceneCaptureStateUnspecified(-1),
  UISceneCaptureStateInactive(0),
  UISceneCaptureStateActive(1);

  final int value;
  const UISceneCaptureState(this.value);

  static UISceneCaptureState fromValue(int value) => switch (value) {
    -1 => UISceneCaptureStateUnspecified,
    0 => UISceneCaptureStateInactive,
    1 => UISceneCaptureStateActive,
    _ => throw ArgumentError('Unknown value for UISceneCaptureState: $value'),
  };
}

enum UIListEnvironment {
  UIListEnvironmentUnspecified(0),
  UIListEnvironmentNone(1),
  UIListEnvironmentPlain(2),
  UIListEnvironmentGrouped(3),
  UIListEnvironmentInsetGrouped(4),
  UIListEnvironmentSidebar(5),
  UIListEnvironmentSidebarPlain(6);

  final int value;
  const UIListEnvironment(this.value);

  static UIListEnvironment fromValue(int value) => switch (value) {
    0 => UIListEnvironmentUnspecified,
    1 => UIListEnvironmentNone,
    2 => UIListEnvironmentPlain,
    3 => UIListEnvironmentGrouped,
    4 => UIListEnvironmentInsetGrouped,
    5 => UIListEnvironmentSidebar,
    6 => UIListEnvironmentSidebarPlain,
    _ => throw ArgumentError('Unknown value for UIListEnvironment: $value'),
  };
}

enum UITabAccessoryEnvironment {
  UITabAccessoryEnvironmentUnspecified(0),
  UITabAccessoryEnvironmentNone(1),
  UITabAccessoryEnvironmentRegular(2),
  UITabAccessoryEnvironmentInline(3);

  final int value;
  const UITabAccessoryEnvironment(this.value);

  static UITabAccessoryEnvironment fromValue(int value) => switch (value) {
    0 => UITabAccessoryEnvironmentUnspecified,
    1 => UITabAccessoryEnvironmentNone,
    2 => UITabAccessoryEnvironmentRegular,
    3 => UITabAccessoryEnvironmentInline,
    _ => throw ArgumentError(
      'Unknown value for UITabAccessoryEnvironment: $value',
    ),
  };
}

enum UISplitViewControllerLayoutEnvironment {
  UISplitViewControllerLayoutEnvironmentNone(0),
  UISplitViewControllerLayoutEnvironmentExpanded(1),
  UISplitViewControllerLayoutEnvironmentCollapsed(2);

  final int value;
  const UISplitViewControllerLayoutEnvironment(this.value);

  static UISplitViewControllerLayoutEnvironment fromValue(int value) =>
      switch (value) {
        0 => UISplitViewControllerLayoutEnvironmentNone,
        1 => UISplitViewControllerLayoutEnvironmentExpanded,
        2 => UISplitViewControllerLayoutEnvironmentCollapsed,
        _ => throw ArgumentError(
          'Unknown value for UISplitViewControllerLayoutEnvironment: $value',
        ),
      };
}

/// WARNING: UIMutableTraits is a stub. To generate bindings for this class, include
/// UIMutableTraits in your config's objc-protocols list.
///
/// UIMutableTraits
extension type UIMutableTraits._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIMutableTraits] that points to the same underlying object as [other].
  UIMutableTraits.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIMutableTraits] that wraps the given raw object pointer.
  UIMutableTraits.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)>`.
abstract final class ObjCBlock_ffiVoid_idUIMutableTraits {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)>
  fromFunction(
    void Function(UIMutableTraits) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(UIMutableTraits.fromPointer(arg0, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)>
  listener(void Function(UIMutableTraits) fn, {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(UIMutableTraits.fromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)>
  blocking(void Function(UIMutableTraits) fn, {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(UIMutableTraits.fromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(UIMutableTraits.fromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)>`.
extension ObjCBlock_ffiVoid_idUIMutableTraits$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>)> {
  void call(UIMutableTraits arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0.ref.pointer);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)>`.
abstract final class ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)
  >
  fromFunction(
    void Function(UITraitEnvironment, UITraitCollection) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ) => fn(
            UITraitEnvironment.fromPointer(arg0, retain: true, release: true),
            UITraitCollection.fromPointer(arg1, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)
  >
  listener(
    void Function(UITraitEnvironment, UITraitCollection) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        UITraitEnvironment.fromPointer(arg0, retain: false, release: true),
        UITraitCollection.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)
  >
  blocking(
    void Function(UITraitEnvironment, UITraitCollection) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        UITraitEnvironment.fromPointer(arg0, retain: false, release: true),
        UITraitCollection.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        UITraitEnvironment.fromPointer(arg0, retain: false, release: true),
        UITraitCollection.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)>`.
extension ObjCBlock_ffiVoid_idUITraitEnvironment_UITraitCollection$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, UITraitCollection)
        > {
  void call(UITraitEnvironment arg0, UITraitCollection arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0.ref.pointer, arg1.ref.pointer);
}

sealed class UIFocusHeading {
  static const UIFocusHeadingNone = 0;
  static const UIFocusHeadingUp = 1;
  static const UIFocusHeadingDown = 2;
  static const UIFocusHeadingLeft = 4;
  static const UIFocusHeadingRight = 8;
  static const UIFocusHeadingNext = 16;
  static const UIFocusHeadingPrevious = 32;
  static const UIFocusHeadingFirst = 256;
  static const UIFocusHeadingLast = 512;
}

/// WARNING: UIFocusItemScrollableContainer is a stub. To generate bindings for this class, include
/// UIFocusItemScrollableContainer in your config's objc-protocols list.
///
/// UIFocusItemScrollableContainer
extension type UIFocusItemScrollableContainer._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, UIFocusItemContainer {
  /// Constructs a [UIFocusItemScrollableContainer] that points to the same underlying object as [other].
  UIFocusItemScrollableContainer.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIFocusItemScrollableContainer] that wraps the given raw object pointer.
  UIFocusItemScrollableContainer.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

enum UIViewLayoutRegionAdaptivityAxis {
  UIViewLayoutRegionAdaptivityAxisNone(0),
  UIViewLayoutRegionAdaptivityAxisHorizontal(1),
  UIViewLayoutRegionAdaptivityAxisVertical(2);

  final int value;
  const UIViewLayoutRegionAdaptivityAxis(this.value);

  static UIViewLayoutRegionAdaptivityAxis fromValue(int value) =>
      switch (value) {
        0 => UIViewLayoutRegionAdaptivityAxisNone,
        1 => UIViewLayoutRegionAdaptivityAxisHorizontal,
        2 => UIViewLayoutRegionAdaptivityAxisVertical,
        _ => throw ArgumentError(
          'Unknown value for UIViewLayoutRegionAdaptivityAxis: $value',
        ),
      };
}

late final _class_UIAction = objc.getClass("UIAction");

/// Construction methods for `objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSString_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    objc.NSString Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSString_ffiVoid$CallExtension
    on objc.ObjCBlock<objc.NSString Function(ffi.Pointer<ffi.Void>)> {
  objc.NSString call(ffi.Pointer<ffi.Void> arg0) => objc.NSString.fromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >()(ref.pointer, arg0),
    retain: true,
    release: true,
  );
}

late final _sel_setTitle_ = objc.registerName("setTitle:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.NSString) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSString.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.NSString) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSString.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.NSString) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSString.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSString.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIContentSizeCategory$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSString)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSString arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_setImage_ = objc.registerName("setImage:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIImage {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, UIImage?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : UIImage.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, UIImage?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : UIImage.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, UIImage?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : UIImage.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        arg1.address == 0
            ? null
            : UIImage.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIImage$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIImage?)> {
  void call(ffi.Pointer<ffi.Void> arg0, UIImage? arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_discoverabilityTitle = objc.registerName(
  "discoverabilityTitle",
);
late final _sel_setDiscoverabilityTitle_ = objc.registerName(
  "setDiscoverabilityTitle:",
);
late final _sel_attributes = objc.registerName("attributes");
final _objc_msgSend_kzdfm1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIMenuElementAttributes_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    int Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static int _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.UnsignedLong Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline, 0)
          .cast();
  static int _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.UnsignedLong Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline, 0)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIMenuElementAttributes_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> {
  int call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.UnsignedLong Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        int Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
      >()(ref.pointer, arg0);
}

late final _sel_setAttributes_ = objc.registerName("setAttributes:");
final _objc_msgSend_18kcki9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.UnsignedLong arg1)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, int) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, int) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1lmpkp(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, int) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1lmpkp(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, int))(
      arg0,
      arg1,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.UnsignedLong,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.UnsignedLong,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, int))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.UnsignedLong,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.UnsignedLong,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.UnsignedLong,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.UnsignedLong,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.UnsignedLong arg1)
        >
      >()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, int))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedLong,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIMenuElementAttributes$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, int arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.UnsignedLong arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          int,
        )
      >()(ref.pointer, arg0, arg1);
}

late final _sel_state = objc.registerName("state");
final _objc_msgSend_13oxpc5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIMenuElementState_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromFunction(
    UIMenuElementState Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).value,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static int _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline, 0)
          .cast();
  static int _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline, 0)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIMenuElementState_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> {
  UIMenuElementState call(ffi.Pointer<ffi.Void> arg0) =>
      UIMenuElementState.fromValue(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                ffi.Long Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0,
                )
              >
            >()
            .asFunction<
              int Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
              )
            >()(ref.pointer, arg0),
      );
}

late final _sel_setState_ = objc.registerName("setState:");
final _objc_msgSend_1qgnjih = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, UIMenuElementState) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, UIMenuElementState.fromValue(arg1)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, UIMenuElementState) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, UIMenuElementState.fromValue(arg1)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1mm4s9d(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, UIMenuElementState) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, UIMenuElementState.fromValue(arg1)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, UIMenuElementState.fromValue(arg1)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1mm4s9d(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, int))(
      arg0,
      arg1,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, int))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)
        >
      >()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Long,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, int))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Long,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIMenuElementState$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)> {
  void call(ffi.Pointer<ffi.Void> arg0, UIMenuElementState arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Long arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          int,
        )
      >()(ref.pointer, arg0, arg1.value);
}

late final _sel_sender = objc.registerName("sender");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_objcObjCObjectImpl_ffiVoid$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
  >
  fromFunction(
    objc.ObjCObject? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0) =>
              fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_objcObjCObjectImpl_ffiVoid$1$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
        > {
  objc.ObjCObject? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : objc.ObjCObject(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_actionWithHandler_ = objc.registerName("actionWithHandler:");
final _objc_msgSend_nnxkei = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_actionWithTitle_image_identifier_handler_ = objc.registerName(
  "actionWithTitle:image:identifier:handler:",
);
final _objc_msgSend_bpwlds = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_selectedImage = objc.registerName("selectedImage");
late final _sel_setSelectedImage_ = objc.registerName("setSelectedImage:");
late final _sel_repeatBehavior = objc.registerName("repeatBehavior");
final _objc_msgSend_16il6gh = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIMenuElementRepeatBehavior_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> fromFunction(
    UIMenuElementRepeatBehavior Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).value,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static int _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline, 0)
          .cast();
  static int _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline, 0)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIMenuElementRepeatBehavior_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>)> {
  UIMenuElementRepeatBehavior call(ffi.Pointer<ffi.Void> arg0) =>
      UIMenuElementRepeatBehavior.fromValue(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                ffi.Long Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0,
                )
              >
            >()
            .asFunction<
              int Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
              )
            >()(ref.pointer, arg0),
      );
}

late final _sel_setRepeatBehavior_ = objc.registerName("setRepeatBehavior:");
final _objc_msgSend_bhswox = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIMenuElementRepeatBehavior {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, UIMenuElementRepeatBehavior) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, UIMenuElementRepeatBehavior.fromValue(arg1)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, UIMenuElementRepeatBehavior) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, UIMenuElementRepeatBehavior.fromValue(arg1)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1wqrf61(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, UIMenuElementRepeatBehavior) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, UIMenuElementRepeatBehavior.fromValue(arg1)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, int arg1) =>
          fn(arg0, UIMenuElementRepeatBehavior.fromValue(arg1)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1wqrf61(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, int))(
      arg0,
      arg1,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, int))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Long arg1)
        >
      >()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Long,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, int))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Long,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIMenuElementRepeatBehavior$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Long)> {
  void call(ffi.Pointer<ffi.Void> arg0, UIMenuElementRepeatBehavior arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Long arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          int,
        )
      >()(ref.pointer, arg0, arg1.value);
}

late final _sel_presentationSourceItem = objc.registerName(
  "presentationSourceItem",
);

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUIPopoverPresentationControllerSourceItem_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
  >
  fromFunction(
    UIPopoverPresentationControllerSourceItem$1? Function(ffi.Pointer<ffi.Void>)
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0) =>
              fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUIPopoverPresentationControllerSourceItem_ffiVoid$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>)
        > {
  UIPopoverPresentationControllerSourceItem$1? call(
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIPopoverPresentationControllerSourceItem$1.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                )
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_performWithSender_target_ = objc.registerName(
  "performWithSender:target:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl_objcObjCObjectImpl {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>?,
      ffi.Pointer<objc.ObjCObjectImpl>?,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>?,
          ffi.Pointer<objc.ObjCObjectImpl>?,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>?,
      ffi.Pointer<objc.ObjCObjectImpl>?,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>?,
          ffi.Pointer<objc.ObjCObjectImpl>?,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>?,
      ffi.Pointer<objc.ObjCObjectImpl>?,
    )
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObject?, objc.ObjCObject?)
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>?,
          ffi.Pointer<objc.ObjCObjectImpl>?,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0,
            arg1.address == 0
                ? null
                : objc.ObjCObject(arg1, retain: true, release: true),
            arg2.address == 0
                ? null
                : objc.ObjCObject(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>?,
      ffi.Pointer<objc.ObjCObjectImpl>?,
    )
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObject?, objc.ObjCObject?)
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.ObjCObject(arg1, retain: false, release: true),
        arg2.address == 0
            ? null
            : objc.ObjCObject(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObjectImpl>?,
        ffi.Pointer<objc.ObjCObjectImpl>?,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>?,
      ffi.Pointer<objc.ObjCObjectImpl>?,
    )
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObject?, objc.ObjCObject?)
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.ObjCObject(arg1, retain: false, release: true),
        arg2.address == 0
            ? null
            : objc.ObjCObject(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.ObjCObject(arg1, retain: false, release: true),
        arg2.address == 0
            ? null
            : objc.ObjCObject(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_fjrv01(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObjectImpl>?,
        ffi.Pointer<objc.ObjCObjectImpl>?,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, ffi.Pointer<objc.ObjCObjectImpl>?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl_objcObjCObjectImpl$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>?,
            ffi.Pointer<objc.ObjCObjectImpl>?,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    objc.ObjCObject? arg1,
    objc.ObjCObject? arg2,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1?.ref.pointer ?? ffi.nullptr,
        arg2?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_captureTextFromCameraActionForResponder_identifier_ = objc
    .registerName("captureTextFromCameraActionForResponder:identifier:");

/// UICaptureTextFromCameraSupporting
extension UICaptureTextFromCameraSupporting$1 on UIAction {}

/// UIAction
extension type UIAction._(objc.ObjCObject object$)
    implements objc.ObjCObject, UIMenuElement, UIMenuLeaf {
  /// Constructs a [UIAction] that points to the same underlying object as [other].
  UIAction.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIAction', iOS: (false, (13, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UIAction] that wraps the given raw object pointer.
  UIAction.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIAction', iOS: (false, (13, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UIAction].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_UIAction,
  );

  /// actionWithHandler:
  static UIAction actionWithHandler(
    objc.ObjCBlock<ffi.Void Function(UIAction)> handler,
  ) {
    objc.checkOsVersionInternal(
      'UIAction.actionWithHandler:',
      iOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_nnxkei(
      _class_UIAction,
      _sel_actionWithHandler_,
      handler.ref.pointer,
    );
    return UIAction.fromPointer($ret, retain: true, release: true);
  }

  /// actionWithTitle:image:identifier:handler:
  static UIAction actionWithTitle(
    objc.NSString title, {
    UIImage? image,
    objc.NSString? identifier,
    required objc.ObjCBlock<ffi.Void Function(UIAction)> handler,
  }) {
    final $ret = _objc_msgSend_bpwlds(
      _class_UIAction,
      _sel_actionWithTitle_image_identifier_handler_,
      title.ref.pointer,
      image?.ref.pointer ?? ffi.nullptr,
      identifier?.ref.pointer ?? ffi.nullptr,
      handler.ref.pointer,
    );
    return UIAction.fromPointer($ret, retain: true, release: true);
  }

  /// alloc
  static UIAction alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIAction, _sel_alloc);
    return UIAction.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIAction allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_UIAction,
      _sel_allocWithZone_,
      zone,
    );
    return UIAction.fromPointer($ret, retain: false, release: true);
  }

  /// captureTextFromCameraActionForResponder:identifier:
  static UIAction captureTextFromCameraActionForResponder(
    UIResponder responder, {
    objc.NSString? identifier,
  }) {
    objc.checkOsVersionInternal(
      'UIAction.captureTextFromCameraActionForResponder:identifier:',
      iOS: (false, (15, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_UIAction,
      _sel_captureTextFromCameraActionForResponder_identifier_,
      responder.ref.pointer,
      identifier?.ref.pointer ?? ffi.nullptr,
    );
    return UIAction.fromPointer($ret, retain: true, release: true);
  }

  /// new
  static UIAction new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIAction, _sel_new);
    return UIAction.fromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UIAction, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of UIAction constructed with the default `new` method.
  UIAction() : this.as(new$().object$);
}

extension UIAction$Methods on UIAction {
  /// attributes
  int get attributes {
    objc.checkOsVersionInternal(
      'UIAction.attributes',
      iOS: (false, (16, 0, 0)),
    );
    return _objc_msgSend_kzdfm1(object$.ref.pointer, _sel_attributes);
  }

  /// discoverabilityTitle
  objc.NSString? get discoverabilityTitle {
    objc.checkOsVersionInternal(
      'UIAction.discoverabilityTitle',
      iOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_discoverabilityTitle,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// identifier
  objc.NSString get identifier {
    objc.checkOsVersionInternal(
      'UIAction.identifier',
      iOS: (false, (13, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_identifier);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// image
  UIImage? get image {
    objc.checkOsVersionInternal('UIAction.image', iOS: (false, (16, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_image);
    return $ret.address == 0
        ? null
        : UIImage.fromPointer($ret, retain: true, release: true);
  }

  /// init
  UIAction init() {
    objc.checkOsVersionInternal(
      'UIAction.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return UIAction.fromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIAction? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : UIAction.fromPointer($ret, retain: false, release: true);
  }

  /// performWithSender:target:
  void performWithSender(objc.ObjCObject? sender, {objc.ObjCObject? target}) {
    objc.checkOsVersionInternal(
      'UIAction.performWithSender:target:',
      iOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_performWithSender_target_,
      sender?.ref.pointer ?? ffi.nullptr,
      target?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// presentationSourceItem
  UIPopoverPresentationControllerSourceItem$1? get presentationSourceItem {
    objc.checkOsVersionInternal(
      'UIAction.presentationSourceItem',
      iOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_presentationSourceItem,
    );
    return $ret.address == 0
        ? null
        : UIPopoverPresentationControllerSourceItem$1.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// repeatBehavior
  UIMenuElementRepeatBehavior get repeatBehavior {
    objc.checkOsVersionInternal(
      'UIAction.repeatBehavior',
      iOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_16il6gh(
      object$.ref.pointer,
      _sel_repeatBehavior,
    );
    return UIMenuElementRepeatBehavior.fromValue($ret);
  }

  /// selectedImage
  UIImage? get selectedImage {
    objc.checkOsVersionInternal(
      'UIAction.selectedImage',
      iOS: (false, (17, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_selectedImage);
    return $ret.address == 0
        ? null
        : UIImage.fromPointer($ret, retain: true, release: true);
  }

  /// sender
  objc.ObjCObject? get sender {
    objc.checkOsVersionInternal('UIAction.sender', iOS: (false, (16, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_sender);
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// setAttributes:
  set attributes(int value) {
    objc.checkOsVersionInternal(
      'UIAction.setAttributes:',
      iOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_18kcki9(object$.ref.pointer, _sel_setAttributes_, value);
  }

  /// setDiscoverabilityTitle:
  set discoverabilityTitle(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'UIAction.setDiscoverabilityTitle:',
      iOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setDiscoverabilityTitle_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setImage:
  set image$1(UIImage? value) {
    objc.checkOsVersionInternal('UIAction.setImage:', iOS: (false, (16, 0, 0)));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setImage_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setRepeatBehavior:
  set repeatBehavior(UIMenuElementRepeatBehavior value) {
    objc.checkOsVersionInternal(
      'UIAction.setRepeatBehavior:',
      iOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_bhswox(
      object$.ref.pointer,
      _sel_setRepeatBehavior_,
      value.value,
    );
  }

  /// setSelectedImage:
  set selectedImage(UIImage? value) {
    objc.checkOsVersionInternal(
      'UIAction.setSelectedImage:',
      iOS: (false, (17, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setSelectedImage_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setState:
  set state(UIMenuElementState value) {
    objc.checkOsVersionInternal('UIAction.setState:', iOS: (false, (16, 0, 0)));
    _objc_msgSend_1qgnjih(object$.ref.pointer, _sel_setState_, value.value);
  }

  /// setTitle:
  set title$1(objc.NSString value) {
    objc.checkOsVersionInternal('UIAction.setTitle:', iOS: (false, (16, 0, 0)));
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setTitle_,
      value.ref.pointer,
    );
  }

  /// state
  UIMenuElementState get state {
    objc.checkOsVersionInternal('UIAction.state', iOS: (false, (16, 0, 0)));
    final $ret = _objc_msgSend_13oxpc5(object$.ref.pointer, _sel_state);
    return UIMenuElementState.fromValue($ret);
  }

  /// title
  objc.NSString get title {
    objc.checkOsVersionInternal('UIAction.title', iOS: (false, (16, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_title);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(UIAction)>`.
abstract final class ObjCBlock_ffiVoid_UIAction {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(UIAction)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(UIAction)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(UIAction)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(UIAction)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UIAction)> fromFunction(
    void Function(UIAction) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(UIAction)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(UIAction.fromPointer(arg0, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UIAction)> listener(
    void Function(UIAction) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(UIAction.fromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(UIAction)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(UIAction)> blocking(
    void Function(UIAction) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(UIAction.fromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(UIAction.fromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(UIAction)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(UIAction)>`.
extension ObjCBlock_ffiVoid_UIAction$CallExtension
    on objc.ObjCBlock<ffi.Void Function(UIAction)> {
  void call(UIAction arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0.ref.pointer);
}

enum UIContextMenuConfigurationElementOrder {
  UIContextMenuConfigurationElementOrderAutomatic(0),
  UIContextMenuConfigurationElementOrderPriority(1),
  UIContextMenuConfigurationElementOrderFixed(2);

  final int value;
  const UIContextMenuConfigurationElementOrder(this.value);

  static UIContextMenuConfigurationElementOrder fromValue(int value) =>
      switch (value) {
        0 => UIContextMenuConfigurationElementOrderAutomatic,
        1 => UIContextMenuConfigurationElementOrderPriority,
        2 => UIContextMenuConfigurationElementOrderFixed,
        _ => throw ArgumentError(
          'Unknown value for UIContextMenuConfigurationElementOrder: $value',
        ),
      };
}

/// Construction methods for `objc.ObjCBlock<UIMenu? Function(objc.NSArray)>`.
abstract final class ObjCBlock_UIMenu_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIMenu? Function(objc.NSArray)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UIMenu? Function(objc.NSArray)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIMenu? Function(objc.NSArray)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<UIMenu? Function(objc.NSArray)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIMenu? Function(objc.NSArray)> fromFunction(
    UIMenu? Function(objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UIMenu? Function(objc.NSArray)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(
            objc.NSArray.fromPointer(arg0, retain: true, release: true),
          )?.ref.retainAndAutorelease() ??
          ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<UIMenu? Function(objc.NSArray)>`.
extension ObjCBlock_UIMenu_NSArray$CallExtension
    on objc.ObjCBlock<UIMenu? Function(objc.NSArray)> {
  UIMenu? call(objc.NSArray arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<objc.ObjCObjectImpl> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0.ref.pointer)
              .address ==
          0
      ? null
      : UIMenu.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<objc.ObjCObjectImpl> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0.ref.pointer),
          retain: true,
          release: true,
        );
}

/// WARNING: UIViewController is a stub. To generate bindings for this class, include
/// UIViewController in your config's objc-interfaces list.
///
/// UIViewController
extension type UIViewController._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        UIResponder,
        objc.NSCoding,
        UIAppearanceContainer,
        UITraitEnvironment,
        UIContentContainer,
        UIFocusEnvironment {
  /// Constructs a [UIViewController] that points to the same underlying object as [other].
  UIViewController.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIViewController', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIViewController] that wraps the given raw object pointer.
  UIViewController.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIViewController', iOS: (false, (2, 0, 0)));
  }
}

/// Construction methods for `objc.ObjCBlock<UIViewController? Function()>`.
abstract final class ObjCBlock_UIViewController {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIViewController? Function()> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UIViewController? Function()>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIViewController? Function()> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function()>>
    ptr,
  ) => objc.ObjCBlock<UIViewController? Function()>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIViewController? Function()> fromFunction(
    UIViewController? Function() fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UIViewController? Function()>(
    objc.newClosureBlock(
      _closureCallable,
      () => fn()?.ref.retainAndAutorelease() ?? ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function()>>()
      .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function()>()();
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function())();
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<UIViewController? Function()>`.
extension ObjCBlock_UIViewController$CallExtension
    on objc.ObjCBlock<UIViewController? Function()> {
  UIViewController? call() =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >()(ref.pointer)
              .address ==
          0
      ? null
      : UIViewController.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >()(ref.pointer),
          retain: true,
          release: true,
        );
}

enum UIContextMenuInteractionCommitStyle {
  UIContextMenuInteractionCommitStyleDismiss(0),
  UIContextMenuInteractionCommitStylePop(1);

  final int value;
  const UIContextMenuInteractionCommitStyle(this.value);

  static UIContextMenuInteractionCommitStyle fromValue(int value) =>
      switch (value) {
        0 => UIContextMenuInteractionCommitStyleDismiss,
        1 => UIContextMenuInteractionCommitStylePop,
        _ => throw ArgumentError(
          'Unknown value for UIContextMenuInteractionCommitStyle: $value',
        ),
      };
}

enum UIContextMenuInteractionAppearance {
  UIContextMenuInteractionAppearanceUnknown(0),
  UIContextMenuInteractionAppearanceRich(1),
  UIContextMenuInteractionAppearanceCompact(2);

  final int value;
  const UIContextMenuInteractionAppearance(this.value);

  static UIContextMenuInteractionAppearance fromValue(int value) =>
      switch (value) {
        0 => UIContextMenuInteractionAppearanceUnknown,
        1 => UIContextMenuInteractionAppearanceRich,
        2 => UIContextMenuInteractionAppearanceCompact,
        _ => throw ArgumentError(
          'Unknown value for UIContextMenuInteractionAppearance: $value',
        ),
      };
}

sealed class UIControlEvents {
  static const UIControlEventTouchDown = 1;
  static const UIControlEventTouchDownRepeat = 2;
  static const UIControlEventTouchDragInside = 4;
  static const UIControlEventTouchDragOutside = 8;
  static const UIControlEventTouchDragEnter = 16;
  static const UIControlEventTouchDragExit = 32;
  static const UIControlEventTouchUpInside = 64;
  static const UIControlEventTouchUpOutside = 128;
  static const UIControlEventTouchCancel = 256;
  static const UIControlEventValueChanged = 4096;
  static const UIControlEventPrimaryActionTriggered = 8192;
  static const UIControlEventMenuActionTriggered = 16384;
  static const UIControlEventEditingDidBegin = 65536;
  static const UIControlEventEditingChanged = 131072;
  static const UIControlEventEditingDidEnd = 262144;
  static const UIControlEventEditingDidEndOnExit = 524288;
  static const UIControlEventAllTouchEvents = 4095;
  static const UIControlEventAllEditingEvents = 983040;
  static const UIControlEventApplicationReserved = 251658240;
  static const UIControlEventSystemReserved = 4026531840;
  static const UIControlEventAllEvents = 4294967295;
}

enum UIControlContentVerticalAlignment {
  UIControlContentVerticalAlignmentCenter(0),
  UIControlContentVerticalAlignmentTop(1),
  UIControlContentVerticalAlignmentBottom(2),
  UIControlContentVerticalAlignmentFill(3);

  final int value;
  const UIControlContentVerticalAlignment(this.value);

  static UIControlContentVerticalAlignment fromValue(int value) =>
      switch (value) {
        0 => UIControlContentVerticalAlignmentCenter,
        1 => UIControlContentVerticalAlignmentTop,
        2 => UIControlContentVerticalAlignmentBottom,
        3 => UIControlContentVerticalAlignmentFill,
        _ => throw ArgumentError(
          'Unknown value for UIControlContentVerticalAlignment: $value',
        ),
      };
}

enum UIControlContentHorizontalAlignment {
  UIControlContentHorizontalAlignmentCenter(0),
  UIControlContentHorizontalAlignmentLeft(1),
  UIControlContentHorizontalAlignmentRight(2),
  UIControlContentHorizontalAlignmentFill(3),
  UIControlContentHorizontalAlignmentLeading(4),
  UIControlContentHorizontalAlignmentTrailing(5);

  final int value;
  const UIControlContentHorizontalAlignment(this.value);

  static UIControlContentHorizontalAlignment fromValue(int value) =>
      switch (value) {
        0 => UIControlContentHorizontalAlignmentCenter,
        1 => UIControlContentHorizontalAlignmentLeft,
        2 => UIControlContentHorizontalAlignmentRight,
        3 => UIControlContentHorizontalAlignmentFill,
        4 => UIControlContentHorizontalAlignmentLeading,
        5 => UIControlContentHorizontalAlignmentTrailing,
        _ => throw ArgumentError(
          'Unknown value for UIControlContentHorizontalAlignment: $value',
        ),
      };
}

sealed class UIControlState {
  static const UIControlStateNormal = 0;
  static const UIControlStateHighlighted = 1;
  static const UIControlStateDisabled = 2;
  static const UIControlStateSelected = 4;
  static const UIControlStateFocused = 8;
  static const UIControlStateApplication = 16711680;
  static const UIControlStateReserved = 4278190080;
}

enum UIScrollViewIndicatorStyle {
  UIScrollViewIndicatorStyleDefault(0),
  UIScrollViewIndicatorStyleBlack(1),
  UIScrollViewIndicatorStyleWhite(2);

  final int value;
  const UIScrollViewIndicatorStyle(this.value);

  static UIScrollViewIndicatorStyle fromValue(int value) => switch (value) {
    0 => UIScrollViewIndicatorStyleDefault,
    1 => UIScrollViewIndicatorStyleBlack,
    2 => UIScrollViewIndicatorStyleWhite,
    _ => throw ArgumentError(
      'Unknown value for UIScrollViewIndicatorStyle: $value',
    ),
  };
}

enum UIScrollViewKeyboardDismissMode {
  UIScrollViewKeyboardDismissModeNone(0),
  UIScrollViewKeyboardDismissModeOnDrag(1),
  UIScrollViewKeyboardDismissModeInteractive(2),
  UIScrollViewKeyboardDismissModeOnDragWithAccessory(3),
  UIScrollViewKeyboardDismissModeInteractiveWithAccessory(4);

  final int value;
  const UIScrollViewKeyboardDismissMode(this.value);

  static UIScrollViewKeyboardDismissMode fromValue(int value) =>
      switch (value) {
        0 => UIScrollViewKeyboardDismissModeNone,
        1 => UIScrollViewKeyboardDismissModeOnDrag,
        2 => UIScrollViewKeyboardDismissModeInteractive,
        3 => UIScrollViewKeyboardDismissModeOnDragWithAccessory,
        4 => UIScrollViewKeyboardDismissModeInteractiveWithAccessory,
        _ => throw ArgumentError(
          'Unknown value for UIScrollViewKeyboardDismissMode: $value',
        ),
      };
}

enum UIScrollViewIndexDisplayMode {
  UIScrollViewIndexDisplayModeAutomatic(0),
  UIScrollViewIndexDisplayModeAlwaysHidden(1);

  final int value;
  const UIScrollViewIndexDisplayMode(this.value);

  static UIScrollViewIndexDisplayMode fromValue(int value) => switch (value) {
    0 => UIScrollViewIndexDisplayModeAutomatic,
    1 => UIScrollViewIndexDisplayModeAlwaysHidden,
    _ => throw ArgumentError(
      'Unknown value for UIScrollViewIndexDisplayMode: $value',
    ),
  };
}

enum UIScrollViewContentInsetAdjustmentBehavior {
  UIScrollViewContentInsetAdjustmentAutomatic(0),
  UIScrollViewContentInsetAdjustmentScrollableAxes(1),
  UIScrollViewContentInsetAdjustmentNever(2),
  UIScrollViewContentInsetAdjustmentAlways(3);

  final int value;
  const UIScrollViewContentInsetAdjustmentBehavior(this.value);

  static UIScrollViewContentInsetAdjustmentBehavior fromValue(
    int value,
  ) => switch (value) {
    0 => UIScrollViewContentInsetAdjustmentAutomatic,
    1 => UIScrollViewContentInsetAdjustmentScrollableAxes,
    2 => UIScrollViewContentInsetAdjustmentNever,
    3 => UIScrollViewContentInsetAdjustmentAlways,
    _ => throw ArgumentError(
      'Unknown value for UIScrollViewContentInsetAdjustmentBehavior: $value',
    ),
  };
}

/// WARNING: UIScrollView is a stub. To generate bindings for this class, include
/// UIScrollView in your config's objc-interfaces list.
///
/// UIScrollView
extension type UIScrollView._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        UIView,
        objc.NSCoding,
        UIFocusItemScrollableContainer {
  /// Constructs a [UIScrollView] that points to the same underlying object as [other].
  UIScrollView.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIScrollView', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIScrollView] that wraps the given raw object pointer.
  UIScrollView.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIScrollView', iOS: (false, (2, 0, 0)));
  }
}

/// WARNING: UIConversationContext is a stub. To generate bindings for this class, include
/// UIConversationContext in your config's objc-interfaces list.
///
/// UIConversationContext
extension type UIConversationContext._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [UIConversationContext] that points to the same underlying object as [other].
  UIConversationContext.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UIConversationContext',
      iOS: (false, (18, 4, 0)),
    );
  }

  /// Constructs a [UIConversationContext] that wraps the given raw object pointer.
  UIConversationContext.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UIConversationContext',
      iOS: (false, (18, 4, 0)),
    );
  }
}

enum UITextAutocapitalizationType {
  UITextAutocapitalizationTypeNone(0),
  UITextAutocapitalizationTypeWords(1),
  UITextAutocapitalizationTypeSentences(2),
  UITextAutocapitalizationTypeAllCharacters(3);

  final int value;
  const UITextAutocapitalizationType(this.value);

  static UITextAutocapitalizationType fromValue(int value) => switch (value) {
    0 => UITextAutocapitalizationTypeNone,
    1 => UITextAutocapitalizationTypeWords,
    2 => UITextAutocapitalizationTypeSentences,
    3 => UITextAutocapitalizationTypeAllCharacters,
    _ => throw ArgumentError(
      'Unknown value for UITextAutocapitalizationType: $value',
    ),
  };
}

enum UITextAutocorrectionType {
  UITextAutocorrectionTypeDefault(0),
  UITextAutocorrectionTypeNo(1),
  UITextAutocorrectionTypeYes(2);

  final int value;
  const UITextAutocorrectionType(this.value);

  static UITextAutocorrectionType fromValue(int value) => switch (value) {
    0 => UITextAutocorrectionTypeDefault,
    1 => UITextAutocorrectionTypeNo,
    2 => UITextAutocorrectionTypeYes,
    _ => throw ArgumentError(
      'Unknown value for UITextAutocorrectionType: $value',
    ),
  };
}

enum UITextSpellCheckingType {
  UITextSpellCheckingTypeDefault(0),
  UITextSpellCheckingTypeNo(1),
  UITextSpellCheckingTypeYes(2);

  final int value;
  const UITextSpellCheckingType(this.value);

  static UITextSpellCheckingType fromValue(int value) => switch (value) {
    0 => UITextSpellCheckingTypeDefault,
    1 => UITextSpellCheckingTypeNo,
    2 => UITextSpellCheckingTypeYes,
    _ => throw ArgumentError(
      'Unknown value for UITextSpellCheckingType: $value',
    ),
  };
}

enum UITextSmartQuotesType {
  UITextSmartQuotesTypeDefault(0),
  UITextSmartQuotesTypeNo(1),
  UITextSmartQuotesTypeYes(2);

  final int value;
  const UITextSmartQuotesType(this.value);

  static UITextSmartQuotesType fromValue(int value) => switch (value) {
    0 => UITextSmartQuotesTypeDefault,
    1 => UITextSmartQuotesTypeNo,
    2 => UITextSmartQuotesTypeYes,
    _ => throw ArgumentError('Unknown value for UITextSmartQuotesType: $value'),
  };
}

enum UITextSmartDashesType {
  UITextSmartDashesTypeDefault(0),
  UITextSmartDashesTypeNo(1),
  UITextSmartDashesTypeYes(2);

  final int value;
  const UITextSmartDashesType(this.value);

  static UITextSmartDashesType fromValue(int value) => switch (value) {
    0 => UITextSmartDashesTypeDefault,
    1 => UITextSmartDashesTypeNo,
    2 => UITextSmartDashesTypeYes,
    _ => throw ArgumentError('Unknown value for UITextSmartDashesType: $value'),
  };
}

enum UITextSmartInsertDeleteType {
  UITextSmartInsertDeleteTypeDefault(0),
  UITextSmartInsertDeleteTypeNo(1),
  UITextSmartInsertDeleteTypeYes(2);

  final int value;
  const UITextSmartInsertDeleteType(this.value);

  static UITextSmartInsertDeleteType fromValue(int value) => switch (value) {
    0 => UITextSmartInsertDeleteTypeDefault,
    1 => UITextSmartInsertDeleteTypeNo,
    2 => UITextSmartInsertDeleteTypeYes,
    _ => throw ArgumentError(
      'Unknown value for UITextSmartInsertDeleteType: $value',
    ),
  };
}

enum UITextInlinePredictionType {
  UITextInlinePredictionTypeDefault(0),
  UITextInlinePredictionTypeNo(1),
  UITextInlinePredictionTypeYes(2);

  final int value;
  const UITextInlinePredictionType(this.value);

  static UITextInlinePredictionType fromValue(int value) => switch (value) {
    0 => UITextInlinePredictionTypeDefault,
    1 => UITextInlinePredictionTypeNo,
    2 => UITextInlinePredictionTypeYes,
    _ => throw ArgumentError(
      'Unknown value for UITextInlinePredictionType: $value',
    ),
  };
}

enum UITextMathExpressionCompletionType {
  UITextMathExpressionCompletionTypeDefault(0),
  UITextMathExpressionCompletionTypeNo(1),
  UITextMathExpressionCompletionTypeYes(2);

  final int value;
  const UITextMathExpressionCompletionType(this.value);

  static UITextMathExpressionCompletionType fromValue(int value) =>
      switch (value) {
        0 => UITextMathExpressionCompletionTypeDefault,
        1 => UITextMathExpressionCompletionTypeNo,
        2 => UITextMathExpressionCompletionTypeYes,
        _ => throw ArgumentError(
          'Unknown value for UITextMathExpressionCompletionType: $value',
        ),
      };
}

enum UIKeyboardType {
  UIKeyboardTypeDefault(0),
  UIKeyboardTypeASCIICapable(1),
  UIKeyboardTypeNumbersAndPunctuation(2),
  UIKeyboardTypeURL(3),
  UIKeyboardTypeNumberPad(4),
  UIKeyboardTypePhonePad(5),
  UIKeyboardTypeNamePhonePad(6),
  UIKeyboardTypeEmailAddress(7),
  UIKeyboardTypeDecimalPad(8),
  UIKeyboardTypeTwitter(9),
  UIKeyboardTypeWebSearch(10),
  UIKeyboardTypeASCIICapableNumberPad(11);

  static const UIKeyboardTypeAlphabet = UIKeyboardTypeASCIICapable;

  final int value;
  const UIKeyboardType(this.value);

  static UIKeyboardType fromValue(int value) => switch (value) {
    0 => UIKeyboardTypeDefault,
    1 => UIKeyboardTypeASCIICapable,
    2 => UIKeyboardTypeNumbersAndPunctuation,
    3 => UIKeyboardTypeURL,
    4 => UIKeyboardTypeNumberPad,
    5 => UIKeyboardTypePhonePad,
    6 => UIKeyboardTypeNamePhonePad,
    7 => UIKeyboardTypeEmailAddress,
    8 => UIKeyboardTypeDecimalPad,
    9 => UIKeyboardTypeTwitter,
    10 => UIKeyboardTypeWebSearch,
    11 => UIKeyboardTypeASCIICapableNumberPad,
    _ => throw ArgumentError('Unknown value for UIKeyboardType: $value'),
  };

  @override
  String toString() {
    if (this == UIKeyboardTypeASCIICapable)
      return "UIKeyboardType.UIKeyboardTypeASCIICapable, UIKeyboardType.UIKeyboardTypeAlphabet";
    return super.toString();
  }
}

enum UIKeyboardAppearance {
  UIKeyboardAppearanceDefault(0),
  UIKeyboardAppearanceDark(1),
  UIKeyboardAppearanceLight(2);

  static const UIKeyboardAppearanceAlert = UIKeyboardAppearanceDark;

  final int value;
  const UIKeyboardAppearance(this.value);

  static UIKeyboardAppearance fromValue(int value) => switch (value) {
    0 => UIKeyboardAppearanceDefault,
    1 => UIKeyboardAppearanceDark,
    2 => UIKeyboardAppearanceLight,
    _ => throw ArgumentError('Unknown value for UIKeyboardAppearance: $value'),
  };

  @override
  String toString() {
    if (this == UIKeyboardAppearanceDark)
      return "UIKeyboardAppearance.UIKeyboardAppearanceDark, UIKeyboardAppearance.UIKeyboardAppearanceAlert";
    return super.toString();
  }
}

enum UIReturnKeyType {
  UIReturnKeyDefault(0),
  UIReturnKeyGo(1),
  UIReturnKeyGoogle(2),
  UIReturnKeyJoin(3),
  UIReturnKeyNext(4),
  UIReturnKeyRoute(5),
  UIReturnKeySearch(6),
  UIReturnKeySend(7),
  UIReturnKeyYahoo(8),
  UIReturnKeyDone(9),
  UIReturnKeyEmergencyCall(10),
  UIReturnKeyContinue(11);

  final int value;
  const UIReturnKeyType(this.value);

  static UIReturnKeyType fromValue(int value) => switch (value) {
    0 => UIReturnKeyDefault,
    1 => UIReturnKeyGo,
    2 => UIReturnKeyGoogle,
    3 => UIReturnKeyJoin,
    4 => UIReturnKeyNext,
    5 => UIReturnKeyRoute,
    6 => UIReturnKeySearch,
    7 => UIReturnKeySend,
    8 => UIReturnKeyYahoo,
    9 => UIReturnKeyDone,
    10 => UIReturnKeyEmergencyCall,
    11 => UIReturnKeyContinue,
    _ => throw ArgumentError('Unknown value for UIReturnKeyType: $value'),
  };
}

enum UIWritingToolsBehavior {
  UIWritingToolsBehaviorNone(-1),
  UIWritingToolsBehaviorDefault(0),
  UIWritingToolsBehaviorComplete(1),
  UIWritingToolsBehaviorLimited(2);

  final int value;
  const UIWritingToolsBehavior(this.value);

  static UIWritingToolsBehavior fromValue(int value) => switch (value) {
    -1 => UIWritingToolsBehaviorNone,
    0 => UIWritingToolsBehaviorDefault,
    1 => UIWritingToolsBehaviorComplete,
    2 => UIWritingToolsBehaviorLimited,
    _ => throw ArgumentError(
      'Unknown value for UIWritingToolsBehavior: $value',
    ),
  };
}

sealed class UIWritingToolsResultOptions {
  static const UIWritingToolsResultDefault = 0;
  static const UIWritingToolsResultPlainText = 1;
  static const UIWritingToolsResultRichText = 2;
  static const UIWritingToolsResultList = 4;
  static const UIWritingToolsResultTable = 8;
  static const UIWritingToolsResultPresentationIntent = 16;
}

enum UITextStorageDirection {
  UITextStorageDirectionForward(0),
  UITextStorageDirectionBackward(1);

  final int value;
  const UITextStorageDirection(this.value);

  static UITextStorageDirection fromValue(int value) => switch (value) {
    0 => UITextStorageDirectionForward,
    1 => UITextStorageDirectionBackward,
    _ => throw ArgumentError(
      'Unknown value for UITextStorageDirection: $value',
    ),
  };
}

enum UITextLayoutDirection {
  UITextLayoutDirectionRight(2),
  UITextLayoutDirectionLeft(3),
  UITextLayoutDirectionUp(4),
  UITextLayoutDirectionDown(5);

  final int value;
  const UITextLayoutDirection(this.value);

  static UITextLayoutDirection fromValue(int value) => switch (value) {
    2 => UITextLayoutDirectionRight,
    3 => UITextLayoutDirectionLeft,
    4 => UITextLayoutDirectionUp,
    5 => UITextLayoutDirectionDown,
    _ => throw ArgumentError('Unknown value for UITextLayoutDirection: $value'),
  };
}

enum UITextGranularity {
  UITextGranularityCharacter(0),
  UITextGranularityWord(1),
  UITextGranularitySentence(2),
  UITextGranularityParagraph(3),
  UITextGranularityLine(4),
  UITextGranularityDocument(5);

  final int value;
  const UITextGranularity(this.value);

  static UITextGranularity fromValue(int value) => switch (value) {
    0 => UITextGranularityCharacter,
    1 => UITextGranularityWord,
    2 => UITextGranularitySentence,
    3 => UITextGranularityParagraph,
    4 => UITextGranularityLine,
    5 => UITextGranularityDocument,
    _ => throw ArgumentError('Unknown value for UITextGranularity: $value'),
  };
}

enum UITextAlternativeStyle {
  UITextAlternativeStyleNone(0),
  UITextAlternativeStyleLowConfidence(1);

  final int value;
  const UITextAlternativeStyle(this.value);

  static UITextAlternativeStyle fromValue(int value) => switch (value) {
    0 => UITextAlternativeStyleNone,
    1 => UITextAlternativeStyleLowConfidence,
    _ => throw ArgumentError(
      'Unknown value for UITextAlternativeStyle: $value',
    ),
  };
}

/// WARNING: UITextInputDelegate is a stub. To generate bindings for this class, include
/// UITextInputDelegate in your config's objc-protocols list.
///
/// UITextInputDelegate
extension type UITextInputDelegate._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UITextInputDelegate] that points to the same underlying object as [other].
  UITextInputDelegate.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UITextInputDelegate] that wraps the given raw object pointer.
  UITextInputDelegate.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

enum UIBaselineAdjustment {
  UIBaselineAdjustmentAlignBaselines(0),
  UIBaselineAdjustmentAlignCenters(1),
  UIBaselineAdjustmentNone(2);

  final int value;
  const UIBaselineAdjustment(this.value);

  static UIBaselineAdjustment fromValue(int value) => switch (value) {
    0 => UIBaselineAdjustmentAlignBaselines,
    1 => UIBaselineAdjustmentAlignCenters,
    2 => UIBaselineAdjustmentNone,
    _ => throw ArgumentError('Unknown value for UIBaselineAdjustment: $value'),
  };
}

enum UIDropOperation {
  UIDropOperationCancel(0),
  UIDropOperationForbidden(1),
  UIDropOperationCopy(2),
  UIDropOperationMove(3);

  final int value;
  const UIDropOperation(this.value);

  static UIDropOperation fromValue(int value) => switch (value) {
    0 => UIDropOperationCancel,
    1 => UIDropOperationForbidden,
    2 => UIDropOperationCopy,
    3 => UIDropOperationMove,
    _ => throw ArgumentError('Unknown value for UIDropOperation: $value'),
  };
}

enum UIViewAnimatingState {
  UIViewAnimatingStateInactive(0),
  UIViewAnimatingStateActive(1),
  UIViewAnimatingStateStopped(2);

  final int value;
  const UIViewAnimatingState(this.value);

  static UIViewAnimatingState fromValue(int value) => switch (value) {
    0 => UIViewAnimatingStateInactive,
    1 => UIViewAnimatingStateActive,
    2 => UIViewAnimatingStateStopped,
    _ => throw ArgumentError('Unknown value for UIViewAnimatingState: $value'),
  };
}

enum UIViewAnimatingPosition {
  UIViewAnimatingPositionEnd(0),
  UIViewAnimatingPositionStart(1),
  UIViewAnimatingPositionCurrent(2);

  final int value;
  const UIViewAnimatingPosition(this.value);

  static UIViewAnimatingPosition fromValue(int value) => switch (value) {
    0 => UIViewAnimatingPositionEnd,
    1 => UIViewAnimatingPositionStart,
    2 => UIViewAnimatingPositionCurrent,
    _ => throw ArgumentError(
      'Unknown value for UIViewAnimatingPosition: $value',
    ),
  };
}

sealed class UITextDragOptions {
  static const UITextDragOptionsNone = 0;
  static const UITextDragOptionStripTextColorFromPreviews = 1;
}

enum UITextDropAction {
  UITextDropActionInsert(0),
  UITextDropActionReplaceSelection(1),
  UITextDropActionReplaceAll(2);

  final int value;
  const UITextDropAction(this.value);

  static UITextDropAction fromValue(int value) => switch (value) {
    0 => UITextDropActionInsert,
    1 => UITextDropActionReplaceSelection,
    2 => UITextDropActionReplaceAll,
    _ => throw ArgumentError('Unknown value for UITextDropAction: $value'),
  };
}

enum UITextDropProgressMode {
  UITextDropProgressModeSystem(0),
  UITextDropProgressModeCustom(1);

  final int value;
  const UITextDropProgressMode(this.value);

  static UITextDropProgressMode fromValue(int value) => switch (value) {
    0 => UITextDropProgressModeSystem,
    1 => UITextDropProgressModeCustom,
    _ => throw ArgumentError(
      'Unknown value for UITextDropProgressMode: $value',
    ),
  };
}

enum UITextDropPerformer {
  UITextDropPerformerView(0),
  UITextDropPerformerDelegate(1);

  final int value;
  const UITextDropPerformer(this.value);

  static UITextDropPerformer fromValue(int value) => switch (value) {
    0 => UITextDropPerformerView,
    1 => UITextDropPerformerDelegate,
    _ => throw ArgumentError('Unknown value for UITextDropPerformer: $value'),
  };
}

enum UITextDropEditability {
  UITextDropEditabilityNo(0),
  UITextDropEditabilityTemporary(1),
  UITextDropEditabilityYes(2);

  final int value;
  const UITextDropEditability(this.value);

  static UITextDropEditability fromValue(int value) => switch (value) {
    0 => UITextDropEditabilityNo,
    1 => UITextDropEditabilityTemporary,
    2 => UITextDropEditabilityYes,
    _ => throw ArgumentError('Unknown value for UITextDropEditability: $value'),
  };
}

/// WARNING: UIContentSizeCategoryAdjusting is a stub. To generate bindings for this class, include
/// UIContentSizeCategoryAdjusting in your config's objc-protocols list.
///
/// UIContentSizeCategoryAdjusting
extension type UIContentSizeCategoryAdjusting._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIContentSizeCategoryAdjusting] that points to the same underlying object as [other].
  UIContentSizeCategoryAdjusting.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIContentSizeCategoryAdjusting] that wraps the given raw object pointer.
  UIContentSizeCategoryAdjusting.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

enum UILetterformAwareSizingRule {
  UILetterformAwareSizingRuleTypographic(0),
  UILetterformAwareSizingRuleOversize(1);

  final int value;
  const UILetterformAwareSizingRule(this.value);

  static UILetterformAwareSizingRule fromValue(int value) => switch (value) {
    0 => UILetterformAwareSizingRuleTypographic,
    1 => UILetterformAwareSizingRuleOversize,
    _ => throw ArgumentError(
      'Unknown value for UILetterformAwareSizingRule: $value',
    ),
  };
}

/// WARNING: UILetterformAwareAdjusting is a stub. To generate bindings for this class, include
/// UILetterformAwareAdjusting in your config's objc-protocols list.
///
/// UILetterformAwareAdjusting
extension type UILetterformAwareAdjusting._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UILetterformAwareAdjusting] that points to the same underlying object as [other].
  UILetterformAwareAdjusting.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UILetterformAwareAdjusting] that wraps the given raw object pointer.
  UILetterformAwareAdjusting.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

enum UITextBorderStyle {
  UITextBorderStyleNone(0),
  UITextBorderStyleLine(1),
  UITextBorderStyleBezel(2),
  UITextBorderStyleRoundedRect(3);

  final int value;
  const UITextBorderStyle(this.value);

  static UITextBorderStyle fromValue(int value) => switch (value) {
    0 => UITextBorderStyleNone,
    1 => UITextBorderStyleLine,
    2 => UITextBorderStyleBezel,
    3 => UITextBorderStyleRoundedRect,
    _ => throw ArgumentError('Unknown value for UITextBorderStyle: $value'),
  };
}

enum UITextFieldViewMode {
  UITextFieldViewModeNever(0),
  UITextFieldViewModeWhileEditing(1),
  UITextFieldViewModeUnlessEditing(2),
  UITextFieldViewModeAlways(3);

  final int value;
  const UITextFieldViewMode(this.value);

  static UITextFieldViewMode fromValue(int value) => switch (value) {
    0 => UITextFieldViewModeNever,
    1 => UITextFieldViewModeWhileEditing,
    2 => UITextFieldViewModeUnlessEditing,
    3 => UITextFieldViewModeAlways,
    _ => throw ArgumentError('Unknown value for UITextFieldViewMode: $value'),
  };
}

enum UITextFieldDidEndEditingReason {
  UITextFieldDidEndEditingReasonCommitted(0),
  UITextFieldDidEndEditingReasonCancelled(1);

  final int value;
  const UITextFieldDidEndEditingReason(this.value);

  static UITextFieldDidEndEditingReason fromValue(int value) => switch (value) {
    0 => UITextFieldDidEndEditingReasonCommitted,
    1 => UITextFieldDidEndEditingReasonCancelled,
    _ => throw ArgumentError(
      'Unknown value for UITextFieldDidEndEditingReason: $value',
    ),
  };
}

enum UIStatusBarStyle {
  UIStatusBarStyleDefault(0),
  UIStatusBarStyleLightContent(1),
  UIStatusBarStyleDarkContent(3),
  UIStatusBarStyleBlackOpaque(2);

  static const UIStatusBarStyleBlackTranslucent = UIStatusBarStyleLightContent;

  final int value;
  const UIStatusBarStyle(this.value);

  static UIStatusBarStyle fromValue(int value) => switch (value) {
    0 => UIStatusBarStyleDefault,
    1 => UIStatusBarStyleLightContent,
    3 => UIStatusBarStyleDarkContent,
    2 => UIStatusBarStyleBlackOpaque,
    _ => throw ArgumentError('Unknown value for UIStatusBarStyle: $value'),
  };

  @override
  String toString() {
    if (this == UIStatusBarStyleLightContent)
      return "UIStatusBarStyle.UIStatusBarStyleLightContent, UIStatusBarStyle.UIStatusBarStyleBlackTranslucent";
    return super.toString();
  }
}

enum UIStatusBarAnimation {
  UIStatusBarAnimationNone(0),
  UIStatusBarAnimationFade(1),
  UIStatusBarAnimationSlide(2);

  final int value;
  const UIStatusBarAnimation(this.value);

  static UIStatusBarAnimation fromValue(int value) => switch (value) {
    0 => UIStatusBarAnimationNone,
    1 => UIStatusBarAnimationFade,
    2 => UIStatusBarAnimationSlide,
    _ => throw ArgumentError('Unknown value for UIStatusBarAnimation: $value'),
  };
}

enum UIModalTransitionStyle {
  UIModalTransitionStyleCoverVertical(0),
  UIModalTransitionStyleFlipHorizontal(1),
  UIModalTransitionStyleCrossDissolve(2),
  UIModalTransitionStylePartialCurl(3);

  final int value;
  const UIModalTransitionStyle(this.value);

  static UIModalTransitionStyle fromValue(int value) => switch (value) {
    0 => UIModalTransitionStyleCoverVertical,
    1 => UIModalTransitionStyleFlipHorizontal,
    2 => UIModalTransitionStyleCrossDissolve,
    3 => UIModalTransitionStylePartialCurl,
    _ => throw ArgumentError(
      'Unknown value for UIModalTransitionStyle: $value',
    ),
  };
}

enum UIModalPresentationStyle {
  UIModalPresentationFullScreen(0),
  UIModalPresentationPageSheet(1),
  UIModalPresentationFormSheet(2),
  UIModalPresentationCurrentContext(3),
  UIModalPresentationCustom(4),
  UIModalPresentationOverFullScreen(5),
  UIModalPresentationOverCurrentContext(6),
  UIModalPresentationPopover(7),
  UIModalPresentationBlurOverFullScreen(8),
  UIModalPresentationNone(-1),
  UIModalPresentationAutomatic(-2);

  final int value;
  const UIModalPresentationStyle(this.value);

  static UIModalPresentationStyle fromValue(int value) => switch (value) {
    0 => UIModalPresentationFullScreen,
    1 => UIModalPresentationPageSheet,
    2 => UIModalPresentationFormSheet,
    3 => UIModalPresentationCurrentContext,
    4 => UIModalPresentationCustom,
    5 => UIModalPresentationOverFullScreen,
    6 => UIModalPresentationOverCurrentContext,
    7 => UIModalPresentationPopover,
    8 => UIModalPresentationBlurOverFullScreen,
    -1 => UIModalPresentationNone,
    -2 => UIModalPresentationAutomatic,
    _ => throw ArgumentError(
      'Unknown value for UIModalPresentationStyle: $value',
    ),
  };
}

/// WARNING: UIContentContainer is a stub. To generate bindings for this class, include
/// UIContentContainer in your config's objc-protocols list.
///
/// UIContentContainer
extension type UIContentContainer._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIContentContainer] that points to the same underlying object as [other].
  UIContentContainer.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIContentContainer] that wraps the given raw object pointer.
  UIContentContainer.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

enum UIContainerBackgroundStyle {
  UIContainerBackgroundStyleAutomatic(0),
  UIContainerBackgroundStyleGlass(1),
  UIContainerBackgroundStyleHidden(2);

  final int value;
  const UIContainerBackgroundStyle(this.value);

  static UIContainerBackgroundStyle fromValue(int value) => switch (value) {
    0 => UIContainerBackgroundStyleAutomatic,
    1 => UIContainerBackgroundStyleGlass,
    2 => UIContainerBackgroundStyleHidden,
    _ => throw ArgumentError(
      'Unknown value for UIContainerBackgroundStyle: $value',
    ),
  };
}

late final _class_UISymbolEffectCompletionContext = objc.getClass(
  "UISymbolEffectCompletionContext",
);
late final _sel_isFinished = objc.registerName("isFinished");

/// WARNING: NSSymbolEffect is a stub. To generate bindings for this class, include
/// NSSymbolEffect in your config's objc-interfaces list.
///
/// NSSymbolEffect
extension type NSSymbolEffect._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSCopying,
        objc.NSSecureCoding {
  /// Constructs a [NSSymbolEffect] that points to the same underlying object as [other].
  NSSymbolEffect.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSSymbolEffect',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
  }

  /// Constructs a [NSSymbolEffect] that wraps the given raw object pointer.
  NSSymbolEffect.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSSymbolEffect',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
  }
}

late final _sel_effect = objc.registerName("effect");

/// WARNING: NSSymbolContentTransition is a stub. To generate bindings for this class, include
/// NSSymbolContentTransition in your config's objc-interfaces list.
///
/// NSSymbolContentTransition
extension type NSSymbolContentTransition._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSCopying,
        objc.NSSecureCoding {
  /// Constructs a [NSSymbolContentTransition] that points to the same underlying object as [other].
  NSSymbolContentTransition.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSSymbolContentTransition',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
  }

  /// Constructs a [NSSymbolContentTransition] that wraps the given raw object pointer.
  NSSymbolContentTransition.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSSymbolContentTransition',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
  }
}

late final _sel_contentTransition = objc.registerName("contentTransition");

/// UISymbolEffectCompletionContext
extension type UISymbolEffectCompletionContext._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [UISymbolEffectCompletionContext] that points to the same underlying object as [other].
  UISymbolEffectCompletionContext.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UISymbolEffectCompletionContext',
      iOS: (false, (17, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [UISymbolEffectCompletionContext] that wraps the given raw object pointer.
  UISymbolEffectCompletionContext.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UISymbolEffectCompletionContext',
      iOS: (false, (17, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UISymbolEffectCompletionContext].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_UISymbolEffectCompletionContext,
  );

  /// alloc
  static UISymbolEffectCompletionContext alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_UISymbolEffectCompletionContext,
      _sel_alloc,
    );
    return UISymbolEffectCompletionContext.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static UISymbolEffectCompletionContext allocWithZone(
    ffi.Pointer<objc.NSZone> zone,
  ) {
    final $ret = _objc_msgSend_1cwp428(
      _class_UISymbolEffectCompletionContext,
      _sel_allocWithZone_,
      zone,
    );
    return UISymbolEffectCompletionContext.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static UISymbolEffectCompletionContext new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_UISymbolEffectCompletionContext,
      _sel_new,
    );
    return UISymbolEffectCompletionContext.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// Returns a new instance of UISymbolEffectCompletionContext constructed with the default `new` method.
  UISymbolEffectCompletionContext() : this.as(new$().object$);
}

extension UISymbolEffectCompletionContext$Methods
    on UISymbolEffectCompletionContext {
  /// contentTransition
  NSSymbolContentTransition? get contentTransition {
    objc.checkOsVersionInternal(
      'UISymbolEffectCompletionContext.contentTransition',
      iOS: (false, (17, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_contentTransition,
    );
    return $ret.address == 0
        ? null
        : NSSymbolContentTransition.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// effect
  NSSymbolEffect? get effect {
    objc.checkOsVersionInternal(
      'UISymbolEffectCompletionContext.effect',
      iOS: (false, (17, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_effect);
    return $ret.address == 0
        ? null
        : NSSymbolEffect.fromPointer($ret, retain: true, release: true);
  }

  /// init
  UISymbolEffectCompletionContext init() {
    objc.checkOsVersionInternal(
      'UISymbolEffectCompletionContext.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return UISymbolEffectCompletionContext.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// isFinished
  bool get isFinished {
    objc.checkOsVersionInternal(
      'UISymbolEffectCompletionContext.isFinished',
      iOS: (false, (17, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isFinished);
  }

  /// sender
  objc.ObjCObject? get sender {
    objc.checkOsVersionInternal(
      'UISymbolEffectCompletionContext.sender',
      iOS: (false, (17, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_sender);
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>`.
abstract final class ObjCBlock_ffiVoid_UISymbolEffectCompletionContext {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>
  fromFunction(
    void Function(UISymbolEffectCompletionContext) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        UISymbolEffectCompletionContext.fromPointer(
          arg0,
          retain: true,
          release: true,
        ),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>
  listener(
    void Function(UISymbolEffectCompletionContext) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        UISymbolEffectCompletionContext.fromPointer(
          arg0,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>
  blocking(
    void Function(UISymbolEffectCompletionContext) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        UISymbolEffectCompletionContext.fromPointer(
          arg0,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        UISymbolEffectCompletionContext.fromPointer(
          arg0,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)>`.
extension ObjCBlock_ffiVoid_UISymbolEffectCompletionContext$CallExtension
    on objc.ObjCBlock<ffi.Void Function(UISymbolEffectCompletionContext)> {
  void call(UISymbolEffectCompletionContext arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0.ref.pointer);
}

/// WARNING: UIImageView is a stub. To generate bindings for this class, include
/// UIImageView in your config's objc-interfaces list.
///
/// UIImageView
extension type UIImageView._(objc.ObjCObject object$)
    implements objc.ObjCObject, UIView {
  /// Constructs a [UIImageView] that points to the same underlying object as [other].
  UIImageView.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIImageView', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIImageView] that wraps the given raw object pointer.
  UIImageView.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIImageView', iOS: (false, (2, 0, 0)));
  }
}

/// Construction methods for `objc.ObjCBlock<UIColor Function(UIColor)>`.
abstract final class ObjCBlock_UIColor_UIColor {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIColor Function(UIColor)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UIColor Function(UIColor)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIColor Function(UIColor)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<UIColor Function(UIColor)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIColor Function(UIColor)> fromFunction(
    UIColor Function(UIColor) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UIColor Function(UIColor)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        UIColor.fromPointer(arg0, retain: true, release: true),
      ).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<UIColor Function(UIColor)>`.
extension ObjCBlock_UIColor_UIColor$CallExtension
    on objc.ObjCBlock<UIColor Function(UIColor)> {
  UIColor call(UIColor arg0) => UIColor.fromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<objc.ObjCObjectImpl> arg0,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >()(ref.pointer, arg0.ref.pointer),
    retain: true,
    release: true,
  );
}

/// WARNING: UIBackgroundConfiguration is a stub. To generate bindings for this class, include
/// UIBackgroundConfiguration in your config's objc-interfaces list.
///
/// UIBackgroundConfiguration
extension type UIBackgroundConfiguration._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSCopying,
        objc.NSSecureCoding {
  /// Constructs a [UIBackgroundConfiguration] that points to the same underlying object as [other].
  UIBackgroundConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UIBackgroundConfiguration',
      iOS: (false, (14, 0, 0)),
    );
  }

  /// Constructs a [UIBackgroundConfiguration] that wraps the given raw object pointer.
  UIBackgroundConfiguration.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UIBackgroundConfiguration',
      iOS: (false, (14, 0, 0)),
    );
  }
}

enum UIBarMetrics {
  UIBarMetricsDefault(0),
  UIBarMetricsCompact(1),
  UIBarMetricsDefaultPrompt(101),
  UIBarMetricsCompactPrompt(102);

  static const UIBarMetricsLandscapePhone = UIBarMetricsCompact;
  static const UIBarMetricsLandscapePhonePrompt = UIBarMetricsCompactPrompt;

  final int value;
  const UIBarMetrics(this.value);

  static UIBarMetrics fromValue(int value) => switch (value) {
    0 => UIBarMetricsDefault,
    1 => UIBarMetricsCompact,
    101 => UIBarMetricsDefaultPrompt,
    102 => UIBarMetricsCompactPrompt,
    _ => throw ArgumentError('Unknown value for UIBarMetrics: $value'),
  };

  @override
  String toString() {
    if (this == UIBarMetricsCompact)
      return "UIBarMetrics.UIBarMetricsCompact, UIBarMetrics.UIBarMetricsLandscapePhone";
    if (this == UIBarMetricsCompactPrompt)
      return "UIBarMetrics.UIBarMetricsCompactPrompt, UIBarMetrics.UIBarMetricsLandscapePhonePrompt";
    return super.toString();
  }
}

enum UIBarPosition {
  UIBarPositionAny(0),
  UIBarPositionBottom(1),
  UIBarPositionTop(2),
  UIBarPositionTopAttached(3);

  final int value;
  const UIBarPosition(this.value);

  static UIBarPosition fromValue(int value) => switch (value) {
    0 => UIBarPositionAny,
    1 => UIBarPositionBottom,
    2 => UIBarPositionTop,
    3 => UIBarPositionTopAttached,
    _ => throw ArgumentError('Unknown value for UIBarPosition: $value'),
  };
}

enum UIBarButtonItemStyle {
  UIBarButtonItemStylePlain(0),
  UIBarButtonItemStyleProminent(2),
  UIBarButtonItemStyleBordered(1);

  static const UIBarButtonItemStyleDone = UIBarButtonItemStyleProminent;

  final int value;
  const UIBarButtonItemStyle(this.value);

  static UIBarButtonItemStyle fromValue(int value) => switch (value) {
    0 => UIBarButtonItemStylePlain,
    2 => UIBarButtonItemStyleProminent,
    1 => UIBarButtonItemStyleBordered,
    _ => throw ArgumentError('Unknown value for UIBarButtonItemStyle: $value'),
  };

  @override
  String toString() {
    if (this == UIBarButtonItemStyleProminent)
      return "UIBarButtonItemStyle.UIBarButtonItemStyleProminent, UIBarButtonItemStyle.UIBarButtonItemStyleDone";
    return super.toString();
  }
}

enum UIBarButtonSystemItem {
  UIBarButtonSystemItemDone(0),
  UIBarButtonSystemItemCancel(1),
  UIBarButtonSystemItemEdit(2),
  UIBarButtonSystemItemSave(3),
  UIBarButtonSystemItemAdd(4),
  UIBarButtonSystemItemFlexibleSpace(5),
  UIBarButtonSystemItemFixedSpace(6),
  UIBarButtonSystemItemCompose(7),
  UIBarButtonSystemItemReply(8),
  UIBarButtonSystemItemAction(9),
  UIBarButtonSystemItemOrganize(10),
  UIBarButtonSystemItemBookmarks(11),
  UIBarButtonSystemItemSearch(12),
  UIBarButtonSystemItemRefresh(13),
  UIBarButtonSystemItemStop(14),
  UIBarButtonSystemItemCamera(15),
  UIBarButtonSystemItemTrash(16),
  UIBarButtonSystemItemPlay(17),
  UIBarButtonSystemItemPause(18),
  UIBarButtonSystemItemRewind(19),
  UIBarButtonSystemItemFastForward(20),
  UIBarButtonSystemItemUndo(21),
  UIBarButtonSystemItemRedo(22),
  UIBarButtonSystemItemPageCurl(23),
  UIBarButtonSystemItemClose(24),
  UIBarButtonSystemItemWritingTools(25);

  final int value;
  const UIBarButtonSystemItem(this.value);

  static UIBarButtonSystemItem fromValue(int value) => switch (value) {
    0 => UIBarButtonSystemItemDone,
    1 => UIBarButtonSystemItemCancel,
    2 => UIBarButtonSystemItemEdit,
    3 => UIBarButtonSystemItemSave,
    4 => UIBarButtonSystemItemAdd,
    5 => UIBarButtonSystemItemFlexibleSpace,
    6 => UIBarButtonSystemItemFixedSpace,
    7 => UIBarButtonSystemItemCompose,
    8 => UIBarButtonSystemItemReply,
    9 => UIBarButtonSystemItemAction,
    10 => UIBarButtonSystemItemOrganize,
    11 => UIBarButtonSystemItemBookmarks,
    12 => UIBarButtonSystemItemSearch,
    13 => UIBarButtonSystemItemRefresh,
    14 => UIBarButtonSystemItemStop,
    15 => UIBarButtonSystemItemCamera,
    16 => UIBarButtonSystemItemTrash,
    17 => UIBarButtonSystemItemPlay,
    18 => UIBarButtonSystemItemPause,
    19 => UIBarButtonSystemItemRewind,
    20 => UIBarButtonSystemItemFastForward,
    21 => UIBarButtonSystemItemUndo,
    22 => UIBarButtonSystemItemRedo,
    23 => UIBarButtonSystemItemPageCurl,
    24 => UIBarButtonSystemItemClose,
    25 => UIBarButtonSystemItemWritingTools,
    _ => throw ArgumentError('Unknown value for UIBarButtonSystemItem: $value'),
  };
}

enum UIGestureRecognizerState {
  UIGestureRecognizerStatePossible(0),
  UIGestureRecognizerStateBegan(1),
  UIGestureRecognizerStateChanged(2),
  UIGestureRecognizerStateEnded(3),
  UIGestureRecognizerStateCancelled(4),
  UIGestureRecognizerStateFailed(5);

  static const UIGestureRecognizerStateRecognized =
      UIGestureRecognizerStateEnded;

  final int value;
  const UIGestureRecognizerState(this.value);

  static UIGestureRecognizerState fromValue(int value) => switch (value) {
    0 => UIGestureRecognizerStatePossible,
    1 => UIGestureRecognizerStateBegan,
    2 => UIGestureRecognizerStateChanged,
    3 => UIGestureRecognizerStateEnded,
    4 => UIGestureRecognizerStateCancelled,
    5 => UIGestureRecognizerStateFailed,
    _ => throw ArgumentError(
      'Unknown value for UIGestureRecognizerState: $value',
    ),
  };

  @override
  String toString() {
    if (this == UIGestureRecognizerStateEnded)
      return "UIGestureRecognizerState.UIGestureRecognizerStateEnded, UIGestureRecognizerState.UIGestureRecognizerStateRecognized";
    return super.toString();
  }
}

/// WARNING: UIGestureRecognizerDelegate is a stub. To generate bindings for this class, include
/// UIGestureRecognizerDelegate in your config's objc-protocols list.
///
/// UIGestureRecognizerDelegate
extension type UIGestureRecognizerDelegate._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [UIGestureRecognizerDelegate] that points to the same underlying object as [other].
  UIGestureRecognizerDelegate.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIGestureRecognizerDelegate] that wraps the given raw object pointer.
  UIGestureRecognizerDelegate.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

enum UITableViewCellStyle {
  UITableViewCellStyleDefault(0),
  UITableViewCellStyleValue1(1),
  UITableViewCellStyleValue2(2),
  UITableViewCellStyleSubtitle(3);

  final int value;
  const UITableViewCellStyle(this.value);

  static UITableViewCellStyle fromValue(int value) => switch (value) {
    0 => UITableViewCellStyleDefault,
    1 => UITableViewCellStyleValue1,
    2 => UITableViewCellStyleValue2,
    3 => UITableViewCellStyleSubtitle,
    _ => throw ArgumentError('Unknown value for UITableViewCellStyle: $value'),
  };
}

enum UITableViewCellSeparatorStyle {
  UITableViewCellSeparatorStyleNone(0),
  UITableViewCellSeparatorStyleSingleLine(1),
  UITableViewCellSeparatorStyleSingleLineEtched(2);

  final int value;
  const UITableViewCellSeparatorStyle(this.value);

  static UITableViewCellSeparatorStyle fromValue(int value) => switch (value) {
    0 => UITableViewCellSeparatorStyleNone,
    1 => UITableViewCellSeparatorStyleSingleLine,
    2 => UITableViewCellSeparatorStyleSingleLineEtched,
    _ => throw ArgumentError(
      'Unknown value for UITableViewCellSeparatorStyle: $value',
    ),
  };
}

enum UITableViewCellSelectionStyle {
  UITableViewCellSelectionStyleNone(0),
  UITableViewCellSelectionStyleBlue(1),
  UITableViewCellSelectionStyleGray(2),
  UITableViewCellSelectionStyleDefault(3);

  final int value;
  const UITableViewCellSelectionStyle(this.value);

  static UITableViewCellSelectionStyle fromValue(int value) => switch (value) {
    0 => UITableViewCellSelectionStyleNone,
    1 => UITableViewCellSelectionStyleBlue,
    2 => UITableViewCellSelectionStyleGray,
    3 => UITableViewCellSelectionStyleDefault,
    _ => throw ArgumentError(
      'Unknown value for UITableViewCellSelectionStyle: $value',
    ),
  };
}

enum UITableViewCellFocusStyle {
  UITableViewCellFocusStyleDefault(0),
  UITableViewCellFocusStyleCustom(1);

  final int value;
  const UITableViewCellFocusStyle(this.value);

  static UITableViewCellFocusStyle fromValue(int value) => switch (value) {
    0 => UITableViewCellFocusStyleDefault,
    1 => UITableViewCellFocusStyleCustom,
    _ => throw ArgumentError(
      'Unknown value for UITableViewCellFocusStyle: $value',
    ),
  };
}

enum UITableViewCellEditingStyle {
  UITableViewCellEditingStyleNone(0),
  UITableViewCellEditingStyleDelete(1),
  UITableViewCellEditingStyleInsert(2);

  final int value;
  const UITableViewCellEditingStyle(this.value);

  static UITableViewCellEditingStyle fromValue(int value) => switch (value) {
    0 => UITableViewCellEditingStyleNone,
    1 => UITableViewCellEditingStyleDelete,
    2 => UITableViewCellEditingStyleInsert,
    _ => throw ArgumentError(
      'Unknown value for UITableViewCellEditingStyle: $value',
    ),
  };
}

enum UITableViewCellAccessoryType {
  UITableViewCellAccessoryNone(0),
  UITableViewCellAccessoryDisclosureIndicator(1),
  UITableViewCellAccessoryDetailDisclosureButton(2),
  UITableViewCellAccessoryCheckmark(3),
  UITableViewCellAccessoryDetailButton(4);

  final int value;
  const UITableViewCellAccessoryType(this.value);

  static UITableViewCellAccessoryType fromValue(int value) => switch (value) {
    0 => UITableViewCellAccessoryNone,
    1 => UITableViewCellAccessoryDisclosureIndicator,
    2 => UITableViewCellAccessoryDetailDisclosureButton,
    3 => UITableViewCellAccessoryCheckmark,
    4 => UITableViewCellAccessoryDetailButton,
    _ => throw ArgumentError(
      'Unknown value for UITableViewCellAccessoryType: $value',
    ),
  };
}

sealed class UITableViewCellStateMask {
  static const UITableViewCellStateDefaultMask = 0;
  static const UITableViewCellStateShowingEditControlMask = 1;
  static const UITableViewCellStateShowingDeleteConfirmationMask = 2;
}

enum UITableViewCellDragState {
  UITableViewCellDragStateNone(0),
  UITableViewCellDragStateLifting(1),
  UITableViewCellDragStateDragging(2);

  final int value;
  const UITableViewCellDragState(this.value);

  static UITableViewCellDragState fromValue(int value) => switch (value) {
    0 => UITableViewCellDragStateNone,
    1 => UITableViewCellDragStateLifting,
    2 => UITableViewCellDragStateDragging,
    _ => throw ArgumentError(
      'Unknown value for UITableViewCellDragState: $value',
    ),
  };
}

late final _class_UITableViewCell = objc.getClass("UITableViewCell");
late final _sel_initWithStyle_reuseIdentifier_ = objc.registerName(
  "initWithStyle:reuseIdentifier:",
);
final _objc_msgSend_96u4vv = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _class_UICellConfigurationState = objc.getClass(
  "UICellConfigurationState",
);
late final _sel_isEditing = objc.registerName("isEditing");
late final _sel_setEditing_ = objc.registerName("setEditing:");
late final _sel_isExpanded = objc.registerName("isExpanded");
late final _sel_setExpanded_ = objc.registerName("setExpanded:");
late final _sel_isSwiped = objc.registerName("isSwiped");
late final _sel_setSwiped_ = objc.registerName("setSwiped:");
late final _sel_isReordering = objc.registerName("isReordering");
late final _sel_setReordering_ = objc.registerName("setReordering:");

enum UICellConfigurationDragState {
  UICellConfigurationDragStateNone(0),
  UICellConfigurationDragStateLifting(1),
  UICellConfigurationDragStateDragging(2);

  final int value;
  const UICellConfigurationDragState(this.value);

  static UICellConfigurationDragState fromValue(int value) => switch (value) {
    0 => UICellConfigurationDragStateNone,
    1 => UICellConfigurationDragStateLifting,
    2 => UICellConfigurationDragStateDragging,
    _ => throw ArgumentError(
      'Unknown value for UICellConfigurationDragState: $value',
    ),
  };
}

late final _sel_cellDragState = objc.registerName("cellDragState");
final _objc_msgSend_10i7aka = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setCellDragState_ = objc.registerName("setCellDragState:");
final _objc_msgSend_1murqn0 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

enum UICellConfigurationDropState {
  UICellConfigurationDropStateNone(0),
  UICellConfigurationDropStateNotTargeted(1),
  UICellConfigurationDropStateTargeted(2);

  final int value;
  const UICellConfigurationDropState(this.value);

  static UICellConfigurationDropState fromValue(int value) => switch (value) {
    0 => UICellConfigurationDropStateNone,
    1 => UICellConfigurationDropStateNotTargeted,
    2 => UICellConfigurationDropStateTargeted,
    _ => throw ArgumentError(
      'Unknown value for UICellConfigurationDropState: $value',
    ),
  };
}

late final _sel_cellDropState = objc.registerName("cellDropState");
final _objc_msgSend_1g9qrcf = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setCellDropState_ = objc.registerName("setCellDropState:");
final _objc_msgSend_9t0hj7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_initWithTraitCollection_ = objc.registerName(
  "initWithTraitCollection:",
);

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_UITraitCollection$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>> Function(
      ffi.Pointer<ffi.Void>,
      UITraitCollection,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>> Function(
          ffi.Pointer<ffi.Void>,
          UITraitCollection,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>> Function(
      ffi.Pointer<ffi.Void>,
      UITraitCollection,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>> Function(
          ffi.Pointer<ffi.Void>,
          UITraitCollection,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>> Function(
      ffi.Pointer<ffi.Void>,
      UITraitCollection,
    )
  >
  fromFunction(
    Dartinstancetype Function(ffi.Pointer<ffi.Void>, UITraitCollection) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>> Function(
          ffi.Pointer<ffi.Void>,
          UITraitCollection,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                UITraitCollection.fromPointer(
                  arg1,
                  retain: true,
                  release: true,
                ),
              ).ref.retainAndReturnPointer(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static instancetype _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          instancetype Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static instancetype _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as instancetype Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>`.
extension ObjCBlock_instancetype_ffiVoid_UITraitCollection$1$CallExtension
    on
        objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>> Function(
            ffi.Pointer<ffi.Void>,
            UITraitCollection,
          )
        > {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, UITraitCollection arg1) =>
      objc.ObjCObject(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0,
                  ffi.Pointer<objc.ObjCObjectImpl> arg1,
                )
              >
            >()
            .asFunction<
              instancetype Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObjectImpl>,
              )
            >()(ref.pointer, arg0, arg1.ref.pointer),
        retain: false,
        release: true,
      );
}

late final _class_UIViewConfigurationState = objc.getClass(
  "UIViewConfigurationState",
);
late final _sel_setTraitCollection_ = objc.registerName("setTraitCollection:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, UITraitCollection) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                UITraitCollection.fromPointer(
                  arg1,
                  retain: true,
                  release: true,
                ),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, UITraitCollection) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        UITraitCollection.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, UITraitCollection) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        UITraitCollection.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        UITraitCollection.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$1$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, UITraitCollection arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_isDisabled = objc.registerName("isDisabled");
late final _sel_setDisabled_ = objc.registerName("setDisabled:");
late final _sel_isHighlighted = objc.registerName("isHighlighted");
late final _sel_setHighlighted_ = objc.registerName("setHighlighted:");
late final _sel_isSelected = objc.registerName("isSelected");
late final _sel_setSelected_ = objc.registerName("setSelected:");
late final _sel_setFocused_ = objc.registerName("setFocused:");
late final _sel_isPinned = objc.registerName("isPinned");
late final _sel_setPinned_ = objc.registerName("setPinned:");
late final _sel_customStateForKey_ = objc.registerName("customStateForKey:");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
abstract final class ObjCBlock_objcObjCObjectImpl_ffiVoid_UIActivityItemsConfigurationMetadataKey {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSString,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSString,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSString,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSString,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSString,
    )
  >
  fromFunction(
    objc.ObjCObject? Function(ffi.Pointer<ffi.Void>, objc.NSString) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSString,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                objc.NSString.fromPointer(arg1, retain: true, release: true),
              )?.ref.retainAndAutorelease() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
extension ObjCBlock_objcObjCObjectImpl_ffiVoid_UIActivityItemsConfigurationMetadataKey$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObjectImpl>? Function(
            ffi.Pointer<ffi.Void>,
            objc.NSString,
          )
        > {
  objc.ObjCObject? call(ffi.Pointer<ffi.Void> arg0, objc.NSString arg1) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer)
              .address ==
          0
      ? null
      : objc.ObjCObject(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer),
          retain: true,
          release: true,
        );
}

late final _sel_setCustomState_forKey_ = objc.registerName(
  "setCustomState:forKey:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSString)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl_UIConfigurationStateCustomKey {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>?,
      objc.NSString,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>?,
          objc.NSString,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>?,
      objc.NSString,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>?,
          objc.NSString,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>?,
      objc.NSString,
    )
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObject?, objc.NSString) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>?,
          objc.NSString,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0,
            arg1.address == 0
                ? null
                : objc.ObjCObject(arg1, retain: true, release: true),
            objc.NSString.fromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>?,
      objc.NSString,
    )
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObject?, objc.NSString) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.ObjCObject(arg1, retain: false, release: true),
        objc.NSString.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObjectImpl>?,
        objc.NSString,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>?,
      objc.NSString,
    )
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObject?, objc.NSString) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.ObjCObject(arg1, retain: false, release: true),
        objc.NSString.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        arg1.address == 0
            ? null
            : objc.ObjCObject(arg1, retain: false, release: true),
        objc.NSString.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_fjrv01(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObjectImpl>?,
        objc.NSString,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSString)>`.
extension ObjCBlock_ffiVoid_ffiVoid_objcObjCObjectImpl_UIConfigurationStateCustomKey$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>?,
            objc.NSString,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    objc.ObjCObject? arg1,
    objc.NSString arg2,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1?.ref.pointer ?? ffi.nullptr,
        arg2.ref.pointer,
      );
}

late final _sel_objectForKeyedSubscript_ = objc.registerName(
  "objectForKeyedSubscript:",
);
late final _sel_setObject_forKeyedSubscript_ = objc.registerName(
  "setObject:forKeyedSubscript:",
);

/// WARNING: UIConfigurationState is a stub. To generate bindings for this class, include
/// UIConfigurationState in your config's objc-protocols list.
///
/// UIConfigurationState
extension type UIConfigurationState._(objc.ObjCProtocol object$)
    implements
        objc.ObjCProtocol,
        objc.NSObjectProtocol,
        objc.NSCopying,
        objc.NSSecureCoding {
  /// Constructs a [UIConfigurationState] that points to the same underlying object as [other].
  UIConfigurationState.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIConfigurationState] that wraps the given raw object pointer.
  UIConfigurationState.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

/// UIViewConfigurationState
extension type UIViewConfigurationState._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, UIConfigurationState {
  /// Constructs a [UIViewConfigurationState] that points to the same underlying object as [other].
  UIViewConfigurationState.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UIViewConfigurationState',
      iOS: (false, (14, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [UIViewConfigurationState] that wraps the given raw object pointer.
  UIViewConfigurationState.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UIViewConfigurationState',
      iOS: (false, (14, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UIViewConfigurationState].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_UIViewConfigurationState,
  );

  /// alloc
  static UIViewConfigurationState alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_UIViewConfigurationState,
      _sel_alloc,
    );
    return UIViewConfigurationState.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static UIViewConfigurationState allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_UIViewConfigurationState,
      _sel_allocWithZone_,
      zone,
    );
    return UIViewConfigurationState.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static UIViewConfigurationState new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_UIViewConfigurationState,
      _sel_new,
    );
    return UIViewConfigurationState.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
      _class_UIViewConfigurationState,
      _sel_supportsSecureCoding,
    );
  }

  /// Returns a new instance of UIViewConfigurationState constructed with the default `new` method.
  UIViewConfigurationState() : this.as(new$().object$);
}

extension UIViewConfigurationState$Methods on UIViewConfigurationState {
  /// customStateForKey:
  objc.ObjCObject? customStateForKey(objc.NSString key) {
    objc.checkOsVersionInternal(
      'UIViewConfigurationState.customStateForKey:',
      iOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_customStateForKey_,
      key.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// init
  UIViewConfigurationState init() {
    objc.checkOsVersionInternal(
      'UIViewConfigurationState.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return UIViewConfigurationState.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCoder:
  UIViewConfigurationState? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : UIViewConfigurationState.fromPointer(
            $ret,
            retain: false,
            release: true,
          );
  }

  /// initWithTraitCollection:
  UIViewConfigurationState initWithTraitCollection(
    UITraitCollection traitCollection,
  ) {
    objc.checkOsVersionInternal(
      'UIViewConfigurationState.initWithTraitCollection:',
      iOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithTraitCollection_,
      traitCollection.ref.pointer,
    );
    return UIViewConfigurationState.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// isDisabled
  bool get isDisabled {
    objc.checkOsVersionInternal(
      'UIViewConfigurationState.isDisabled',
      iOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isDisabled);
  }

  /// isFocused
  bool get isFocused {
    objc.checkOsVersionInternal(
      'UIViewConfigurationState.isFocused',
      iOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isFocused);
  }

  /// isHighlighted
  bool get isHighlighted {
    objc.checkOsVersionInternal(
      'UIViewConfigurationState.isHighlighted',
      iOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isHighlighted);
  }

  /// isPinned
  bool get isPinned {
    objc.checkOsVersionInternal(
      'UIViewConfigurationState.isPinned',
      iOS: (false, (15, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isPinned);
  }

  /// isSelected
  bool get isSelected {
    objc.checkOsVersionInternal(
      'UIViewConfigurationState.isSelected',
      iOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isSelected);
  }

  /// objectForKeyedSubscript:
  objc.ObjCObject? objectForKeyedSubscript(objc.NSString key) {
    objc.checkOsVersionInternal(
      'UIViewConfigurationState.objectForKeyedSubscript:',
      iOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_objectForKeyedSubscript_,
      key.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// setCustomState:forKey:
  void setCustomState(
    objc.ObjCObject? customState, {
    required objc.NSString forKey,
  }) {
    objc.checkOsVersionInternal(
      'UIViewConfigurationState.setCustomState:forKey:',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_setCustomState_forKey_,
      customState?.ref.pointer ?? ffi.nullptr,
      forKey.ref.pointer,
    );
  }

  /// setDisabled:
  set isDisabled(bool value) {
    objc.checkOsVersionInternal(
      'UIViewConfigurationState.setDisabled:',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setDisabled_, value);
  }

  /// setFocused:
  set isFocused(bool value) {
    objc.checkOsVersionInternal(
      'UIViewConfigurationState.setFocused:',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setFocused_, value);
  }

  /// setHighlighted:
  set isHighlighted(bool value) {
    objc.checkOsVersionInternal(
      'UIViewConfigurationState.setHighlighted:',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setHighlighted_, value);
  }

  /// setObject:forKeyedSubscript:
  void setObject(
    objc.ObjCObject? obj, {
    required objc.NSString forKeyedSubscript,
  }) {
    objc.checkOsVersionInternal(
      'UIViewConfigurationState.setObject:forKeyedSubscript:',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_setObject_forKeyedSubscript_,
      obj?.ref.pointer ?? ffi.nullptr,
      forKeyedSubscript.ref.pointer,
    );
  }

  /// setPinned:
  set isPinned(bool value) {
    objc.checkOsVersionInternal(
      'UIViewConfigurationState.setPinned:',
      iOS: (false, (15, 0, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setPinned_, value);
  }

  /// setSelected:
  set isSelected(bool value) {
    objc.checkOsVersionInternal(
      'UIViewConfigurationState.setSelected:',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setSelected_, value);
  }

  /// setTraitCollection:
  set traitCollection(UITraitCollection value) {
    objc.checkOsVersionInternal(
      'UIViewConfigurationState.setTraitCollection:',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setTraitCollection_,
      value.ref.pointer,
    );
  }

  /// traitCollection
  UITraitCollection get traitCollection {
    objc.checkOsVersionInternal(
      'UIViewConfigurationState.traitCollection',
      iOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_traitCollection,
    );
    return UITraitCollection.fromPointer($ret, retain: true, release: true);
  }
}

/// UICellConfigurationState
extension type UICellConfigurationState._(objc.ObjCObject object$)
    implements objc.ObjCObject, UIViewConfigurationState {
  /// Constructs a [UICellConfigurationState] that points to the same underlying object as [other].
  UICellConfigurationState.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UICellConfigurationState',
      iOS: (false, (14, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [UICellConfigurationState] that wraps the given raw object pointer.
  UICellConfigurationState.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UICellConfigurationState',
      iOS: (false, (14, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UICellConfigurationState].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_UICellConfigurationState,
  );

  /// alloc
  static UICellConfigurationState alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_UICellConfigurationState,
      _sel_alloc,
    );
    return UICellConfigurationState.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static UICellConfigurationState allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_UICellConfigurationState,
      _sel_allocWithZone_,
      zone,
    );
    return UICellConfigurationState.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static UICellConfigurationState new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_UICellConfigurationState,
      _sel_new,
    );
    return UICellConfigurationState.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
      _class_UICellConfigurationState,
      _sel_supportsSecureCoding,
    );
  }

  /// Returns a new instance of UICellConfigurationState constructed with the default `new` method.
  UICellConfigurationState() : this.as(new$().object$);
}

extension UICellConfigurationState$Methods on UICellConfigurationState {
  /// cellDragState
  UICellConfigurationDragState get cellDragState {
    final $ret = _objc_msgSend_10i7aka(object$.ref.pointer, _sel_cellDragState);
    return UICellConfigurationDragState.fromValue($ret);
  }

  /// cellDropState
  UICellConfigurationDropState get cellDropState {
    final $ret = _objc_msgSend_1g9qrcf(object$.ref.pointer, _sel_cellDropState);
    return UICellConfigurationDropState.fromValue($ret);
  }

  /// init
  UICellConfigurationState init() {
    objc.checkOsVersionInternal(
      'UICellConfigurationState.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return UICellConfigurationState.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCoder:
  UICellConfigurationState? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : UICellConfigurationState.fromPointer(
            $ret,
            retain: false,
            release: true,
          );
  }

  /// initWithTraitCollection:
  UICellConfigurationState initWithTraitCollection(
    UITraitCollection traitCollection,
  ) {
    objc.checkOsVersionInternal(
      'UICellConfigurationState.initWithTraitCollection:',
      iOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithTraitCollection_,
      traitCollection.ref.pointer,
    );
    return UICellConfigurationState.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// isEditing
  bool get isEditing {
    objc.checkOsVersionInternal(
      'UICellConfigurationState.isEditing',
      iOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isEditing);
  }

  /// isExpanded
  bool get isExpanded {
    objc.checkOsVersionInternal(
      'UICellConfigurationState.isExpanded',
      iOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isExpanded);
  }

  /// isReordering
  bool get isReordering {
    objc.checkOsVersionInternal(
      'UICellConfigurationState.isReordering',
      iOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isReordering);
  }

  /// isSwiped
  bool get isSwiped {
    objc.checkOsVersionInternal(
      'UICellConfigurationState.isSwiped',
      iOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isSwiped);
  }

  /// setCellDragState:
  set cellDragState(UICellConfigurationDragState value) {
    _objc_msgSend_1murqn0(
      object$.ref.pointer,
      _sel_setCellDragState_,
      value.value,
    );
  }

  /// setCellDropState:
  set cellDropState(UICellConfigurationDropState value) {
    _objc_msgSend_9t0hj7(
      object$.ref.pointer,
      _sel_setCellDropState_,
      value.value,
    );
  }

  /// setEditing:
  set isEditing(bool value) {
    objc.checkOsVersionInternal(
      'UICellConfigurationState.setEditing:',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setEditing_, value);
  }

  /// setExpanded:
  set isExpanded(bool value) {
    objc.checkOsVersionInternal(
      'UICellConfigurationState.setExpanded:',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setExpanded_, value);
  }

  /// setReordering:
  set isReordering(bool value) {
    objc.checkOsVersionInternal(
      'UICellConfigurationState.setReordering:',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setReordering_, value);
  }

  /// setSwiped:
  set isSwiped(bool value) {
    objc.checkOsVersionInternal(
      'UICellConfigurationState.setSwiped:',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setSwiped_, value);
  }
}

late final _sel_configurationState = objc.registerName("configurationState");
late final _sel_setNeedsUpdateConfiguration = objc.registerName(
  "setNeedsUpdateConfiguration",
);
late final _sel_updateConfigurationUsingState_ = objc.registerName(
  "updateConfigurationUsingState:",
);
late final _sel_configurationUpdateHandler = objc.registerName(
  "configurationUpdateHandler",
);
final _objc_msgSend_uwvaik = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setConfigurationUpdateHandler_ = objc.registerName(
  "setConfigurationUpdateHandler:",
);

/// WARNING: UIListContentConfiguration is a stub. To generate bindings for this class, include
/// UIListContentConfiguration in your config's objc-interfaces list.
///
/// UIListContentConfiguration
extension type UIListContentConfiguration._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        UIContentConfiguration,
        objc.NSSecureCoding {
  /// Constructs a [UIListContentConfiguration] that points to the same underlying object as [other].
  UIListContentConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UIListContentConfiguration',
      iOS: (false, (14, 0, 0)),
    );
  }

  /// Constructs a [UIListContentConfiguration] that wraps the given raw object pointer.
  UIListContentConfiguration.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UIListContentConfiguration',
      iOS: (false, (14, 0, 0)),
    );
  }
}

late final _sel_defaultContentConfiguration = objc.registerName(
  "defaultContentConfiguration",
);

/// WARNING: UIContentConfiguration is a stub. To generate bindings for this class, include
/// UIContentConfiguration in your config's objc-protocols list.
///
/// UIContentConfiguration
extension type UIContentConfiguration._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol, objc.NSCopying {
  /// Constructs a [UIContentConfiguration] that points to the same underlying object as [other].
  UIContentConfiguration.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [UIContentConfiguration] that wraps the given raw object pointer.
  UIContentConfiguration.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_contentConfiguration = objc.registerName(
  "contentConfiguration",
);
late final _sel_setContentConfiguration_ = objc.registerName(
  "setContentConfiguration:",
);
late final _sel_automaticallyUpdatesContentConfiguration = objc.registerName(
  "automaticallyUpdatesContentConfiguration",
);
late final _sel_setAutomaticallyUpdatesContentConfiguration_ = objc
    .registerName("setAutomaticallyUpdatesContentConfiguration:");
late final _sel_contentView = objc.registerName("contentView");
late final _sel_imageView = objc.registerName("imageView");

/// WARNING: UILabel is a stub. To generate bindings for this class, include
/// UILabel in your config's objc-interfaces list.
///
/// UILabel
extension type UILabel._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        UIView,
        objc.NSCoding,
        UIContentSizeCategoryAdjusting,
        UILetterformAwareAdjusting {
  /// Constructs a [UILabel] that points to the same underlying object as [other].
  UILabel.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UILabel', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UILabel] that wraps the given raw object pointer.
  UILabel.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UILabel', iOS: (false, (2, 0, 0)));
  }
}

late final _sel_textLabel = objc.registerName("textLabel");
late final _sel_detailTextLabel = objc.registerName("detailTextLabel");
late final _sel_defaultBackgroundConfiguration = objc.registerName(
  "defaultBackgroundConfiguration",
);
late final _sel_backgroundConfiguration = objc.registerName(
  "backgroundConfiguration",
);
late final _sel_setBackgroundConfiguration_ = objc.registerName(
  "setBackgroundConfiguration:",
);
late final _sel_automaticallyUpdatesBackgroundConfiguration = objc.registerName(
  "automaticallyUpdatesBackgroundConfiguration",
);
late final _sel_setAutomaticallyUpdatesBackgroundConfiguration_ = objc
    .registerName("setAutomaticallyUpdatesBackgroundConfiguration:");
late final _sel_backgroundView = objc.registerName("backgroundView");
late final _sel_setBackgroundView_ = objc.registerName("setBackgroundView:");
late final _sel_selectedBackgroundView = objc.registerName(
  "selectedBackgroundView",
);
late final _sel_setSelectedBackgroundView_ = objc.registerName(
  "setSelectedBackgroundView:",
);
late final _sel_multipleSelectionBackgroundView = objc.registerName(
  "multipleSelectionBackgroundView",
);
late final _sel_setMultipleSelectionBackgroundView_ = objc.registerName(
  "setMultipleSelectionBackgroundView:",
);
late final _sel_reuseIdentifier = objc.registerName("reuseIdentifier");
late final _sel_prepareForReuse = objc.registerName("prepareForReuse");
late final _sel_selectionStyle = objc.registerName("selectionStyle");
final _objc_msgSend_1d2lxkb = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setSelectionStyle_ = objc.registerName("setSelectionStyle:");
final _objc_msgSend_1uwq2nz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_setSelected_animated_ = objc.registerName(
  "setSelected:animated:",
);
final _objc_msgSend_14iqu8t = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
        bool,
      )
    >();
late final _sel_setHighlighted_animated_ = objc.registerName(
  "setHighlighted:animated:",
);
late final _sel_editingStyle = objc.registerName("editingStyle");
final _objc_msgSend_rz99rt = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_showsReorderControl = objc.registerName("showsReorderControl");
late final _sel_setShowsReorderControl_ = objc.registerName(
  "setShowsReorderControl:",
);
late final _sel_shouldIndentWhileEditing = objc.registerName(
  "shouldIndentWhileEditing",
);
late final _sel_setShouldIndentWhileEditing_ = objc.registerName(
  "setShouldIndentWhileEditing:",
);
late final _sel_accessoryType = objc.registerName("accessoryType");
final _objc_msgSend_1vg5j0q = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setAccessoryType_ = objc.registerName("setAccessoryType:");
final _objc_msgSend_c8nyto = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_accessoryView = objc.registerName("accessoryView");
late final _sel_setAccessoryView_ = objc.registerName("setAccessoryView:");
late final _sel_editingAccessoryType = objc.registerName(
  "editingAccessoryType",
);
late final _sel_setEditingAccessoryType_ = objc.registerName(
  "setEditingAccessoryType:",
);
late final _sel_editingAccessoryView = objc.registerName(
  "editingAccessoryView",
);
late final _sel_setEditingAccessoryView_ = objc.registerName(
  "setEditingAccessoryView:",
);
late final _sel_indentationLevel = objc.registerName("indentationLevel");
late final _sel_setIndentationLevel_ = objc.registerName(
  "setIndentationLevel:",
);
late final _sel_indentationWidth = objc.registerName("indentationWidth");
late final _sel_setIndentationWidth_ = objc.registerName(
  "setIndentationWidth:",
);
late final _sel_separatorInset = objc.registerName("separatorInset");
late final _sel_setSeparatorInset_ = objc.registerName("setSeparatorInset:");
late final _sel_setEditing_animated_ = objc.registerName(
  "setEditing:animated:",
);
late final _sel_showingDeleteConfirmation = objc.registerName(
  "showingDeleteConfirmation",
);
late final _sel_focusStyle = objc.registerName("focusStyle");
final _objc_msgSend_1o6ymet = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setFocusStyle_ = objc.registerName("setFocusStyle:");
final _objc_msgSend_tbdrv1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_willTransitionToState_ = objc.registerName(
  "willTransitionToState:",
);
final _objc_msgSend_ipxvh9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_didTransitionToState_ = objc.registerName(
  "didTransitionToState:",
);
late final _sel_dragStateDidChange_ = objc.registerName("dragStateDidChange:");
final _objc_msgSend_c54vyn = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_userInteractionEnabledWhileDragging = objc.registerName(
  "userInteractionEnabledWhileDragging",
);
late final _sel_setUserInteractionEnabledWhileDragging_ = objc.registerName(
  "setUserInteractionEnabledWhileDragging:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)>`.
abstract final class ObjCBlock_bool_ffiVoid_UIGestureRecognizer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)
  >
  fromFunction(
    bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                UIGestureRecognizer.fromPointer(
                  arg1,
                  retain: true,
                  release: true,
                ),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as bool Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)>`.
extension ObjCBlock_bool_ffiVoid_UIGestureRecognizer$CallExtension
    on
        objc.ObjCBlock<
          ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer)
        > {
  bool call(ffi.Pointer<ffi.Void> arg0, UIGestureRecognizer arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_gestureRecognizer_shouldRecognizeSimultaneouslyWithGestureRecognizer_ =
    objc.registerName(
      "gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:",
    );
final _objc_msgSend_1lsax7n = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIGestureRecognizer)>`.
abstract final class ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIGestureRecognizer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Bool Function(
      ffi.Pointer<ffi.Void>,
      UIGestureRecognizer,
      UIGestureRecognizer,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void>,
          UIGestureRecognizer,
          UIGestureRecognizer,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Bool Function(
      ffi.Pointer<ffi.Void>,
      UIGestureRecognizer,
      UIGestureRecognizer,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void>,
          UIGestureRecognizer,
          UIGestureRecognizer,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Bool Function(
      ffi.Pointer<ffi.Void>,
      UIGestureRecognizer,
      UIGestureRecognizer,
    )
  >
  fromFunction(
    bool Function(
      ffi.Pointer<ffi.Void>,
      UIGestureRecognizer,
      UIGestureRecognizer,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void>,
          UIGestureRecognizer,
          UIGestureRecognizer,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0,
            UIGestureRecognizer.fromPointer(arg1, retain: true, release: true),
            UIGestureRecognizer.fromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as bool Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIGestureRecognizer)>`.
extension ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIGestureRecognizer$CallExtension
    on
        objc.ObjCBlock<
          ffi.Bool Function(
            ffi.Pointer<ffi.Void>,
            UIGestureRecognizer,
            UIGestureRecognizer,
          )
        > {
  bool call(
    ffi.Pointer<ffi.Void> arg0,
    UIGestureRecognizer arg1,
    UIGestureRecognizer arg2,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_gestureRecognizer_shouldRequireFailureOfGestureRecognizer_ =
    objc.registerName(
      "gestureRecognizer:shouldRequireFailureOfGestureRecognizer:",
    );
late final _sel_gestureRecognizer_shouldBeRequiredToFailByGestureRecognizer_ =
    objc.registerName(
      "gestureRecognizer:shouldBeRequiredToFailByGestureRecognizer:",
    );
late final _sel_gestureRecognizer_shouldReceiveTouch_ = objc.registerName(
  "gestureRecognizer:shouldReceiveTouch:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)>`.
abstract final class ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UITouch {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)
  >
  fromFunction(
    bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0,
            UIGestureRecognizer.fromPointer(arg1, retain: true, release: true),
            UITouch.fromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as bool Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)>`.
extension ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UITouch$CallExtension
    on
        objc.ObjCBlock<
          ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UITouch)
        > {
  bool call(
    ffi.Pointer<ffi.Void> arg0,
    UIGestureRecognizer arg1,
    UITouch arg2,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

/// WARNING: UIPress is a stub. To generate bindings for this class, include
/// UIPress in your config's objc-interfaces list.
///
/// UIPress
extension type UIPress._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [UIPress] that points to the same underlying object as [other].
  UIPress.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIPress', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UIPress] that wraps the given raw object pointer.
  UIPress.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIPress', iOS: (false, (9, 0, 0)));
  }
}

late final _sel_gestureRecognizer_shouldReceivePress_ = objc.registerName(
  "gestureRecognizer:shouldReceivePress:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)>`.
abstract final class ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIPress {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)
  >
  fromFunction(
    bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0,
            UIGestureRecognizer.fromPointer(arg1, retain: true, release: true),
            UIPress.fromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as bool Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)>`.
extension ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIPress$CallExtension
    on
        objc.ObjCBlock<
          ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIPress)
        > {
  bool call(
    ffi.Pointer<ffi.Void> arg0,
    UIGestureRecognizer arg1,
    UIPress arg2,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_gestureRecognizer_shouldReceiveEvent_ = objc.registerName(
  "gestureRecognizer:shouldReceiveEvent:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)>`.
abstract final class ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIEvent {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)
  >
  fromFunction(
    bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0,
            UIGestureRecognizer.fromPointer(arg1, retain: true, release: true),
            UIEvent.fromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as bool Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)>`.
extension ObjCBlock_bool_ffiVoid_UIGestureRecognizer_UIEvent$CallExtension
    on
        objc.ObjCBlock<
          ffi.Bool Function(ffi.Pointer<ffi.Void>, UIGestureRecognizer, UIEvent)
        > {
  bool call(
    ffi.Pointer<ffi.Void> arg0,
    UIGestureRecognizer arg1,
    UIEvent arg2,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_initWithFrame_reuseIdentifier_ = objc.registerName(
  "initWithFrame:reuseIdentifier:",
);
final _objc_msgSend_gxusyk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_text = objc.registerName("text");
late final _sel_setText_ = objc.registerName("setText:");
late final _sel_font = objc.registerName("font");
late final _sel_setFont_ = objc.registerName("setFont:");
late final _sel_textAlignment = objc.registerName("textAlignment");
final _objc_msgSend_buxwfm = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setTextAlignment_ = objc.registerName("setTextAlignment:");
final _objc_msgSend_12huos = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_lineBreakMode = objc.registerName("lineBreakMode");
final _objc_msgSend_ybsdio = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setLineBreakMode_ = objc.registerName("setLineBreakMode:");
final _objc_msgSend_1kdet46 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_textColor = objc.registerName("textColor");
late final _sel_setTextColor_ = objc.registerName("setTextColor:");
late final _sel_selectedTextColor = objc.registerName("selectedTextColor");
late final _sel_setSelectedTextColor_ = objc.registerName(
  "setSelectedTextColor:",
);
late final _sel_hidesAccessoryWhenEditing = objc.registerName(
  "hidesAccessoryWhenEditing",
);
late final _sel_setHidesAccessoryWhenEditing_ = objc.registerName(
  "setHidesAccessoryWhenEditing:",
);
late final _sel_target = objc.registerName("target");
late final _sel_setTarget_ = objc.registerName("setTarget:");
late final _sel_editAction = objc.registerName("editAction");
final _objc_msgSend_1ovaulg = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCSelector> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCSelector> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setEditAction_ = objc.registerName("setEditAction:");
late final _sel_accessoryAction = objc.registerName("accessoryAction");
late final _sel_setAccessoryAction_ = objc.registerName("setAccessoryAction:");

/// UIDeprecated
extension UIDeprecated on UITableViewCell {
  /// accessoryAction
  ffi.Pointer<objc.ObjCSelector> get accessoryAction {
    objc.checkOsVersionInternal(
      'UITableViewCell.accessoryAction',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_1ovaulg(object$.ref.pointer, _sel_accessoryAction);
  }

  /// editAction
  ffi.Pointer<objc.ObjCSelector> get editAction {
    objc.checkOsVersionInternal(
      'UITableViewCell.editAction',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_1ovaulg(object$.ref.pointer, _sel_editAction);
  }

  /// font
  UIFont? get font {
    objc.checkOsVersionInternal(
      'UITableViewCell.font',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_font);
    return $ret.address == 0
        ? null
        : UIFont.fromPointer($ret, retain: true, release: true);
  }

  /// hidesAccessoryWhenEditing
  bool get hidesAccessoryWhenEditing {
    objc.checkOsVersionInternal(
      'UITableViewCell.hidesAccessoryWhenEditing',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_hidesAccessoryWhenEditing,
    );
  }

  /// image
  UIImage? get image {
    objc.checkOsVersionInternal(
      'UITableViewCell.image',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_image);
    return $ret.address == 0
        ? null
        : UIImage.fromPointer($ret, retain: true, release: true);
  }

  /// initWithFrame:reuseIdentifier:
  objc.ObjCObject initWithFrame$1(
    objc.CGRect frame, {
    objc.NSString? reuseIdentifier,
  }) {
    objc.checkOsVersionInternal(
      'UITableViewCell.initWithFrame:reuseIdentifier:',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_gxusyk(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithFrame_reuseIdentifier_,
      frame,
      reuseIdentifier?.ref.pointer ?? ffi.nullptr,
    );
    return objc.ObjCObject($ret, retain: false, release: true);
  }

  /// lineBreakMode
  NSLineBreakMode get lineBreakMode {
    objc.checkOsVersionInternal(
      'UITableViewCell.lineBreakMode',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_ybsdio(object$.ref.pointer, _sel_lineBreakMode);
    return NSLineBreakMode.fromValue($ret);
  }

  /// selectedImage
  UIImage? get selectedImage {
    objc.checkOsVersionInternal(
      'UITableViewCell.selectedImage',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_selectedImage);
    return $ret.address == 0
        ? null
        : UIImage.fromPointer($ret, retain: true, release: true);
  }

  /// selectedTextColor
  UIColor? get selectedTextColor {
    objc.checkOsVersionInternal(
      'UITableViewCell.selectedTextColor',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_selectedTextColor,
    );
    return $ret.address == 0
        ? null
        : UIColor.fromPointer($ret, retain: true, release: true);
  }

  /// setAccessoryAction:
  set accessoryAction(ffi.Pointer<objc.ObjCSelector> value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setAccessoryAction:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1d9e4oe(object$.ref.pointer, _sel_setAccessoryAction_, value);
  }

  /// setEditAction:
  set editAction(ffi.Pointer<objc.ObjCSelector> value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setEditAction:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1d9e4oe(object$.ref.pointer, _sel_setEditAction_, value);
  }

  /// setFont:
  set font(UIFont? value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setFont:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setFont_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setHidesAccessoryWhenEditing:
  set hidesAccessoryWhenEditing(bool value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setHidesAccessoryWhenEditing:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setHidesAccessoryWhenEditing_,
      value,
    );
  }

  /// setImage:
  set image(UIImage? value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setImage:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setImage_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setLineBreakMode:
  set lineBreakMode(NSLineBreakMode value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setLineBreakMode:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1kdet46(
      object$.ref.pointer,
      _sel_setLineBreakMode_,
      value.value,
    );
  }

  /// setSelectedImage:
  set selectedImage(UIImage? value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setSelectedImage:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setSelectedImage_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setSelectedTextColor:
  set selectedTextColor(UIColor? value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setSelectedTextColor:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setSelectedTextColor_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setTarget:
  set target(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setTarget:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setTarget_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setText:
  set text(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setText:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setText_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setTextAlignment:
  set textAlignment(NSTextAlignment value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setTextAlignment:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_12huos(
      object$.ref.pointer,
      _sel_setTextAlignment_,
      value.value,
    );
  }

  /// setTextColor:
  set textColor(UIColor? value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setTextColor:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setTextColor_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// target
  objc.ObjCObject? get target {
    objc.checkOsVersionInternal(
      'UITableViewCell.target',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_target);
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// text
  objc.NSString? get text {
    objc.checkOsVersionInternal(
      'UITableViewCell.text',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_text);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// textAlignment
  NSTextAlignment get textAlignment {
    objc.checkOsVersionInternal(
      'UITableViewCell.textAlignment',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_buxwfm(object$.ref.pointer, _sel_textAlignment);
    return NSTextAlignment.fromValue($ret);
  }

  /// textColor
  UIColor? get textColor {
    objc.checkOsVersionInternal(
      'UITableViewCell.textColor',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textColor);
    return $ret.address == 0
        ? null
        : UIColor.fromPointer($ret, retain: true, release: true);
  }
}

/// UITableViewCell
extension type UITableViewCell._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        UIView,
        objc.NSCoding,
        UIGestureRecognizerDelegate {
  /// Constructs a [UITableViewCell] that points to the same underlying object as [other].
  UITableViewCell.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UITableViewCell', iOS: (false, (2, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [UITableViewCell] that wraps the given raw object pointer.
  UITableViewCell.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITableViewCell', iOS: (false, (2, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UITableViewCell].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_UITableViewCell,
  );

  /// alloc
  static UITableViewCell alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UITableViewCell, _sel_alloc);
    return UITableViewCell.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UITableViewCell allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_UITableViewCell,
      _sel_allocWithZone_,
      zone,
    );
    return UITableViewCell.fromPointer($ret, retain: false, release: true);
  }

  /// appearance
  static UITableViewCell appearance() {
    final $ret = _objc_msgSend_151sglz(_class_UITableViewCell, _sel_appearance);
    return UITableViewCell.fromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:
  static UITableViewCell appearanceForTraitCollection(UITraitCollection trait) {
    objc.checkOsVersionInternal(
      'UITableViewCell.appearanceForTraitCollection:',
      iOS: (false, (8, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_UITableViewCell,
      _sel_appearanceForTraitCollection_,
      trait.ref.pointer,
    );
    return UITableViewCell.fromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedIn:
  static UITableViewCell appearanceForTraitCollection$1(
    UITraitCollection trait, {
    UIAppearanceContainer? whenContainedIn,
  }) {
    objc.checkOsVersionInternal(
      'UITableViewCell.appearanceForTraitCollection:whenContainedIn:',
      iOS: (false, (8, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_UITableViewCell,
      _sel_appearanceForTraitCollection_whenContainedIn_,
      trait.ref.pointer,
      whenContainedIn?.ref.pointer ?? ffi.nullptr,
    );
    return UITableViewCell.fromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedInInstancesOfClasses:
  static UITableViewCell appearanceForTraitCollection$2(
    UITraitCollection trait, {
    required objc.NSArray whenContainedInInstancesOfClasses,
  }) {
    objc.checkOsVersionInternal(
      'UITableViewCell.appearanceForTraitCollection:whenContainedInInstancesOfClasses:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_UITableViewCell,
      _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_,
      trait.ref.pointer,
      whenContainedInInstancesOfClasses.ref.pointer,
    );
    return UITableViewCell.fromPointer($ret, retain: true, release: true);
  }

  /// appearanceWhenContainedIn:
  static UITableViewCell appearanceWhenContainedIn(
    UIAppearanceContainer? ContainerClass,
  ) {
    objc.checkOsVersionInternal(
      'UITableViewCell.appearanceWhenContainedIn:',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_UITableViewCell,
      _sel_appearanceWhenContainedIn_,
      ContainerClass?.ref.pointer ?? ffi.nullptr,
    );
    return UITableViewCell.fromPointer($ret, retain: true, release: true);
  }

  /// appearanceWhenContainedInInstancesOfClasses:
  static UITableViewCell appearanceWhenContainedInInstancesOfClasses(
    objc.NSArray containerTypes,
  ) {
    objc.checkOsVersionInternal(
      'UITableViewCell.appearanceWhenContainedInInstancesOfClasses:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_UITableViewCell,
      _sel_appearanceWhenContainedInInstancesOfClasses_,
      containerTypes.ref.pointer,
    );
    return UITableViewCell.fromPointer($ret, retain: true, release: true);
  }

  /// layerClass
  static objc.ObjCObject getLayerClass() {
    objc.checkOsVersionInternal(
      'UITableViewCell.layerClass',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_class_UITableViewCell, _sel_layerClass);
    return objc.ObjCObject($ret, retain: true, release: true);
  }

  /// new
  static UITableViewCell new$() {
    final $ret = _objc_msgSend_151sglz(_class_UITableViewCell, _sel_new);
    return UITableViewCell.fromPointer($ret, retain: false, release: true);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection
  userInterfaceLayoutDirectionForSemanticContentAttribute(
    UISemanticContentAttribute attribute,
  ) {
    objc.checkOsVersionInternal(
      'UITableViewCell.userInterfaceLayoutDirectionForSemanticContentAttribute:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_racczx(
      _class_UITableViewCell,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
      attribute.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection
  userInterfaceLayoutDirectionForSemanticContentAttribute$1(
    UISemanticContentAttribute semanticContentAttribute, {
    required UIUserInterfaceLayoutDirection relativeToLayoutDirection,
  }) {
    objc.checkOsVersionInternal(
      'UITableViewCell.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
      iOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_tz4p54(
      _class_UITableViewCell,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
      semanticContentAttribute.value,
      relativeToLayoutDirection.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }

  /// Returns a new instance of UITableViewCell constructed with the default `new` method.
  UITableViewCell() : this.as(new$().object$);
}

extension UITableViewCell$Methods on UITableViewCell {
  /// accessoryType
  UITableViewCellAccessoryType get accessoryType {
    objc.checkOsVersionInternal(
      'UITableViewCell.accessoryType',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_1vg5j0q(object$.ref.pointer, _sel_accessoryType);
    return UITableViewCellAccessoryType.fromValue($ret);
  }

  /// accessoryView
  UIView? get accessoryView {
    objc.checkOsVersionInternal(
      'UITableViewCell.accessoryView',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_accessoryView);
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }

  /// automaticallyUpdatesBackgroundConfiguration
  bool get automaticallyUpdatesBackgroundConfiguration {
    objc.checkOsVersionInternal(
      'UITableViewCell.automaticallyUpdatesBackgroundConfiguration',
      iOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_automaticallyUpdatesBackgroundConfiguration,
    );
  }

  /// automaticallyUpdatesContentConfiguration
  bool get automaticallyUpdatesContentConfiguration {
    objc.checkOsVersionInternal(
      'UITableViewCell.automaticallyUpdatesContentConfiguration',
      iOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_automaticallyUpdatesContentConfiguration,
    );
  }

  /// backgroundConfiguration
  UIBackgroundConfiguration? get backgroundConfiguration {
    objc.checkOsVersionInternal(
      'UITableViewCell.backgroundConfiguration',
      iOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_backgroundConfiguration,
    );
    return $ret.address == 0
        ? null
        : UIBackgroundConfiguration.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// backgroundView
  UIView? get backgroundView {
    objc.checkOsVersionInternal(
      'UITableViewCell.backgroundView',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_backgroundView,
    );
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }

  /// configurationState
  UICellConfigurationState get configurationState {
    objc.checkOsVersionInternal(
      'UITableViewCell.configurationState',
      iOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_configurationState,
    );
    return UICellConfigurationState.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// configurationUpdateHandler
  objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)>?
  get configurationUpdateHandler {
    objc.checkOsVersionInternal(
      'UITableViewCell.configurationUpdateHandler',
      iOS: (false, (15, 0, 0)),
    );
    final $ret = _objc_msgSend_uwvaik(
      object$.ref.pointer,
      _sel_configurationUpdateHandler,
    );
    return $ret.address == 0
        ? null
        : ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// contentConfiguration
  UIContentConfiguration? get contentConfiguration {
    objc.checkOsVersionInternal(
      'UITableViewCell.contentConfiguration',
      iOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_contentConfiguration,
    );
    return $ret.address == 0
        ? null
        : UIContentConfiguration.fromPointer($ret, retain: true, release: true);
  }

  /// contentView
  UIView get contentView {
    objc.checkOsVersionInternal(
      'UITableViewCell.contentView',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_contentView);
    return UIView.fromPointer($ret, retain: true, release: true);
  }

  /// defaultBackgroundConfiguration
  UIBackgroundConfiguration defaultBackgroundConfiguration() {
    objc.checkOsVersionInternal(
      'UITableViewCell.defaultBackgroundConfiguration',
      iOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_defaultBackgroundConfiguration,
    );
    return UIBackgroundConfiguration.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// defaultContentConfiguration
  UIListContentConfiguration defaultContentConfiguration() {
    objc.checkOsVersionInternal(
      'UITableViewCell.defaultContentConfiguration',
      iOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_defaultContentConfiguration,
    );
    return UIListContentConfiguration.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// detailTextLabel
  UILabel? get detailTextLabel {
    objc.checkOsVersionInternal(
      'UITableViewCell.detailTextLabel',
      iOS: (false, (3, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_detailTextLabel,
    );
    return $ret.address == 0
        ? null
        : UILabel.fromPointer($ret, retain: true, release: true);
  }

  /// didTransitionToState:
  void didTransitionToState(int state) {
    objc.checkOsVersionInternal(
      'UITableViewCell.didTransitionToState:',
      iOS: (false, (3, 0, 0)),
    );
    _objc_msgSend_ipxvh9(
      object$.ref.pointer,
      _sel_didTransitionToState_,
      state,
    );
  }

  /// dragStateDidChange:
  void dragStateDidChange(UITableViewCellDragState dragState) {
    objc.checkOsVersionInternal(
      'UITableViewCell.dragStateDidChange:',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_c54vyn(
      object$.ref.pointer,
      _sel_dragStateDidChange_,
      dragState.value,
    );
  }

  /// editingAccessoryType
  UITableViewCellAccessoryType get editingAccessoryType {
    objc.checkOsVersionInternal(
      'UITableViewCell.editingAccessoryType',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_1vg5j0q(
      object$.ref.pointer,
      _sel_editingAccessoryType,
    );
    return UITableViewCellAccessoryType.fromValue($ret);
  }

  /// editingAccessoryView
  UIView? get editingAccessoryView {
    objc.checkOsVersionInternal(
      'UITableViewCell.editingAccessoryView',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_editingAccessoryView,
    );
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }

  /// editingStyle
  UITableViewCellEditingStyle get editingStyle {
    objc.checkOsVersionInternal(
      'UITableViewCell.editingStyle',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_rz99rt(object$.ref.pointer, _sel_editingStyle);
    return UITableViewCellEditingStyle.fromValue($ret);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// focusStyle
  UITableViewCellFocusStyle get focusStyle {
    objc.checkOsVersionInternal(
      'UITableViewCell.focusStyle',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_1o6ymet(object$.ref.pointer, _sel_focusStyle);
    return UITableViewCellFocusStyle.fromValue($ret);
  }

  /// gestureRecognizer:shouldBeRequiredToFailByGestureRecognizer:
  bool gestureRecognizer(
    UIGestureRecognizer gestureRecognizer, {
    required UIGestureRecognizer shouldBeRequiredToFailByGestureRecognizer,
  }) {
    objc.checkOsVersionInternal(
      'UITableViewCell.gestureRecognizer:shouldBeRequiredToFailByGestureRecognizer:',
      iOS: (false, (7, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_gestureRecognizer_shouldBeRequiredToFailByGestureRecognizer_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UITableViewCell',
        'gestureRecognizer:shouldBeRequiredToFailByGestureRecognizer:',
      );
    }
    return _objc_msgSend_1lsax7n(
      object$.ref.pointer,
      _sel_gestureRecognizer_shouldBeRequiredToFailByGestureRecognizer_,
      gestureRecognizer.ref.pointer,
      shouldBeRequiredToFailByGestureRecognizer.ref.pointer,
    );
  }

  /// gestureRecognizer:shouldReceiveEvent:
  bool gestureRecognizer$1(
    UIGestureRecognizer gestureRecognizer, {
    required UIEvent shouldReceiveEvent,
  }) {
    objc.checkOsVersionInternal(
      'UITableViewCell.gestureRecognizer:shouldReceiveEvent:',
      iOS: (false, (13, 4, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_gestureRecognizer_shouldReceiveEvent_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UITableViewCell',
        'gestureRecognizer:shouldReceiveEvent:',
      );
    }
    return _objc_msgSend_1lsax7n(
      object$.ref.pointer,
      _sel_gestureRecognizer_shouldReceiveEvent_,
      gestureRecognizer.ref.pointer,
      shouldReceiveEvent.ref.pointer,
    );
  }

  /// gestureRecognizer:shouldReceivePress:
  bool gestureRecognizer$2(
    UIGestureRecognizer gestureRecognizer, {
    required UIPress shouldReceivePress,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_gestureRecognizer_shouldReceivePress_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UITableViewCell',
        'gestureRecognizer:shouldReceivePress:',
      );
    }
    return _objc_msgSend_1lsax7n(
      object$.ref.pointer,
      _sel_gestureRecognizer_shouldReceivePress_,
      gestureRecognizer.ref.pointer,
      shouldReceivePress.ref.pointer,
    );
  }

  /// gestureRecognizer:shouldReceiveTouch:
  bool gestureRecognizer$3(
    UIGestureRecognizer gestureRecognizer, {
    required UITouch shouldReceiveTouch,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_gestureRecognizer_shouldReceiveTouch_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UITableViewCell',
        'gestureRecognizer:shouldReceiveTouch:',
      );
    }
    return _objc_msgSend_1lsax7n(
      object$.ref.pointer,
      _sel_gestureRecognizer_shouldReceiveTouch_,
      gestureRecognizer.ref.pointer,
      shouldReceiveTouch.ref.pointer,
    );
  }

  /// gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:
  bool gestureRecognizer$4(
    UIGestureRecognizer gestureRecognizer, {
    required UIGestureRecognizer
    shouldRecognizeSimultaneouslyWithGestureRecognizer,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_gestureRecognizer_shouldRecognizeSimultaneouslyWithGestureRecognizer_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UITableViewCell',
        'gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:',
      );
    }
    return _objc_msgSend_1lsax7n(
      object$.ref.pointer,
      _sel_gestureRecognizer_shouldRecognizeSimultaneouslyWithGestureRecognizer_,
      gestureRecognizer.ref.pointer,
      shouldRecognizeSimultaneouslyWithGestureRecognizer.ref.pointer,
    );
  }

  /// gestureRecognizer:shouldRequireFailureOfGestureRecognizer:
  bool gestureRecognizer$5(
    UIGestureRecognizer gestureRecognizer, {
    required UIGestureRecognizer shouldRequireFailureOfGestureRecognizer,
  }) {
    objc.checkOsVersionInternal(
      'UITableViewCell.gestureRecognizer:shouldRequireFailureOfGestureRecognizer:',
      iOS: (false, (7, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_gestureRecognizer_shouldRequireFailureOfGestureRecognizer_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UITableViewCell',
        'gestureRecognizer:shouldRequireFailureOfGestureRecognizer:',
      );
    }
    return _objc_msgSend_1lsax7n(
      object$.ref.pointer,
      _sel_gestureRecognizer_shouldRequireFailureOfGestureRecognizer_,
      gestureRecognizer.ref.pointer,
      shouldRequireFailureOfGestureRecognizer.ref.pointer,
    );
  }

  /// gestureRecognizerShouldBegin:
  bool gestureRecognizerShouldBegin(UIGestureRecognizer gestureRecognizer) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_gestureRecognizerShouldBegin_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'UITableViewCell',
        'gestureRecognizerShouldBegin:',
      );
    }
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_gestureRecognizerShouldBegin_,
      gestureRecognizer.ref.pointer,
    );
  }

  /// imageView
  UIImageView? get imageView {
    objc.checkOsVersionInternal(
      'UITableViewCell.imageView',
      iOS: (false, (3, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_imageView);
    return $ret.address == 0
        ? null
        : UIImageView.fromPointer($ret, retain: true, release: true);
  }

  /// indentationLevel
  int get indentationLevel {
    objc.checkOsVersionInternal(
      'UITableViewCell.indentationLevel',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_indentationLevel);
  }

  /// indentationWidth
  double get indentationWidth {
    objc.checkOsVersionInternal(
      'UITableViewCell.indentationWidth',
      iOS: (false, (2, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_indentationWidth)
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_indentationWidth);
  }

  /// init
  UITableViewCell init() {
    objc.checkOsVersionInternal(
      'UITableViewCell.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return UITableViewCell.fromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  UITableViewCell? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : UITableViewCell.fromPointer($ret, retain: false, release: true);
  }

  /// initWithFrame:
  UITableViewCell initWithFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal(
      'UITableViewCell.initWithFrame:',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_15yz4e6(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithFrame_,
      frame,
    );
    return UITableViewCell.fromPointer($ret, retain: false, release: true);
  }

  /// initWithStyle:reuseIdentifier:
  UITableViewCell initWithStyle(
    UITableViewCellStyle style, {
    objc.NSString? reuseIdentifier,
  }) {
    objc.checkOsVersionInternal(
      'UITableViewCell.initWithStyle:reuseIdentifier:',
      iOS: (false, (3, 0, 0)),
    );
    final $ret = _objc_msgSend_96u4vv(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithStyle_reuseIdentifier_,
      style.value,
      reuseIdentifier?.ref.pointer ?? ffi.nullptr,
    );
    return UITableViewCell.fromPointer($ret, retain: false, release: true);
  }

  /// isEditing
  bool get isEditing {
    objc.checkOsVersionInternal(
      'UITableViewCell.isEditing',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isEditing);
  }

  /// isHighlighted
  bool get isHighlighted {
    objc.checkOsVersionInternal(
      'UITableViewCell.isHighlighted',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isHighlighted);
  }

  /// isSelected
  bool get isSelected {
    objc.checkOsVersionInternal(
      'UITableViewCell.isSelected',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isSelected);
  }

  /// multipleSelectionBackgroundView
  UIView? get multipleSelectionBackgroundView {
    objc.checkOsVersionInternal(
      'UITableViewCell.multipleSelectionBackgroundView',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_multipleSelectionBackgroundView,
    );
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }

  /// prepareForReuse
  void prepareForReuse() {
    objc.checkOsVersionInternal(
      'UITableViewCell.prepareForReuse',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_prepareForReuse);
  }

  /// reuseIdentifier
  objc.NSString? get reuseIdentifier {
    objc.checkOsVersionInternal(
      'UITableViewCell.reuseIdentifier',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_reuseIdentifier,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// selectedBackgroundView
  UIView? get selectedBackgroundView {
    objc.checkOsVersionInternal(
      'UITableViewCell.selectedBackgroundView',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_selectedBackgroundView,
    );
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }

  /// selectionStyle
  UITableViewCellSelectionStyle get selectionStyle {
    objc.checkOsVersionInternal(
      'UITableViewCell.selectionStyle',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_1d2lxkb(
      object$.ref.pointer,
      _sel_selectionStyle,
    );
    return UITableViewCellSelectionStyle.fromValue($ret);
  }

  /// separatorInset
  UIEdgeInsets get separatorInset {
    objc.checkOsVersionInternal(
      'UITableViewCell.separatorInset',
      iOS: (false, (7, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(
            $ptr,
            object$.ref.pointer,
            _sel_separatorInset,
          )
        : $ptr.ref = _objc_msgSend_ct4cu5(
            object$.ref.pointer,
            _sel_separatorInset,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// setAccessoryType:
  set accessoryType(UITableViewCellAccessoryType value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setAccessoryType:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_c8nyto(
      object$.ref.pointer,
      _sel_setAccessoryType_,
      value.value,
    );
  }

  /// setAccessoryView:
  set accessoryView(UIView? value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setAccessoryView:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAccessoryView_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAutomaticallyUpdatesBackgroundConfiguration:
  set automaticallyUpdatesBackgroundConfiguration(bool value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setAutomaticallyUpdatesBackgroundConfiguration:',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAutomaticallyUpdatesBackgroundConfiguration_,
      value,
    );
  }

  /// setAutomaticallyUpdatesContentConfiguration:
  set automaticallyUpdatesContentConfiguration(bool value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setAutomaticallyUpdatesContentConfiguration:',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAutomaticallyUpdatesContentConfiguration_,
      value,
    );
  }

  /// setBackgroundConfiguration:
  set backgroundConfiguration(UIBackgroundConfiguration? value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setBackgroundConfiguration:',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setBackgroundConfiguration_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setBackgroundView:
  set backgroundView(UIView? value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setBackgroundView:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setBackgroundView_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setConfigurationUpdateHandler:
  set configurationUpdateHandler(
    objc.ObjCBlock<
      ffi.Void Function(UITableViewCell, UICellConfigurationState)
    >?
    value,
  ) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setConfigurationUpdateHandler:',
      iOS: (false, (15, 0, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_setConfigurationUpdateHandler_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setContentConfiguration:
  set contentConfiguration(UIContentConfiguration? value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setContentConfiguration:',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setContentConfiguration_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setEditing:
  set isEditing(bool value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setEditing:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setEditing_, value);
  }

  /// setEditing:animated:
  void setEditing(bool editing, {required bool animated}) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setEditing:animated:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_14iqu8t(
      object$.ref.pointer,
      _sel_setEditing_animated_,
      editing,
      animated,
    );
  }

  /// setEditingAccessoryType:
  set editingAccessoryType(UITableViewCellAccessoryType value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setEditingAccessoryType:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_c8nyto(
      object$.ref.pointer,
      _sel_setEditingAccessoryType_,
      value.value,
    );
  }

  /// setEditingAccessoryView:
  set editingAccessoryView(UIView? value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setEditingAccessoryView:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setEditingAccessoryView_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setFocusStyle:
  set focusStyle(UITableViewCellFocusStyle value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setFocusStyle:',
      iOS: (false, (9, 0, 0)),
    );
    _objc_msgSend_tbdrv1(object$.ref.pointer, _sel_setFocusStyle_, value.value);
  }

  /// setHighlighted:
  set isHighlighted(bool value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setHighlighted:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setHighlighted_, value);
  }

  /// setHighlighted:animated:
  void setHighlighted(bool highlighted, {required bool animated}) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setHighlighted:animated:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_14iqu8t(
      object$.ref.pointer,
      _sel_setHighlighted_animated_,
      highlighted,
      animated,
    );
  }

  /// setIndentationLevel:
  set indentationLevel(int value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setIndentationLevel:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_4sp4xj(object$.ref.pointer, _sel_setIndentationLevel_, value);
  }

  /// setIndentationWidth:
  set indentationWidth(double value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setIndentationWidth:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setIndentationWidth_, value);
  }

  /// setMultipleSelectionBackgroundView:
  set multipleSelectionBackgroundView(UIView? value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setMultipleSelectionBackgroundView:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMultipleSelectionBackgroundView_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setNeedsUpdateConfiguration
  void setNeedsUpdateConfiguration() {
    objc.checkOsVersionInternal(
      'UITableViewCell.setNeedsUpdateConfiguration',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(
      object$.ref.pointer,
      _sel_setNeedsUpdateConfiguration,
    );
  }

  /// setSelected:
  set isSelected(bool value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setSelected:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setSelected_, value);
  }

  /// setSelected:animated:
  void setSelected(bool selected, {required bool animated}) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setSelected:animated:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_14iqu8t(
      object$.ref.pointer,
      _sel_setSelected_animated_,
      selected,
      animated,
    );
  }

  /// setSelectedBackgroundView:
  set selectedBackgroundView(UIView? value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setSelectedBackgroundView:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setSelectedBackgroundView_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setSelectionStyle:
  set selectionStyle(UITableViewCellSelectionStyle value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setSelectionStyle:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1uwq2nz(
      object$.ref.pointer,
      _sel_setSelectionStyle_,
      value.value,
    );
  }

  /// setSeparatorInset:
  set separatorInset(UIEdgeInsets value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setSeparatorInset:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_1g8fos5(object$.ref.pointer, _sel_setSeparatorInset_, value);
  }

  /// setShouldIndentWhileEditing:
  set shouldIndentWhileEditing(bool value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setShouldIndentWhileEditing:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setShouldIndentWhileEditing_,
      value,
    );
  }

  /// setShowsReorderControl:
  set showsReorderControl(bool value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setShowsReorderControl:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setShowsReorderControl_,
      value,
    );
  }

  /// setUserInteractionEnabledWhileDragging:
  set userInteractionEnabledWhileDragging(bool value) {
    objc.checkOsVersionInternal(
      'UITableViewCell.setUserInteractionEnabledWhileDragging:',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setUserInteractionEnabledWhileDragging_,
      value,
    );
  }

  /// shouldIndentWhileEditing
  bool get shouldIndentWhileEditing {
    objc.checkOsVersionInternal(
      'UITableViewCell.shouldIndentWhileEditing',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_shouldIndentWhileEditing,
    );
  }

  /// showingDeleteConfirmation
  bool get showingDeleteConfirmation {
    objc.checkOsVersionInternal(
      'UITableViewCell.showingDeleteConfirmation',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_showingDeleteConfirmation,
    );
  }

  /// showsReorderControl
  bool get showsReorderControl {
    objc.checkOsVersionInternal(
      'UITableViewCell.showsReorderControl',
      iOS: (false, (2, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_showsReorderControl);
  }

  /// textLabel
  UILabel? get textLabel {
    objc.checkOsVersionInternal(
      'UITableViewCell.textLabel',
      iOS: (false, (3, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textLabel);
    return $ret.address == 0
        ? null
        : UILabel.fromPointer($ret, retain: true, release: true);
  }

  /// updateConfigurationUsingState:
  void updateConfigurationUsingState(UICellConfigurationState state) {
    objc.checkOsVersionInternal(
      'UITableViewCell.updateConfigurationUsingState:',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_updateConfigurationUsingState_,
      state.ref.pointer,
    );
  }

  /// userInteractionEnabledWhileDragging
  bool get userInteractionEnabledWhileDragging {
    objc.checkOsVersionInternal(
      'UITableViewCell.userInteractionEnabledWhileDragging',
      iOS: (false, (11, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_userInteractionEnabledWhileDragging,
    );
  }

  /// willTransitionToState:
  void willTransitionToState(int state) {
    objc.checkOsVersionInternal(
      'UITableViewCell.willTransitionToState:',
      iOS: (false, (3, 0, 0)),
    );
    _objc_msgSend_ipxvh9(
      object$.ref.pointer,
      _sel_willTransitionToState_,
      state,
    );
  }
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)>`.
abstract final class ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(UITableViewCell, UICellConfigurationState)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(UITableViewCell, UICellConfigurationState)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(UITableViewCell, UICellConfigurationState)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(UITableViewCell, UICellConfigurationState)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(UITableViewCell, UICellConfigurationState)
  >
  fromFunction(
    void Function(UITableViewCell, UICellConfigurationState) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(UITableViewCell, UICellConfigurationState)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ) => fn(
            UITableViewCell.fromPointer(arg0, retain: true, release: true),
            UICellConfigurationState.fromPointer(
              arg1,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(UITableViewCell, UICellConfigurationState)
  >
  listener(
    void Function(UITableViewCell, UICellConfigurationState) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        UITableViewCell.fromPointer(arg0, retain: false, release: true),
        UICellConfigurationState.fromPointer(
          arg1,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(UITableViewCell, UICellConfigurationState)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(UITableViewCell, UICellConfigurationState)
  >
  blocking(
    void Function(UITableViewCell, UICellConfigurationState) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        UITableViewCell.fromPointer(arg0, retain: false, release: true),
        UICellConfigurationState.fromPointer(
          arg1,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        UITableViewCell.fromPointer(arg0, retain: false, release: true),
        UICellConfigurationState.fromPointer(
          arg1,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(UITableViewCell, UICellConfigurationState)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(UITableViewCell, UICellConfigurationState)>`.
extension ObjCBlock_ffiVoid_UITableViewCell_UICellConfigurationState$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(UITableViewCell, UICellConfigurationState)
        > {
  void call(UITableViewCell arg0, UICellConfigurationState arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0.ref.pointer, arg1.ref.pointer);
}

enum UITableViewStyle {
  UITableViewStylePlain(0),
  UITableViewStyleGrouped(1),
  UITableViewStyleInsetGrouped(2);

  final int value;
  const UITableViewStyle(this.value);

  static UITableViewStyle fromValue(int value) => switch (value) {
    0 => UITableViewStylePlain,
    1 => UITableViewStyleGrouped,
    2 => UITableViewStyleInsetGrouped,
    _ => throw ArgumentError('Unknown value for UITableViewStyle: $value'),
  };
}

enum UITableViewScrollPosition {
  UITableViewScrollPositionNone(0),
  UITableViewScrollPositionTop(1),
  UITableViewScrollPositionMiddle(2),
  UITableViewScrollPositionBottom(3);

  final int value;
  const UITableViewScrollPosition(this.value);

  static UITableViewScrollPosition fromValue(int value) => switch (value) {
    0 => UITableViewScrollPositionNone,
    1 => UITableViewScrollPositionTop,
    2 => UITableViewScrollPositionMiddle,
    3 => UITableViewScrollPositionBottom,
    _ => throw ArgumentError(
      'Unknown value for UITableViewScrollPosition: $value',
    ),
  };
}

enum UITableViewRowAnimation {
  UITableViewRowAnimationFade(0),
  UITableViewRowAnimationRight(1),
  UITableViewRowAnimationLeft(2),
  UITableViewRowAnimationTop(3),
  UITableViewRowAnimationBottom(4),
  UITableViewRowAnimationNone(5),
  UITableViewRowAnimationMiddle(6),
  UITableViewRowAnimationAutomatic(100);

  final int value;
  const UITableViewRowAnimation(this.value);

  static UITableViewRowAnimation fromValue(int value) => switch (value) {
    0 => UITableViewRowAnimationFade,
    1 => UITableViewRowAnimationRight,
    2 => UITableViewRowAnimationLeft,
    3 => UITableViewRowAnimationTop,
    4 => UITableViewRowAnimationBottom,
    5 => UITableViewRowAnimationNone,
    6 => UITableViewRowAnimationMiddle,
    100 => UITableViewRowAnimationAutomatic,
    _ => throw ArgumentError(
      'Unknown value for UITableViewRowAnimation: $value',
    ),
  };
}

sealed class UITableViewContentHuggingElements {
  static const UITableViewContentHuggingElementsNone = 0;
  static const UITableViewContentHuggingElementsSectionHeaders = 1;
}

enum UITableViewSeparatorInsetReference {
  UITableViewSeparatorInsetFromCellEdges(0),
  UITableViewSeparatorInsetFromAutomaticInsets(1);

  final int value;
  const UITableViewSeparatorInsetReference(this.value);

  static UITableViewSeparatorInsetReference fromValue(int value) =>
      switch (value) {
        0 => UITableViewSeparatorInsetFromCellEdges,
        1 => UITableViewSeparatorInsetFromAutomaticInsets,
        _ => throw ArgumentError(
          'Unknown value for UITableViewSeparatorInsetReference: $value',
        ),
      };
}

enum UITableViewSelfSizingInvalidation {
  UITableViewSelfSizingInvalidationDisabled(0),
  UITableViewSelfSizingInvalidationEnabled(1),
  UITableViewSelfSizingInvalidationEnabledIncludingConstraints(2);

  final int value;
  const UITableViewSelfSizingInvalidation(this.value);

  static UITableViewSelfSizingInvalidation fromValue(int value) =>
      switch (value) {
        0 => UITableViewSelfSizingInvalidationDisabled,
        1 => UITableViewSelfSizingInvalidationEnabled,
        2 => UITableViewSelfSizingInvalidationEnabledIncludingConstraints,
        _ => throw ArgumentError(
          'Unknown value for UITableViewSelfSizingInvalidation: $value',
        ),
      };
}

enum UITableViewDropIntent {
  UITableViewDropIntentUnspecified(0),
  UITableViewDropIntentInsertAtDestinationIndexPath(1),
  UITableViewDropIntentInsertIntoDestinationIndexPath(2),
  UITableViewDropIntentAutomatic(3);

  final int value;
  const UITableViewDropIntent(this.value);

  static UITableViewDropIntent fromValue(int value) => switch (value) {
    0 => UITableViewDropIntentUnspecified,
    1 => UITableViewDropIntentInsertAtDestinationIndexPath,
    2 => UITableViewDropIntentInsertIntoDestinationIndexPath,
    3 => UITableViewDropIntentAutomatic,
    _ => throw ArgumentError('Unknown value for UITableViewDropIntent: $value'),
  };
}

enum UIListContentTextAlignment {
  UIListContentTextAlignmentNatural(0),
  UIListContentTextAlignmentCenter(1),
  UIListContentTextAlignmentJustified(2);

  final int value;
  const UIListContentTextAlignment(this.value);

  static UIListContentTextAlignment fromValue(int value) => switch (value) {
    0 => UIListContentTextAlignmentNatural,
    1 => UIListContentTextAlignmentCenter,
    2 => UIListContentTextAlignmentJustified,
    _ => throw ArgumentError(
      'Unknown value for UIListContentTextAlignment: $value',
    ),
  };
}

enum UIListContentTextTransform {
  UIListContentTextTransformNone(0),
  UIListContentTextTransformUppercase(1),
  UIListContentTextTransformLowercase(2),
  UIListContentTextTransformCapitalized(3);

  final int value;
  const UIListContentTextTransform(this.value);

  static UIListContentTextTransform fromValue(int value) => switch (value) {
    0 => UIListContentTextTransformNone,
    1 => UIListContentTextTransformUppercase,
    2 => UIListContentTextTransformLowercase,
    3 => UIListContentTextTransformCapitalized,
    _ => throw ArgumentError(
      'Unknown value for UIListContentTextTransform: $value',
    ),
  };
}

enum UIKeyboardHIDUsage {
  UIKeyboardHIDUsageKeyboardErrorRollOver(1),
  UIKeyboardHIDUsageKeyboardPOSTFail(2),
  UIKeyboardHIDUsageKeyboardErrorUndefined(3),
  UIKeyboardHIDUsageKeyboardA(4),
  UIKeyboardHIDUsageKeyboardB(5),
  UIKeyboardHIDUsageKeyboardC(6),
  UIKeyboardHIDUsageKeyboardD(7),
  UIKeyboardHIDUsageKeyboardE(8),
  UIKeyboardHIDUsageKeyboardF(9),
  UIKeyboardHIDUsageKeyboardG(10),
  UIKeyboardHIDUsageKeyboardH(11),
  UIKeyboardHIDUsageKeyboardI(12),
  UIKeyboardHIDUsageKeyboardJ(13),
  UIKeyboardHIDUsageKeyboardK(14),
  UIKeyboardHIDUsageKeyboardL(15),
  UIKeyboardHIDUsageKeyboardM(16),
  UIKeyboardHIDUsageKeyboardN(17),
  UIKeyboardHIDUsageKeyboardO(18),
  UIKeyboardHIDUsageKeyboardP(19),
  UIKeyboardHIDUsageKeyboardQ(20),
  UIKeyboardHIDUsageKeyboardR(21),
  UIKeyboardHIDUsageKeyboardS(22),
  UIKeyboardHIDUsageKeyboardT(23),
  UIKeyboardHIDUsageKeyboardU(24),
  UIKeyboardHIDUsageKeyboardV(25),
  UIKeyboardHIDUsageKeyboardW(26),
  UIKeyboardHIDUsageKeyboardX(27),
  UIKeyboardHIDUsageKeyboardY(28),
  UIKeyboardHIDUsageKeyboardZ(29),
  UIKeyboardHIDUsageKeyboard1(30),
  UIKeyboardHIDUsageKeyboard2(31),
  UIKeyboardHIDUsageKeyboard3(32),
  UIKeyboardHIDUsageKeyboard4(33),
  UIKeyboardHIDUsageKeyboard5(34),
  UIKeyboardHIDUsageKeyboard6(35),
  UIKeyboardHIDUsageKeyboard7(36),
  UIKeyboardHIDUsageKeyboard8(37),
  UIKeyboardHIDUsageKeyboard9(38),
  UIKeyboardHIDUsageKeyboard0(39),
  UIKeyboardHIDUsageKeyboardReturnOrEnter(40),
  UIKeyboardHIDUsageKeyboardEscape(41),
  UIKeyboardHIDUsageKeyboardDeleteOrBackspace(42),
  UIKeyboardHIDUsageKeyboardTab(43),
  UIKeyboardHIDUsageKeyboardSpacebar(44),
  UIKeyboardHIDUsageKeyboardHyphen(45),
  UIKeyboardHIDUsageKeyboardEqualSign(46),
  UIKeyboardHIDUsageKeyboardOpenBracket(47),
  UIKeyboardHIDUsageKeyboardCloseBracket(48),
  UIKeyboardHIDUsageKeyboardBackslash(49),
  UIKeyboardHIDUsageKeyboardNonUSPound(50),
  UIKeyboardHIDUsageKeyboardSemicolon(51),
  UIKeyboardHIDUsageKeyboardQuote(52),
  UIKeyboardHIDUsageKeyboardGraveAccentAndTilde(53),
  UIKeyboardHIDUsageKeyboardComma(54),
  UIKeyboardHIDUsageKeyboardPeriod(55),
  UIKeyboardHIDUsageKeyboardSlash(56),
  UIKeyboardHIDUsageKeyboardCapsLock(57),
  UIKeyboardHIDUsageKeyboardF1(58),
  UIKeyboardHIDUsageKeyboardF2(59),
  UIKeyboardHIDUsageKeyboardF3(60),
  UIKeyboardHIDUsageKeyboardF4(61),
  UIKeyboardHIDUsageKeyboardF5(62),
  UIKeyboardHIDUsageKeyboardF6(63),
  UIKeyboardHIDUsageKeyboardF7(64),
  UIKeyboardHIDUsageKeyboardF8(65),
  UIKeyboardHIDUsageKeyboardF9(66),
  UIKeyboardHIDUsageKeyboardF10(67),
  UIKeyboardHIDUsageKeyboardF11(68),
  UIKeyboardHIDUsageKeyboardF12(69),
  UIKeyboardHIDUsageKeyboardPrintScreen(70),
  UIKeyboardHIDUsageKeyboardScrollLock(71),
  UIKeyboardHIDUsageKeyboardPause(72),
  UIKeyboardHIDUsageKeyboardInsert(73),
  UIKeyboardHIDUsageKeyboardHome(74),
  UIKeyboardHIDUsageKeyboardPageUp(75),
  UIKeyboardHIDUsageKeyboardDeleteForward(76),
  UIKeyboardHIDUsageKeyboardEnd(77),
  UIKeyboardHIDUsageKeyboardPageDown(78),
  UIKeyboardHIDUsageKeyboardRightArrow(79),
  UIKeyboardHIDUsageKeyboardLeftArrow(80),
  UIKeyboardHIDUsageKeyboardDownArrow(81),
  UIKeyboardHIDUsageKeyboardUpArrow(82),
  UIKeyboardHIDUsageKeypadNumLock(83),
  UIKeyboardHIDUsageKeypadSlash(84),
  UIKeyboardHIDUsageKeypadAsterisk(85),
  UIKeyboardHIDUsageKeypadHyphen(86),
  UIKeyboardHIDUsageKeypadPlus(87),
  UIKeyboardHIDUsageKeypadEnter(88),
  UIKeyboardHIDUsageKeypad1(89),
  UIKeyboardHIDUsageKeypad2(90),
  UIKeyboardHIDUsageKeypad3(91),
  UIKeyboardHIDUsageKeypad4(92),
  UIKeyboardHIDUsageKeypad5(93),
  UIKeyboardHIDUsageKeypad6(94),
  UIKeyboardHIDUsageKeypad7(95),
  UIKeyboardHIDUsageKeypad8(96),
  UIKeyboardHIDUsageKeypad9(97),
  UIKeyboardHIDUsageKeypad0(98),
  UIKeyboardHIDUsageKeypadPeriod(99),
  UIKeyboardHIDUsageKeyboardNonUSBackslash(100),
  UIKeyboardHIDUsageKeyboardApplication(101),
  UIKeyboardHIDUsageKeyboardPower(102),
  UIKeyboardHIDUsageKeypadEqualSign(103),
  UIKeyboardHIDUsageKeyboardF13(104),
  UIKeyboardHIDUsageKeyboardF14(105),
  UIKeyboardHIDUsageKeyboardF15(106),
  UIKeyboardHIDUsageKeyboardF16(107),
  UIKeyboardHIDUsageKeyboardF17(108),
  UIKeyboardHIDUsageKeyboardF18(109),
  UIKeyboardHIDUsageKeyboardF19(110),
  UIKeyboardHIDUsageKeyboardF20(111),
  UIKeyboardHIDUsageKeyboardF21(112),
  UIKeyboardHIDUsageKeyboardF22(113),
  UIKeyboardHIDUsageKeyboardF23(114),
  UIKeyboardHIDUsageKeyboardF24(115),
  UIKeyboardHIDUsageKeyboardExecute(116),
  UIKeyboardHIDUsageKeyboardHelp(117),
  UIKeyboardHIDUsageKeyboardMenu(118),
  UIKeyboardHIDUsageKeyboardSelect(119),
  UIKeyboardHIDUsageKeyboardStop(120),
  UIKeyboardHIDUsageKeyboardAgain(121),
  UIKeyboardHIDUsageKeyboardUndo(122),
  UIKeyboardHIDUsageKeyboardCut(123),
  UIKeyboardHIDUsageKeyboardCopy(124),
  UIKeyboardHIDUsageKeyboardPaste(125),
  UIKeyboardHIDUsageKeyboardFind(126),
  UIKeyboardHIDUsageKeyboardMute(127),
  UIKeyboardHIDUsageKeyboardVolumeUp(128),
  UIKeyboardHIDUsageKeyboardVolumeDown(129),
  UIKeyboardHIDUsageKeyboardLockingCapsLock(130),
  UIKeyboardHIDUsageKeyboardLockingNumLock(131),
  UIKeyboardHIDUsageKeyboardLockingScrollLock(132),
  UIKeyboardHIDUsageKeypadComma(133),
  UIKeyboardHIDUsageKeypadEqualSignAS400(134),
  UIKeyboardHIDUsageKeyboardInternational1(135),
  UIKeyboardHIDUsageKeyboardInternational2(136),
  UIKeyboardHIDUsageKeyboardInternational3(137),
  UIKeyboardHIDUsageKeyboardInternational4(138),
  UIKeyboardHIDUsageKeyboardInternational5(139),
  UIKeyboardHIDUsageKeyboardInternational6(140),
  UIKeyboardHIDUsageKeyboardInternational7(141),
  UIKeyboardHIDUsageKeyboardInternational8(142),
  UIKeyboardHIDUsageKeyboardInternational9(143),
  UIKeyboardHIDUsageKeyboardLANG1(144),
  UIKeyboardHIDUsageKeyboardLANG2(145),
  UIKeyboardHIDUsageKeyboardLANG3(146),
  UIKeyboardHIDUsageKeyboardLANG4(147),
  UIKeyboardHIDUsageKeyboardLANG5(148),
  UIKeyboardHIDUsageKeyboardLANG6(149),
  UIKeyboardHIDUsageKeyboardLANG7(150),
  UIKeyboardHIDUsageKeyboardLANG8(151),
  UIKeyboardHIDUsageKeyboardLANG9(152),
  UIKeyboardHIDUsageKeyboardAlternateErase(153),
  UIKeyboardHIDUsageKeyboardSysReqOrAttention(154),
  UIKeyboardHIDUsageKeyboardCancel(155),
  UIKeyboardHIDUsageKeyboardClear(156),
  UIKeyboardHIDUsageKeyboardPrior(157),
  UIKeyboardHIDUsageKeyboardReturn(158),
  UIKeyboardHIDUsageKeyboardSeparator(159),
  UIKeyboardHIDUsageKeyboardOut(160),
  UIKeyboardHIDUsageKeyboardOper(161),
  UIKeyboardHIDUsageKeyboardClearOrAgain(162),
  UIKeyboardHIDUsageKeyboardCrSelOrProps(163),
  UIKeyboardHIDUsageKeyboardExSel(164),
  UIKeyboardHIDUsageKeyboardLeftControl(224),
  UIKeyboardHIDUsageKeyboardLeftShift(225),
  UIKeyboardHIDUsageKeyboardLeftAlt(226),
  UIKeyboardHIDUsageKeyboardLeftGUI(227),
  UIKeyboardHIDUsageKeyboardRightControl(228),
  UIKeyboardHIDUsageKeyboardRightShift(229),
  UIKeyboardHIDUsageKeyboardRightAlt(230),
  UIKeyboardHIDUsageKeyboardRightGUI(231),
  UIKeyboardHIDUsageKeyboard_Reserved(65535);

  static const UIKeyboardHIDUsageKeyboardHangul =
      UIKeyboardHIDUsageKeyboardLANG1;
  static const UIKeyboardHIDUsageKeyboardHanja =
      UIKeyboardHIDUsageKeyboardLANG2;
  static const UIKeyboardHIDUsageKeyboardKanaSwitch =
      UIKeyboardHIDUsageKeyboardLANG1;
  static const UIKeyboardHIDUsageKeyboardAlphanumericSwitch =
      UIKeyboardHIDUsageKeyboardLANG2;
  static const UIKeyboardHIDUsageKeyboardKatakana =
      UIKeyboardHIDUsageKeyboardLANG3;
  static const UIKeyboardHIDUsageKeyboardHiragana =
      UIKeyboardHIDUsageKeyboardLANG4;
  static const UIKeyboardHIDUsageKeyboardZenkakuHankakuKanji =
      UIKeyboardHIDUsageKeyboardLANG5;

  final int value;
  const UIKeyboardHIDUsage(this.value);

  static UIKeyboardHIDUsage fromValue(int value) => switch (value) {
    1 => UIKeyboardHIDUsageKeyboardErrorRollOver,
    2 => UIKeyboardHIDUsageKeyboardPOSTFail,
    3 => UIKeyboardHIDUsageKeyboardErrorUndefined,
    4 => UIKeyboardHIDUsageKeyboardA,
    5 => UIKeyboardHIDUsageKeyboardB,
    6 => UIKeyboardHIDUsageKeyboardC,
    7 => UIKeyboardHIDUsageKeyboardD,
    8 => UIKeyboardHIDUsageKeyboardE,
    9 => UIKeyboardHIDUsageKeyboardF,
    10 => UIKeyboardHIDUsageKeyboardG,
    11 => UIKeyboardHIDUsageKeyboardH,
    12 => UIKeyboardHIDUsageKeyboardI,
    13 => UIKeyboardHIDUsageKeyboardJ,
    14 => UIKeyboardHIDUsageKeyboardK,
    15 => UIKeyboardHIDUsageKeyboardL,
    16 => UIKeyboardHIDUsageKeyboardM,
    17 => UIKeyboardHIDUsageKeyboardN,
    18 => UIKeyboardHIDUsageKeyboardO,
    19 => UIKeyboardHIDUsageKeyboardP,
    20 => UIKeyboardHIDUsageKeyboardQ,
    21 => UIKeyboardHIDUsageKeyboardR,
    22 => UIKeyboardHIDUsageKeyboardS,
    23 => UIKeyboardHIDUsageKeyboardT,
    24 => UIKeyboardHIDUsageKeyboardU,
    25 => UIKeyboardHIDUsageKeyboardV,
    26 => UIKeyboardHIDUsageKeyboardW,
    27 => UIKeyboardHIDUsageKeyboardX,
    28 => UIKeyboardHIDUsageKeyboardY,
    29 => UIKeyboardHIDUsageKeyboardZ,
    30 => UIKeyboardHIDUsageKeyboard1,
    31 => UIKeyboardHIDUsageKeyboard2,
    32 => UIKeyboardHIDUsageKeyboard3,
    33 => UIKeyboardHIDUsageKeyboard4,
    34 => UIKeyboardHIDUsageKeyboard5,
    35 => UIKeyboardHIDUsageKeyboard6,
    36 => UIKeyboardHIDUsageKeyboard7,
    37 => UIKeyboardHIDUsageKeyboard8,
    38 => UIKeyboardHIDUsageKeyboard9,
    39 => UIKeyboardHIDUsageKeyboard0,
    40 => UIKeyboardHIDUsageKeyboardReturnOrEnter,
    41 => UIKeyboardHIDUsageKeyboardEscape,
    42 => UIKeyboardHIDUsageKeyboardDeleteOrBackspace,
    43 => UIKeyboardHIDUsageKeyboardTab,
    44 => UIKeyboardHIDUsageKeyboardSpacebar,
    45 => UIKeyboardHIDUsageKeyboardHyphen,
    46 => UIKeyboardHIDUsageKeyboardEqualSign,
    47 => UIKeyboardHIDUsageKeyboardOpenBracket,
    48 => UIKeyboardHIDUsageKeyboardCloseBracket,
    49 => UIKeyboardHIDUsageKeyboardBackslash,
    50 => UIKeyboardHIDUsageKeyboardNonUSPound,
    51 => UIKeyboardHIDUsageKeyboardSemicolon,
    52 => UIKeyboardHIDUsageKeyboardQuote,
    53 => UIKeyboardHIDUsageKeyboardGraveAccentAndTilde,
    54 => UIKeyboardHIDUsageKeyboardComma,
    55 => UIKeyboardHIDUsageKeyboardPeriod,
    56 => UIKeyboardHIDUsageKeyboardSlash,
    57 => UIKeyboardHIDUsageKeyboardCapsLock,
    58 => UIKeyboardHIDUsageKeyboardF1,
    59 => UIKeyboardHIDUsageKeyboardF2,
    60 => UIKeyboardHIDUsageKeyboardF3,
    61 => UIKeyboardHIDUsageKeyboardF4,
    62 => UIKeyboardHIDUsageKeyboardF5,
    63 => UIKeyboardHIDUsageKeyboardF6,
    64 => UIKeyboardHIDUsageKeyboardF7,
    65 => UIKeyboardHIDUsageKeyboardF8,
    66 => UIKeyboardHIDUsageKeyboardF9,
    67 => UIKeyboardHIDUsageKeyboardF10,
    68 => UIKeyboardHIDUsageKeyboardF11,
    69 => UIKeyboardHIDUsageKeyboardF12,
    70 => UIKeyboardHIDUsageKeyboardPrintScreen,
    71 => UIKeyboardHIDUsageKeyboardScrollLock,
    72 => UIKeyboardHIDUsageKeyboardPause,
    73 => UIKeyboardHIDUsageKeyboardInsert,
    74 => UIKeyboardHIDUsageKeyboardHome,
    75 => UIKeyboardHIDUsageKeyboardPageUp,
    76 => UIKeyboardHIDUsageKeyboardDeleteForward,
    77 => UIKeyboardHIDUsageKeyboardEnd,
    78 => UIKeyboardHIDUsageKeyboardPageDown,
    79 => UIKeyboardHIDUsageKeyboardRightArrow,
    80 => UIKeyboardHIDUsageKeyboardLeftArrow,
    81 => UIKeyboardHIDUsageKeyboardDownArrow,
    82 => UIKeyboardHIDUsageKeyboardUpArrow,
    83 => UIKeyboardHIDUsageKeypadNumLock,
    84 => UIKeyboardHIDUsageKeypadSlash,
    85 => UIKeyboardHIDUsageKeypadAsterisk,
    86 => UIKeyboardHIDUsageKeypadHyphen,
    87 => UIKeyboardHIDUsageKeypadPlus,
    88 => UIKeyboardHIDUsageKeypadEnter,
    89 => UIKeyboardHIDUsageKeypad1,
    90 => UIKeyboardHIDUsageKeypad2,
    91 => UIKeyboardHIDUsageKeypad3,
    92 => UIKeyboardHIDUsageKeypad4,
    93 => UIKeyboardHIDUsageKeypad5,
    94 => UIKeyboardHIDUsageKeypad6,
    95 => UIKeyboardHIDUsageKeypad7,
    96 => UIKeyboardHIDUsageKeypad8,
    97 => UIKeyboardHIDUsageKeypad9,
    98 => UIKeyboardHIDUsageKeypad0,
    99 => UIKeyboardHIDUsageKeypadPeriod,
    100 => UIKeyboardHIDUsageKeyboardNonUSBackslash,
    101 => UIKeyboardHIDUsageKeyboardApplication,
    102 => UIKeyboardHIDUsageKeyboardPower,
    103 => UIKeyboardHIDUsageKeypadEqualSign,
    104 => UIKeyboardHIDUsageKeyboardF13,
    105 => UIKeyboardHIDUsageKeyboardF14,
    106 => UIKeyboardHIDUsageKeyboardF15,
    107 => UIKeyboardHIDUsageKeyboardF16,
    108 => UIKeyboardHIDUsageKeyboardF17,
    109 => UIKeyboardHIDUsageKeyboardF18,
    110 => UIKeyboardHIDUsageKeyboardF19,
    111 => UIKeyboardHIDUsageKeyboardF20,
    112 => UIKeyboardHIDUsageKeyboardF21,
    113 => UIKeyboardHIDUsageKeyboardF22,
    114 => UIKeyboardHIDUsageKeyboardF23,
    115 => UIKeyboardHIDUsageKeyboardF24,
    116 => UIKeyboardHIDUsageKeyboardExecute,
    117 => UIKeyboardHIDUsageKeyboardHelp,
    118 => UIKeyboardHIDUsageKeyboardMenu,
    119 => UIKeyboardHIDUsageKeyboardSelect,
    120 => UIKeyboardHIDUsageKeyboardStop,
    121 => UIKeyboardHIDUsageKeyboardAgain,
    122 => UIKeyboardHIDUsageKeyboardUndo,
    123 => UIKeyboardHIDUsageKeyboardCut,
    124 => UIKeyboardHIDUsageKeyboardCopy,
    125 => UIKeyboardHIDUsageKeyboardPaste,
    126 => UIKeyboardHIDUsageKeyboardFind,
    127 => UIKeyboardHIDUsageKeyboardMute,
    128 => UIKeyboardHIDUsageKeyboardVolumeUp,
    129 => UIKeyboardHIDUsageKeyboardVolumeDown,
    130 => UIKeyboardHIDUsageKeyboardLockingCapsLock,
    131 => UIKeyboardHIDUsageKeyboardLockingNumLock,
    132 => UIKeyboardHIDUsageKeyboardLockingScrollLock,
    133 => UIKeyboardHIDUsageKeypadComma,
    134 => UIKeyboardHIDUsageKeypadEqualSignAS400,
    135 => UIKeyboardHIDUsageKeyboardInternational1,
    136 => UIKeyboardHIDUsageKeyboardInternational2,
    137 => UIKeyboardHIDUsageKeyboardInternational3,
    138 => UIKeyboardHIDUsageKeyboardInternational4,
    139 => UIKeyboardHIDUsageKeyboardInternational5,
    140 => UIKeyboardHIDUsageKeyboardInternational6,
    141 => UIKeyboardHIDUsageKeyboardInternational7,
    142 => UIKeyboardHIDUsageKeyboardInternational8,
    143 => UIKeyboardHIDUsageKeyboardInternational9,
    144 => UIKeyboardHIDUsageKeyboardLANG1,
    145 => UIKeyboardHIDUsageKeyboardLANG2,
    146 => UIKeyboardHIDUsageKeyboardLANG3,
    147 => UIKeyboardHIDUsageKeyboardLANG4,
    148 => UIKeyboardHIDUsageKeyboardLANG5,
    149 => UIKeyboardHIDUsageKeyboardLANG6,
    150 => UIKeyboardHIDUsageKeyboardLANG7,
    151 => UIKeyboardHIDUsageKeyboardLANG8,
    152 => UIKeyboardHIDUsageKeyboardLANG9,
    153 => UIKeyboardHIDUsageKeyboardAlternateErase,
    154 => UIKeyboardHIDUsageKeyboardSysReqOrAttention,
    155 => UIKeyboardHIDUsageKeyboardCancel,
    156 => UIKeyboardHIDUsageKeyboardClear,
    157 => UIKeyboardHIDUsageKeyboardPrior,
    158 => UIKeyboardHIDUsageKeyboardReturn,
    159 => UIKeyboardHIDUsageKeyboardSeparator,
    160 => UIKeyboardHIDUsageKeyboardOut,
    161 => UIKeyboardHIDUsageKeyboardOper,
    162 => UIKeyboardHIDUsageKeyboardClearOrAgain,
    163 => UIKeyboardHIDUsageKeyboardCrSelOrProps,
    164 => UIKeyboardHIDUsageKeyboardExSel,
    224 => UIKeyboardHIDUsageKeyboardLeftControl,
    225 => UIKeyboardHIDUsageKeyboardLeftShift,
    226 => UIKeyboardHIDUsageKeyboardLeftAlt,
    227 => UIKeyboardHIDUsageKeyboardLeftGUI,
    228 => UIKeyboardHIDUsageKeyboardRightControl,
    229 => UIKeyboardHIDUsageKeyboardRightShift,
    230 => UIKeyboardHIDUsageKeyboardRightAlt,
    231 => UIKeyboardHIDUsageKeyboardRightGUI,
    65535 => UIKeyboardHIDUsageKeyboard_Reserved,
    _ => throw ArgumentError('Unknown value for UIKeyboardHIDUsage: $value'),
  };

  @override
  String toString() {
    if (this == UIKeyboardHIDUsageKeyboardLANG1)
      return "UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardLANG1, UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardHangul, UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardKanaSwitch";
    if (this == UIKeyboardHIDUsageKeyboardLANG2)
      return "UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardLANG2, UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardHanja, UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardAlphanumericSwitch";
    if (this == UIKeyboardHIDUsageKeyboardLANG3)
      return "UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardLANG3, UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardKatakana";
    if (this == UIKeyboardHIDUsageKeyboardLANG4)
      return "UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardLANG4, UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardHiragana";
    if (this == UIKeyboardHIDUsageKeyboardLANG5)
      return "UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardLANG5, UIKeyboardHIDUsage.UIKeyboardHIDUsageKeyboardZenkakuHankakuKanji";
    return super.toString();
  }
}

enum UINavigationItemLargeTitleDisplayMode {
  UINavigationItemLargeTitleDisplayModeAutomatic(0),
  UINavigationItemLargeTitleDisplayModeAlways(1),
  UINavigationItemLargeTitleDisplayModeNever(2),
  UINavigationItemLargeTitleDisplayModeInline(3);

  final int value;
  const UINavigationItemLargeTitleDisplayMode(this.value);

  static UINavigationItemLargeTitleDisplayMode fromValue(int value) =>
      switch (value) {
        0 => UINavigationItemLargeTitleDisplayModeAutomatic,
        1 => UINavigationItemLargeTitleDisplayModeAlways,
        2 => UINavigationItemLargeTitleDisplayModeNever,
        3 => UINavigationItemLargeTitleDisplayModeInline,
        _ => throw ArgumentError(
          'Unknown value for UINavigationItemLargeTitleDisplayMode: $value',
        ),
      };
}

enum UINavigationItemBackButtonDisplayMode {
  UINavigationItemBackButtonDisplayModeDefault(0),
  UINavigationItemBackButtonDisplayModeGeneric(1),
  UINavigationItemBackButtonDisplayModeMinimal(2);

  final int value;
  const UINavigationItemBackButtonDisplayMode(this.value);

  static UINavigationItemBackButtonDisplayMode fromValue(int value) =>
      switch (value) {
        0 => UINavigationItemBackButtonDisplayModeDefault,
        1 => UINavigationItemBackButtonDisplayModeGeneric,
        2 => UINavigationItemBackButtonDisplayModeMinimal,
        _ => throw ArgumentError(
          'Unknown value for UINavigationItemBackButtonDisplayMode: $value',
        ),
      };
}

enum UINavigationItemSearchBarPlacement {
  UINavigationItemSearchBarPlacementAutomatic(0),
  UINavigationItemSearchBarPlacementIntegrated(1),
  UINavigationItemSearchBarPlacementStacked(2),
  UINavigationItemSearchBarPlacementIntegratedCentered(3),
  UINavigationItemSearchBarPlacementIntegratedButton(4);

  static const UINavigationItemSearchBarPlacementInline =
      UINavigationItemSearchBarPlacementIntegrated;

  final int value;
  const UINavigationItemSearchBarPlacement(this.value);

  static UINavigationItemSearchBarPlacement fromValue(int value) =>
      switch (value) {
        0 => UINavigationItemSearchBarPlacementAutomatic,
        1 => UINavigationItemSearchBarPlacementIntegrated,
        2 => UINavigationItemSearchBarPlacementStacked,
        3 => UINavigationItemSearchBarPlacementIntegratedCentered,
        4 => UINavigationItemSearchBarPlacementIntegratedButton,
        _ => throw ArgumentError(
          'Unknown value for UINavigationItemSearchBarPlacement: $value',
        ),
      };

  @override
  String toString() {
    if (this == UINavigationItemSearchBarPlacementIntegrated)
      return "UINavigationItemSearchBarPlacement.UINavigationItemSearchBarPlacementIntegrated, UINavigationItemSearchBarPlacement.UINavigationItemSearchBarPlacementInline";
    return super.toString();
  }
}

enum UINavigationItemStyle {
  UINavigationItemStyleNavigator(0),
  UINavigationItemStyleBrowser(1),
  UINavigationItemStyleEditor(2);

  final int value;
  const UINavigationItemStyle(this.value);

  static UINavigationItemStyle fromValue(int value) => switch (value) {
    0 => UINavigationItemStyleNavigator,
    1 => UINavigationItemStyleBrowser,
    2 => UINavigationItemStyleEditor,
    _ => throw ArgumentError('Unknown value for UINavigationItemStyle: $value'),
  };
}

enum UIBlurEffectStyle {
  UIBlurEffectStyleExtraLight(0),
  UIBlurEffectStyleLight(1),
  UIBlurEffectStyleDark(2),
  UIBlurEffectStyleExtraDark(3),
  UIBlurEffectStyleRegular(4),
  UIBlurEffectStyleProminent(5),
  UIBlurEffectStyleSystemUltraThinMaterial(6),
  UIBlurEffectStyleSystemThinMaterial(7),
  UIBlurEffectStyleSystemMaterial(8),
  UIBlurEffectStyleSystemThickMaterial(9),
  UIBlurEffectStyleSystemChromeMaterial(10),
  UIBlurEffectStyleSystemUltraThinMaterialLight(11),
  UIBlurEffectStyleSystemThinMaterialLight(12),
  UIBlurEffectStyleSystemMaterialLight(13),
  UIBlurEffectStyleSystemThickMaterialLight(14),
  UIBlurEffectStyleSystemChromeMaterialLight(15),
  UIBlurEffectStyleSystemUltraThinMaterialDark(16),
  UIBlurEffectStyleSystemThinMaterialDark(17),
  UIBlurEffectStyleSystemMaterialDark(18),
  UIBlurEffectStyleSystemThickMaterialDark(19),
  UIBlurEffectStyleSystemChromeMaterialDark(20);

  final int value;
  const UIBlurEffectStyle(this.value);

  static UIBlurEffectStyle fromValue(int value) => switch (value) {
    0 => UIBlurEffectStyleExtraLight,
    1 => UIBlurEffectStyleLight,
    2 => UIBlurEffectStyleDark,
    3 => UIBlurEffectStyleExtraDark,
    4 => UIBlurEffectStyleRegular,
    5 => UIBlurEffectStyleProminent,
    6 => UIBlurEffectStyleSystemUltraThinMaterial,
    7 => UIBlurEffectStyleSystemThinMaterial,
    8 => UIBlurEffectStyleSystemMaterial,
    9 => UIBlurEffectStyleSystemThickMaterial,
    10 => UIBlurEffectStyleSystemChromeMaterial,
    11 => UIBlurEffectStyleSystemUltraThinMaterialLight,
    12 => UIBlurEffectStyleSystemThinMaterialLight,
    13 => UIBlurEffectStyleSystemMaterialLight,
    14 => UIBlurEffectStyleSystemThickMaterialLight,
    15 => UIBlurEffectStyleSystemChromeMaterialLight,
    16 => UIBlurEffectStyleSystemUltraThinMaterialDark,
    17 => UIBlurEffectStyleSystemThinMaterialDark,
    18 => UIBlurEffectStyleSystemMaterialDark,
    19 => UIBlurEffectStyleSystemThickMaterialDark,
    20 => UIBlurEffectStyleSystemChromeMaterialDark,
    _ => throw ArgumentError('Unknown value for UIBlurEffectStyle: $value'),
  };
}

enum UIGraphicsImageRendererFormatRange {
  UIGraphicsImageRendererFormatRangeUnspecified(-1),
  UIGraphicsImageRendererFormatRangeAutomatic(0),
  UIGraphicsImageRendererFormatRangeExtended(1),
  UIGraphicsImageRendererFormatRangeStandard(2);

  final int value;
  const UIGraphicsImageRendererFormatRange(this.value);

  static UIGraphicsImageRendererFormatRange fromValue(int value) =>
      switch (value) {
        -1 => UIGraphicsImageRendererFormatRangeUnspecified,
        0 => UIGraphicsImageRendererFormatRangeAutomatic,
        1 => UIGraphicsImageRendererFormatRangeExtended,
        2 => UIGraphicsImageRendererFormatRangeStandard,
        _ => throw ArgumentError(
          'Unknown value for UIGraphicsImageRendererFormatRange: $value',
        ),
      };
}

sealed class UIScrollTypeMask {
  static const UIScrollTypeMaskDiscrete = 1;
  static const UIScrollTypeMaskContinuous = 2;
  static const UIScrollTypeMaskAll = 3;
}

enum UINavigationControllerOperation {
  UINavigationControllerOperationNone(0),
  UINavigationControllerOperationPush(1),
  UINavigationControllerOperationPop(2);

  final int value;
  const UINavigationControllerOperation(this.value);

  static UINavigationControllerOperation fromValue(int value) =>
      switch (value) {
        0 => UINavigationControllerOperationNone,
        1 => UINavigationControllerOperationPush,
        2 => UINavigationControllerOperationPop,
        _ => throw ArgumentError(
          'Unknown value for UINavigationControllerOperation: $value',
        ),
      };
}

enum UIInputViewStyle {
  UIInputViewStyleDefault(0),
  UIInputViewStyleKeyboard(1);

  final int value;
  const UIInputViewStyle(this.value);

  static UIInputViewStyle fromValue(int value) => switch (value) {
    0 => UIInputViewStyleDefault,
    1 => UIInputViewStyleKeyboard,
    _ => throw ArgumentError('Unknown value for UIInputViewStyle: $value'),
  };
}

enum UILabelVibrancy {
  UILabelVibrancyNone(0),
  UILabelVibrancyAutomatic(1);

  final int value;
  const UILabelVibrancy(this.value);

  static UILabelVibrancy fromValue(int value) => switch (value) {
    0 => UILabelVibrancyNone,
    1 => UILabelVibrancyAutomatic,
    _ => throw ArgumentError('Unknown value for UILabelVibrancy: $value'),
  };
}

enum UIApplicationShortcutIconType {
  UIApplicationShortcutIconTypeCompose(0),
  UIApplicationShortcutIconTypePlay(1),
  UIApplicationShortcutIconTypePause(2),
  UIApplicationShortcutIconTypeAdd(3),
  UIApplicationShortcutIconTypeLocation(4),
  UIApplicationShortcutIconTypeSearch(5),
  UIApplicationShortcutIconTypeShare(6),
  UIApplicationShortcutIconTypeProhibit(7),
  UIApplicationShortcutIconTypeContact(8),
  UIApplicationShortcutIconTypeHome(9),
  UIApplicationShortcutIconTypeMarkLocation(10),
  UIApplicationShortcutIconTypeFavorite(11),
  UIApplicationShortcutIconTypeLove(12),
  UIApplicationShortcutIconTypeCloud(13),
  UIApplicationShortcutIconTypeInvitation(14),
  UIApplicationShortcutIconTypeConfirmation(15),
  UIApplicationShortcutIconTypeMail(16),
  UIApplicationShortcutIconTypeMessage(17),
  UIApplicationShortcutIconTypeDate(18),
  UIApplicationShortcutIconTypeTime(19),
  UIApplicationShortcutIconTypeCapturePhoto(20),
  UIApplicationShortcutIconTypeCaptureVideo(21),
  UIApplicationShortcutIconTypeTask(22),
  UIApplicationShortcutIconTypeTaskCompleted(23),
  UIApplicationShortcutIconTypeAlarm(24),
  UIApplicationShortcutIconTypeBookmark(25),
  UIApplicationShortcutIconTypeShuffle(26),
  UIApplicationShortcutIconTypeAudio(27),
  UIApplicationShortcutIconTypeUpdate(28);

  final int value;
  const UIApplicationShortcutIconType(this.value);

  static UIApplicationShortcutIconType fromValue(int value) => switch (value) {
    0 => UIApplicationShortcutIconTypeCompose,
    1 => UIApplicationShortcutIconTypePlay,
    2 => UIApplicationShortcutIconTypePause,
    3 => UIApplicationShortcutIconTypeAdd,
    4 => UIApplicationShortcutIconTypeLocation,
    5 => UIApplicationShortcutIconTypeSearch,
    6 => UIApplicationShortcutIconTypeShare,
    7 => UIApplicationShortcutIconTypeProhibit,
    8 => UIApplicationShortcutIconTypeContact,
    9 => UIApplicationShortcutIconTypeHome,
    10 => UIApplicationShortcutIconTypeMarkLocation,
    11 => UIApplicationShortcutIconTypeFavorite,
    12 => UIApplicationShortcutIconTypeLove,
    13 => UIApplicationShortcutIconTypeCloud,
    14 => UIApplicationShortcutIconTypeInvitation,
    15 => UIApplicationShortcutIconTypeConfirmation,
    16 => UIApplicationShortcutIconTypeMail,
    17 => UIApplicationShortcutIconTypeMessage,
    18 => UIApplicationShortcutIconTypeDate,
    19 => UIApplicationShortcutIconTypeTime,
    20 => UIApplicationShortcutIconTypeCapturePhoto,
    21 => UIApplicationShortcutIconTypeCaptureVideo,
    22 => UIApplicationShortcutIconTypeTask,
    23 => UIApplicationShortcutIconTypeTaskCompleted,
    24 => UIApplicationShortcutIconTypeAlarm,
    25 => UIApplicationShortcutIconTypeBookmark,
    26 => UIApplicationShortcutIconTypeShuffle,
    27 => UIApplicationShortcutIconTypeAudio,
    28 => UIApplicationShortcutIconTypeUpdate,
    _ => throw ArgumentError(
      'Unknown value for UIApplicationShortcutIconType: $value',
    ),
  };
}

enum UICornerCurve {
  UICornerCurveAutomatic(0),
  UICornerCurveCircular(1),
  UICornerCurveContinuous(2);

  final int value;
  const UICornerCurve(this.value);

  static UICornerCurve fromValue(int value) => switch (value) {
    0 => UICornerCurveAutomatic,
    1 => UICornerCurveCircular,
    2 => UICornerCurveContinuous,
    _ => throw ArgumentError('Unknown value for UICornerCurve: $value'),
  };
}

enum UIBehavioralStyle {
  UIBehavioralStyleAutomatic(0),
  UIBehavioralStylePad(1),
  UIBehavioralStyleMac(2);

  final int value;
  const UIBehavioralStyle(this.value);

  static UIBehavioralStyle fromValue(int value) => switch (value) {
    0 => UIBehavioralStyleAutomatic,
    1 => UIBehavioralStylePad,
    2 => UIBehavioralStyleMac,
    _ => throw ArgumentError('Unknown value for UIBehavioralStyle: $value'),
  };
}

enum UINavigationBarNSToolbarSection {
  UINavigationBarNSToolbarSectionNone(0),
  UINavigationBarNSToolbarSectionSidebar(1),
  UINavigationBarNSToolbarSectionSupplementary(2),
  UINavigationBarNSToolbarSectionContent(3);

  final int value;
  const UINavigationBarNSToolbarSection(this.value);

  static UINavigationBarNSToolbarSection fromValue(int value) =>
      switch (value) {
        0 => UINavigationBarNSToolbarSectionNone,
        1 => UINavigationBarNSToolbarSectionSidebar,
        2 => UINavigationBarNSToolbarSectionSupplementary,
        3 => UINavigationBarNSToolbarSectionContent,
        _ => throw ArgumentError(
          'Unknown value for UINavigationBarNSToolbarSection: $value',
        ),
      };
}

sealed class UIPopoverArrowDirection {
  static const UIPopoverArrowDirectionUp = 1;
  static const UIPopoverArrowDirectionDown = 2;
  static const UIPopoverArrowDirectionLeft = 4;
  static const UIPopoverArrowDirectionRight = 8;
  static const UIPopoverArrowDirectionAny = 15;
  static const UIPopoverArrowDirectionUnknown = -1;
}

enum UIPressPhase {
  UIPressPhaseBegan(0),
  UIPressPhaseChanged(1),
  UIPressPhaseStationary(2),
  UIPressPhaseEnded(3),
  UIPressPhaseCancelled(4);

  final int value;
  const UIPressPhase(this.value);

  static UIPressPhase fromValue(int value) => switch (value) {
    0 => UIPressPhaseBegan,
    1 => UIPressPhaseChanged,
    2 => UIPressPhaseStationary,
    3 => UIPressPhaseEnded,
    4 => UIPressPhaseCancelled,
    _ => throw ArgumentError('Unknown value for UIPressPhase: $value'),
  };
}

enum UIPressType {
  UIPressTypeUpArrow(0),
  UIPressTypeDownArrow(1),
  UIPressTypeLeftArrow(2),
  UIPressTypeRightArrow(3),
  UIPressTypeSelect(4),
  UIPressTypeMenu(5),
  UIPressTypePlayPause(6),
  UIPressTypePageUp(30),
  UIPressTypePageDown(31),
  UIPressTypeTVRemoteOneTwoThree(32),
  UIPressTypeTVRemoteFourColors(33);

  final int value;
  const UIPressType(this.value);

  static UIPressType fromValue(int value) => switch (value) {
    0 => UIPressTypeUpArrow,
    1 => UIPressTypeDownArrow,
    2 => UIPressTypeLeftArrow,
    3 => UIPressTypeRightArrow,
    4 => UIPressTypeSelect,
    5 => UIPressTypeMenu,
    6 => UIPressTypePlayPause,
    30 => UIPressTypePageUp,
    31 => UIPressTypePageDown,
    32 => UIPressTypeTVRemoteOneTwoThree,
    33 => UIPressTypeTVRemoteFourColors,
    _ => throw ArgumentError('Unknown value for UIPressType: $value'),
  };
}

enum UIScreenOverscanCompensation {
  UIScreenOverscanCompensationScale(0),
  UIScreenOverscanCompensationInsetBounds(1),
  UIScreenOverscanCompensationNone(2);

  static const UIScreenOverscanCompensationInsetApplicationFrame =
      UIScreenOverscanCompensationNone;

  final int value;
  const UIScreenOverscanCompensation(this.value);

  static UIScreenOverscanCompensation fromValue(int value) => switch (value) {
    0 => UIScreenOverscanCompensationScale,
    1 => UIScreenOverscanCompensationInsetBounds,
    2 => UIScreenOverscanCompensationNone,
    _ => throw ArgumentError(
      'Unknown value for UIScreenOverscanCompensation: $value',
    ),
  };

  @override
  String toString() {
    if (this == UIScreenOverscanCompensationNone)
      return "UIScreenOverscanCompensation.UIScreenOverscanCompensationNone, UIScreenOverscanCompensation.UIScreenOverscanCompensationInsetApplicationFrame";
    return super.toString();
  }
}

enum UIScreenReferenceDisplayModeStatus {
  UIScreenReferenceDisplayModeStatusNotSupported(0),
  UIScreenReferenceDisplayModeStatusNotEnabled(1),
  UIScreenReferenceDisplayModeStatusLimited(2),
  UIScreenReferenceDisplayModeStatusEnabled(3);

  final int value;
  const UIScreenReferenceDisplayModeStatus(this.value);

  static UIScreenReferenceDisplayModeStatus fromValue(int value) =>
      switch (value) {
        0 => UIScreenReferenceDisplayModeStatusNotSupported,
        1 => UIScreenReferenceDisplayModeStatusNotEnabled,
        2 => UIScreenReferenceDisplayModeStatusLimited,
        3 => UIScreenReferenceDisplayModeStatusEnabled,
        _ => throw ArgumentError(
          'Unknown value for UIScreenReferenceDisplayModeStatus: $value',
        ),
      };
}

enum UISearchBarIcon {
  UISearchBarIconSearch(0),
  UISearchBarIconClear(1),
  UISearchBarIconBookmark(2),
  UISearchBarIconResultsList(3);

  final int value;
  const UISearchBarIcon(this.value);

  static UISearchBarIcon fromValue(int value) => switch (value) {
    0 => UISearchBarIconSearch,
    1 => UISearchBarIconClear,
    2 => UISearchBarIconBookmark,
    3 => UISearchBarIconResultsList,
    _ => throw ArgumentError('Unknown value for UISearchBarIcon: $value'),
  };
}

enum UISearchBarStyle {
  UISearchBarStyleDefault(0),
  UISearchBarStyleProminent(1),
  UISearchBarStyleMinimal(2);

  final int value;
  const UISearchBarStyle(this.value);

  static UISearchBarStyle fromValue(int value) => switch (value) {
    0 => UISearchBarStyleDefault,
    1 => UISearchBarStyleProminent,
    2 => UISearchBarStyleMinimal,
    _ => throw ArgumentError('Unknown value for UISearchBarStyle: $value'),
  };
}

enum UITimingCurveType {
  UITimingCurveTypeBuiltin(0),
  UITimingCurveTypeCubic(1),
  UITimingCurveTypeSpring(2),
  UITimingCurveTypeComposed(3);

  final int value;
  const UITimingCurveType(this.value);

  static UITimingCurveType fromValue(int value) => switch (value) {
    0 => UITimingCurveTypeBuiltin,
    1 => UITimingCurveTypeCubic,
    2 => UITimingCurveTypeSpring,
    3 => UITimingCurveTypeComposed,
    _ => throw ArgumentError('Unknown value for UITimingCurveType: $value'),
  };
}

enum UISearchControllerScopeBarActivation {
  UISearchControllerScopeBarActivationAutomatic(0),
  UISearchControllerScopeBarActivationManual(1),
  UISearchControllerScopeBarActivationOnTextEntry(2),
  UISearchControllerScopeBarActivationOnSearchActivation(3);

  final int value;
  const UISearchControllerScopeBarActivation(this.value);

  static UISearchControllerScopeBarActivation fromValue(int value) =>
      switch (value) {
        0 => UISearchControllerScopeBarActivationAutomatic,
        1 => UISearchControllerScopeBarActivationManual,
        2 => UISearchControllerScopeBarActivationOnTextEntry,
        3 => UISearchControllerScopeBarActivationOnSearchActivation,
        _ => throw ArgumentError(
          'Unknown value for UISearchControllerScopeBarActivation: $value',
        ),
      };
}

enum UISplitViewControllerDisplayMode {
  UISplitViewControllerDisplayModeAutomatic(0),
  UISplitViewControllerDisplayModeSecondaryOnly(1),
  UISplitViewControllerDisplayModeOneBesideSecondary(2),
  UISplitViewControllerDisplayModeOneOverSecondary(3),
  UISplitViewControllerDisplayModeTwoBesideSecondary(4),
  UISplitViewControllerDisplayModeTwoOverSecondary(5),
  UISplitViewControllerDisplayModeTwoDisplaceSecondary(6);

  static const UISplitViewControllerDisplayModePrimaryHidden =
      UISplitViewControllerDisplayModeSecondaryOnly;
  static const UISplitViewControllerDisplayModeAllVisible =
      UISplitViewControllerDisplayModeOneBesideSecondary;
  static const UISplitViewControllerDisplayModePrimaryOverlay =
      UISplitViewControllerDisplayModeOneOverSecondary;

  final int value;
  const UISplitViewControllerDisplayMode(this.value);

  static UISplitViewControllerDisplayMode fromValue(int value) =>
      switch (value) {
        0 => UISplitViewControllerDisplayModeAutomatic,
        1 => UISplitViewControllerDisplayModeSecondaryOnly,
        2 => UISplitViewControllerDisplayModeOneBesideSecondary,
        3 => UISplitViewControllerDisplayModeOneOverSecondary,
        4 => UISplitViewControllerDisplayModeTwoBesideSecondary,
        5 => UISplitViewControllerDisplayModeTwoOverSecondary,
        6 => UISplitViewControllerDisplayModeTwoDisplaceSecondary,
        _ => throw ArgumentError(
          'Unknown value for UISplitViewControllerDisplayMode: $value',
        ),
      };

  @override
  String toString() {
    if (this == UISplitViewControllerDisplayModeSecondaryOnly)
      return "UISplitViewControllerDisplayMode.UISplitViewControllerDisplayModeSecondaryOnly, UISplitViewControllerDisplayMode.UISplitViewControllerDisplayModePrimaryHidden";
    if (this == UISplitViewControllerDisplayModeOneBesideSecondary)
      return "UISplitViewControllerDisplayMode.UISplitViewControllerDisplayModeOneBesideSecondary, UISplitViewControllerDisplayMode.UISplitViewControllerDisplayModeAllVisible";
    if (this == UISplitViewControllerDisplayModeOneOverSecondary)
      return "UISplitViewControllerDisplayMode.UISplitViewControllerDisplayModeOneOverSecondary, UISplitViewControllerDisplayMode.UISplitViewControllerDisplayModePrimaryOverlay";
    return super.toString();
  }
}

enum UISplitViewControllerPrimaryEdge {
  UISplitViewControllerPrimaryEdgeLeading(0),
  UISplitViewControllerPrimaryEdgeTrailing(1);

  final int value;
  const UISplitViewControllerPrimaryEdge(this.value);

  static UISplitViewControllerPrimaryEdge fromValue(int value) =>
      switch (value) {
        0 => UISplitViewControllerPrimaryEdgeLeading,
        1 => UISplitViewControllerPrimaryEdgeTrailing,
        _ => throw ArgumentError(
          'Unknown value for UISplitViewControllerPrimaryEdge: $value',
        ),
      };
}

enum UISplitViewControllerBackgroundStyle {
  UISplitViewControllerBackgroundStyleNone(0),
  UISplitViewControllerBackgroundStyleSidebar(1);

  final int value;
  const UISplitViewControllerBackgroundStyle(this.value);

  static UISplitViewControllerBackgroundStyle fromValue(int value) =>
      switch (value) {
        0 => UISplitViewControllerBackgroundStyleNone,
        1 => UISplitViewControllerBackgroundStyleSidebar,
        _ => throw ArgumentError(
          'Unknown value for UISplitViewControllerBackgroundStyle: $value',
        ),
      };
}

enum UISplitViewControllerStyle {
  UISplitViewControllerStyleUnspecified(0),
  UISplitViewControllerStyleDoubleColumn(1),
  UISplitViewControllerStyleTripleColumn(2);

  final int value;
  const UISplitViewControllerStyle(this.value);

  static UISplitViewControllerStyle fromValue(int value) => switch (value) {
    0 => UISplitViewControllerStyleUnspecified,
    1 => UISplitViewControllerStyleDoubleColumn,
    2 => UISplitViewControllerStyleTripleColumn,
    _ => throw ArgumentError(
      'Unknown value for UISplitViewControllerStyle: $value',
    ),
  };
}

enum UISplitViewControllerColumn {
  UISplitViewControllerColumnPrimary(0),
  UISplitViewControllerColumnSupplementary(1),
  UISplitViewControllerColumnSecondary(2),
  UISplitViewControllerColumnCompact(3),
  UISplitViewControllerColumnInspector(4);

  final int value;
  const UISplitViewControllerColumn(this.value);

  static UISplitViewControllerColumn fromValue(int value) => switch (value) {
    0 => UISplitViewControllerColumnPrimary,
    1 => UISplitViewControllerColumnSupplementary,
    2 => UISplitViewControllerColumnSecondary,
    3 => UISplitViewControllerColumnCompact,
    4 => UISplitViewControllerColumnInspector,
    _ => throw ArgumentError(
      'Unknown value for UISplitViewControllerColumn: $value',
    ),
  };
}

enum UISplitViewControllerSplitBehavior {
  UISplitViewControllerSplitBehaviorAutomatic(0),
  UISplitViewControllerSplitBehaviorTile(1),
  UISplitViewControllerSplitBehaviorOverlay(2),
  UISplitViewControllerSplitBehaviorDisplace(3);

  final int value;
  const UISplitViewControllerSplitBehavior(this.value);

  static UISplitViewControllerSplitBehavior fromValue(int value) =>
      switch (value) {
        0 => UISplitViewControllerSplitBehaviorAutomatic,
        1 => UISplitViewControllerSplitBehaviorTile,
        2 => UISplitViewControllerSplitBehaviorOverlay,
        3 => UISplitViewControllerSplitBehaviorDisplace,
        _ => throw ArgumentError(
          'Unknown value for UISplitViewControllerSplitBehavior: $value',
        ),
      };
}

enum UISplitViewControllerDisplayModeButtonVisibility {
  UISplitViewControllerDisplayModeButtonVisibilityAutomatic(0),
  UISplitViewControllerDisplayModeButtonVisibilityNever(1),
  UISplitViewControllerDisplayModeButtonVisibilityAlways(2);

  final int value;
  const UISplitViewControllerDisplayModeButtonVisibility(this.value);

  static UISplitViewControllerDisplayModeButtonVisibility fromValue(
    int value,
  ) => switch (value) {
    0 => UISplitViewControllerDisplayModeButtonVisibilityAutomatic,
    1 => UISplitViewControllerDisplayModeButtonVisibilityNever,
    2 => UISplitViewControllerDisplayModeButtonVisibilityAlways,
    _ => throw ArgumentError(
      'Unknown value for UISplitViewControllerDisplayModeButtonVisibility: $value',
    ),
  };
}

/// Construction methods for `objc.ObjCBlock<UIViewController? Function(objc.NSCoder)>`.
abstract final class ObjCBlock_UIViewController_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIViewController? Function(objc.NSCoder)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UIViewController? Function(objc.NSCoder)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIViewController? Function(objc.NSCoder)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<UIViewController? Function(objc.NSCoder)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIViewController? Function(objc.NSCoder)> fromFunction(
    UIViewController? Function(objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UIViewController? Function(objc.NSCoder)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(
            objc.NSCoder.fromPointer(arg0, retain: true, release: true),
          )?.ref.retainAndAutorelease() ??
          ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<UIViewController? Function(objc.NSCoder)>`.
extension ObjCBlock_UIViewController_NSCoder$CallExtension
    on objc.ObjCBlock<UIViewController? Function(objc.NSCoder)> {
  UIViewController? call(objc.NSCoder arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<objc.ObjCObjectImpl> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0.ref.pointer)
              .address ==
          0
      ? null
      : UIViewController.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<objc.ObjCObjectImpl> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0.ref.pointer),
          retain: true,
          release: true,
        );
}

enum UITabBarItemPositioning {
  UITabBarItemPositioningAutomatic(0),
  UITabBarItemPositioningFill(1),
  UITabBarItemPositioningCentered(2);

  final int value;
  const UITabBarItemPositioning(this.value);

  static UITabBarItemPositioning fromValue(int value) => switch (value) {
    0 => UITabBarItemPositioningAutomatic,
    1 => UITabBarItemPositioningFill,
    2 => UITabBarItemPositioningCentered,
    _ => throw ArgumentError(
      'Unknown value for UITabBarItemPositioning: $value',
    ),
  };
}

enum UITabBarControllerMode {
  UITabBarControllerModeAutomatic(0),
  UITabBarControllerModeTabBar(1),
  UITabBarControllerModeTabSidebar(2);

  final int value;
  const UITabBarControllerMode(this.value);

  static UITabBarControllerMode fromValue(int value) => switch (value) {
    0 => UITabBarControllerModeAutomatic,
    1 => UITabBarControllerModeTabBar,
    2 => UITabBarControllerModeTabSidebar,
    _ => throw ArgumentError(
      'Unknown value for UITabBarControllerMode: $value',
    ),
  };
}

enum UITabBarMinimizeBehavior {
  UITabBarMinimizeBehaviorAutomatic(0),
  UITabBarMinimizeBehaviorNever(1),
  UITabBarMinimizeBehaviorOnScrollDown(2),
  UITabBarMinimizeBehaviorOnScrollUp(3);

  final int value;
  const UITabBarMinimizeBehavior(this.value);

  static UITabBarMinimizeBehavior fromValue(int value) => switch (value) {
    0 => UITabBarMinimizeBehaviorAutomatic,
    1 => UITabBarMinimizeBehaviorNever,
    2 => UITabBarMinimizeBehaviorOnScrollDown,
    3 => UITabBarMinimizeBehaviorOnScrollUp,
    _ => throw ArgumentError(
      'Unknown value for UITabBarMinimizeBehavior: $value',
    ),
  };
}

enum UITabBarSystemItem {
  UITabBarSystemItemMore(0),
  UITabBarSystemItemFavorites(1),
  UITabBarSystemItemFeatured(2),
  UITabBarSystemItemTopRated(3),
  UITabBarSystemItemRecents(4),
  UITabBarSystemItemContacts(5),
  UITabBarSystemItemHistory(6),
  UITabBarSystemItemBookmarks(7),
  UITabBarSystemItemSearch(8),
  UITabBarSystemItemDownloads(9),
  UITabBarSystemItemMostRecent(10),
  UITabBarSystemItemMostViewed(11);

  final int value;
  const UITabBarSystemItem(this.value);

  static UITabBarSystemItem fromValue(int value) => switch (value) {
    0 => UITabBarSystemItemMore,
    1 => UITabBarSystemItemFavorites,
    2 => UITabBarSystemItemFeatured,
    3 => UITabBarSystemItemTopRated,
    4 => UITabBarSystemItemRecents,
    5 => UITabBarSystemItemContacts,
    6 => UITabBarSystemItemHistory,
    7 => UITabBarSystemItemBookmarks,
    8 => UITabBarSystemItemSearch,
    9 => UITabBarSystemItemDownloads,
    10 => UITabBarSystemItemMostRecent,
    11 => UITabBarSystemItemMostViewed,
    _ => throw ArgumentError('Unknown value for UITabBarSystemItem: $value'),
  };
}

late final _class_UITableViewHeaderFooterView = objc.getClass(
  "UITableViewHeaderFooterView",
);
late final _sel_initWithReuseIdentifier_ = objc.registerName(
  "initWithReuseIdentifier:",
);

/// UITableViewHeaderFooterView
extension type UITableViewHeaderFooterView._(objc.ObjCObject object$)
    implements objc.ObjCObject, UIView {
  /// Constructs a [UITableViewHeaderFooterView] that points to the same underlying object as [other].
  UITableViewHeaderFooterView.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView',
      iOS: (false, (6, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [UITableViewHeaderFooterView] that wraps the given raw object pointer.
  UITableViewHeaderFooterView.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView',
      iOS: (false, (6, 0, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [UITableViewHeaderFooterView].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_UITableViewHeaderFooterView,
  );

  /// alloc
  static UITableViewHeaderFooterView alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_UITableViewHeaderFooterView,
      _sel_alloc,
    );
    return UITableViewHeaderFooterView.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static UITableViewHeaderFooterView allocWithZone(
    ffi.Pointer<objc.NSZone> zone,
  ) {
    final $ret = _objc_msgSend_1cwp428(
      _class_UITableViewHeaderFooterView,
      _sel_allocWithZone_,
      zone,
    );
    return UITableViewHeaderFooterView.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// appearance
  static UITableViewHeaderFooterView appearance() {
    final $ret = _objc_msgSend_151sglz(
      _class_UITableViewHeaderFooterView,
      _sel_appearance,
    );
    return UITableViewHeaderFooterView.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// appearanceForTraitCollection:
  static UITableViewHeaderFooterView appearanceForTraitCollection(
    UITraitCollection trait,
  ) {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.appearanceForTraitCollection:',
      iOS: (false, (8, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_UITableViewHeaderFooterView,
      _sel_appearanceForTraitCollection_,
      trait.ref.pointer,
    );
    return UITableViewHeaderFooterView.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// appearanceForTraitCollection:whenContainedIn:
  static UITableViewHeaderFooterView appearanceForTraitCollection$1(
    UITraitCollection trait, {
    UIAppearanceContainer? whenContainedIn,
  }) {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.appearanceForTraitCollection:whenContainedIn:',
      iOS: (false, (8, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_UITableViewHeaderFooterView,
      _sel_appearanceForTraitCollection_whenContainedIn_,
      trait.ref.pointer,
      whenContainedIn?.ref.pointer ?? ffi.nullptr,
    );
    return UITableViewHeaderFooterView.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// appearanceForTraitCollection:whenContainedInInstancesOfClasses:
  static UITableViewHeaderFooterView appearanceForTraitCollection$2(
    UITraitCollection trait, {
    required objc.NSArray whenContainedInInstancesOfClasses,
  }) {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.appearanceForTraitCollection:whenContainedInInstancesOfClasses:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_UITableViewHeaderFooterView,
      _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_,
      trait.ref.pointer,
      whenContainedInInstancesOfClasses.ref.pointer,
    );
    return UITableViewHeaderFooterView.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// appearanceWhenContainedIn:
  static UITableViewHeaderFooterView appearanceWhenContainedIn(
    UIAppearanceContainer? ContainerClass,
  ) {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.appearanceWhenContainedIn:',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_UITableViewHeaderFooterView,
      _sel_appearanceWhenContainedIn_,
      ContainerClass?.ref.pointer ?? ffi.nullptr,
    );
    return UITableViewHeaderFooterView.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// appearanceWhenContainedInInstancesOfClasses:
  static UITableViewHeaderFooterView
  appearanceWhenContainedInInstancesOfClasses(objc.NSArray containerTypes) {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.appearanceWhenContainedInInstancesOfClasses:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_UITableViewHeaderFooterView,
      _sel_appearanceWhenContainedInInstancesOfClasses_,
      containerTypes.ref.pointer,
    );
    return UITableViewHeaderFooterView.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// layerClass
  static objc.ObjCObject getLayerClass() {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.layerClass',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _class_UITableViewHeaderFooterView,
      _sel_layerClass,
    );
    return objc.ObjCObject($ret, retain: true, release: true);
  }

  /// new
  static UITableViewHeaderFooterView new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_UITableViewHeaderFooterView,
      _sel_new,
    );
    return UITableViewHeaderFooterView.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection
  userInterfaceLayoutDirectionForSemanticContentAttribute(
    UISemanticContentAttribute attribute,
  ) {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.userInterfaceLayoutDirectionForSemanticContentAttribute:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_racczx(
      _class_UITableViewHeaderFooterView,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
      attribute.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection
  userInterfaceLayoutDirectionForSemanticContentAttribute$1(
    UISemanticContentAttribute semanticContentAttribute, {
    required UIUserInterfaceLayoutDirection relativeToLayoutDirection,
  }) {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
      iOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_tz4p54(
      _class_UITableViewHeaderFooterView,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
      semanticContentAttribute.value,
      relativeToLayoutDirection.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }

  /// Returns a new instance of UITableViewHeaderFooterView constructed with the default `new` method.
  UITableViewHeaderFooterView() : this.as(new$().object$);
}

extension UITableViewHeaderFooterView$Methods on UITableViewHeaderFooterView {
  /// automaticallyUpdatesBackgroundConfiguration
  bool get automaticallyUpdatesBackgroundConfiguration {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.automaticallyUpdatesBackgroundConfiguration',
      iOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_automaticallyUpdatesBackgroundConfiguration,
    );
  }

  /// automaticallyUpdatesContentConfiguration
  bool get automaticallyUpdatesContentConfiguration {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.automaticallyUpdatesContentConfiguration',
      iOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_automaticallyUpdatesContentConfiguration,
    );
  }

  /// backgroundConfiguration
  UIBackgroundConfiguration? get backgroundConfiguration {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.backgroundConfiguration',
      iOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_backgroundConfiguration,
    );
    return $ret.address == 0
        ? null
        : UIBackgroundConfiguration.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// backgroundView
  UIView? get backgroundView {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.backgroundView',
      iOS: (false, (6, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_backgroundView,
    );
    return $ret.address == 0
        ? null
        : UIView.fromPointer($ret, retain: true, release: true);
  }

  /// configurationState
  UIViewConfigurationState get configurationState {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.configurationState',
      iOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_configurationState,
    );
    return UIViewConfigurationState.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// configurationUpdateHandler
  objc.ObjCBlock<
    ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)
  >?
  get configurationUpdateHandler {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.configurationUpdateHandler',
      iOS: (false, (15, 0, 0)),
    );
    final $ret = _objc_msgSend_uwvaik(
      object$.ref.pointer,
      _sel_configurationUpdateHandler,
    );
    return $ret.address == 0
        ? null
        : ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// contentConfiguration
  UIContentConfiguration? get contentConfiguration {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.contentConfiguration',
      iOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_contentConfiguration,
    );
    return $ret.address == 0
        ? null
        : UIContentConfiguration.fromPointer($ret, retain: true, release: true);
  }

  /// contentView
  UIView get contentView {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.contentView',
      iOS: (false, (6, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_contentView);
    return UIView.fromPointer($ret, retain: true, release: true);
  }

  /// defaultBackgroundConfiguration
  UIBackgroundConfiguration defaultBackgroundConfiguration() {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.defaultBackgroundConfiguration',
      iOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_defaultBackgroundConfiguration,
    );
    return UIBackgroundConfiguration.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// defaultContentConfiguration
  UIListContentConfiguration defaultContentConfiguration() {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.defaultContentConfiguration',
      iOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_defaultContentConfiguration,
    );
    return UIListContentConfiguration.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// detailTextLabel
  UILabel? get detailTextLabel {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.detailTextLabel',
      iOS: (false, (6, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_detailTextLabel,
    );
    return $ret.address == 0
        ? null
        : UILabel.fromPointer($ret, retain: true, release: true);
  }

  /// init
  UITableViewHeaderFooterView init() {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return UITableViewHeaderFooterView.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCoder:
  UITableViewHeaderFooterView? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : UITableViewHeaderFooterView.fromPointer(
            $ret,
            retain: false,
            release: true,
          );
  }

  /// initWithFrame:
  UITableViewHeaderFooterView initWithFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.initWithFrame:',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_15yz4e6(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithFrame_,
      frame,
    );
    return UITableViewHeaderFooterView.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithReuseIdentifier:
  UITableViewHeaderFooterView initWithReuseIdentifier(
    objc.NSString? reuseIdentifier,
  ) {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.initWithReuseIdentifier:',
      iOS: (false, (6, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithReuseIdentifier_,
      reuseIdentifier?.ref.pointer ?? ffi.nullptr,
    );
    return UITableViewHeaderFooterView.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// prepareForReuse
  void prepareForReuse() {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.prepareForReuse',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_prepareForReuse);
  }

  /// reuseIdentifier
  objc.NSString? get reuseIdentifier {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.reuseIdentifier',
      iOS: (false, (6, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_reuseIdentifier,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// setAutomaticallyUpdatesBackgroundConfiguration:
  set automaticallyUpdatesBackgroundConfiguration(bool value) {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.setAutomaticallyUpdatesBackgroundConfiguration:',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAutomaticallyUpdatesBackgroundConfiguration_,
      value,
    );
  }

  /// setAutomaticallyUpdatesContentConfiguration:
  set automaticallyUpdatesContentConfiguration(bool value) {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.setAutomaticallyUpdatesContentConfiguration:',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAutomaticallyUpdatesContentConfiguration_,
      value,
    );
  }

  /// setBackgroundConfiguration:
  set backgroundConfiguration(UIBackgroundConfiguration? value) {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.setBackgroundConfiguration:',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setBackgroundConfiguration_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setBackgroundView:
  set backgroundView(UIView? value) {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.setBackgroundView:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setBackgroundView_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setConfigurationUpdateHandler:
  set configurationUpdateHandler(
    objc.ObjCBlock<
      ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)
    >?
    value,
  ) {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.setConfigurationUpdateHandler:',
      iOS: (false, (15, 0, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_setConfigurationUpdateHandler_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setContentConfiguration:
  set contentConfiguration(UIContentConfiguration? value) {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.setContentConfiguration:',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setContentConfiguration_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setNeedsUpdateConfiguration
  void setNeedsUpdateConfiguration() {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.setNeedsUpdateConfiguration',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(
      object$.ref.pointer,
      _sel_setNeedsUpdateConfiguration,
    );
  }

  /// textLabel
  UILabel? get textLabel {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.textLabel',
      iOS: (false, (6, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_textLabel);
    return $ret.address == 0
        ? null
        : UILabel.fromPointer($ret, retain: true, release: true);
  }

  /// updateConfigurationUsingState:
  void updateConfigurationUsingState(UIViewConfigurationState state) {
    objc.checkOsVersionInternal(
      'UITableViewHeaderFooterView.updateConfigurationUsingState:',
      iOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_updateConfigurationUsingState_,
      state.ref.pointer,
    );
  }
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)>`.
abstract final class ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)
  >
  fromFunction(
    void Function(UITableViewHeaderFooterView, UIViewConfigurationState) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ) => fn(
            UITableViewHeaderFooterView.fromPointer(
              arg0,
              retain: true,
              release: true,
            ),
            UIViewConfigurationState.fromPointer(
              arg1,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)
  >
  listener(
    void Function(UITableViewHeaderFooterView, UIViewConfigurationState) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        UITableViewHeaderFooterView.fromPointer(
          arg0,
          retain: false,
          release: true,
        ),
        UIViewConfigurationState.fromPointer(
          arg1,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)
  >
  blocking(
    void Function(UITableViewHeaderFooterView, UIViewConfigurationState) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        UITableViewHeaderFooterView.fromPointer(
          arg0,
          retain: false,
          release: true,
        ),
        UIViewConfigurationState.fromPointer(
          arg1,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        UITableViewHeaderFooterView.fromPointer(
          arg0,
          retain: false,
          release: true,
        ),
        UIViewConfigurationState.fromPointer(
          arg1,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(UITableViewHeaderFooterView, UIViewConfigurationState)>`.
extension ObjCBlock_ffiVoid_UITableViewHeaderFooterView_UIViewConfigurationState$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            UITableViewHeaderFooterView,
            UIViewConfigurationState,
          )
        > {
  void call(UITableViewHeaderFooterView arg0, UIViewConfigurationState arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObjectImpl> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(ref.pointer, arg0.ref.pointer, arg1.ref.pointer);
}

enum UIFindSessionSearchResultDisplayStyle {
  UIFindSessionSearchResultDisplayStyleCurrentAndTotal(0),
  UIFindSessionSearchResultDisplayStyleTotal(1),
  UIFindSessionSearchResultDisplayStyleNone(2);

  final int value;
  const UIFindSessionSearchResultDisplayStyle(this.value);

  static UIFindSessionSearchResultDisplayStyle fromValue(int value) =>
      switch (value) {
        0 => UIFindSessionSearchResultDisplayStyleCurrentAndTotal,
        1 => UIFindSessionSearchResultDisplayStyleTotal,
        2 => UIFindSessionSearchResultDisplayStyleNone,
        _ => throw ArgumentError(
          'Unknown value for UIFindSessionSearchResultDisplayStyle: $value',
        ),
      };
}

enum UITextSearchMatchMethod {
  UITextSearchMatchMethodContains(0),
  UITextSearchMatchMethodStartsWith(1),
  UITextSearchMatchMethodFullWord(2);

  final int value;
  const UITextSearchMatchMethod(this.value);

  static UITextSearchMatchMethod fromValue(int value) => switch (value) {
    0 => UITextSearchMatchMethodContains,
    1 => UITextSearchMatchMethodStartsWith,
    2 => UITextSearchMatchMethodFullWord,
    _ => throw ArgumentError(
      'Unknown value for UITextSearchMatchMethod: $value',
    ),
  };
}

/// WARNING: UIFindInteraction is a stub. To generate bindings for this class, include
/// UIFindInteraction in your config's objc-interfaces list.
///
/// UIFindInteraction
extension type UIFindInteraction._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, UIInteraction {
  /// Constructs a [UIFindInteraction] that points to the same underlying object as [other].
  UIFindInteraction.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIFindInteraction', iOS: (false, (16, 0, 0)));
  }

  /// Constructs a [UIFindInteraction] that wraps the given raw object pointer.
  UIFindInteraction.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIFindInteraction', iOS: (false, (16, 0, 0)));
  }
}

enum UIDropSessionProgressIndicatorStyle {
  UIDropSessionProgressIndicatorStyleNone(0),
  UIDropSessionProgressIndicatorStyleDefault(1);

  final int value;
  const UIDropSessionProgressIndicatorStyle(this.value);

  static UIDropSessionProgressIndicatorStyle fromValue(int value) =>
      switch (value) {
        0 => UIDropSessionProgressIndicatorStyleNone,
        1 => UIDropSessionProgressIndicatorStyleDefault,
        _ => throw ArgumentError(
          'Unknown value for UIDropSessionProgressIndicatorStyle: $value',
        ),
      };
}

enum UISpringLoadedInteractionEffectState {
  UISpringLoadedInteractionEffectStateInactive(0),
  UISpringLoadedInteractionEffectStatePossible(1),
  UISpringLoadedInteractionEffectStateActivating(2),
  UISpringLoadedInteractionEffectStateActivated(3);

  final int value;
  const UISpringLoadedInteractionEffectState(this.value);

  static UISpringLoadedInteractionEffectState fromValue(int value) =>
      switch (value) {
        0 => UISpringLoadedInteractionEffectStateInactive,
        1 => UISpringLoadedInteractionEffectStatePossible,
        2 => UISpringLoadedInteractionEffectStateActivating,
        3 => UISpringLoadedInteractionEffectStateActivated,
        _ => throw ArgumentError(
          'Unknown value for UISpringLoadedInteractionEffectState: $value',
        ),
      };
}

enum UITabBarItemAppearanceStyle {
  UITabBarItemAppearanceStyleStacked(0),
  UITabBarItemAppearanceStyleInline(1),
  UITabBarItemAppearanceStyleCompactInline(2);

  final int value;
  const UITabBarItemAppearanceStyle(this.value);

  static UITabBarItemAppearanceStyle fromValue(int value) => switch (value) {
    0 => UITabBarItemAppearanceStyleStacked,
    1 => UITabBarItemAppearanceStyleInline,
    2 => UITabBarItemAppearanceStyleCompactInline,
    _ => throw ArgumentError(
      'Unknown value for UITabBarItemAppearanceStyle: $value',
    ),
  };
}

/// WARNING: NSLayoutAnchor is a stub. To generate bindings for this class, include
/// NSLayoutAnchor in your config's objc-interfaces list.
///
/// NSLayoutAnchor
extension type NSLayoutAnchor._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying, objc.NSCoding {
  /// Constructs a [NSLayoutAnchor] that points to the same underlying object as [other].
  NSLayoutAnchor.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSLayoutAnchor',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }

  /// Constructs a [NSLayoutAnchor] that wraps the given raw object pointer.
  NSLayoutAnchor.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSLayoutAnchor',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }
}

/// WARNING: UITrackingLayoutGuide is a stub. To generate bindings for this class, include
/// UITrackingLayoutGuide in your config's objc-interfaces list.
///
/// UITrackingLayoutGuide
extension type UITrackingLayoutGuide._(objc.ObjCObject object$)
    implements objc.ObjCObject, UILayoutGuide {
  /// Constructs a [UITrackingLayoutGuide] that points to the same underlying object as [other].
  UITrackingLayoutGuide.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'UITrackingLayoutGuide',
      iOS: (false, (15, 0, 0)),
    );
  }

  /// Constructs a [UITrackingLayoutGuide] that wraps the given raw object pointer.
  UITrackingLayoutGuide.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'UITrackingLayoutGuide',
      iOS: (false, (15, 0, 0)),
    );
  }
}

sealed class NSTextStorageEditActions {
  static const NSTextStorageEditedAttributes = 1;
  static const NSTextStorageEditedCharacters = 2;
}

enum NSTextLayoutOrientation {
  NSTextLayoutOrientationHorizontal(0),
  NSTextLayoutOrientationVertical(1);

  final int value;
  const NSTextLayoutOrientation(this.value);

  static NSTextLayoutOrientation fromValue(int value) => switch (value) {
    0 => NSTextLayoutOrientationHorizontal,
    1 => NSTextLayoutOrientationVertical,
    _ => throw ArgumentError(
      'Unknown value for NSTextLayoutOrientation: $value',
    ),
  };
}

sealed class NSGlyphProperty {
  static const NSGlyphPropertyNull = 1;
  static const NSGlyphPropertyControlCharacter = 2;
  static const NSGlyphPropertyElastic = 4;
  static const NSGlyphPropertyNonBaseCharacter = 8;
}

sealed class NSControlCharacterAction {
  static const NSControlCharacterActionZeroAdvancement = 1;
  static const NSControlCharacterActionWhitespace = 2;
  static const NSControlCharacterActionHorizontalTab = 4;
  static const NSControlCharacterActionLineBreak = 8;
  static const NSControlCharacterActionParagraphBreak = 16;
  static const NSControlCharacterActionContainerBreak = 32;
}

enum UIWindowSceneResizingRestrictions {
  UIWindowSceneResizingRestrictionsUnspecified(0),
  UIWindowSceneResizingRestrictionsNone(1),
  UIWindowSceneResizingRestrictionsUniform(2),
  UIWindowSceneResizingRestrictionsFreeform(3);

  final int value;
  const UIWindowSceneResizingRestrictions(this.value);

  static UIWindowSceneResizingRestrictions fromValue(int value) =>
      switch (value) {
        0 => UIWindowSceneResizingRestrictionsUnspecified,
        1 => UIWindowSceneResizingRestrictionsNone,
        2 => UIWindowSceneResizingRestrictionsUniform,
        3 => UIWindowSceneResizingRestrictionsFreeform,
        _ => throw ArgumentError(
          'Unknown value for UIWindowSceneResizingRestrictions: $value',
        ),
      };
}

enum UITabPlacement {
  UITabPlacementAutomatic(0),
  UITabPlacementDefault(1),
  UITabPlacementOptional(2),
  UITabPlacementMovable(3),
  UITabPlacementPinned(4),
  UITabPlacementFixed(5),
  UITabPlacementSidebarOnly(6);

  final int value;
  const UITabPlacement(this.value);

  static UITabPlacement fromValue(int value) => switch (value) {
    0 => UITabPlacementAutomatic,
    1 => UITabPlacementDefault,
    2 => UITabPlacementOptional,
    3 => UITabPlacementMovable,
    4 => UITabPlacementPinned,
    5 => UITabPlacementFixed,
    6 => UITabPlacementSidebarOnly,
    _ => throw ArgumentError('Unknown value for UITabPlacement: $value'),
  };
}

enum UITabGroupSidebarAppearance {
  UITabGroupSidebarAppearanceAutomatic(0),
  UITabGroupSidebarAppearanceInline(1),
  UITabGroupSidebarAppearanceRootSection(2);

  final int value;
  const UITabGroupSidebarAppearance(this.value);

  static UITabGroupSidebarAppearance fromValue(int value) => switch (value) {
    0 => UITabGroupSidebarAppearanceAutomatic,
    1 => UITabGroupSidebarAppearanceInline,
    2 => UITabGroupSidebarAppearanceRootSection,
    _ => throw ArgumentError(
      'Unknown value for UITabGroupSidebarAppearance: $value',
    ),
  };
}

enum UITabBarControllerSidebarLayout {
  UITabBarControllerSidebarLayoutAutomatic(0),
  UITabBarControllerSidebarLayoutOverlap(1),
  UITabBarControllerSidebarLayoutTile(2);

  final int value;
  const UITabBarControllerSidebarLayout(this.value);

  static UITabBarControllerSidebarLayout fromValue(int value) =>
      switch (value) {
        0 => UITabBarControllerSidebarLayoutAutomatic,
        1 => UITabBarControllerSidebarLayoutOverlap,
        2 => UITabBarControllerSidebarLayoutTile,
        _ => throw ArgumentError(
          'Unknown value for UITabBarControllerSidebarLayout: $value',
        ),
      };
}

enum NSTextSelectionGranularity {
  NSTextSelectionGranularityCharacter(0),
  NSTextSelectionGranularityWord(1),
  NSTextSelectionGranularityParagraph(2),
  NSTextSelectionGranularityLine(3),
  NSTextSelectionGranularitySentence(4);

  final int value;
  const NSTextSelectionGranularity(this.value);

  static NSTextSelectionGranularity fromValue(int value) => switch (value) {
    0 => NSTextSelectionGranularityCharacter,
    1 => NSTextSelectionGranularityWord,
    2 => NSTextSelectionGranularityParagraph,
    3 => NSTextSelectionGranularityLine,
    4 => NSTextSelectionGranularitySentence,
    _ => throw ArgumentError(
      'Unknown value for NSTextSelectionGranularity: $value',
    ),
  };
}

enum NSTextSelectionAffinity {
  NSTextSelectionAffinityUpstream(0),
  NSTextSelectionAffinityDownstream(1);

  final int value;
  const NSTextSelectionAffinity(this.value);

  static NSTextSelectionAffinity fromValue(int value) => switch (value) {
    0 => NSTextSelectionAffinityUpstream,
    1 => NSTextSelectionAffinityDownstream,
    _ => throw ArgumentError(
      'Unknown value for NSTextSelectionAffinity: $value',
    ),
  };
}

enum NSTextSelectionNavigationDirection {
  NSTextSelectionNavigationDirectionForward(0),
  NSTextSelectionNavigationDirectionBackward(1),
  NSTextSelectionNavigationDirectionRight(2),
  NSTextSelectionNavigationDirectionLeft(3),
  NSTextSelectionNavigationDirectionUp(4),
  NSTextSelectionNavigationDirectionDown(5);

  final int value;
  const NSTextSelectionNavigationDirection(this.value);

  static NSTextSelectionNavigationDirection fromValue(int value) =>
      switch (value) {
        0 => NSTextSelectionNavigationDirectionForward,
        1 => NSTextSelectionNavigationDirectionBackward,
        2 => NSTextSelectionNavigationDirectionRight,
        3 => NSTextSelectionNavigationDirectionLeft,
        4 => NSTextSelectionNavigationDirectionUp,
        5 => NSTextSelectionNavigationDirectionDown,
        _ => throw ArgumentError(
          'Unknown value for NSTextSelectionNavigationDirection: $value',
        ),
      };
}

enum NSTextSelectionNavigationDestination {
  NSTextSelectionNavigationDestinationCharacter(0),
  NSTextSelectionNavigationDestinationWord(1),
  NSTextSelectionNavigationDestinationLine(2),
  NSTextSelectionNavigationDestinationSentence(3),
  NSTextSelectionNavigationDestinationParagraph(4),
  NSTextSelectionNavigationDestinationContainer(5),
  NSTextSelectionNavigationDestinationDocument(6);

  final int value;
  const NSTextSelectionNavigationDestination(this.value);

  static NSTextSelectionNavigationDestination fromValue(int value) =>
      switch (value) {
        0 => NSTextSelectionNavigationDestinationCharacter,
        1 => NSTextSelectionNavigationDestinationWord,
        2 => NSTextSelectionNavigationDestinationLine,
        3 => NSTextSelectionNavigationDestinationSentence,
        4 => NSTextSelectionNavigationDestinationParagraph,
        5 => NSTextSelectionNavigationDestinationContainer,
        6 => NSTextSelectionNavigationDestinationDocument,
        _ => throw ArgumentError(
          'Unknown value for NSTextSelectionNavigationDestination: $value',
        ),
      };
}

sealed class NSTextSelectionNavigationModifier {
  static const NSTextSelectionNavigationModifierExtend = 1;
  static const NSTextSelectionNavigationModifierVisual = 2;
  static const NSTextSelectionNavigationModifierMultiple = 4;
}

enum NSTextSelectionNavigationWritingDirection {
  NSTextSelectionNavigationWritingDirectionLeftToRight(0),
  NSTextSelectionNavigationWritingDirectionRightToLeft(1);

  final int value;
  const NSTextSelectionNavigationWritingDirection(this.value);

  static NSTextSelectionNavigationWritingDirection fromValue(int value) =>
      switch (value) {
        0 => NSTextSelectionNavigationWritingDirectionLeftToRight,
        1 => NSTextSelectionNavigationWritingDirectionRightToLeft,
        _ => throw ArgumentError(
          'Unknown value for NSTextSelectionNavigationWritingDirection: $value',
        ),
      };
}

enum NSTextSelectionNavigationLayoutOrientation {
  NSTextSelectionNavigationLayoutOrientationHorizontal(0),
  NSTextSelectionNavigationLayoutOrientationVertical(1);

  final int value;
  const NSTextSelectionNavigationLayoutOrientation(this.value);

  static NSTextSelectionNavigationLayoutOrientation fromValue(
    int value,
  ) => switch (value) {
    0 => NSTextSelectionNavigationLayoutOrientationHorizontal,
    1 => NSTextSelectionNavigationLayoutOrientationVertical,
    _ => throw ArgumentError(
      'Unknown value for NSTextSelectionNavigationLayoutOrientation: $value',
    ),
  };
}

sealed class NSTextContentManagerEnumerationOptions {
  static const NSTextContentManagerEnumerationOptionsNone = 0;
  static const NSTextContentManagerEnumerationOptionsReverse = 1;
}

sealed class NSTextLayoutFragmentEnumerationOptions {
  static const NSTextLayoutFragmentEnumerationOptionsNone = 0;
  static const NSTextLayoutFragmentEnumerationOptionsReverse = 1;
  static const NSTextLayoutFragmentEnumerationOptionsEstimatesSize = 2;
  static const NSTextLayoutFragmentEnumerationOptionsEnsuresLayout = 4;
  static const NSTextLayoutFragmentEnumerationOptionsEnsuresExtraLineFragment =
      8;
}

enum NSTextLayoutFragmentState {
  NSTextLayoutFragmentStateNone(0),
  NSTextLayoutFragmentStateEstimatedUsageBounds(1),
  NSTextLayoutFragmentStateCalculatedUsageBounds(2),
  NSTextLayoutFragmentStateLayoutAvailable(3);

  final int value;
  const NSTextLayoutFragmentState(this.value);

  static NSTextLayoutFragmentState fromValue(int value) => switch (value) {
    0 => NSTextLayoutFragmentStateNone,
    1 => NSTextLayoutFragmentStateEstimatedUsageBounds,
    2 => NSTextLayoutFragmentStateCalculatedUsageBounds,
    3 => NSTextLayoutFragmentStateLayoutAvailable,
    _ => throw ArgumentError(
      'Unknown value for NSTextLayoutFragmentState: $value',
    ),
  };
}

enum NSTextLayoutManagerSegmentType {
  NSTextLayoutManagerSegmentTypeStandard(0),
  NSTextLayoutManagerSegmentTypeSelection(1),
  NSTextLayoutManagerSegmentTypeHighlight(2);

  final int value;
  const NSTextLayoutManagerSegmentType(this.value);

  static NSTextLayoutManagerSegmentType fromValue(int value) => switch (value) {
    0 => NSTextLayoutManagerSegmentTypeStandard,
    1 => NSTextLayoutManagerSegmentTypeSelection,
    2 => NSTextLayoutManagerSegmentTypeHighlight,
    _ => throw ArgumentError(
      'Unknown value for NSTextLayoutManagerSegmentType: $value',
    ),
  };
}

sealed class NSTextLayoutManagerSegmentOptions {
  static const NSTextLayoutManagerSegmentOptionsNone = 0;
  static const NSTextLayoutManagerSegmentOptionsRangeNotRequired = 1;
  static const NSTextLayoutManagerSegmentOptionsMiddleFragmentsExcluded = 2;
  static const NSTextLayoutManagerSegmentOptionsHeadSegmentExtended = 4;
  static const NSTextLayoutManagerSegmentOptionsTailSegmentExtended = 8;
  static const NSTextLayoutManagerSegmentOptionsUpstreamAffinity = 16;
}

sealed class UIActivitySectionTypes {
  static const UIActivitySectionTypesNone = 0;
  static const UIActivitySectionTypesPeopleSuggestions = 1;
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>`.
abstract final class ObjCBlock_ffiVoid_UIActivityType_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Bool arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>
  fromFunction(
    void Function(objc.NSString?, bool) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0, bool arg1) => fn(
        arg0.address == 0
            ? null
            : objc.NSString.fromPointer(arg0, retain: true, release: true),
        arg1,
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)> listener(
    void Function(objc.NSString?, bool) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0, bool arg1) => fn(
        arg0.address == 0
            ? null
            : objc.NSString.fromPointer(arg0, retain: false, release: true),
        arg1,
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_6p7ndb(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)> blocking(
    void Function(objc.NSString?, bool) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0, bool arg1) => fn(
        arg0.address == 0
            ? null
            : objc.NSString.fromPointer(arg0, retain: false, release: true),
        arg1,
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0, bool arg1) => fn(
        arg0.address == 0
            ? null
            : objc.NSString.fromPointer(arg0, retain: false, release: true),
        arg1,
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_6p7ndb(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    bool arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>, bool))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Bool,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Bool,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    bool arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>, bool))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Bool,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Bool,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Bool,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Bool,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    bool arg1,
  ) =>
      block.ref.target
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCObjectImpl> arg0,
                ffi.Bool arg1,
              )
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>, bool)>()(
        arg0,
        arg1,
      );
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Bool,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    bool arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>, bool))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Bool,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)>`.
extension ObjCBlock_ffiVoid_UIActivityType_bool$CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool)> {
  void call(objc.NSString? arg0, bool arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Bool arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          bool,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          objc.NSString?,
          ffi.Bool,
          objc.NSArray?,
          objc.NSError?,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Bool arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          objc.NSString?,
          ffi.Bool,
          objc.NSArray?,
          objc.NSError?,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)
  >
  fromFunction(
    void Function(objc.NSString?, bool, objc.NSArray?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          objc.NSString?,
          ffi.Bool,
          objc.NSArray?,
          objc.NSError?,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            bool arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ) => fn(
            arg0.address == 0
                ? null
                : objc.NSString.fromPointer(arg0, retain: true, release: true),
            arg1,
            arg2.address == 0
                ? null
                : objc.NSArray.fromPointer(arg2, retain: true, release: true),
            arg3.address == 0
                ? null
                : objc.NSError.fromPointer(arg3, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)
  >
  listener(
    void Function(objc.NSString?, bool, objc.NSArray?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        bool arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0.address == 0
            ? null
            : objc.NSString.fromPointer(arg0, retain: false, release: true),
        arg1,
        arg2.address == 0
            ? null
            : objc.NSArray.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_13x5jor(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)
  >
  blocking(
    void Function(objc.NSString?, bool, objc.NSArray?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        bool arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0.address == 0
            ? null
            : objc.NSString.fromPointer(arg0, retain: false, release: true),
        arg1,
        arg2.address == 0
            ? null
            : objc.NSArray.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        bool arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0.address == 0
            ? null
            : objc.NSString.fromPointer(arg0, retain: false, release: true),
        arg1,
        arg2.address == 0
            ? null
            : objc.NSArray.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_13x5jor(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    bool arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          bool,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Bool,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Bool,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    bool arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            bool,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Bool,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Bool,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Bool,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Bool,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    bool arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Bool arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          bool,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Bool,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    bool arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            bool,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Bool,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSString?, ffi.Bool, objc.NSArray?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_UIActivityType_bool_NSArray_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            objc.NSString?,
            ffi.Bool,
            objc.NSArray?,
            objc.NSError?,
          )
        > {
  void call(
    objc.NSString? arg0,
    bool arg1,
    objc.NSArray? arg2,
    objc.NSError? arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObjectImpl> arg0,
                ffi.Bool arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              bool,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0?.ref.pointer ?? ffi.nullptr,
        arg1,
        arg2?.ref.pointer ?? ffi.nullptr,
        arg3?.ref.pointer ?? ffi.nullptr,
      );
}

/// WARNING: UIPrintFormatter$1 is a stub. To generate bindings for this class, include
/// UIPrintFormatter in your config's objc-interfaces list.
///
/// UIPrintFormatter
extension type UIPrintFormatter$1._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [UIPrintFormatter$1] that points to the same underlying object as [other].
  UIPrintFormatter$1.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('UIPrintFormatter', iOS: (false, (4, 2, 0)));
  }

  /// Constructs a [UIPrintFormatter$1] that wraps the given raw object pointer.
  UIPrintFormatter$1.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIPrintFormatter', iOS: (false, (4, 2, 0)));
  }
}

enum UIPrintRenderingQuality {
  UIPrintRenderingQualityBest(0),
  UIPrintRenderingQualityResponsive(1);

  final int value;
  const UIPrintRenderingQuality(this.value);

  static UIPrintRenderingQuality fromValue(int value) => switch (value) {
    0 => UIPrintRenderingQualityBest,
    1 => UIPrintRenderingQualityResponsive,
    _ => throw ArgumentError(
      'Unknown value for UIPrintRenderingQuality: $value',
    ),
  };
}

/// WARNING: WKBackForwardListItem is a stub. To generate bindings for this class, include
/// WKBackForwardListItem in your config's objc-interfaces list.
///
/// WKBackForwardListItem
extension type WKBackForwardListItem._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [WKBackForwardListItem] that points to the same underlying object as [other].
  WKBackForwardListItem.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKBackForwardListItem',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }

  /// Constructs a [WKBackForwardListItem] that wraps the given raw object pointer.
  WKBackForwardListItem.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKBackForwardListItem',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }
}

/// WARNING: WKBackForwardList is a stub. To generate bindings for this class, include
/// WKBackForwardList in your config's objc-interfaces list.
///
/// WKBackForwardList
extension type WKBackForwardList._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [WKBackForwardList] that points to the same underlying object as [other].
  WKBackForwardList.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKBackForwardList',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }

  /// Constructs a [WKBackForwardList] that wraps the given raw object pointer.
  WKBackForwardList.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKBackForwardList',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }
}

/// WARNING: WKContentWorld is a stub. To generate bindings for this class, include
/// WKContentWorld in your config's objc-interfaces list.
///
/// WKContentWorld
extension type WKContentWorld._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [WKContentWorld] that points to the same underlying object as [other].
  WKContentWorld.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKContentWorld',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
  }

  /// Constructs a [WKContentWorld] that wraps the given raw object pointer.
  WKContentWorld.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKContentWorld',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
  }
}

/// WARNING: WKDownload is a stub. To generate bindings for this class, include
/// WKDownload in your config's objc-interfaces list.
///
/// WKDownload
extension type WKDownload._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, NSProgressReporting {
  /// Constructs a [WKDownload] that points to the same underlying object as [other].
  WKDownload.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKDownload',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
  }

  /// Constructs a [WKDownload] that wraps the given raw object pointer.
  WKDownload.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKDownload',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
  }
}

enum WKDownloadRedirectPolicy {
  WKDownloadRedirectPolicyCancel(0),
  WKDownloadRedirectPolicyAllow(1);

  final int value;
  const WKDownloadRedirectPolicy(this.value);

  static WKDownloadRedirectPolicy fromValue(int value) => switch (value) {
    0 => WKDownloadRedirectPolicyCancel,
    1 => WKDownloadRedirectPolicyAllow,
    _ => throw ArgumentError(
      'Unknown value for WKDownloadRedirectPolicy: $value',
    ),
  };
}

enum WKDownloadPlaceholderPolicy {
  WKDownloadPlaceholderPolicyDisable(0),
  WKDownloadPlaceholderPolicyEnable(1);

  final int value;
  const WKDownloadPlaceholderPolicy(this.value);

  static WKDownloadPlaceholderPolicy fromValue(int value) => switch (value) {
    0 => WKDownloadPlaceholderPolicyDisable,
    1 => WKDownloadPlaceholderPolicyEnable,
    _ => throw ArgumentError(
      'Unknown value for WKDownloadPlaceholderPolicy: $value',
    ),
  };
}

/// WARNING: WKFindConfiguration is a stub. To generate bindings for this class, include
/// WKFindConfiguration in your config's objc-interfaces list.
///
/// WKFindConfiguration
extension type WKFindConfiguration._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [WKFindConfiguration] that points to the same underlying object as [other].
  WKFindConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKFindConfiguration',
      iOS: (false, (13, 4, 0)),
      macOS: (false, (10, 15, 4)),
    );
  }

  /// Constructs a [WKFindConfiguration] that wraps the given raw object pointer.
  WKFindConfiguration.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKFindConfiguration',
      iOS: (false, (13, 4, 0)),
      macOS: (false, (10, 15, 4)),
    );
  }
}

/// WARNING: WKFindResult is a stub. To generate bindings for this class, include
/// WKFindResult in your config's objc-interfaces list.
///
/// WKFindResult
extension type WKFindResult._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [WKFindResult] that points to the same underlying object as [other].
  WKFindResult.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKFindResult',
      iOS: (false, (13, 4, 0)),
      macOS: (false, (10, 15, 4)),
    );
  }

  /// Constructs a [WKFindResult] that wraps the given raw object pointer.
  WKFindResult.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKFindResult',
      iOS: (false, (13, 4, 0)),
      macOS: (false, (10, 15, 4)),
    );
  }
}

late final _class_WKWebView = objc.getClass("WKWebView");
late final _class_WKWebViewConfiguration = objc.getClass(
  "WKWebViewConfiguration",
);

/// WARNING: WKProcessPool is a stub. To generate bindings for this class, include
/// WKProcessPool in your config's objc-interfaces list.
///
/// WKProcessPool
extension type WKProcessPool._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSSecureCoding {
  /// Constructs a [WKProcessPool] that points to the same underlying object as [other].
  WKProcessPool.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKProcessPool',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }

  /// Constructs a [WKProcessPool] that wraps the given raw object pointer.
  WKProcessPool.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKProcessPool',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }
}

late final _sel_processPool = objc.registerName("processPool");
late final _sel_setProcessPool_ = objc.registerName("setProcessPool:");

/// WARNING: WKPreferences is a stub. To generate bindings for this class, include
/// WKPreferences in your config's objc-interfaces list.
///
/// WKPreferences
extension type WKPreferences._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSSecureCoding {
  /// Constructs a [WKPreferences] that points to the same underlying object as [other].
  WKPreferences.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKPreferences',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }

  /// Constructs a [WKPreferences] that wraps the given raw object pointer.
  WKPreferences.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKPreferences',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }
}

late final _sel_preferences = objc.registerName("preferences");
late final _sel_setPreferences_ = objc.registerName("setPreferences:");

/// WARNING: WKUserContentController is a stub. To generate bindings for this class, include
/// WKUserContentController in your config's objc-interfaces list.
///
/// WKUserContentController
extension type WKUserContentController._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSSecureCoding {
  /// Constructs a [WKUserContentController] that points to the same underlying object as [other].
  WKUserContentController.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKUserContentController',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }

  /// Constructs a [WKUserContentController] that wraps the given raw object pointer.
  WKUserContentController.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKUserContentController',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }
}

late final _sel_userContentController = objc.registerName(
  "userContentController",
);
late final _sel_setUserContentController_ = objc.registerName(
  "setUserContentController:",
);

/// WARNING: WKWebExtensionController is a stub. To generate bindings for this class, include
/// WKWebExtensionController in your config's objc-interfaces list.
///
/// WKWebExtensionController
extension type WKWebExtensionController._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [WKWebExtensionController] that points to the same underlying object as [other].
  WKWebExtensionController.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKWebExtensionController',
      iOS: (false, (18, 4, 0)),
      macOS: (false, (15, 4, 0)),
    );
  }

  /// Constructs a [WKWebExtensionController] that wraps the given raw object pointer.
  WKWebExtensionController.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKWebExtensionController',
      iOS: (false, (18, 4, 0)),
      macOS: (false, (15, 4, 0)),
    );
  }
}

late final _sel_webExtensionController = objc.registerName(
  "webExtensionController",
);
late final _sel_setWebExtensionController_ = objc.registerName(
  "setWebExtensionController:",
);

/// WARNING: WKWebsiteDataStore is a stub. To generate bindings for this class, include
/// WKWebsiteDataStore in your config's objc-interfaces list.
///
/// WKWebsiteDataStore
extension type WKWebsiteDataStore._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSSecureCoding {
  /// Constructs a [WKWebsiteDataStore] that points to the same underlying object as [other].
  WKWebsiteDataStore.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKWebsiteDataStore',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }

  /// Constructs a [WKWebsiteDataStore] that wraps the given raw object pointer.
  WKWebsiteDataStore.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKWebsiteDataStore',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }
}

late final _sel_websiteDataStore = objc.registerName("websiteDataStore");
late final _sel_setWebsiteDataStore_ = objc.registerName(
  "setWebsiteDataStore:",
);
late final _sel_suppressesIncrementalRendering = objc.registerName(
  "suppressesIncrementalRendering",
);
late final _sel_setSuppressesIncrementalRendering_ = objc.registerName(
  "setSuppressesIncrementalRendering:",
);
late final _sel_applicationNameForUserAgent = objc.registerName(
  "applicationNameForUserAgent",
);
late final _sel_setApplicationNameForUserAgent_ = objc.registerName(
  "setApplicationNameForUserAgent:",
);
late final _sel_allowsAirPlayForMediaPlayback = objc.registerName(
  "allowsAirPlayForMediaPlayback",
);
late final _sel_setAllowsAirPlayForMediaPlayback_ = objc.registerName(
  "setAllowsAirPlayForMediaPlayback:",
);
late final _sel_showsSystemScreenTimeBlockingView = objc.registerName(
  "showsSystemScreenTimeBlockingView",
);
late final _sel_setShowsSystemScreenTimeBlockingView_ = objc.registerName(
  "setShowsSystemScreenTimeBlockingView:",
);
late final _sel_upgradeKnownHostsToHTTPS = objc.registerName(
  "upgradeKnownHostsToHTTPS",
);
late final _sel_setUpgradeKnownHostsToHTTPS_ = objc.registerName(
  "setUpgradeKnownHostsToHTTPS:",
);

sealed class WKAudiovisualMediaTypes {
  static const WKAudiovisualMediaTypeNone = 0;
  static const WKAudiovisualMediaTypeAudio = 1;
  static const WKAudiovisualMediaTypeVideo = 2;
  static const WKAudiovisualMediaTypeAll = -1;
}

late final _sel_mediaTypesRequiringUserActionForPlayback = objc.registerName(
  "mediaTypesRequiringUserActionForPlayback",
);
final _objc_msgSend_qtd8pu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setMediaTypesRequiringUserActionForPlayback_ = objc
    .registerName("setMediaTypesRequiringUserActionForPlayback:");
final _objc_msgSend_jrlv5k = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// WARNING: WKWebpagePreferences is a stub. To generate bindings for this class, include
/// WKWebpagePreferences in your config's objc-interfaces list.
///
/// WKWebpagePreferences
extension type WKWebpagePreferences._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [WKWebpagePreferences] that points to the same underlying object as [other].
  WKWebpagePreferences.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKWebpagePreferences',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
  }

  /// Constructs a [WKWebpagePreferences] that wraps the given raw object pointer.
  WKWebpagePreferences.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKWebpagePreferences',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
  }
}

late final _sel_defaultWebpagePreferences = objc.registerName(
  "defaultWebpagePreferences",
);
late final _sel_setDefaultWebpagePreferences_ = objc.registerName(
  "setDefaultWebpagePreferences:",
);
late final _sel_limitsNavigationsToAppBoundDomains = objc.registerName(
  "limitsNavigationsToAppBoundDomains",
);
late final _sel_setLimitsNavigationsToAppBoundDomains_ = objc.registerName(
  "setLimitsNavigationsToAppBoundDomains:",
);
late final _sel_allowsInlinePredictions = objc.registerName(
  "allowsInlinePredictions",
);
late final _sel_setAllowsInlinePredictions_ = objc.registerName(
  "setAllowsInlinePredictions:",
);
late final _sel_allowsInlineMediaPlayback = objc.registerName(
  "allowsInlineMediaPlayback",
);
late final _sel_setAllowsInlineMediaPlayback_ = objc.registerName(
  "setAllowsInlineMediaPlayback:",
);

enum WKSelectionGranularity {
  WKSelectionGranularityDynamic(0),
  WKSelectionGranularityCharacter(1);

  final int value;
  const WKSelectionGranularity(this.value);

  static WKSelectionGranularity fromValue(int value) => switch (value) {
    0 => WKSelectionGranularityDynamic,
    1 => WKSelectionGranularityCharacter,
    _ => throw ArgumentError(
      'Unknown value for WKSelectionGranularity: $value',
    ),
  };
}

late final _sel_selectionGranularity = objc.registerName(
  "selectionGranularity",
);
final _objc_msgSend_x6nksd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setSelectionGranularity_ = objc.registerName(
  "setSelectionGranularity:",
);
final _objc_msgSend_1f87ntx = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_allowsPictureInPictureMediaPlayback = objc.registerName(
  "allowsPictureInPictureMediaPlayback",
);
late final _sel_setAllowsPictureInPictureMediaPlayback_ = objc.registerName(
  "setAllowsPictureInPictureMediaPlayback:",
);

sealed class WKDataDetectorTypes {
  static const WKDataDetectorTypeNone = 0;
  static const WKDataDetectorTypePhoneNumber = 1;
  static const WKDataDetectorTypeLink = 2;
  static const WKDataDetectorTypeAddress = 4;
  static const WKDataDetectorTypeCalendarEvent = 8;
  static const WKDataDetectorTypeTrackingNumber = 16;
  static const WKDataDetectorTypeFlightNumber = 32;
  static const WKDataDetectorTypeLookupSuggestion = 64;
  static const WKDataDetectorTypeAll = -1;
  static const WKDataDetectorTypeSpotlightSuggestion = 64;
}

late final _sel_dataDetectorTypes = objc.registerName("dataDetectorTypes");
final _objc_msgSend_1vipcae = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setDataDetectorTypes_ = objc.registerName(
  "setDataDetectorTypes:",
);
final _objc_msgSend_1b3p3z8 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_ignoresViewportScaleLimits = objc.registerName(
  "ignoresViewportScaleLimits",
);
late final _sel_setIgnoresViewportScaleLimits_ = objc.registerName(
  "setIgnoresViewportScaleLimits:",
);

/// WARNING: WKURLSchemeHandler is a stub. To generate bindings for this class, include
/// WKURLSchemeHandler in your config's objc-protocols list.
///
/// WKURLSchemeHandler
extension type WKURLSchemeHandler._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [WKURLSchemeHandler] that points to the same underlying object as [other].
  WKURLSchemeHandler.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [WKURLSchemeHandler] that wraps the given raw object pointer.
  WKURLSchemeHandler.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_setURLSchemeHandler_forURLScheme_ = objc.registerName(
  "setURLSchemeHandler:forURLScheme:",
);
late final _sel_urlSchemeHandlerForURLScheme_ = objc.registerName(
  "urlSchemeHandlerForURLScheme:",
);
late final _sel_supportsAdaptiveImageGlyph = objc.registerName(
  "supportsAdaptiveImageGlyph",
);
late final _sel_setSupportsAdaptiveImageGlyph_ = objc.registerName(
  "setSupportsAdaptiveImageGlyph:",
);
late final _sel_writingToolsBehavior = objc.registerName(
  "writingToolsBehavior",
);
final _objc_msgSend_oh4nku = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setWritingToolsBehavior_ = objc.registerName(
  "setWritingToolsBehavior:",
);
final _objc_msgSend_1kfsipg = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_mediaPlaybackRequiresUserAction = objc.registerName(
  "mediaPlaybackRequiresUserAction",
);
late final _sel_setMediaPlaybackRequiresUserAction_ = objc.registerName(
  "setMediaPlaybackRequiresUserAction:",
);
late final _sel_mediaPlaybackAllowsAirPlay = objc.registerName(
  "mediaPlaybackAllowsAirPlay",
);
late final _sel_setMediaPlaybackAllowsAirPlay_ = objc.registerName(
  "setMediaPlaybackAllowsAirPlay:",
);
late final _sel_requiresUserActionForMediaPlayback = objc.registerName(
  "requiresUserActionForMediaPlayback",
);
late final _sel_setRequiresUserActionForMediaPlayback_ = objc.registerName(
  "setRequiresUserActionForMediaPlayback:",
);

/// WKDeprecated
extension WKDeprecated on WKWebViewConfiguration {
  /// mediaPlaybackAllowsAirPlay
  bool get mediaPlaybackAllowsAirPlay {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.mediaPlaybackAllowsAirPlay',
      iOS: (false, (8, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_mediaPlaybackAllowsAirPlay,
    );
  }

  /// mediaPlaybackRequiresUserAction
  bool get mediaPlaybackRequiresUserAction {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.mediaPlaybackRequiresUserAction',
      iOS: (false, (8, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_mediaPlaybackRequiresUserAction,
    );
  }

  /// requiresUserActionForMediaPlayback
  bool get requiresUserActionForMediaPlayback {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.requiresUserActionForMediaPlayback',
      iOS: (false, (9, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_requiresUserActionForMediaPlayback,
    );
  }

  /// setMediaPlaybackAllowsAirPlay:
  set mediaPlaybackAllowsAirPlay(bool value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setMediaPlaybackAllowsAirPlay:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setMediaPlaybackAllowsAirPlay_,
      value,
    );
  }

  /// setMediaPlaybackRequiresUserAction:
  set mediaPlaybackRequiresUserAction(bool value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setMediaPlaybackRequiresUserAction:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setMediaPlaybackRequiresUserAction_,
      value,
    );
  }

  /// setRequiresUserActionForMediaPlayback:
  set requiresUserActionForMediaPlayback(bool value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setRequiresUserActionForMediaPlayback:',
      iOS: (false, (9, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setRequiresUserActionForMediaPlayback_,
      value,
    );
  }
}

/// WKWebViewConfiguration
extension type WKWebViewConfiguration._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSSecureCoding,
        objc.NSCopying {
  /// Constructs a [WKWebViewConfiguration] that points to the same underlying object as [other].
  WKWebViewConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [WKWebViewConfiguration] that wraps the given raw object pointer.
  WKWebViewConfiguration.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [WKWebViewConfiguration].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_WKWebViewConfiguration,
  );

  /// alloc
  static WKWebViewConfiguration alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_WKWebViewConfiguration,
      _sel_alloc,
    );
    return WKWebViewConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static WKWebViewConfiguration allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_WKWebViewConfiguration,
      _sel_allocWithZone_,
      zone,
    );
    return WKWebViewConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static WKWebViewConfiguration new$() {
    final $ret = _objc_msgSend_151sglz(_class_WKWebViewConfiguration, _sel_new);
    return WKWebViewConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
      _class_WKWebViewConfiguration,
      _sel_supportsSecureCoding,
    );
  }

  /// Returns a new instance of WKWebViewConfiguration constructed with the default `new` method.
  WKWebViewConfiguration() : this.as(new$().object$);
}

extension WKWebViewConfiguration$Methods on WKWebViewConfiguration {
  /// allowsAirPlayForMediaPlayback
  bool get allowsAirPlayForMediaPlayback {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.allowsAirPlayForMediaPlayback',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowsAirPlayForMediaPlayback,
    );
  }

  /// allowsInlineMediaPlayback
  bool get allowsInlineMediaPlayback {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.allowsInlineMediaPlayback',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowsInlineMediaPlayback,
    );
  }

  /// allowsInlinePredictions
  bool get allowsInlinePredictions {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.allowsInlinePredictions',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowsInlinePredictions,
    );
  }

  /// allowsPictureInPictureMediaPlayback
  bool get allowsPictureInPictureMediaPlayback {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.allowsPictureInPictureMediaPlayback',
      iOS: (false, (9, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowsPictureInPictureMediaPlayback,
    );
  }

  /// applicationNameForUserAgent
  objc.NSString? get applicationNameForUserAgent {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.applicationNameForUserAgent',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_applicationNameForUserAgent,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// dataDetectorTypes
  int get dataDetectorTypes {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.dataDetectorTypes',
      iOS: (false, (10, 0, 0)),
    );
    return _objc_msgSend_1vipcae(object$.ref.pointer, _sel_dataDetectorTypes);
  }

  /// defaultWebpagePreferences
  WKWebpagePreferences get defaultWebpagePreferences {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.defaultWebpagePreferences',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_defaultWebpagePreferences,
    );
    return WKWebpagePreferences.fromPointer($ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// ignoresViewportScaleLimits
  bool get ignoresViewportScaleLimits {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.ignoresViewportScaleLimits',
      iOS: (false, (10, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_ignoresViewportScaleLimits,
    );
  }

  /// init
  WKWebViewConfiguration init() {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return WKWebViewConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// initWithCoder:
  WKWebViewConfiguration? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : WKWebViewConfiguration.fromPointer(
            $ret,
            retain: false,
            release: true,
          );
  }

  /// limitsNavigationsToAppBoundDomains
  bool get limitsNavigationsToAppBoundDomains {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.limitsNavigationsToAppBoundDomains',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_limitsNavigationsToAppBoundDomains,
    );
  }

  /// mediaTypesRequiringUserActionForPlayback
  int get mediaTypesRequiringUserActionForPlayback {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.mediaTypesRequiringUserActionForPlayback',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
    return _objc_msgSend_qtd8pu(
      object$.ref.pointer,
      _sel_mediaTypesRequiringUserActionForPlayback,
    );
  }

  /// preferences
  WKPreferences get preferences {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.preferences',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_preferences);
    return WKPreferences.fromPointer($ret, retain: true, release: true);
  }

  /// processPool
  WKProcessPool get processPool {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.processPool',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_processPool);
    return WKProcessPool.fromPointer($ret, retain: true, release: true);
  }

  /// selectionGranularity
  WKSelectionGranularity get selectionGranularity {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.selectionGranularity',
      iOS: (false, (8, 0, 0)),
    );
    final $ret = _objc_msgSend_x6nksd(
      object$.ref.pointer,
      _sel_selectionGranularity,
    );
    return WKSelectionGranularity.fromValue($ret);
  }

  /// setAllowsAirPlayForMediaPlayback:
  set allowsAirPlayForMediaPlayback(bool value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setAllowsAirPlayForMediaPlayback:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAllowsAirPlayForMediaPlayback_,
      value,
    );
  }

  /// setAllowsInlineMediaPlayback:
  set allowsInlineMediaPlayback(bool value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setAllowsInlineMediaPlayback:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAllowsInlineMediaPlayback_,
      value,
    );
  }

  /// setAllowsInlinePredictions:
  set allowsInlinePredictions(bool value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setAllowsInlinePredictions:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAllowsInlinePredictions_,
      value,
    );
  }

  /// setAllowsPictureInPictureMediaPlayback:
  set allowsPictureInPictureMediaPlayback(bool value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setAllowsPictureInPictureMediaPlayback:',
      iOS: (false, (9, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAllowsPictureInPictureMediaPlayback_,
      value,
    );
  }

  /// setApplicationNameForUserAgent:
  set applicationNameForUserAgent(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setApplicationNameForUserAgent:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setApplicationNameForUserAgent_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setDataDetectorTypes:
  set dataDetectorTypes(int value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setDataDetectorTypes:',
      iOS: (false, (10, 0, 0)),
    );
    _objc_msgSend_1b3p3z8(
      object$.ref.pointer,
      _sel_setDataDetectorTypes_,
      value,
    );
  }

  /// setDefaultWebpagePreferences:
  set defaultWebpagePreferences(WKWebpagePreferences value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setDefaultWebpagePreferences:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setDefaultWebpagePreferences_,
      value.ref.pointer,
    );
  }

  /// setIgnoresViewportScaleLimits:
  set ignoresViewportScaleLimits(bool value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setIgnoresViewportScaleLimits:',
      iOS: (false, (10, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setIgnoresViewportScaleLimits_,
      value,
    );
  }

  /// setLimitsNavigationsToAppBoundDomains:
  set limitsNavigationsToAppBoundDomains(bool value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setLimitsNavigationsToAppBoundDomains:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setLimitsNavigationsToAppBoundDomains_,
      value,
    );
  }

  /// setMediaTypesRequiringUserActionForPlayback:
  set mediaTypesRequiringUserActionForPlayback(int value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setMediaTypesRequiringUserActionForPlayback:',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
    _objc_msgSend_jrlv5k(
      object$.ref.pointer,
      _sel_setMediaTypesRequiringUserActionForPlayback_,
      value,
    );
  }

  /// setPreferences:
  set preferences(WKPreferences value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setPreferences:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setPreferences_,
      value.ref.pointer,
    );
  }

  /// setProcessPool:
  set processPool(WKProcessPool value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setProcessPool:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setProcessPool_,
      value.ref.pointer,
    );
  }

  /// setSelectionGranularity:
  set selectionGranularity(WKSelectionGranularity value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setSelectionGranularity:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_1f87ntx(
      object$.ref.pointer,
      _sel_setSelectionGranularity_,
      value.value,
    );
  }

  /// setShowsSystemScreenTimeBlockingView:
  set showsSystemScreenTimeBlockingView(bool value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setShowsSystemScreenTimeBlockingView:',
      iOS: (false, (26, 0, 0)),
      macOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setShowsSystemScreenTimeBlockingView_,
      value,
    );
  }

  /// setSupportsAdaptiveImageGlyph:
  set supportsAdaptiveImageGlyph(bool value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setSupportsAdaptiveImageGlyph:',
      iOS: (false, (18, 0, 0)),
      macOS: (false, (15, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setSupportsAdaptiveImageGlyph_,
      value,
    );
  }

  /// setSuppressesIncrementalRendering:
  set suppressesIncrementalRendering(bool value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setSuppressesIncrementalRendering:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setSuppressesIncrementalRendering_,
      value,
    );
  }

  /// setURLSchemeHandler:forURLScheme:
  void setURLSchemeHandler(
    WKURLSchemeHandler? urlSchemeHandler, {
    required objc.NSString forURLScheme,
  }) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setURLSchemeHandler:forURLScheme:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_setURLSchemeHandler_forURLScheme_,
      urlSchemeHandler?.ref.pointer ?? ffi.nullptr,
      forURLScheme.ref.pointer,
    );
  }

  /// setUpgradeKnownHostsToHTTPS:
  set upgradeKnownHostsToHTTPS(bool value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setUpgradeKnownHostsToHTTPS:',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setUpgradeKnownHostsToHTTPS_,
      value,
    );
  }

  /// setUserContentController:
  set userContentController(WKUserContentController value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setUserContentController:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setUserContentController_,
      value.ref.pointer,
    );
  }

  /// setWebExtensionController:
  set webExtensionController(WKWebExtensionController? value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setWebExtensionController:',
      iOS: (false, (18, 4, 0)),
      macOS: (false, (15, 4, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setWebExtensionController_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setWebsiteDataStore:
  set websiteDataStore(WKWebsiteDataStore value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setWebsiteDataStore:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setWebsiteDataStore_,
      value.ref.pointer,
    );
  }

  /// setWritingToolsBehavior:
  set writingToolsBehavior(UIWritingToolsBehavior value) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.setWritingToolsBehavior:',
      iOS: (false, (18, 0, 0)),
    );
    _objc_msgSend_1kfsipg(
      object$.ref.pointer,
      _sel_setWritingToolsBehavior_,
      value.value,
    );
  }

  /// showsSystemScreenTimeBlockingView
  bool get showsSystemScreenTimeBlockingView {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.showsSystemScreenTimeBlockingView',
      iOS: (false, (26, 0, 0)),
      macOS: (false, (26, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_showsSystemScreenTimeBlockingView,
    );
  }

  /// supportsAdaptiveImageGlyph
  bool get supportsAdaptiveImageGlyph {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.supportsAdaptiveImageGlyph',
      iOS: (false, (18, 0, 0)),
      macOS: (false, (15, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_supportsAdaptiveImageGlyph,
    );
  }

  /// suppressesIncrementalRendering
  bool get suppressesIncrementalRendering {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.suppressesIncrementalRendering',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_suppressesIncrementalRendering,
    );
  }

  /// upgradeKnownHostsToHTTPS
  bool get upgradeKnownHostsToHTTPS {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.upgradeKnownHostsToHTTPS',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_upgradeKnownHostsToHTTPS,
    );
  }

  /// urlSchemeHandlerForURLScheme:
  WKURLSchemeHandler? urlSchemeHandlerForURLScheme(objc.NSString urlScheme) {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.urlSchemeHandlerForURLScheme:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_urlSchemeHandlerForURLScheme_,
      urlScheme.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : WKURLSchemeHandler.fromPointer($ret, retain: true, release: true);
  }

  /// userContentController
  WKUserContentController get userContentController {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.userContentController',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_userContentController,
    );
    return WKUserContentController.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// webExtensionController
  WKWebExtensionController? get webExtensionController {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.webExtensionController',
      iOS: (false, (18, 4, 0)),
      macOS: (false, (15, 4, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_webExtensionController,
    );
    return $ret.address == 0
        ? null
        : WKWebExtensionController.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// websiteDataStore
  WKWebsiteDataStore get websiteDataStore {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.websiteDataStore',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_websiteDataStore,
    );
    return WKWebsiteDataStore.fromPointer($ret, retain: true, release: true);
  }

  /// writingToolsBehavior
  UIWritingToolsBehavior get writingToolsBehavior {
    objc.checkOsVersionInternal(
      'WKWebViewConfiguration.writingToolsBehavior',
      iOS: (false, (18, 0, 0)),
    );
    final $ret = _objc_msgSend_oh4nku(
      object$.ref.pointer,
      _sel_writingToolsBehavior,
    );
    return UIWritingToolsBehavior.fromValue($ret);
  }
}

late final _sel_configuration = objc.registerName("configuration");
late final _protocol_WKNavigationDelegate = objc.getProtocol(
  "WKNavigationDelegate",
);
late final _sel_conformsToProtocol_ = objc.registerName("conformsToProtocol:");
final _objc_msgSend_e3qsqz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCProtocolImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCProtocolImpl>,
      )
    >();

/// WARNING: WKNavigationAction is a stub. To generate bindings for this class, include
/// WKNavigationAction in your config's objc-interfaces list.
///
/// WKNavigationAction
extension type WKNavigationAction._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [WKNavigationAction] that points to the same underlying object as [other].
  WKNavigationAction.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKNavigationAction',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }

  /// Constructs a [WKNavigationAction] that wraps the given raw object pointer.
  WKNavigationAction.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKNavigationAction',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }
}

enum WKNavigationActionPolicy {
  WKNavigationActionPolicyCancel(0),
  WKNavigationActionPolicyAllow(1),
  WKNavigationActionPolicyDownload(2);

  final int value;
  const WKNavigationActionPolicy(this.value);

  static WKNavigationActionPolicy fromValue(int value) => switch (value) {
    0 => WKNavigationActionPolicyCancel,
    1 => WKNavigationActionPolicyAllow,
    2 => WKNavigationActionPolicyDownload,
    _ => throw ArgumentError(
      'Unknown value for WKNavigationActionPolicy: $value',
    ),
  };
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Long)>`.
abstract final class ObjCBlock_ffiVoid_WKNavigationActionPolicy {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Long arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> fromFunction(
    void Function(WKNavigationActionPolicy) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
    objc.newClosureBlock(
      _closureCallable,
      (int arg0) => fn(WKNavigationActionPolicy.fromValue(arg0)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> listener(
    void Function(WKNavigationActionPolicy) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (int arg0) => fn(WKNavigationActionPolicy.fromValue(arg0)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_108000h(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> blocking(
    void Function(WKNavigationActionPolicy) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (int arg0) => fn(WKNavigationActionPolicy.fromValue(arg0)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (int arg0) => fn(WKNavigationActionPolicy.fromValue(arg0)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_108000h(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
  ) {
    (objc.getBlockClosure(block) as void Function(int))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    int arg0,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(int))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Long arg0)>>()
      .asFunction<void Function(int)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
  ) => (objc.getBlockClosure(block) as void Function(int))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Long)>`.
extension ObjCBlock_ffiVoid_WKNavigationActionPolicy$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Long)> {
  void call(WKNavigationActionPolicy arg0) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Long arg0,
              )
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, int)>()(
        ref.pointer,
        arg0.value,
      );
}

late final _sel_webView_decidePolicyForNavigationAction_decisionHandler_ = objc
    .registerName("webView:decidePolicyForNavigationAction:decisionHandler:");
final _objc_msgSend_18qun1e = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>`.
abstract final class ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Long arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
  fromFunction(
    void Function(NSURLSessionAuthChallengeDisposition, NSURLCredential?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>(
    objc.newClosureBlock(
      _closureCallable,
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        NSURLSessionAuthChallengeDisposition.fromValue(arg0),
        arg1.address == 0
            ? null
            : NSURLCredential.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)> listener(
    void Function(NSURLSessionAuthChallengeDisposition, NSURLCredential?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        NSURLSessionAuthChallengeDisposition.fromValue(arg0),
        arg1.address == 0
            ? null
            : NSURLCredential.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_n8yd09(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)> blocking(
    void Function(NSURLSessionAuthChallengeDisposition, NSURLCredential?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        NSURLSessionAuthChallengeDisposition.fromValue(arg0),
        arg1.address == 0
            ? null
            : NSURLCredential.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        NSURLSessionAuthChallengeDisposition.fromValue(arg0),
        arg1.address == 0
            ? null
            : NSURLCredential.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_n8yd09(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(int, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(int, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      block.ref.target
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Long arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<void Function(int, ffi.Pointer<objc.ObjCObjectImpl>)>()(
        arg0,
        arg1,
      );
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Long,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(int, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Long,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>`.
extension ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)> {
  void call(NSURLSessionAuthChallengeDisposition arg0, NSURLCredential? arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Long arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              int,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(ref.pointer, arg0.value, arg1?.ref.pointer ?? ffi.nullptr);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigationAction, objc.ObjCBlock<ffi.Void Function(ffi.Long)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_ffiVoidWKNavigationActionPolicy {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationAction,
          objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCBlockImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationAction,
          objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationAction,
          objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3,
          ) => fn(
            arg0,
            WKWebView.fromPointer(arg1, retain: true, release: true),
            WKNavigationAction.fromPointer(arg2, retain: true, release: true),
            ObjCBlock_ffiVoid_WKNavigationActionPolicy.fromPointer(
              arg3,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationAction.fromPointer(arg2, retain: false, release: true),
        ObjCBlock_ffiVoid_WKNavigationActionPolicy.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_bklti2(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigationAction,
        objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationAction.fromPointer(arg2, retain: false, release: true),
        ObjCBlock_ffiVoid_WKNavigationActionPolicy.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationAction.fromPointer(arg2, retain: false, release: true),
        ObjCBlock_ffiVoid_WKNavigationActionPolicy.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_bklti2(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigationAction,
        objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigationAction, objc.ObjCBlock<ffi.Void Function(ffi.Long)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_ffiVoidWKNavigationActionPolicy$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            WKWebView,
            WKNavigationAction,
            objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    WKWebView arg1,
    WKNavigationAction arg2,
    objc.ObjCBlock<ffi.Void Function(ffi.Long)> arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCBlockImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>`.
abstract final class ObjCBlock_ffiVoid_WKNavigationActionPolicy_WKWebpagePreferences {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Long arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>
  fromFunction(
    void Function(WKNavigationActionPolicy, WKWebpagePreferences) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>(
    objc.newClosureBlock(
      _closureCallable,
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        WKNavigationActionPolicy.fromValue(arg0),
        WKWebpagePreferences.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>
  listener(
    void Function(WKNavigationActionPolicy, WKWebpagePreferences) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        WKNavigationActionPolicy.fromValue(arg0),
        WKWebpagePreferences.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_d2nojr(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>
  blocking(
    void Function(WKNavigationActionPolicy, WKWebpagePreferences) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        WKNavigationActionPolicy.fromValue(arg0),
        WKWebpagePreferences.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        WKNavigationActionPolicy.fromValue(arg0),
        WKWebpagePreferences.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_d2nojr(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(int, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(int, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      block.ref.target
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Long arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<void Function(int, ffi.Pointer<objc.ObjCObjectImpl>)>()(
        arg0,
        arg1,
      );
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Long,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(int, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Long,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>`.
extension ObjCBlock_ffiVoid_WKNavigationActionPolicy_WKWebpagePreferences$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)> {
  void call(WKNavigationActionPolicy arg0, WKWebpagePreferences arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Long arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          int,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0.value, arg1.ref.pointer);
}

late final _sel_webView_decidePolicyForNavigationAction_preferences_decisionHandler_ =
    objc.registerName(
      "webView:decidePolicyForNavigationAction:preferences:decisionHandler:",
    );
final _objc_msgSend_m7tls4 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>`.
abstract final class ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Long arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>
  fromFunction(
    void Function(NSURLSessionDelayedRequestDisposition, NSURLRequest?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>(
    objc.newClosureBlock(
      _closureCallable,
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        NSURLSessionDelayedRequestDisposition.fromValue(arg0),
        arg1.address == 0
            ? null
            : NSURLRequest.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)> listener(
    void Function(NSURLSessionDelayedRequestDisposition, NSURLRequest?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        NSURLSessionDelayedRequestDisposition.fromValue(arg0),
        arg1.address == 0
            ? null
            : NSURLRequest.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1otpo83(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)> blocking(
    void Function(NSURLSessionDelayedRequestDisposition, NSURLRequest?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        NSURLSessionDelayedRequestDisposition.fromValue(arg0),
        arg1.address == 0
            ? null
            : NSURLRequest.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        NSURLSessionDelayedRequestDisposition.fromValue(arg0),
        arg1.address == 0
            ? null
            : NSURLRequest.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1otpo83(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(int, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(int, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      block.ref.target
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Long arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<void Function(int, ffi.Pointer<objc.ObjCObjectImpl>)>()(
        arg0,
        arg1,
      );
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Long,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(int, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Long,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>`.
extension ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)> {
  void call(NSURLSessionDelayedRequestDisposition arg0, NSURLRequest? arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Long arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              int,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(ref.pointer, arg0.value, arg1?.ref.pointer ?? ffi.nullptr);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigationAction, WKWebpagePreferences, objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_WKWebpagePreferences_ffiVoidWKNavigationActionPolicyWKWebpagePreferences {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationAction,
          WKWebpagePreferences,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ffi.Pointer<objc.ObjCBlockImpl> arg4,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationAction,
          WKWebpagePreferences,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationAction,
          WKWebpagePreferences,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4,
          ) => fn(
            arg0,
            WKWebView.fromPointer(arg1, retain: true, release: true),
            WKNavigationAction.fromPointer(arg2, retain: true, release: true),
            WKWebpagePreferences.fromPointer(arg3, retain: true, release: true),
            ObjCBlock_ffiVoid_WKNavigationActionPolicy_WKWebpagePreferences.fromPointer(
              arg4,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationAction.fromPointer(arg2, retain: false, release: true),
        WKWebpagePreferences.fromPointer(arg3, retain: false, release: true),
        ObjCBlock_ffiVoid_WKNavigationActionPolicy_WKWebpagePreferences.fromPointer(
          arg4,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_xx612k(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigationAction,
        WKWebpagePreferences,
        objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationAction.fromPointer(arg2, retain: false, release: true),
        WKWebpagePreferences.fromPointer(arg3, retain: false, release: true),
        ObjCBlock_ffiVoid_WKNavigationActionPolicy_WKWebpagePreferences.fromPointer(
          arg4,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationAction.fromPointer(arg2, retain: false, release: true),
        WKWebpagePreferences.fromPointer(arg3, retain: false, release: true),
        ObjCBlock_ffiVoid_WKNavigationActionPolicy_WKWebpagePreferences.fromPointer(
          arg4,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_xx612k(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigationAction,
        WKWebpagePreferences,
        objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1, arg2, arg3, arg4);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3, arg4);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigationAction, WKWebpagePreferences, objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_WKWebpagePreferences_ffiVoidWKNavigationActionPolicyWKWebpagePreferences$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            WKWebView,
            WKNavigationAction,
            WKWebpagePreferences,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    WKWebView arg1,
    WKNavigationAction arg2,
    WKWebpagePreferences arg3,
    objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)> arg4,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
        arg4.ref.pointer,
      );
}

/// WARNING: WKNavigationResponse is a stub. To generate bindings for this class, include
/// WKNavigationResponse in your config's objc-interfaces list.
///
/// WKNavigationResponse
extension type WKNavigationResponse._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [WKNavigationResponse] that points to the same underlying object as [other].
  WKNavigationResponse.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKNavigationResponse',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }

  /// Constructs a [WKNavigationResponse] that wraps the given raw object pointer.
  WKNavigationResponse.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKNavigationResponse',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }
}

enum WKNavigationResponsePolicy {
  WKNavigationResponsePolicyCancel(0),
  WKNavigationResponsePolicyAllow(1),
  WKNavigationResponsePolicyDownload(2);

  final int value;
  const WKNavigationResponsePolicy(this.value);

  static WKNavigationResponsePolicy fromValue(int value) => switch (value) {
    0 => WKNavigationResponsePolicyCancel,
    1 => WKNavigationResponsePolicyAllow,
    2 => WKNavigationResponsePolicyDownload,
    _ => throw ArgumentError(
      'Unknown value for WKNavigationResponsePolicy: $value',
    ),
  };
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Long)>`.
abstract final class ObjCBlock_ffiVoid_WKNavigationResponsePolicy {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Long arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> fromFunction(
    void Function(WKNavigationResponsePolicy) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
    objc.newClosureBlock(
      _closureCallable,
      (int arg0) => fn(WKNavigationResponsePolicy.fromValue(arg0)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> listener(
    void Function(WKNavigationResponsePolicy) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (int arg0) => fn(WKNavigationResponsePolicy.fromValue(arg0)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1a5qge(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> blocking(
    void Function(WKNavigationResponsePolicy) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (int arg0) => fn(WKNavigationResponsePolicy.fromValue(arg0)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (int arg0) => fn(WKNavigationResponsePolicy.fromValue(arg0)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1a5qge(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
  ) {
    (objc.getBlockClosure(block) as void Function(int))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    int arg0,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(int))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Long arg0)>>()
      .asFunction<void Function(int)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
  ) => (objc.getBlockClosure(block) as void Function(int))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Long)>`.
extension ObjCBlock_ffiVoid_WKNavigationResponsePolicy$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Long)> {
  void call(WKNavigationResponsePolicy arg0) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Long arg0,
              )
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, int)>()(
        ref.pointer,
        arg0.value,
      );
}

late final _sel_webView_decidePolicyForNavigationResponse_decisionHandler_ =
    objc.registerName(
      "webView:decidePolicyForNavigationResponse:decisionHandler:",
    );

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigationResponse, objc.ObjCBlock<ffi.Void Function(ffi.Long)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationResponse_ffiVoidWKNavigationResponsePolicy {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationResponse,
          objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCBlockImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationResponse,
          objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationResponse,
          objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3,
          ) => fn(
            arg0,
            WKWebView.fromPointer(arg1, retain: true, release: true),
            WKNavigationResponse.fromPointer(arg2, retain: true, release: true),
            ObjCBlock_ffiVoid_WKNavigationResponsePolicy.fromPointer(
              arg3,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationResponse.fromPointer(arg2, retain: false, release: true),
        ObjCBlock_ffiVoid_WKNavigationResponsePolicy.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_bklti2(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigationResponse,
        objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationResponse.fromPointer(arg2, retain: false, release: true),
        ObjCBlock_ffiVoid_WKNavigationResponsePolicy.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationResponse.fromPointer(arg2, retain: false, release: true),
        ObjCBlock_ffiVoid_WKNavigationResponsePolicy.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_bklti2(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigationResponse,
        objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigationResponse, objc.ObjCBlock<ffi.Void Function(ffi.Long)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationResponse_ffiVoidWKNavigationResponsePolicy$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            WKWebView,
            WKNavigationResponse,
            objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    WKWebView arg1,
    WKNavigationResponse arg2,
    objc.ObjCBlock<ffi.Void Function(ffi.Long)> arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCBlockImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

/// WARNING: WKNavigation is a stub. To generate bindings for this class, include
/// WKNavigation in your config's objc-interfaces list.
///
/// WKNavigation
extension type WKNavigation._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [WKNavigation] that points to the same underlying object as [other].
  WKNavigation.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKNavigation',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }

  /// Constructs a [WKNavigation] that wraps the given raw object pointer.
  WKNavigation.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKNavigation',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }
}

late final _sel_webView_didStartProvisionalNavigation_ = objc.registerName(
  "webView:didStartProvisionalNavigation:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0,
            WKWebView.fromPointer(arg1, retain: true, release: true),
            WKNavigation.fromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigation.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigation.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigation.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_fjrv01(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)>`.
extension ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, WKWebView arg1, WKNavigation arg2) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_webView_didReceiveServerRedirectForProvisionalNavigation_ = objc
    .registerName("webView:didReceiveServerRedirectForProvisionalNavigation:");
late final _sel_webView_didFailProvisionalNavigation_withError_ = objc
    .registerName("webView:didFailProvisionalNavigation:withError:");
final _objc_msgSend_r8gdi7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation, objc.NSError)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigation,
      objc.NSError,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigation,
          objc.NSError,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigation,
      objc.NSError,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigation,
          objc.NSError,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigation,
      objc.NSError,
    )
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation, objc.NSError)
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigation,
          objc.NSError,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ) => fn(
            arg0,
            WKWebView.fromPointer(arg1, retain: true, release: true),
            WKNavigation.fromPointer(arg2, retain: true, release: true),
            objc.NSError.fromPointer(arg3, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigation,
      objc.NSError,
    )
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation, objc.NSError)
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigation.fromPointer(arg2, retain: false, release: true),
        objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigation,
        objc.NSError,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigation,
      objc.NSError,
    )
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation, objc.NSError)
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigation.fromPointer(arg2, retain: false, release: true),
        objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigation.fromPointer(arg2, retain: false, release: true),
        objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1tz5yf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigation,
        objc.NSError,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigation, objc.NSError)>`.
extension ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            WKWebView,
            WKNavigation,
            objc.NSError,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    WKWebView arg1,
    WKNavigation arg2,
    objc.NSError arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

late final _sel_webView_didCommitNavigation_ = objc.registerName(
  "webView:didCommitNavigation:",
);
late final _sel_webView_didFinishNavigation_ = objc.registerName(
  "webView:didFinishNavigation:",
);
late final _sel_webView_didFailNavigation_withError_ = objc.registerName(
  "webView:didFailNavigation:withError:",
);
late final _sel_webView_didReceiveAuthenticationChallenge_completionHandler_ =
    objc.registerName(
      "webView:didReceiveAuthenticationChallenge:completionHandler:",
    );

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_WKWebView_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCBlockImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3,
          ) => fn(
            arg0,
            WKWebView.fromPointer(arg1, retain: true, release: true),
            NSURLAuthenticationChallenge.fromPointer(
              arg2,
              retain: true,
              release: true,
            ),
            ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential.fromPointer(
              arg3,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        NSURLAuthenticationChallenge.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_bklti2(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        NSURLAuthenticationChallenge,
        objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        NSURLAuthenticationChallenge.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        NSURLAuthenticationChallenge.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_bklti2(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        NSURLAuthenticationChallenge,
        objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_WKWebView_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            WKWebView,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    WKWebView arg1,
    NSURLAuthenticationChallenge arg2,
    objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)> arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCBlockImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

late final _sel_webViewWebContentProcessDidTerminate_ = objc.registerName(
  "webViewWebContentProcessDidTerminate:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_WKWebView {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, WKWebView) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, WKWebView.fromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, WKWebView) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, WKWebView.fromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, WKWebView) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, WKWebView.fromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, WKWebView.fromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)>`.
extension ObjCBlock_ffiVoid_ffiVoid_WKWebView$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView)> {
  void call(ffi.Pointer<ffi.Void> arg0, WKWebView arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_webView_authenticationChallenge_shouldAllowDeprecatedTLS_ = objc
    .registerName("webView:authenticationChallenge:shouldAllowDeprecatedTLS:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(ffi.Bool)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_WKWebView_NSURLAuthenticationChallenge_ffiVoidbool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCBlockImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3,
          ) => fn(
            arg0,
            WKWebView.fromPointer(arg1, retain: true, release: true),
            NSURLAuthenticationChallenge.fromPointer(
              arg2,
              retain: true,
              release: true,
            ),
            ObjCBlock_ffiVoid_bool.fromPointer(
              arg3,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        NSURLAuthenticationChallenge.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        ObjCBlock_ffiVoid_bool.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_bklti2(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        NSURLAuthenticationChallenge,
        objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        NSURLAuthenticationChallenge.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        ObjCBlock_ffiVoid_bool.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        NSURLAuthenticationChallenge.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        ObjCBlock_ffiVoid_bool.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_bklti2(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        NSURLAuthenticationChallenge,
        objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(ffi.Bool)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_WKWebView_NSURLAuthenticationChallenge_ffiVoidbool$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            WKWebView,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    WKWebView arg1,
    NSURLAuthenticationChallenge arg2,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)> arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCBlockImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

late final _sel_webView_navigationAction_didBecomeDownload_ = objc.registerName(
  "webView:navigationAction:didBecomeDownload:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigationAction, WKDownload)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_WKDownload {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKDownload,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationAction,
          WKDownload,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKDownload,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationAction,
          WKDownload,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKDownload,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKDownload,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationAction,
          WKDownload,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ) => fn(
            arg0,
            WKWebView.fromPointer(arg1, retain: true, release: true),
            WKNavigationAction.fromPointer(arg2, retain: true, release: true),
            WKDownload.fromPointer(arg3, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKDownload,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKDownload,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationAction.fromPointer(arg2, retain: false, release: true),
        WKDownload.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigationAction,
        WKDownload,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKDownload,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationAction,
      WKDownload,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationAction.fromPointer(arg2, retain: false, release: true),
        WKDownload.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationAction.fromPointer(arg2, retain: false, release: true),
        WKDownload.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1tz5yf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigationAction,
        WKDownload,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigationAction, WKDownload)>`.
extension ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_WKDownload$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            WKWebView,
            WKNavigationAction,
            WKDownload,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    WKWebView arg1,
    WKNavigationAction arg2,
    WKDownload arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

late final _sel_webView_navigationResponse_didBecomeDownload_ = objc
    .registerName("webView:navigationResponse:didBecomeDownload:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigationResponse, WKDownload)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationResponse_WKDownload {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      WKDownload,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationResponse,
          WKDownload,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      WKDownload,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationResponse,
          WKDownload,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      WKDownload,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      WKDownload,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKNavigationResponse,
          WKDownload,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ) => fn(
            arg0,
            WKWebView.fromPointer(arg1, retain: true, release: true),
            WKNavigationResponse.fromPointer(arg2, retain: true, release: true),
            WKDownload.fromPointer(arg3, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      WKDownload,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      WKDownload,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationResponse.fromPointer(arg2, retain: false, release: true),
        WKDownload.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigationResponse,
        WKDownload,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      WKDownload,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKNavigationResponse,
      WKDownload,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationResponse.fromPointer(arg2, retain: false, release: true),
        WKDownload.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKNavigationResponse.fromPointer(arg2, retain: false, release: true),
        WKDownload.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1tz5yf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKNavigationResponse,
        WKDownload,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKNavigationResponse, WKDownload)>`.
extension ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationResponse_WKDownload$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            WKWebView,
            WKNavigationResponse,
            WKDownload,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    WKWebView arg1,
    WKNavigationResponse arg2,
    WKDownload arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

late final _sel_webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_ =
    objc.registerName(
      "webView:shouldGoToBackForwardListItem:willUseInstantBack:completionHandler:",
    );
final _objc_msgSend_1imhooq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Bool,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        bool,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKBackForwardListItem, ffi.Bool, objc.ObjCBlock<ffi.Void Function(ffi.Bool)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKBackForwardListItem_bool_ffiVoidbool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKBackForwardListItem,
      ffi.Bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKBackForwardListItem,
          ffi.Bool,
          objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKBackForwardListItem,
      ffi.Bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Bool arg3,
          ffi.Pointer<objc.ObjCBlockImpl> arg4,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKBackForwardListItem,
          ffi.Bool,
          objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKBackForwardListItem,
      ffi.Bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKBackForwardListItem,
      bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          WKWebView,
          WKBackForwardListItem,
          ffi.Bool,
          objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            bool arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4,
          ) => fn(
            arg0,
            WKWebView.fromPointer(arg1, retain: true, release: true),
            WKBackForwardListItem.fromPointer(
              arg2,
              retain: true,
              release: true,
            ),
            arg3,
            ObjCBlock_ffiVoid_bool.fromPointer(
              arg4,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKBackForwardListItem,
      ffi.Bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKBackForwardListItem,
      bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        bool arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKBackForwardListItem.fromPointer(arg2, retain: false, release: true),
        arg3,
        ObjCBlock_ffiVoid_bool.fromPointer(arg4, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_axwdf6(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKBackForwardListItem,
        ffi.Bool,
        objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKBackForwardListItem,
      ffi.Bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      WKWebView,
      WKBackForwardListItem,
      bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        bool arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKBackForwardListItem.fromPointer(arg2, retain: false, release: true),
        arg3,
        ObjCBlock_ffiVoid_bool.fromPointer(arg4, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        bool arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        WKWebView.fromPointer(arg1, retain: false, release: true),
        WKBackForwardListItem.fromPointer(arg2, retain: false, release: true),
        arg3,
        ObjCBlock_ffiVoid_bool.fromPointer(arg4, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_axwdf6(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        WKWebView,
        WKBackForwardListItem,
        ffi.Bool,
        objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    bool arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          bool,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1, arg2, arg3, arg4);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Bool,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Bool,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    bool arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3, arg4);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Bool,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Bool,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Bool,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Bool,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    bool arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Bool arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          bool,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Bool,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    bool arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            bool,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Bool,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, WKWebView, WKBackForwardListItem, ffi.Bool, objc.ObjCBlock<ffi.Void Function(ffi.Bool)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKBackForwardListItem_bool_ffiVoidbool$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            WKWebView,
            WKBackForwardListItem,
            ffi.Bool,
            objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    WKWebView arg1,
    WKBackForwardListItem arg2,
    bool arg3,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)> arg4,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Bool arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              bool,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3,
        arg4.ref.pointer,
      );
}

/// WKNavigationDelegate
extension type WKNavigationDelegate._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [WKNavigationDelegate] that points to the same underlying object as [other].
  WKNavigationDelegate.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [WKNavigationDelegate] that wraps the given raw object pointer.
  WKNavigationDelegate.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [WKNavigationDelegate].
  static bool conformsTo(objc.ObjCObject obj) {
    return _objc_msgSend_e3qsqz(
      obj.ref.pointer,
      _sel_conformsToProtocol_,
      _protocol_WKNavigationDelegate,
    );
  }
}

extension WKNavigationDelegate$Methods on WKNavigationDelegate {
  /// webView:authenticationChallenge:shouldAllowDeprecatedTLS:
  void webView(
    WKWebView webView, {
    required NSURLAuthenticationChallenge authenticationChallenge,
    required objc.ObjCBlock<ffi.Void Function(ffi.Bool)>
    shouldAllowDeprecatedTLS,
  }) {
    objc.checkOsVersionInternal(
      'WKNavigationDelegate.webView:authenticationChallenge:shouldAllowDeprecatedTLS:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:authenticationChallenge:shouldAllowDeprecatedTLS:',
      );
    }
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
      webView.ref.pointer,
      authenticationChallenge.ref.pointer,
      shouldAllowDeprecatedTLS.ref.pointer,
    );
  }

  /// webView:decidePolicyForNavigationAction:decisionHandler:
  void webView$1(
    WKWebView webView, {
    required WKNavigationAction decidePolicyForNavigationAction,
    required objc.ObjCBlock<ffi.Void Function(ffi.Long)> decisionHandler,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_decidePolicyForNavigationAction_decisionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:decidePolicyForNavigationAction:decisionHandler:',
      );
    }
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_webView_decidePolicyForNavigationAction_decisionHandler_,
      webView.ref.pointer,
      decidePolicyForNavigationAction.ref.pointer,
      decisionHandler.ref.pointer,
    );
  }

  /// webView:decidePolicyForNavigationAction:preferences:decisionHandler:
  void webView$2(
    WKWebView webView, {
    required WKNavigationAction decidePolicyForNavigationAction,
    required WKWebpagePreferences preferences,
    required objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>
    decisionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKNavigationDelegate.webView:decidePolicyForNavigationAction:preferences:decisionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:decidePolicyForNavigationAction:preferences:decisionHandler:',
      );
    }
    _objc_msgSend_m7tls4(
      object$.ref.pointer,
      _sel_webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
      webView.ref.pointer,
      decidePolicyForNavigationAction.ref.pointer,
      preferences.ref.pointer,
      decisionHandler.ref.pointer,
    );
  }

  /// webView:decidePolicyForNavigationResponse:decisionHandler:
  void webView$3(
    WKWebView webView, {
    required WKNavigationResponse decidePolicyForNavigationResponse,
    required objc.ObjCBlock<ffi.Void Function(ffi.Long)> decisionHandler,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_decidePolicyForNavigationResponse_decisionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:decidePolicyForNavigationResponse:decisionHandler:',
      );
    }
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_webView_decidePolicyForNavigationResponse_decisionHandler_,
      webView.ref.pointer,
      decidePolicyForNavigationResponse.ref.pointer,
      decisionHandler.ref.pointer,
    );
  }

  /// webView:didCommitNavigation:
  void webView$4(
    WKWebView webView, {
    required WKNavigation didCommitNavigation,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_didCommitNavigation_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:didCommitNavigation:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_webView_didCommitNavigation_,
      webView.ref.pointer,
      didCommitNavigation.ref.pointer,
    );
  }

  /// webView:didFailNavigation:withError:
  void webView$5(
    WKWebView webView, {
    required WKNavigation didFailNavigation,
    required objc.NSError withError,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_didFailNavigation_withError_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:didFailNavigation:withError:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_webView_didFailNavigation_withError_,
      webView.ref.pointer,
      didFailNavigation.ref.pointer,
      withError.ref.pointer,
    );
  }

  /// webView:didFailProvisionalNavigation:withError:
  void webView$6(
    WKWebView webView, {
    required WKNavigation didFailProvisionalNavigation,
    required objc.NSError withError,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_didFailProvisionalNavigation_withError_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:didFailProvisionalNavigation:withError:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_webView_didFailProvisionalNavigation_withError_,
      webView.ref.pointer,
      didFailProvisionalNavigation.ref.pointer,
      withError.ref.pointer,
    );
  }

  /// webView:didFinishNavigation:
  void webView$7(
    WKWebView webView, {
    required WKNavigation didFinishNavigation,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_didFinishNavigation_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:didFinishNavigation:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_webView_didFinishNavigation_,
      webView.ref.pointer,
      didFinishNavigation.ref.pointer,
    );
  }

  /// webView:didReceiveAuthenticationChallenge:completionHandler:
  void webView$8(
    WKWebView webView, {
    required NSURLAuthenticationChallenge didReceiveAuthenticationChallenge,
    required objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
    completionHandler,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_didReceiveAuthenticationChallenge_completionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:didReceiveAuthenticationChallenge:completionHandler:',
      );
    }
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_webView_didReceiveAuthenticationChallenge_completionHandler_,
      webView.ref.pointer,
      didReceiveAuthenticationChallenge.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// webView:didReceiveServerRedirectForProvisionalNavigation:
  void webView$9(
    WKWebView webView, {
    required WKNavigation didReceiveServerRedirectForProvisionalNavigation,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_didReceiveServerRedirectForProvisionalNavigation_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:didReceiveServerRedirectForProvisionalNavigation:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_webView_didReceiveServerRedirectForProvisionalNavigation_,
      webView.ref.pointer,
      didReceiveServerRedirectForProvisionalNavigation.ref.pointer,
    );
  }

  /// webView:didStartProvisionalNavigation:
  void webView$10(
    WKWebView webView, {
    required WKNavigation didStartProvisionalNavigation,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_didStartProvisionalNavigation_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:didStartProvisionalNavigation:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_webView_didStartProvisionalNavigation_,
      webView.ref.pointer,
      didStartProvisionalNavigation.ref.pointer,
    );
  }

  /// webView:navigationAction:didBecomeDownload:
  void webView$11(
    WKWebView webView, {
    required WKNavigationAction navigationAction,
    required WKDownload didBecomeDownload,
  }) {
    objc.checkOsVersionInternal(
      'WKNavigationDelegate.webView:navigationAction:didBecomeDownload:',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_navigationAction_didBecomeDownload_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:navigationAction:didBecomeDownload:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_webView_navigationAction_didBecomeDownload_,
      webView.ref.pointer,
      navigationAction.ref.pointer,
      didBecomeDownload.ref.pointer,
    );
  }

  /// webView:navigationResponse:didBecomeDownload:
  void webView$12(
    WKWebView webView, {
    required WKNavigationResponse navigationResponse,
    required WKDownload didBecomeDownload,
  }) {
    objc.checkOsVersionInternal(
      'WKNavigationDelegate.webView:navigationResponse:didBecomeDownload:',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_navigationResponse_didBecomeDownload_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:navigationResponse:didBecomeDownload:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_webView_navigationResponse_didBecomeDownload_,
      webView.ref.pointer,
      navigationResponse.ref.pointer,
      didBecomeDownload.ref.pointer,
    );
  }

  /// webView:shouldGoToBackForwardListItem:willUseInstantBack:completionHandler:
  void webView$13(
    WKWebView webView, {
    required WKBackForwardListItem shouldGoToBackForwardListItem,
    required bool willUseInstantBack,
    required objc.ObjCBlock<ffi.Void Function(ffi.Bool)> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKNavigationDelegate.webView:shouldGoToBackForwardListItem:willUseInstantBack:completionHandler:',
      iOS: (false, (26, 0, 0)),
      macOS: (false, (26, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webView:shouldGoToBackForwardListItem:willUseInstantBack:completionHandler:',
      );
    }
    _objc_msgSend_1imhooq(
      object$.ref.pointer,
      _sel_webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
      webView.ref.pointer,
      shouldGoToBackForwardListItem.ref.pointer,
      willUseInstantBack,
      completionHandler.ref.pointer,
    );
  }

  /// webViewWebContentProcessDidTerminate:
  void webViewWebContentProcessDidTerminate(WKWebView webView) {
    objc.checkOsVersionInternal(
      'WKNavigationDelegate.webViewWebContentProcessDidTerminate:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_webViewWebContentProcessDidTerminate_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'WKNavigationDelegate',
        'webViewWebContentProcessDidTerminate:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_webViewWebContentProcessDidTerminate_,
      webView.ref.pointer,
    );
  }
}

interface class WKNavigationDelegate$Builder {
  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.fromPointer(_protocol_WKNavigationDelegate.cast());

  /// Builds an object that implements the WKNavigationDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static WKNavigationDelegate implement({
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
    void Function(
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationAction_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )?
    webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationResponse_decisionHandler_,
    void Function(WKWebView, WKNavigation)? webView_didCommitNavigation_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailNavigation_withError_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailProvisionalNavigation_withError_,
    void Function(WKWebView, WKNavigation)? webView_didFinishNavigation_,
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    webView_didReceiveAuthenticationChallenge_completionHandler_,
    void Function(WKWebView, WKNavigation)?
    webView_didReceiveServerRedirectForProvisionalNavigation_,
    void Function(WKWebView, WKNavigation)?
    webView_didStartProvisionalNavigation_,
    void Function(WKWebView, WKNavigationAction, WKDownload)?
    webView_navigationAction_didBecomeDownload_,
    void Function(WKWebView, WKNavigationResponse, WKDownload)?
    webView_navigationResponse_didBecomeDownload_,
    void Function(
      WKWebView,
      WKBackForwardListItem,
      bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
    void Function(WKWebView)? webViewWebContentProcessDidTerminate_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'WKNavigationDelegate');
    WKNavigationDelegate$Builder
        .webView_authenticationChallenge_shouldAllowDeprecatedTLS_
        .implement(
          builder,
          webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_decisionHandler_
        .implement(
          builder,
          webView_decidePolicyForNavigationAction_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_preferences_decisionHandler_
        .implement(
          builder,
          webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationResponse_decisionHandler_
        .implement(
          builder,
          webView_decidePolicyForNavigationResponse_decisionHandler_,
        );
    WKNavigationDelegate$Builder.webView_didCommitNavigation_.implement(
      builder,
      webView_didCommitNavigation_,
    );
    WKNavigationDelegate$Builder.webView_didFailNavigation_withError_.implement(
      builder,
      webView_didFailNavigation_withError_,
    );
    WKNavigationDelegate$Builder.webView_didFailProvisionalNavigation_withError_
        .implement(builder, webView_didFailProvisionalNavigation_withError_);
    WKNavigationDelegate$Builder.webView_didFinishNavigation_.implement(
      builder,
      webView_didFinishNavigation_,
    );
    WKNavigationDelegate$Builder
        .webView_didReceiveAuthenticationChallenge_completionHandler_
        .implement(
          builder,
          webView_didReceiveAuthenticationChallenge_completionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_didReceiveServerRedirectForProvisionalNavigation_
        .implement(
          builder,
          webView_didReceiveServerRedirectForProvisionalNavigation_,
        );
    WKNavigationDelegate$Builder.webView_didStartProvisionalNavigation_
        .implement(builder, webView_didStartProvisionalNavigation_);
    WKNavigationDelegate$Builder.webView_navigationAction_didBecomeDownload_
        .implement(builder, webView_navigationAction_didBecomeDownload_);
    WKNavigationDelegate$Builder.webView_navigationResponse_didBecomeDownload_
        .implement(builder, webView_navigationResponse_didBecomeDownload_);
    WKNavigationDelegate$Builder
        .webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_
        .implement(
          builder,
          webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
        );
    WKNavigationDelegate$Builder.webViewWebContentProcessDidTerminate_
        .implement(builder, webViewWebContentProcessDidTerminate_);
    builder.addProtocol($protocol);
    return WKNavigationDelegate.as(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the WKNavigationDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(
    objc.ObjCProtocolBuilder builder, {
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
    void Function(
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationAction_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )?
    webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationResponse_decisionHandler_,
    void Function(WKWebView, WKNavigation)? webView_didCommitNavigation_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailNavigation_withError_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailProvisionalNavigation_withError_,
    void Function(WKWebView, WKNavigation)? webView_didFinishNavigation_,
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    webView_didReceiveAuthenticationChallenge_completionHandler_,
    void Function(WKWebView, WKNavigation)?
    webView_didReceiveServerRedirectForProvisionalNavigation_,
    void Function(WKWebView, WKNavigation)?
    webView_didStartProvisionalNavigation_,
    void Function(WKWebView, WKNavigationAction, WKDownload)?
    webView_navigationAction_didBecomeDownload_,
    void Function(WKWebView, WKNavigationResponse, WKDownload)?
    webView_navigationResponse_didBecomeDownload_,
    void Function(
      WKWebView,
      WKBackForwardListItem,
      bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
    void Function(WKWebView)? webViewWebContentProcessDidTerminate_,
    bool $keepIsolateAlive = true,
  }) {
    WKNavigationDelegate$Builder
        .webView_authenticationChallenge_shouldAllowDeprecatedTLS_
        .implement(
          builder,
          webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_decisionHandler_
        .implement(
          builder,
          webView_decidePolicyForNavigationAction_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_preferences_decisionHandler_
        .implement(
          builder,
          webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationResponse_decisionHandler_
        .implement(
          builder,
          webView_decidePolicyForNavigationResponse_decisionHandler_,
        );
    WKNavigationDelegate$Builder.webView_didCommitNavigation_.implement(
      builder,
      webView_didCommitNavigation_,
    );
    WKNavigationDelegate$Builder.webView_didFailNavigation_withError_.implement(
      builder,
      webView_didFailNavigation_withError_,
    );
    WKNavigationDelegate$Builder.webView_didFailProvisionalNavigation_withError_
        .implement(builder, webView_didFailProvisionalNavigation_withError_);
    WKNavigationDelegate$Builder.webView_didFinishNavigation_.implement(
      builder,
      webView_didFinishNavigation_,
    );
    WKNavigationDelegate$Builder
        .webView_didReceiveAuthenticationChallenge_completionHandler_
        .implement(
          builder,
          webView_didReceiveAuthenticationChallenge_completionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_didReceiveServerRedirectForProvisionalNavigation_
        .implement(
          builder,
          webView_didReceiveServerRedirectForProvisionalNavigation_,
        );
    WKNavigationDelegate$Builder.webView_didStartProvisionalNavigation_
        .implement(builder, webView_didStartProvisionalNavigation_);
    WKNavigationDelegate$Builder.webView_navigationAction_didBecomeDownload_
        .implement(builder, webView_navigationAction_didBecomeDownload_);
    WKNavigationDelegate$Builder.webView_navigationResponse_didBecomeDownload_
        .implement(builder, webView_navigationResponse_didBecomeDownload_);
    WKNavigationDelegate$Builder
        .webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_
        .implement(
          builder,
          webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
        );
    WKNavigationDelegate$Builder.webViewWebContentProcessDidTerminate_
        .implement(builder, webViewWebContentProcessDidTerminate_);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the WKNavigationDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static WKNavigationDelegate implementAsListener({
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
    void Function(
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationAction_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )?
    webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationResponse_decisionHandler_,
    void Function(WKWebView, WKNavigation)? webView_didCommitNavigation_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailNavigation_withError_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailProvisionalNavigation_withError_,
    void Function(WKWebView, WKNavigation)? webView_didFinishNavigation_,
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    webView_didReceiveAuthenticationChallenge_completionHandler_,
    void Function(WKWebView, WKNavigation)?
    webView_didReceiveServerRedirectForProvisionalNavigation_,
    void Function(WKWebView, WKNavigation)?
    webView_didStartProvisionalNavigation_,
    void Function(WKWebView, WKNavigationAction, WKDownload)?
    webView_navigationAction_didBecomeDownload_,
    void Function(WKWebView, WKNavigationResponse, WKDownload)?
    webView_navigationResponse_didBecomeDownload_,
    void Function(
      WKWebView,
      WKBackForwardListItem,
      bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
    void Function(WKWebView)? webViewWebContentProcessDidTerminate_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'WKNavigationDelegate');
    WKNavigationDelegate$Builder
        .webView_authenticationChallenge_shouldAllowDeprecatedTLS_
        .implementAsListener(
          builder,
          webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_decisionHandler_
        .implementAsListener(
          builder,
          webView_decidePolicyForNavigationAction_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_preferences_decisionHandler_
        .implementAsListener(
          builder,
          webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationResponse_decisionHandler_
        .implementAsListener(
          builder,
          webView_decidePolicyForNavigationResponse_decisionHandler_,
        );
    WKNavigationDelegate$Builder.webView_didCommitNavigation_
        .implementAsListener(builder, webView_didCommitNavigation_);
    WKNavigationDelegate$Builder.webView_didFailNavigation_withError_
        .implementAsListener(builder, webView_didFailNavigation_withError_);
    WKNavigationDelegate$Builder.webView_didFailProvisionalNavigation_withError_
        .implementAsListener(
          builder,
          webView_didFailProvisionalNavigation_withError_,
        );
    WKNavigationDelegate$Builder.webView_didFinishNavigation_
        .implementAsListener(builder, webView_didFinishNavigation_);
    WKNavigationDelegate$Builder
        .webView_didReceiveAuthenticationChallenge_completionHandler_
        .implementAsListener(
          builder,
          webView_didReceiveAuthenticationChallenge_completionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_didReceiveServerRedirectForProvisionalNavigation_
        .implementAsListener(
          builder,
          webView_didReceiveServerRedirectForProvisionalNavigation_,
        );
    WKNavigationDelegate$Builder.webView_didStartProvisionalNavigation_
        .implementAsListener(builder, webView_didStartProvisionalNavigation_);
    WKNavigationDelegate$Builder.webView_navigationAction_didBecomeDownload_
        .implementAsListener(
          builder,
          webView_navigationAction_didBecomeDownload_,
        );
    WKNavigationDelegate$Builder.webView_navigationResponse_didBecomeDownload_
        .implementAsListener(
          builder,
          webView_navigationResponse_didBecomeDownload_,
        );
    WKNavigationDelegate$Builder
        .webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_
        .implementAsListener(
          builder,
          webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
        );
    WKNavigationDelegate$Builder.webViewWebContentProcessDidTerminate_
        .implementAsListener(builder, webViewWebContentProcessDidTerminate_);
    builder.addProtocol($protocol);
    return WKNavigationDelegate.as(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the WKNavigationDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(
    objc.ObjCProtocolBuilder builder, {
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
    void Function(
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationAction_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )?
    webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationResponse_decisionHandler_,
    void Function(WKWebView, WKNavigation)? webView_didCommitNavigation_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailNavigation_withError_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailProvisionalNavigation_withError_,
    void Function(WKWebView, WKNavigation)? webView_didFinishNavigation_,
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    webView_didReceiveAuthenticationChallenge_completionHandler_,
    void Function(WKWebView, WKNavigation)?
    webView_didReceiveServerRedirectForProvisionalNavigation_,
    void Function(WKWebView, WKNavigation)?
    webView_didStartProvisionalNavigation_,
    void Function(WKWebView, WKNavigationAction, WKDownload)?
    webView_navigationAction_didBecomeDownload_,
    void Function(WKWebView, WKNavigationResponse, WKDownload)?
    webView_navigationResponse_didBecomeDownload_,
    void Function(
      WKWebView,
      WKBackForwardListItem,
      bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
    void Function(WKWebView)? webViewWebContentProcessDidTerminate_,
    bool $keepIsolateAlive = true,
  }) {
    WKNavigationDelegate$Builder
        .webView_authenticationChallenge_shouldAllowDeprecatedTLS_
        .implementAsListener(
          builder,
          webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_decisionHandler_
        .implementAsListener(
          builder,
          webView_decidePolicyForNavigationAction_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_preferences_decisionHandler_
        .implementAsListener(
          builder,
          webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationResponse_decisionHandler_
        .implementAsListener(
          builder,
          webView_decidePolicyForNavigationResponse_decisionHandler_,
        );
    WKNavigationDelegate$Builder.webView_didCommitNavigation_
        .implementAsListener(builder, webView_didCommitNavigation_);
    WKNavigationDelegate$Builder.webView_didFailNavigation_withError_
        .implementAsListener(builder, webView_didFailNavigation_withError_);
    WKNavigationDelegate$Builder.webView_didFailProvisionalNavigation_withError_
        .implementAsListener(
          builder,
          webView_didFailProvisionalNavigation_withError_,
        );
    WKNavigationDelegate$Builder.webView_didFinishNavigation_
        .implementAsListener(builder, webView_didFinishNavigation_);
    WKNavigationDelegate$Builder
        .webView_didReceiveAuthenticationChallenge_completionHandler_
        .implementAsListener(
          builder,
          webView_didReceiveAuthenticationChallenge_completionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_didReceiveServerRedirectForProvisionalNavigation_
        .implementAsListener(
          builder,
          webView_didReceiveServerRedirectForProvisionalNavigation_,
        );
    WKNavigationDelegate$Builder.webView_didStartProvisionalNavigation_
        .implementAsListener(builder, webView_didStartProvisionalNavigation_);
    WKNavigationDelegate$Builder.webView_navigationAction_didBecomeDownload_
        .implementAsListener(
          builder,
          webView_navigationAction_didBecomeDownload_,
        );
    WKNavigationDelegate$Builder.webView_navigationResponse_didBecomeDownload_
        .implementAsListener(
          builder,
          webView_navigationResponse_didBecomeDownload_,
        );
    WKNavigationDelegate$Builder
        .webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_
        .implementAsListener(
          builder,
          webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
        );
    WKNavigationDelegate$Builder.webViewWebContentProcessDidTerminate_
        .implementAsListener(builder, webViewWebContentProcessDidTerminate_);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the WKNavigationDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static WKNavigationDelegate implementAsBlocking({
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
    void Function(
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationAction_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )?
    webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationResponse_decisionHandler_,
    void Function(WKWebView, WKNavigation)? webView_didCommitNavigation_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailNavigation_withError_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailProvisionalNavigation_withError_,
    void Function(WKWebView, WKNavigation)? webView_didFinishNavigation_,
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    webView_didReceiveAuthenticationChallenge_completionHandler_,
    void Function(WKWebView, WKNavigation)?
    webView_didReceiveServerRedirectForProvisionalNavigation_,
    void Function(WKWebView, WKNavigation)?
    webView_didStartProvisionalNavigation_,
    void Function(WKWebView, WKNavigationAction, WKDownload)?
    webView_navigationAction_didBecomeDownload_,
    void Function(WKWebView, WKNavigationResponse, WKDownload)?
    webView_navigationResponse_didBecomeDownload_,
    void Function(
      WKWebView,
      WKBackForwardListItem,
      bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
    void Function(WKWebView)? webViewWebContentProcessDidTerminate_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'WKNavigationDelegate');
    WKNavigationDelegate$Builder
        .webView_authenticationChallenge_shouldAllowDeprecatedTLS_
        .implementAsBlocking(
          builder,
          webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_decisionHandler_
        .implementAsBlocking(
          builder,
          webView_decidePolicyForNavigationAction_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_preferences_decisionHandler_
        .implementAsBlocking(
          builder,
          webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationResponse_decisionHandler_
        .implementAsBlocking(
          builder,
          webView_decidePolicyForNavigationResponse_decisionHandler_,
        );
    WKNavigationDelegate$Builder.webView_didCommitNavigation_
        .implementAsBlocking(builder, webView_didCommitNavigation_);
    WKNavigationDelegate$Builder.webView_didFailNavigation_withError_
        .implementAsBlocking(builder, webView_didFailNavigation_withError_);
    WKNavigationDelegate$Builder.webView_didFailProvisionalNavigation_withError_
        .implementAsBlocking(
          builder,
          webView_didFailProvisionalNavigation_withError_,
        );
    WKNavigationDelegate$Builder.webView_didFinishNavigation_
        .implementAsBlocking(builder, webView_didFinishNavigation_);
    WKNavigationDelegate$Builder
        .webView_didReceiveAuthenticationChallenge_completionHandler_
        .implementAsBlocking(
          builder,
          webView_didReceiveAuthenticationChallenge_completionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_didReceiveServerRedirectForProvisionalNavigation_
        .implementAsBlocking(
          builder,
          webView_didReceiveServerRedirectForProvisionalNavigation_,
        );
    WKNavigationDelegate$Builder.webView_didStartProvisionalNavigation_
        .implementAsBlocking(builder, webView_didStartProvisionalNavigation_);
    WKNavigationDelegate$Builder.webView_navigationAction_didBecomeDownload_
        .implementAsBlocking(
          builder,
          webView_navigationAction_didBecomeDownload_,
        );
    WKNavigationDelegate$Builder.webView_navigationResponse_didBecomeDownload_
        .implementAsBlocking(
          builder,
          webView_navigationResponse_didBecomeDownload_,
        );
    WKNavigationDelegate$Builder
        .webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_
        .implementAsBlocking(
          builder,
          webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
        );
    WKNavigationDelegate$Builder.webViewWebContentProcessDidTerminate_
        .implementAsBlocking(builder, webViewWebContentProcessDidTerminate_);
    builder.addProtocol($protocol);
    return WKNavigationDelegate.as(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the WKNavigationDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(
    objc.ObjCProtocolBuilder builder, {
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
    void Function(
      WKWebView,
      WKNavigationAction,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationAction_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationAction,
      WKWebpagePreferences,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
    )?
    webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
    void Function(
      WKWebView,
      WKNavigationResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    webView_decidePolicyForNavigationResponse_decisionHandler_,
    void Function(WKWebView, WKNavigation)? webView_didCommitNavigation_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailNavigation_withError_,
    void Function(WKWebView, WKNavigation, objc.NSError)?
    webView_didFailProvisionalNavigation_withError_,
    void Function(WKWebView, WKNavigation)? webView_didFinishNavigation_,
    void Function(
      WKWebView,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    webView_didReceiveAuthenticationChallenge_completionHandler_,
    void Function(WKWebView, WKNavigation)?
    webView_didReceiveServerRedirectForProvisionalNavigation_,
    void Function(WKWebView, WKNavigation)?
    webView_didStartProvisionalNavigation_,
    void Function(WKWebView, WKNavigationAction, WKDownload)?
    webView_navigationAction_didBecomeDownload_,
    void Function(WKWebView, WKNavigationResponse, WKDownload)?
    webView_navigationResponse_didBecomeDownload_,
    void Function(
      WKWebView,
      WKBackForwardListItem,
      bool,
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
    )?
    webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
    void Function(WKWebView)? webViewWebContentProcessDidTerminate_,
    bool $keepIsolateAlive = true,
  }) {
    WKNavigationDelegate$Builder
        .webView_authenticationChallenge_shouldAllowDeprecatedTLS_
        .implementAsBlocking(
          builder,
          webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_decisionHandler_
        .implementAsBlocking(
          builder,
          webView_decidePolicyForNavigationAction_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationAction_preferences_decisionHandler_
        .implementAsBlocking(
          builder,
          webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_decidePolicyForNavigationResponse_decisionHandler_
        .implementAsBlocking(
          builder,
          webView_decidePolicyForNavigationResponse_decisionHandler_,
        );
    WKNavigationDelegate$Builder.webView_didCommitNavigation_
        .implementAsBlocking(builder, webView_didCommitNavigation_);
    WKNavigationDelegate$Builder.webView_didFailNavigation_withError_
        .implementAsBlocking(builder, webView_didFailNavigation_withError_);
    WKNavigationDelegate$Builder.webView_didFailProvisionalNavigation_withError_
        .implementAsBlocking(
          builder,
          webView_didFailProvisionalNavigation_withError_,
        );
    WKNavigationDelegate$Builder.webView_didFinishNavigation_
        .implementAsBlocking(builder, webView_didFinishNavigation_);
    WKNavigationDelegate$Builder
        .webView_didReceiveAuthenticationChallenge_completionHandler_
        .implementAsBlocking(
          builder,
          webView_didReceiveAuthenticationChallenge_completionHandler_,
        );
    WKNavigationDelegate$Builder
        .webView_didReceiveServerRedirectForProvisionalNavigation_
        .implementAsBlocking(
          builder,
          webView_didReceiveServerRedirectForProvisionalNavigation_,
        );
    WKNavigationDelegate$Builder.webView_didStartProvisionalNavigation_
        .implementAsBlocking(builder, webView_didStartProvisionalNavigation_);
    WKNavigationDelegate$Builder.webView_navigationAction_didBecomeDownload_
        .implementAsBlocking(
          builder,
          webView_navigationAction_didBecomeDownload_,
        );
    WKNavigationDelegate$Builder.webView_navigationResponse_didBecomeDownload_
        .implementAsBlocking(
          builder,
          webView_navigationResponse_didBecomeDownload_,
        );
    WKNavigationDelegate$Builder
        .webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_
        .implementAsBlocking(
          builder,
          webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
        );
    WKNavigationDelegate$Builder.webViewWebContentProcessDidTerminate_
        .implementAsBlocking(builder, webViewWebContentProcessDidTerminate_);
    builder.addProtocol($protocol);
  }

  /// webView:authenticationChallenge:shouldAllowDeprecatedTLS:
  static final webView_authenticationChallenge_shouldAllowDeprecatedTLS_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          WKWebView,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
        )
      >(
        _protocol_WKNavigationDelegate,
        _sel_webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_bklti2)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_authenticationChallenge_shouldAllowDeprecatedTLS_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            WKWebView,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_NSURLAuthenticationChallenge_ffiVoidbool.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                NSURLAuthenticationChallenge arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Bool)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            WKWebView,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_NSURLAuthenticationChallenge_ffiVoidbool.listener(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                NSURLAuthenticationChallenge arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Bool)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            WKWebView,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_NSURLAuthenticationChallenge_ffiVoidbool.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                NSURLAuthenticationChallenge arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Bool)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// webView:decidePolicyForNavigationAction:decisionHandler:
  static final webView_decidePolicyForNavigationAction_decisionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          WKWebView,
          WKNavigationAction,
          objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
        )
      >(
        _protocol_WKNavigationDelegate,
        _sel_webView_decidePolicyForNavigationAction_decisionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_bklti2)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_decidePolicyForNavigationAction_decisionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            WKWebView,
            WKNavigationAction,
            objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_ffiVoidWKNavigationActionPolicy.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationAction arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            WKWebView,
            WKNavigationAction,
            objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_ffiVoidWKNavigationActionPolicy.listener(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationAction arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            WKWebView,
            WKNavigationAction,
            objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_ffiVoidWKNavigationActionPolicy.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationAction arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// webView:decidePolicyForNavigationAction:preferences:decisionHandler:
  static final webView_decidePolicyForNavigationAction_preferences_decisionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          WKWebView,
          WKNavigationAction,
          WKWebpagePreferences,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
        )
      >(
        _protocol_WKNavigationDelegate,
        _sel_webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_xx612k)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_decidePolicyForNavigationAction_preferences_decisionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            WKWebView,
            WKNavigationAction,
            WKWebpagePreferences,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_WKWebpagePreferences_ffiVoidWKNavigationActionPolicyWKWebpagePreferences.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationAction arg2,
                WKWebpagePreferences arg3,
                objc.ObjCBlock<
                  ffi.Void Function(ffi.Long, WKWebpagePreferences)
                >
                arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            WKWebView,
            WKNavigationAction,
            WKWebpagePreferences,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_WKWebpagePreferences_ffiVoidWKNavigationActionPolicyWKWebpagePreferences.listener(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationAction arg2,
                WKWebpagePreferences arg3,
                objc.ObjCBlock<
                  ffi.Void Function(ffi.Long, WKWebpagePreferences)
                >
                arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            WKWebView,
            WKNavigationAction,
            WKWebpagePreferences,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, WKWebpagePreferences)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_WKWebpagePreferences_ffiVoidWKNavigationActionPolicyWKWebpagePreferences.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationAction arg2,
                WKWebpagePreferences arg3,
                objc.ObjCBlock<
                  ffi.Void Function(ffi.Long, WKWebpagePreferences)
                >
                arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
      );

  /// webView:decidePolicyForNavigationResponse:decisionHandler:
  static final webView_decidePolicyForNavigationResponse_decisionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          WKWebView,
          WKNavigationResponse,
          objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
        )
      >(
        _protocol_WKNavigationDelegate,
        _sel_webView_decidePolicyForNavigationResponse_decisionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_bklti2)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_decidePolicyForNavigationResponse_decisionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            WKWebView,
            WKNavigationResponse,
            objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationResponse_ffiVoidWKNavigationResponsePolicy.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationResponse arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            WKWebView,
            WKNavigationResponse,
            objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationResponse_ffiVoidWKNavigationResponsePolicy.listener(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationResponse arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            WKWebView,
            WKNavigationResponse,
            objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationResponse_ffiVoidWKNavigationResponsePolicy.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationResponse arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// webView:didCommitNavigation:
  static final webView_didCommitNavigation_ =
      objc.ObjCProtocolListenableMethod<void Function(WKWebView, WKNavigation)>(
        _protocol_WKNavigationDelegate,
        _sel_webView_didCommitNavigation_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_didCommitNavigation_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.fromFunction(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.listener(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.blocking(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
      );

  /// webView:didFailNavigation:withError:
  static final webView_didFailNavigation_withError_ =
      objc.ObjCProtocolListenableMethod<
        void Function(WKWebView, WKNavigation, objc.NSError)
      >(
        _protocol_WKNavigationDelegate,
        _sel_webView_didFailNavigation_withError_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_didFailNavigation_withError_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(WKWebView, WKNavigation, objc.NSError) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigation arg2,
                objc.NSError arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(WKWebView, WKNavigation, objc.NSError) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigation arg2,
                objc.NSError arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(WKWebView, WKNavigation, objc.NSError) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigation arg2,
                objc.NSError arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// webView:didFailProvisionalNavigation:withError:
  static final webView_didFailProvisionalNavigation_withError_ =
      objc.ObjCProtocolListenableMethod<
        void Function(WKWebView, WKNavigation, objc.NSError)
      >(
        _protocol_WKNavigationDelegate,
        _sel_webView_didFailProvisionalNavigation_withError_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_didFailProvisionalNavigation_withError_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(WKWebView, WKNavigation, objc.NSError) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigation arg2,
                objc.NSError arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(WKWebView, WKNavigation, objc.NSError) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigation arg2,
                objc.NSError arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(WKWebView, WKNavigation, objc.NSError) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigation arg2,
                objc.NSError arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// webView:didFinishNavigation:
  static final webView_didFinishNavigation_ =
      objc.ObjCProtocolListenableMethod<void Function(WKWebView, WKNavigation)>(
        _protocol_WKNavigationDelegate,
        _sel_webView_didFinishNavigation_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_didFinishNavigation_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.fromFunction(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.listener(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.blocking(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
      );

  /// webView:didReceiveAuthenticationChallenge:completionHandler:
  static final webView_didReceiveAuthenticationChallenge_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          WKWebView,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
        )
      >(
        _protocol_WKNavigationDelegate,
        _sel_webView_didReceiveAuthenticationChallenge_completionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_bklti2)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_didReceiveAuthenticationChallenge_completionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            WKWebView,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                NSURLAuthenticationChallenge arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            WKWebView,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.listener(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                NSURLAuthenticationChallenge arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            WKWebView,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                NSURLAuthenticationChallenge arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// webView:didReceiveServerRedirectForProvisionalNavigation:
  static final webView_didReceiveServerRedirectForProvisionalNavigation_ =
      objc.ObjCProtocolListenableMethod<void Function(WKWebView, WKNavigation)>(
        _protocol_WKNavigationDelegate,
        _sel_webView_didReceiveServerRedirectForProvisionalNavigation_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_didReceiveServerRedirectForProvisionalNavigation_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.fromFunction(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.listener(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.blocking(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
      );

  /// webView:didStartProvisionalNavigation:
  static final webView_didStartProvisionalNavigation_ =
      objc.ObjCProtocolListenableMethod<void Function(WKWebView, WKNavigation)>(
        _protocol_WKNavigationDelegate,
        _sel_webView_didStartProvisionalNavigation_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_didStartProvisionalNavigation_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.fromFunction(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.listener(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
        (void Function(WKWebView, WKNavigation) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigation.blocking(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1, WKNavigation arg2) =>
                  func(arg1, arg2),
            ),
      );

  /// webView:navigationAction:didBecomeDownload:
  static final webView_navigationAction_didBecomeDownload_ =
      objc.ObjCProtocolListenableMethod<
        void Function(WKWebView, WKNavigationAction, WKDownload)
      >(
        _protocol_WKNavigationDelegate,
        _sel_webView_navigationAction_didBecomeDownload_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_navigationAction_didBecomeDownload_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(WKWebView, WKNavigationAction, WKDownload) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_WKDownload.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationAction arg2,
                WKDownload arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(WKWebView, WKNavigationAction, WKDownload) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_WKDownload.listener(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationAction arg2,
                WKDownload arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(WKWebView, WKNavigationAction, WKDownload) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationAction_WKDownload.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationAction arg2,
                WKDownload arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// webView:navigationResponse:didBecomeDownload:
  static final webView_navigationResponse_didBecomeDownload_ =
      objc.ObjCProtocolListenableMethod<
        void Function(WKWebView, WKNavigationResponse, WKDownload)
      >(
        _protocol_WKNavigationDelegate,
        _sel_webView_navigationResponse_didBecomeDownload_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_navigationResponse_didBecomeDownload_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(WKWebView, WKNavigationResponse, WKDownload) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationResponse_WKDownload.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationResponse arg2,
                WKDownload arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(WKWebView, WKNavigationResponse, WKDownload) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationResponse_WKDownload.listener(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationResponse arg2,
                WKDownload arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(WKWebView, WKNavigationResponse, WKDownload) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKNavigationResponse_WKDownload.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKNavigationResponse arg2,
                WKDownload arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// webView:shouldGoToBackForwardListItem:willUseInstantBack:completionHandler:
  static final webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          WKWebView,
          WKBackForwardListItem,
          bool,
          objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
        )
      >(
        _protocol_WKNavigationDelegate,
        _sel_webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Bool,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_axwdf6)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webView_shouldGoToBackForwardListItem_willUseInstantBack_completionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            WKWebView,
            WKBackForwardListItem,
            bool,
            objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKBackForwardListItem_bool_ffiVoidbool.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKBackForwardListItem arg2,
                bool arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Bool)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            WKWebView,
            WKBackForwardListItem,
            bool,
            objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKBackForwardListItem_bool_ffiVoidbool.listener(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKBackForwardListItem arg2,
                bool arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Bool)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            WKWebView,
            WKBackForwardListItem,
            bool,
            objc.ObjCBlock<ffi.Void Function(ffi.Bool)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView_WKBackForwardListItem_bool_ffiVoidbool.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                WKWebView arg1,
                WKBackForwardListItem arg2,
                bool arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Bool)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
      );

  /// webViewWebContentProcessDidTerminate:
  static final webViewWebContentProcessDidTerminate_ =
      objc.ObjCProtocolListenableMethod<void Function(WKWebView)>(
        _protocol_WKNavigationDelegate,
        _sel_webViewWebContentProcessDidTerminate_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeLibrary_protocolTrampoline_18v1jvf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_WKNavigationDelegate,
          _sel_webViewWebContentProcessDidTerminate_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(WKWebView) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView.fromFunction(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1) => func(arg1),
            ),
        (void Function(WKWebView) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView.listener(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1) => func(arg1),
            ),
        (void Function(WKWebView) func) =>
            ObjCBlock_ffiVoid_ffiVoid_WKWebView.blocking(
              (ffi.Pointer<ffi.Void> _, WKWebView arg1) => func(arg1),
            ),
      );
}

late final _sel_navigationDelegate = objc.registerName("navigationDelegate");
late final _sel_setNavigationDelegate_ = objc.registerName(
  "setNavigationDelegate:",
);

/// WARNING: WKUIDelegate is a stub. To generate bindings for this class, include
/// WKUIDelegate in your config's objc-protocols list.
///
/// WKUIDelegate
extension type WKUIDelegate._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [WKUIDelegate] that points to the same underlying object as [other].
  WKUIDelegate.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [WKUIDelegate] that wraps the given raw object pointer.
  WKUIDelegate.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_UIDelegate = objc.registerName("UIDelegate");
late final _sel_setUIDelegate_ = objc.registerName("setUIDelegate:");
late final _sel_backForwardList = objc.registerName("backForwardList");
late final _sel_initWithFrame_configuration_ = objc.registerName(
  "initWithFrame:configuration:",
);
late final _sel_loadRequest_ = objc.registerName("loadRequest:");
late final _sel_loadFileURL_allowingReadAccessToURL_ = objc.registerName(
  "loadFileURL:allowingReadAccessToURL:",
);
late final _sel_loadHTMLString_baseURL_ = objc.registerName(
  "loadHTMLString:baseURL:",
);
late final _sel_loadData_MIMEType_characterEncodingName_baseURL_ = objc
    .registerName("loadData:MIMEType:characterEncodingName:baseURL:");
final _objc_msgSend_s92gih = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_goToBackForwardListItem_ = objc.registerName(
  "goToBackForwardListItem:",
);
late final _sel_isLoading = objc.registerName("isLoading");
late final _sel_estimatedProgress = objc.registerName("estimatedProgress");
late final _sel_hasOnlySecureContent = objc.registerName(
  "hasOnlySecureContent",
);
late final _sel_serverTrust = objc.registerName("serverTrust");
final _objc_msgSend_1ommad9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<__SecTrust> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<__SecTrust> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_canGoBack = objc.registerName("canGoBack");
late final _sel_canGoForward = objc.registerName("canGoForward");
late final _sel_goBack = objc.registerName("goBack");
late final _sel_goForward = objc.registerName("goForward");
late final _sel_reload = objc.registerName("reload");
late final _sel_reloadFromOrigin = objc.registerName("reloadFromOrigin");
late final _sel_stopLoading = objc.registerName("stopLoading");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_objcObjCObjectImpl_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
  >
  fromFunction(
    void Function(objc.ObjCObject, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ) => fn(
            objc.ObjCObject(arg0, retain: true, release: true),
            arg1.address == 0
                ? null
                : objc.NSError.fromPointer(arg1, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
  >
  listener(
    void Function(objc.ObjCObject, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        objc.ObjCObject(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
  >
  blocking(
    void Function(objc.ObjCObject, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        objc.ObjCObject(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        objc.ObjCObject(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_objcObjCObjectImpl_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
        > {
  void call(objc.ObjCObject arg0, objc.NSError? arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0.ref.pointer, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_evaluateJavaScript_completionHandler_ = objc.registerName(
  "evaluateJavaScript:completionHandler:",
);
final _objc_msgSend_o762yo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// WARNING: WKFrameInfo is a stub. To generate bindings for this class, include
/// WKFrameInfo in your config's objc-interfaces list.
///
/// WKFrameInfo
extension type WKFrameInfo._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [WKFrameInfo] that points to the same underlying object as [other].
  WKFrameInfo.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKFrameInfo',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }

  /// Constructs a [WKFrameInfo] that wraps the given raw object pointer.
  WKFrameInfo.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKFrameInfo',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
  }
}

late final _sel_evaluateJavaScript_inFrame_inContentWorld_completionHandler_ =
    objc.registerName(
      "evaluateJavaScript:inFrame:inContentWorld:completionHandler:",
    );
late final _sel_callAsyncJavaScript_arguments_inFrame_inContentWorld_completionHandler_ =
    objc.registerName(
      "callAsyncJavaScript:arguments:inFrame:inContentWorld:completionHandler:",
    );
final _objc_msgSend_e1wgee = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_closeAllMediaPresentationsWithCompletionHandler_ = objc
    .registerName("closeAllMediaPresentationsWithCompletionHandler:");
late final _sel_closeAllMediaPresentations = objc.registerName(
  "closeAllMediaPresentations",
);
late final _sel_pauseAllMediaPlaybackWithCompletionHandler_ = objc.registerName(
  "pauseAllMediaPlaybackWithCompletionHandler:",
);
late final _sel_pauseAllMediaPlayback_ = objc.registerName(
  "pauseAllMediaPlayback:",
);
late final _sel_setAllMediaPlaybackSuspended_completionHandler_ = objc
    .registerName("setAllMediaPlaybackSuspended:completionHandler:");
final _objc_msgSend_1ocak7a = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_resumeAllMediaPlayback_ = objc.registerName(
  "resumeAllMediaPlayback:",
);
late final _sel_suspendAllMediaPlayback_ = objc.registerName(
  "suspendAllMediaPlayback:",
);

enum WKMediaPlaybackState {
  WKMediaPlaybackStateNone(0),
  WKMediaPlaybackStatePlaying(1),
  WKMediaPlaybackStatePaused(2),
  WKMediaPlaybackStateSuspended(3);

  final int value;
  const WKMediaPlaybackState(this.value);

  static WKMediaPlaybackState fromValue(int value) => switch (value) {
    0 => WKMediaPlaybackStateNone,
    1 => WKMediaPlaybackStatePlaying,
    2 => WKMediaPlaybackStatePaused,
    3 => WKMediaPlaybackStateSuspended,
    _ => throw ArgumentError('Unknown value for WKMediaPlaybackState: $value'),
  };
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Long)>`.
abstract final class ObjCBlock_ffiVoid_WKMediaPlaybackState {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Long arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> fromFunction(
    void Function(WKMediaPlaybackState) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
    objc.newClosureBlock(
      _closureCallable,
      (int arg0) => fn(WKMediaPlaybackState.fromValue(arg0)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> listener(
    void Function(WKMediaPlaybackState) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (int arg0) => fn(WKMediaPlaybackState.fromValue(arg0)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_19s8ne9(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> blocking(
    void Function(WKMediaPlaybackState) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (int arg0) => fn(WKMediaPlaybackState.fromValue(arg0)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (int arg0) => fn(WKMediaPlaybackState.fromValue(arg0)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_19s8ne9(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
  ) {
    (objc.getBlockClosure(block) as void Function(int))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    int arg0,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(int))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Long arg0)>>()
      .asFunction<void Function(int)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
  ) => (objc.getBlockClosure(block) as void Function(int))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Long)>`.
extension ObjCBlock_ffiVoid_WKMediaPlaybackState$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Long)> {
  void call(WKMediaPlaybackState arg0) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Long arg0,
              )
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, int)>()(
        ref.pointer,
        arg0.value,
      );
}

late final _sel_requestMediaPlaybackStateWithCompletionHandler_ = objc
    .registerName("requestMediaPlaybackStateWithCompletionHandler:");
late final _sel_requestMediaPlaybackState_ = objc.registerName(
  "requestMediaPlaybackState:",
);

enum WKMediaCaptureState {
  WKMediaCaptureStateNone(0),
  WKMediaCaptureStateActive(1),
  WKMediaCaptureStateMuted(2);

  final int value;
  const WKMediaCaptureState(this.value);

  static WKMediaCaptureState fromValue(int value) => switch (value) {
    0 => WKMediaCaptureStateNone,
    1 => WKMediaCaptureStateActive,
    2 => WKMediaCaptureStateMuted,
    _ => throw ArgumentError('Unknown value for WKMediaCaptureState: $value'),
  };
}

late final _sel_cameraCaptureState = objc.registerName("cameraCaptureState");
final _objc_msgSend_1s3s7ey = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_microphoneCaptureState = objc.registerName(
  "microphoneCaptureState",
);
late final _sel_setCameraCaptureState_completionHandler_ = objc.registerName(
  "setCameraCaptureState:completionHandler:",
);
final _objc_msgSend_dhyh3z = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_setMicrophoneCaptureState_completionHandler_ = objc
    .registerName("setMicrophoneCaptureState:completionHandler:");

/// WARNING: WKSnapshotConfiguration is a stub. To generate bindings for this class, include
/// WKSnapshotConfiguration in your config's objc-interfaces list.
///
/// WKSnapshotConfiguration
extension type WKSnapshotConfiguration._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [WKSnapshotConfiguration] that points to the same underlying object as [other].
  WKSnapshotConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKSnapshotConfiguration',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
  }

  /// Constructs a [WKSnapshotConfiguration] that wraps the given raw object pointer.
  WKSnapshotConfiguration.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKSnapshotConfiguration',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
  }
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(UIImage?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_UIImage_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(UIImage?, objc.NSError?)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(UIImage?, objc.NSError?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(UIImage?, objc.NSError?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(UIImage?, objc.NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UIImage?, objc.NSError?)>
  fromFunction(
    void Function(UIImage?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(UIImage?, objc.NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : UIImage.fromPointer(arg0, retain: true, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UIImage?, objc.NSError?)> listener(
    void Function(UIImage?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : UIImage.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(UIImage?, objc.NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(UIImage?, objc.NSError?)> blocking(
    void Function(UIImage?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : UIImage.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : UIImage.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(UIImage?, objc.NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(UIImage?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_UIImage_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(UIImage?, objc.NSError?)> {
  void call(UIImage? arg0, objc.NSError? arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObjectImpl> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0?.ref.pointer ?? ffi.nullptr,
        arg1?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_takeSnapshotWithConfiguration_completionHandler_ = objc
    .registerName("takeSnapshotWithConfiguration:completionHandler:");
late final _class_WKPDFConfiguration = objc.getClass("WKPDFConfiguration");
late final _sel_rect = objc.registerName("rect");
late final _sel_setRect_ = objc.registerName("setRect:");
late final _sel_allowTransparentBackground = objc.registerName(
  "allowTransparentBackground",
);
late final _sel_setAllowTransparentBackground_ = objc.registerName(
  "setAllowTransparentBackground:",
);

/// WKPDFConfiguration
extension type WKPDFConfiguration._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [WKPDFConfiguration] that points to the same underlying object as [other].
  WKPDFConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKPDFConfiguration',
      iOS: (false, (13, 4, 0)),
      macOS: (false, (10, 15, 4)),
    );
    assert(isA(object$));
  }

  /// Constructs a [WKPDFConfiguration] that wraps the given raw object pointer.
  WKPDFConfiguration.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKPDFConfiguration',
      iOS: (false, (13, 4, 0)),
      macOS: (false, (10, 15, 4)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [WKPDFConfiguration].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_WKPDFConfiguration,
  );

  /// alloc
  static WKPDFConfiguration alloc() {
    final $ret = _objc_msgSend_151sglz(_class_WKPDFConfiguration, _sel_alloc);
    return WKPDFConfiguration.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static WKPDFConfiguration allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_WKPDFConfiguration,
      _sel_allocWithZone_,
      zone,
    );
    return WKPDFConfiguration.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static WKPDFConfiguration new$() {
    final $ret = _objc_msgSend_151sglz(_class_WKPDFConfiguration, _sel_new);
    return WKPDFConfiguration.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of WKPDFConfiguration constructed with the default `new` method.
  WKPDFConfiguration() : this.as(new$().object$);
}

extension WKPDFConfiguration$Methods on WKPDFConfiguration {
  /// allowTransparentBackground
  bool get allowTransparentBackground {
    objc.checkOsVersionInternal(
      'WKPDFConfiguration.allowTransparentBackground',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowTransparentBackground,
    );
  }

  /// init
  WKPDFConfiguration init() {
    objc.checkOsVersionInternal(
      'WKPDFConfiguration.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return WKPDFConfiguration.fromPointer($ret, retain: false, release: true);
  }

  /// rect
  objc.CGRect get rect {
    objc.checkOsVersionInternal(
      'WKPDFConfiguration.rect',
      iOS: (false, (13, 4, 0)),
      macOS: (false, (10, 15, 4)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, object$.ref.pointer, _sel_rect)
        : $ptr.ref = _objc_msgSend_bu1hbw(object$.ref.pointer, _sel_rect);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// setAllowTransparentBackground:
  set allowTransparentBackground(bool value) {
    objc.checkOsVersionInternal(
      'WKPDFConfiguration.setAllowTransparentBackground:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAllowTransparentBackground_,
      value,
    );
  }

  /// setRect:
  set rect(objc.CGRect value) {
    objc.checkOsVersionInternal(
      'WKPDFConfiguration.setRect:',
      iOS: (false, (13, 4, 0)),
      macOS: (false, (10, 15, 4)),
    );
    _objc_msgSend_1okkq16(object$.ref.pointer, _sel_setRect_, value);
  }
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSData_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
  fromFunction(
    void Function(objc.NSData?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : objc.NSData.fromPointer(arg0, retain: true, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
  listener(
    void Function(objc.NSData?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : objc.NSData.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
  blocking(
    void Function(objc.NSData?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : objc.NSData.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : objc.NSData.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSData_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> {
  void call(objc.NSData? arg0, objc.NSError? arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObjectImpl> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0?.ref.pointer ?? ffi.nullptr,
        arg1?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_createPDFWithConfiguration_completionHandler_ = objc
    .registerName("createPDFWithConfiguration:completionHandler:");
late final _sel_createWebArchiveDataWithCompletionHandler_ = objc.registerName(
  "createWebArchiveDataWithCompletionHandler:",
);
late final _sel_allowsBackForwardNavigationGestures = objc.registerName(
  "allowsBackForwardNavigationGestures",
);
late final _sel_setAllowsBackForwardNavigationGestures_ = objc.registerName(
  "setAllowsBackForwardNavigationGestures:",
);
late final _sel_customUserAgent = objc.registerName("customUserAgent");
late final _sel_setCustomUserAgent_ = objc.registerName("setCustomUserAgent:");
late final _sel_allowsLinkPreview = objc.registerName("allowsLinkPreview");
late final _sel_setAllowsLinkPreview_ = objc.registerName(
  "setAllowsLinkPreview:",
);
late final _sel_scrollView = objc.registerName("scrollView");
late final _sel_pageZoom = objc.registerName("pageZoom");
late final _sel_setPageZoom_ = objc.registerName("setPageZoom:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(WKFindResult)>`.
abstract final class ObjCBlock_ffiVoid_WKFindResult {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(WKFindResult)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(WKFindResult)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(WKFindResult)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(WKFindResult)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(WKFindResult)> fromFunction(
    void Function(WKFindResult) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(WKFindResult)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(WKFindResult.fromPointer(arg0, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(WKFindResult)> listener(
    void Function(WKFindResult) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(WKFindResult.fromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(WKFindResult)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(WKFindResult)> blocking(
    void Function(WKFindResult) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(WKFindResult.fromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(WKFindResult.fromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(WKFindResult)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(WKFindResult)>`.
extension ObjCBlock_ffiVoid_WKFindResult$CallExtension
    on objc.ObjCBlock<ffi.Void Function(WKFindResult)> {
  void call(WKFindResult arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0.ref.pointer);
}

late final _sel_findString_withConfiguration_completionHandler_ = objc
    .registerName("findString:withConfiguration:completionHandler:");
late final _sel_handlesURLScheme_ = objc.registerName("handlesURLScheme:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(WKDownload)>`.
abstract final class ObjCBlock_ffiVoid_WKDownload {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(WKDownload)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(WKDownload)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(WKDownload)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(WKDownload)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(WKDownload)> fromFunction(
    void Function(WKDownload) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(WKDownload)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(WKDownload.fromPointer(arg0, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(WKDownload)> listener(
    void Function(WKDownload) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(WKDownload.fromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(WKDownload)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(WKDownload)> blocking(
    void Function(WKDownload) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(WKDownload.fromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(WKDownload.fromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(WKDownload)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(WKDownload)>`.
extension ObjCBlock_ffiVoid_WKDownload$CallExtension
    on objc.ObjCBlock<ffi.Void Function(WKDownload)> {
  void call(WKDownload arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0.ref.pointer);
}

late final _sel_startDownloadUsingRequest_completionHandler_ = objc
    .registerName("startDownloadUsingRequest:completionHandler:");
late final _sel_resumeDownloadFromResumeData_completionHandler_ = objc
    .registerName("resumeDownloadFromResumeData:completionHandler:");
late final _sel_mediaType = objc.registerName("mediaType");
late final _sel_setMediaType_ = objc.registerName("setMediaType:");
late final _sel_interactionState = objc.registerName("interactionState");
late final _sel_setInteractionState_ = objc.registerName(
  "setInteractionState:",
);
late final _sel_isBlockedByScreenTime = objc.registerName(
  "isBlockedByScreenTime",
);
late final _sel_loadSimulatedRequest_response_responseData_ = objc.registerName(
  "loadSimulatedRequest:response:responseData:",
);
final _objc_msgSend_11spmsz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_loadSimulatedRequest_withResponse_responseData_ = objc
    .registerName("loadSimulatedRequest:withResponse:responseData:");
late final _sel_loadFileRequest_allowingReadAccessToURL_ = objc.registerName(
  "loadFileRequest:allowingReadAccessToURL:",
);
late final _sel_loadSimulatedRequest_responseHTMLString_ = objc.registerName(
  "loadSimulatedRequest:responseHTMLString:",
);
late final _sel_loadSimulatedRequest_withResponseHTMLString_ = objc
    .registerName("loadSimulatedRequest:withResponseHTMLString:");
late final _sel_themeColor = objc.registerName("themeColor");
late final _sel_underPageBackgroundColor = objc.registerName(
  "underPageBackgroundColor",
);
late final _sel_setUnderPageBackgroundColor_ = objc.registerName(
  "setUnderPageBackgroundColor:",
);

enum WKFullscreenState {
  WKFullscreenStateNotInFullscreen(0),
  WKFullscreenStateEnteringFullscreen(1),
  WKFullscreenStateInFullscreen(2),
  WKFullscreenStateExitingFullscreen(3);

  final int value;
  const WKFullscreenState(this.value);

  static WKFullscreenState fromValue(int value) => switch (value) {
    0 => WKFullscreenStateNotInFullscreen,
    1 => WKFullscreenStateEnteringFullscreen,
    2 => WKFullscreenStateInFullscreen,
    3 => WKFullscreenStateExitingFullscreen,
    _ => throw ArgumentError('Unknown value for WKFullscreenState: $value'),
  };
}

late final _sel_fullscreenState = objc.registerName("fullscreenState");
final _objc_msgSend_lnv78v = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_minimumViewportInset = objc.registerName(
  "minimumViewportInset",
);
late final _sel_maximumViewportInset = objc.registerName(
  "maximumViewportInset",
);
late final _sel_setMinimumViewportInset_maximumViewportInset_ = objc
    .registerName("setMinimumViewportInset:maximumViewportInset:");
final _objc_msgSend_j1wf65 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          UIEdgeInsets,
          UIEdgeInsets,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        UIEdgeInsets,
        UIEdgeInsets,
      )
    >();
late final _sel_isFindInteractionEnabled = objc.registerName(
  "isFindInteractionEnabled",
);
late final _sel_setFindInteractionEnabled_ = objc.registerName(
  "setFindInteractionEnabled:",
);
late final _sel_findInteraction = objc.registerName("findInteraction");
late final _sel_conversationContext = objc.registerName("conversationContext");
late final _sel_setConversationContext_ = objc.registerName(
  "setConversationContext:",
);
late final _sel_isInspectable = objc.registerName("isInspectable");
late final _sel_setInspectable_ = objc.registerName("setInspectable:");
late final _sel_isWritingToolsActive = objc.registerName(
  "isWritingToolsActive",
);

sealed class WKWebViewDataType {
  static const WKWebViewDataTypeSessionStorage = 1;
}

late final _sel_fetchDataOfTypes_completionHandler_ = objc.registerName(
  "fetchDataOfTypes:completionHandler:",
);
final _objc_msgSend_13b1z7j = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_restoreData_completionHandler_ = objc.registerName(
  "restoreData:completionHandler:",
);
late final _sel_obscuredContentInsets = objc.registerName(
  "obscuredContentInsets",
);
late final _sel_setObscuredContentInsets_ = objc.registerName(
  "setObscuredContentInsets:",
);
late final _sel_certificateChain = objc.registerName("certificateChain");

/// WKDeprecated
extension WKDeprecated$1 on WKWebView {
  /// certificateChain
  objc.NSArray get certificateChain {
    objc.checkOsVersionInternal(
      'WKWebView.certificateChain',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_certificateChain,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
}

/// WKWebView
extension type WKWebView._(objc.ObjCObject object$)
    implements objc.ObjCObject, UIView {
  /// Constructs a [WKWebView] that points to the same underlying object as [other].
  WKWebView.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'WKWebView',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [WKWebView] that wraps the given raw object pointer.
  WKWebView.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'WKWebView',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [WKWebView].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_WKWebView,
  );

  /// alloc
  static WKWebView alloc() {
    final $ret = _objc_msgSend_151sglz(_class_WKWebView, _sel_alloc);
    return WKWebView.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static WKWebView allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_WKWebView,
      _sel_allocWithZone_,
      zone,
    );
    return WKWebView.fromPointer($ret, retain: false, release: true);
  }

  /// appearance
  static WKWebView appearance() {
    final $ret = _objc_msgSend_151sglz(_class_WKWebView, _sel_appearance);
    return WKWebView.fromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:
  static WKWebView appearanceForTraitCollection(UITraitCollection trait) {
    objc.checkOsVersionInternal(
      'WKWebView.appearanceForTraitCollection:',
      iOS: (false, (8, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_WKWebView,
      _sel_appearanceForTraitCollection_,
      trait.ref.pointer,
    );
    return WKWebView.fromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedIn:
  static WKWebView appearanceForTraitCollection$1(
    UITraitCollection trait, {
    UIAppearanceContainer? whenContainedIn,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.appearanceForTraitCollection:whenContainedIn:',
      iOS: (false, (8, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_WKWebView,
      _sel_appearanceForTraitCollection_whenContainedIn_,
      trait.ref.pointer,
      whenContainedIn?.ref.pointer ?? ffi.nullptr,
    );
    return WKWebView.fromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedInInstancesOfClasses:
  static WKWebView appearanceForTraitCollection$2(
    UITraitCollection trait, {
    required objc.NSArray whenContainedInInstancesOfClasses,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.appearanceForTraitCollection:whenContainedInInstancesOfClasses:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_WKWebView,
      _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_,
      trait.ref.pointer,
      whenContainedInInstancesOfClasses.ref.pointer,
    );
    return WKWebView.fromPointer($ret, retain: true, release: true);
  }

  /// appearanceWhenContainedIn:
  static WKWebView appearanceWhenContainedIn(
    UIAppearanceContainer? ContainerClass,
  ) {
    objc.checkOsVersionInternal(
      'WKWebView.appearanceWhenContainedIn:',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_WKWebView,
      _sel_appearanceWhenContainedIn_,
      ContainerClass?.ref.pointer ?? ffi.nullptr,
    );
    return WKWebView.fromPointer($ret, retain: true, release: true);
  }

  /// appearanceWhenContainedInInstancesOfClasses:
  static WKWebView appearanceWhenContainedInInstancesOfClasses(
    objc.NSArray containerTypes,
  ) {
    objc.checkOsVersionInternal(
      'WKWebView.appearanceWhenContainedInInstancesOfClasses:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_WKWebView,
      _sel_appearanceWhenContainedInInstancesOfClasses_,
      containerTypes.ref.pointer,
    );
    return WKWebView.fromPointer($ret, retain: true, release: true);
  }

  /// handlesURLScheme:
  static bool handlesURLScheme(objc.NSString urlScheme) {
    objc.checkOsVersionInternal(
      'WKWebView.handlesURLScheme:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    return _objc_msgSend_19nvye5(
      _class_WKWebView,
      _sel_handlesURLScheme_,
      urlScheme.ref.pointer,
    );
  }

  /// layerClass
  static objc.ObjCObject getLayerClass() {
    objc.checkOsVersionInternal(
      'WKWebView.layerClass',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_class_WKWebView, _sel_layerClass);
    return objc.ObjCObject($ret, retain: true, release: true);
  }

  /// new
  static WKWebView new$() {
    final $ret = _objc_msgSend_151sglz(_class_WKWebView, _sel_new);
    return WKWebView.fromPointer($ret, retain: false, release: true);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection
  userInterfaceLayoutDirectionForSemanticContentAttribute(
    UISemanticContentAttribute attribute,
  ) {
    objc.checkOsVersionInternal(
      'WKWebView.userInterfaceLayoutDirectionForSemanticContentAttribute:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_racczx(
      _class_WKWebView,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
      attribute.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection
  userInterfaceLayoutDirectionForSemanticContentAttribute$1(
    UISemanticContentAttribute semanticContentAttribute, {
    required UIUserInterfaceLayoutDirection relativeToLayoutDirection,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
      iOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_tz4p54(
      _class_WKWebView,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
      semanticContentAttribute.value,
      relativeToLayoutDirection.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }

  /// Returns a new instance of WKWebView constructed with the default `new` method.
  WKWebView() : this.as(new$().object$);
}

extension WKWebView$Methods on WKWebView {
  /// UIDelegate
  WKUIDelegate? get UIDelegate {
    objc.checkOsVersionInternal(
      'WKWebView.UIDelegate',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_UIDelegate);
    return $ret.address == 0
        ? null
        : WKUIDelegate.fromPointer($ret, retain: true, release: true);
  }

  /// URL
  objc.NSURL? get URL {
    objc.checkOsVersionInternal(
      'WKWebView.URL',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_URL);
    return $ret.address == 0
        ? null
        : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }

  /// allowsBackForwardNavigationGestures
  bool get allowsBackForwardNavigationGestures {
    objc.checkOsVersionInternal(
      'WKWebView.allowsBackForwardNavigationGestures',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowsBackForwardNavigationGestures,
    );
  }

  /// allowsLinkPreview
  bool get allowsLinkPreview {
    objc.checkOsVersionInternal(
      'WKWebView.allowsLinkPreview',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_allowsLinkPreview);
  }

  /// backForwardList
  WKBackForwardList get backForwardList {
    objc.checkOsVersionInternal(
      'WKWebView.backForwardList',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_backForwardList,
    );
    return WKBackForwardList.fromPointer($ret, retain: true, release: true);
  }

  /// callAsyncJavaScript:arguments:inFrame:inContentWorld:completionHandler:
  void callAsyncJavaScript(
    objc.NSString functionBody, {
    objc.NSDictionary? arguments,
    WKFrameInfo? inFrame,
    required WKContentWorld inContentWorld,
    objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
    >?
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.callAsyncJavaScript:arguments:inFrame:inContentWorld:completionHandler:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_e1wgee(
      object$.ref.pointer,
      _sel_callAsyncJavaScript_arguments_inFrame_inContentWorld_completionHandler_,
      functionBody.ref.pointer,
      arguments?.ref.pointer ?? ffi.nullptr,
      inFrame?.ref.pointer ?? ffi.nullptr,
      inContentWorld.ref.pointer,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// cameraCaptureState
  WKMediaCaptureState get cameraCaptureState {
    objc.checkOsVersionInternal(
      'WKWebView.cameraCaptureState',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_1s3s7ey(
      object$.ref.pointer,
      _sel_cameraCaptureState,
    );
    return WKMediaCaptureState.fromValue($ret);
  }

  /// canGoBack
  bool get canGoBack {
    objc.checkOsVersionInternal(
      'WKWebView.canGoBack',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_canGoBack);
  }

  /// canGoForward
  bool get canGoForward {
    objc.checkOsVersionInternal(
      'WKWebView.canGoForward',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_canGoForward);
  }

  /// closeAllMediaPresentations
  void closeAllMediaPresentations() {
    objc.checkOsVersionInternal(
      'WKWebView.closeAllMediaPresentations',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_closeAllMediaPresentations);
  }

  /// closeAllMediaPresentationsWithCompletionHandler:
  void closeAllMediaPresentationsWithCompletionHandler(
    objc.ObjCBlock<ffi.Void Function()>? completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'WKWebView.closeAllMediaPresentationsWithCompletionHandler:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_closeAllMediaPresentationsWithCompletionHandler_,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// configuration
  WKWebViewConfiguration get configuration {
    objc.checkOsVersionInternal(
      'WKWebView.configuration',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_configuration);
    return WKWebViewConfiguration.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// conversationContext
  UIConversationContext get conversationContext {
    objc.checkOsVersionInternal(
      'WKWebView.conversationContext',
      iOS: (false, (26, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_conversationContext,
    );
    return UIConversationContext.fromPointer($ret, retain: true, release: true);
  }

  /// createPDFWithConfiguration:completionHandler:
  void createPDFWithConfiguration(
    WKPDFConfiguration? pdfConfiguration, {
    required objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.createPDFWithConfiguration:completionHandler:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_o762yo(
      object$.ref.pointer,
      _sel_createPDFWithConfiguration_completionHandler_,
      pdfConfiguration?.ref.pointer ?? ffi.nullptr,
      completionHandler.ref.pointer,
    );
  }

  /// createWebArchiveDataWithCompletionHandler:
  void createWebArchiveDataWithCompletionHandler(
    objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
    completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'WKWebView.createWebArchiveDataWithCompletionHandler:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_createWebArchiveDataWithCompletionHandler_,
      completionHandler.ref.pointer,
    );
  }

  /// customUserAgent
  objc.NSString? get customUserAgent {
    objc.checkOsVersionInternal(
      'WKWebView.customUserAgent',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_customUserAgent,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// estimatedProgress
  double get estimatedProgress {
    objc.checkOsVersionInternal(
      'WKWebView.estimatedProgress',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            object$.ref.pointer,
            _sel_estimatedProgress,
          )
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_estimatedProgress);
  }

  /// evaluateJavaScript:completionHandler:
  void evaluateJavaScript(
    objc.NSString javaScriptString, {
    objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
    >?
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.evaluateJavaScript:completionHandler:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_o762yo(
      object$.ref.pointer,
      _sel_evaluateJavaScript_completionHandler_,
      javaScriptString.ref.pointer,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// evaluateJavaScript:inFrame:inContentWorld:completionHandler:
  void evaluateJavaScript$1(
    objc.NSString javaScriptString, {
    WKFrameInfo? inFrame,
    required WKContentWorld inContentWorld,
    objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, objc.NSError?)
    >?
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.evaluateJavaScript:inFrame:inContentWorld:completionHandler:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_m7tls4(
      object$.ref.pointer,
      _sel_evaluateJavaScript_inFrame_inContentWorld_completionHandler_,
      javaScriptString.ref.pointer,
      inFrame?.ref.pointer ?? ffi.nullptr,
      inContentWorld.ref.pointer,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// fetchDataOfTypes:completionHandler:
  void fetchDataOfTypes(
    int dataTypes, {
    required objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.fetchDataOfTypes:completionHandler:',
      iOS: (false, (26, 0, 0)),
      macOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_13b1z7j(
      object$.ref.pointer,
      _sel_fetchDataOfTypes_completionHandler_,
      dataTypes,
      completionHandler.ref.pointer,
    );
  }

  /// findInteraction
  UIFindInteraction? get findInteraction {
    objc.checkOsVersionInternal(
      'WKWebView.findInteraction',
      iOS: (false, (16, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_findInteraction,
    );
    return $ret.address == 0
        ? null
        : UIFindInteraction.fromPointer($ret, retain: true, release: true);
  }

  /// findString:withConfiguration:completionHandler:
  void findString(
    objc.NSString string, {
    WKFindConfiguration? withConfiguration,
    required objc.ObjCBlock<ffi.Void Function(WKFindResult)> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.findString:withConfiguration:completionHandler:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_findString_withConfiguration_completionHandler_,
      string.ref.pointer,
      withConfiguration?.ref.pointer ?? ffi.nullptr,
      completionHandler.ref.pointer,
    );
  }

  /// fullscreenState
  WKFullscreenState get fullscreenState {
    objc.checkOsVersionInternal(
      'WKWebView.fullscreenState',
      iOS: (false, (16, 0, 0)),
      macOS: (false, (13, 0, 0)),
    );
    final $ret = _objc_msgSend_lnv78v(
      object$.ref.pointer,
      _sel_fullscreenState,
    );
    return WKFullscreenState.fromValue($ret);
  }

  /// goBack
  WKNavigation? goBack() {
    objc.checkOsVersionInternal(
      'WKWebView.goBack',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_goBack);
    return $ret.address == 0
        ? null
        : WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// goForward
  WKNavigation? goForward() {
    objc.checkOsVersionInternal(
      'WKWebView.goForward',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_goForward);
    return $ret.address == 0
        ? null
        : WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// goToBackForwardListItem:
  WKNavigation? goToBackForwardListItem(WKBackForwardListItem item) {
    objc.checkOsVersionInternal(
      'WKWebView.goToBackForwardListItem:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_goToBackForwardListItem_,
      item.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// hasOnlySecureContent
  bool get hasOnlySecureContent {
    objc.checkOsVersionInternal(
      'WKWebView.hasOnlySecureContent',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_hasOnlySecureContent);
  }

  /// init
  WKWebView init() {
    objc.checkOsVersionInternal(
      'WKWebView.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return WKWebView.fromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  WKWebView? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : WKWebView.fromPointer($ret, retain: false, release: true);
  }

  /// initWithFrame:
  WKWebView initWithFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal(
      'WKWebView.initWithFrame:',
      iOS: (false, (2, 0, 0)),
    );
    final $ret = _objc_msgSend_15yz4e6(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithFrame_,
      frame,
    );
    return WKWebView.fromPointer($ret, retain: false, release: true);
  }

  /// initWithFrame:configuration:
  WKWebView initWithFrame$1(
    objc.CGRect frame, {
    required WKWebViewConfiguration configuration,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.initWithFrame:configuration:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_gxusyk(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithFrame_configuration_,
      frame,
      configuration.ref.pointer,
    );
    return WKWebView.fromPointer($ret, retain: false, release: true);
  }

  /// interactionState
  objc.ObjCObject? get interactionState {
    objc.checkOsVersionInternal(
      'WKWebView.interactionState',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_interactionState,
    );
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// isBlockedByScreenTime
  bool get isBlockedByScreenTime {
    objc.checkOsVersionInternal(
      'WKWebView.isBlockedByScreenTime',
      iOS: (false, (26, 0, 0)),
      macOS: (false, (26, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isBlockedByScreenTime,
    );
  }

  /// isFindInteractionEnabled
  bool get isFindInteractionEnabled {
    objc.checkOsVersionInternal(
      'WKWebView.isFindInteractionEnabled',
      iOS: (false, (16, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_isFindInteractionEnabled,
    );
  }

  /// isInspectable
  bool get isInspectable {
    objc.checkOsVersionInternal(
      'WKWebView.isInspectable',
      iOS: (false, (16, 4, 0)),
      macOS: (false, (13, 3, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isInspectable);
  }

  /// isLoading
  bool get isLoading {
    objc.checkOsVersionInternal(
      'WKWebView.isLoading',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isLoading);
  }

  /// isWritingToolsActive
  bool get isWritingToolsActive {
    objc.checkOsVersionInternal(
      'WKWebView.isWritingToolsActive',
      iOS: (false, (18, 0, 0)),
      macOS: (false, (15, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isWritingToolsActive);
  }

  /// loadData:MIMEType:characterEncodingName:baseURL:
  WKNavigation? loadData(
    objc.NSData data, {
    required objc.NSString MIMEType,
    required objc.NSString characterEncodingName,
    required objc.NSURL baseURL,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.loadData:MIMEType:characterEncodingName:baseURL:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_s92gih(
      object$.ref.pointer,
      _sel_loadData_MIMEType_characterEncodingName_baseURL_,
      data.ref.pointer,
      MIMEType.ref.pointer,
      characterEncodingName.ref.pointer,
      baseURL.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// loadFileRequest:allowingReadAccessToURL:
  WKNavigation loadFileRequest(
    NSURLRequest request, {
    required objc.NSURL allowingReadAccessToURL,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.loadFileRequest:allowingReadAccessToURL:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_loadFileRequest_allowingReadAccessToURL_,
      request.ref.pointer,
      allowingReadAccessToURL.ref.pointer,
    );
    return WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// loadFileURL:allowingReadAccessToURL:
  WKNavigation? loadFileURL(
    objc.NSURL URL, {
    required objc.NSURL allowingReadAccessToURL,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.loadFileURL:allowingReadAccessToURL:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_loadFileURL_allowingReadAccessToURL_,
      URL.ref.pointer,
      allowingReadAccessToURL.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// loadHTMLString:baseURL:
  WKNavigation? loadHTMLString(objc.NSString string, {objc.NSURL? baseURL}) {
    objc.checkOsVersionInternal(
      'WKWebView.loadHTMLString:baseURL:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_loadHTMLString_baseURL_,
      string.ref.pointer,
      baseURL?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0
        ? null
        : WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// loadRequest:
  WKNavigation? loadRequest(NSURLRequest request) {
    objc.checkOsVersionInternal(
      'WKWebView.loadRequest:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_loadRequest_,
      request.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// loadSimulatedRequest:response:responseData:
  WKNavigation loadSimulatedRequest(
    NSURLRequest request, {
    required NSURLResponse response,
    required objc.NSData responseData,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.loadSimulatedRequest:response:responseData:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      object$.ref.pointer,
      _sel_loadSimulatedRequest_response_responseData_,
      request.ref.pointer,
      response.ref.pointer,
      responseData.ref.pointer,
    );
    return WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// loadSimulatedRequest:responseHTMLString:
  WKNavigation loadSimulatedRequest$1(
    NSURLRequest request, {
    required objc.NSString responseHTMLString,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.loadSimulatedRequest:responseHTMLString:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_loadSimulatedRequest_responseHTMLString_,
      request.ref.pointer,
      responseHTMLString.ref.pointer,
    );
    return WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// loadSimulatedRequest:withResponse:responseData:
  WKNavigation loadSimulatedRequest$2(
    NSURLRequest request, {
    required NSURLResponse withResponse,
    required objc.NSData responseData,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.loadSimulatedRequest:withResponse:responseData:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      object$.ref.pointer,
      _sel_loadSimulatedRequest_withResponse_responseData_,
      request.ref.pointer,
      withResponse.ref.pointer,
      responseData.ref.pointer,
    );
    return WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// loadSimulatedRequest:withResponseHTMLString:
  WKNavigation loadSimulatedRequest$3(
    NSURLRequest request, {
    required objc.NSString withResponseHTMLString,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.loadSimulatedRequest:withResponseHTMLString:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_loadSimulatedRequest_withResponseHTMLString_,
      request.ref.pointer,
      withResponseHTMLString.ref.pointer,
    );
    return WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// maximumViewportInset
  UIEdgeInsets get maximumViewportInset {
    objc.checkOsVersionInternal(
      'WKWebView.maximumViewportInset',
      iOS: (false, (15, 5, 0)),
    );
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(
            $ptr,
            object$.ref.pointer,
            _sel_maximumViewportInset,
          )
        : $ptr.ref = _objc_msgSend_ct4cu5(
            object$.ref.pointer,
            _sel_maximumViewportInset,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// mediaType
  objc.NSString? get mediaType {
    objc.checkOsVersionInternal(
      'WKWebView.mediaType',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_mediaType);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// microphoneCaptureState
  WKMediaCaptureState get microphoneCaptureState {
    objc.checkOsVersionInternal(
      'WKWebView.microphoneCaptureState',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_1s3s7ey(
      object$.ref.pointer,
      _sel_microphoneCaptureState,
    );
    return WKMediaCaptureState.fromValue($ret);
  }

  /// minimumViewportInset
  UIEdgeInsets get minimumViewportInset {
    objc.checkOsVersionInternal(
      'WKWebView.minimumViewportInset',
      iOS: (false, (15, 5, 0)),
    );
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(
            $ptr,
            object$.ref.pointer,
            _sel_minimumViewportInset,
          )
        : $ptr.ref = _objc_msgSend_ct4cu5(
            object$.ref.pointer,
            _sel_minimumViewportInset,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// navigationDelegate
  WKNavigationDelegate? get navigationDelegate {
    objc.checkOsVersionInternal(
      'WKWebView.navigationDelegate',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_navigationDelegate,
    );
    return $ret.address == 0
        ? null
        : WKNavigationDelegate.fromPointer($ret, retain: true, release: true);
  }

  /// obscuredContentInsets
  UIEdgeInsets get obscuredContentInsets {
    objc.checkOsVersionInternal(
      'WKWebView.obscuredContentInsets',
      iOS: (false, (26, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret(
            $ptr,
            object$.ref.pointer,
            _sel_obscuredContentInsets,
          )
        : $ptr.ref = _objc_msgSend_ct4cu5(
            object$.ref.pointer,
            _sel_obscuredContentInsets,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// pageZoom
  double get pageZoom {
    objc.checkOsVersionInternal(
      'WKWebView.pageZoom',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_pageZoom)
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_pageZoom);
  }

  /// pauseAllMediaPlayback:
  void pauseAllMediaPlayback(
    objc.ObjCBlock<ffi.Void Function()>? completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'WKWebView.pauseAllMediaPlayback:',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_pauseAllMediaPlayback_,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// pauseAllMediaPlaybackWithCompletionHandler:
  void pauseAllMediaPlaybackWithCompletionHandler(
    objc.ObjCBlock<ffi.Void Function()>? completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'WKWebView.pauseAllMediaPlaybackWithCompletionHandler:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_pauseAllMediaPlaybackWithCompletionHandler_,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// reload
  WKNavigation? reload() {
    objc.checkOsVersionInternal(
      'WKWebView.reload',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_reload);
    return $ret.address == 0
        ? null
        : WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// reloadFromOrigin
  WKNavigation? reloadFromOrigin() {
    objc.checkOsVersionInternal(
      'WKWebView.reloadFromOrigin',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_reloadFromOrigin,
    );
    return $ret.address == 0
        ? null
        : WKNavigation.fromPointer($ret, retain: true, release: true);
  }

  /// requestMediaPlaybackState:
  void requestMediaPlaybackState(
    objc.ObjCBlock<ffi.Void Function(ffi.Long)> completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'WKWebView.requestMediaPlaybackState:',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_requestMediaPlaybackState_,
      completionHandler.ref.pointer,
    );
  }

  /// requestMediaPlaybackStateWithCompletionHandler:
  void requestMediaPlaybackStateWithCompletionHandler(
    objc.ObjCBlock<ffi.Void Function(ffi.Long)> completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'WKWebView.requestMediaPlaybackStateWithCompletionHandler:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_requestMediaPlaybackStateWithCompletionHandler_,
      completionHandler.ref.pointer,
    );
  }

  /// restoreData:completionHandler:
  void restoreData(
    objc.NSData data, {
    required objc.ObjCBlock<ffi.Void Function(objc.NSError?)> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.restoreData:completionHandler:',
      iOS: (false, (26, 0, 0)),
      macOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_o762yo(
      object$.ref.pointer,
      _sel_restoreData_completionHandler_,
      data.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// resumeAllMediaPlayback:
  void resumeAllMediaPlayback(
    objc.ObjCBlock<ffi.Void Function()>? completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'WKWebView.resumeAllMediaPlayback:',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_resumeAllMediaPlayback_,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// resumeDownloadFromResumeData:completionHandler:
  void resumeDownloadFromResumeData(
    objc.NSData resumeData, {
    required objc.ObjCBlock<ffi.Void Function(WKDownload)> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.resumeDownloadFromResumeData:completionHandler:',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    _objc_msgSend_o762yo(
      object$.ref.pointer,
      _sel_resumeDownloadFromResumeData_completionHandler_,
      resumeData.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// scrollView
  UIScrollView get scrollView {
    objc.checkOsVersionInternal(
      'WKWebView.scrollView',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_scrollView);
    return UIScrollView.fromPointer($ret, retain: true, release: true);
  }

  /// serverTrust
  ffi.Pointer<__SecTrust> get serverTrust {
    objc.checkOsVersionInternal(
      'WKWebView.serverTrust',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
    return _objc_msgSend_1ommad9(object$.ref.pointer, _sel_serverTrust);
  }

  /// setAllMediaPlaybackSuspended:completionHandler:
  void setAllMediaPlaybackSuspended(
    bool suspended, {
    objc.ObjCBlock<ffi.Void Function()>? completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.setAllMediaPlaybackSuspended:completionHandler:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    _objc_msgSend_1ocak7a(
      object$.ref.pointer,
      _sel_setAllMediaPlaybackSuspended_completionHandler_,
      suspended,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAllowsBackForwardNavigationGestures:
  set allowsBackForwardNavigationGestures(bool value) {
    objc.checkOsVersionInternal(
      'WKWebView.setAllowsBackForwardNavigationGestures:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAllowsBackForwardNavigationGestures_,
      value,
    );
  }

  /// setAllowsLinkPreview:
  set allowsLinkPreview(bool value) {
    objc.checkOsVersionInternal(
      'WKWebView.setAllowsLinkPreview:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAllowsLinkPreview_,
      value,
    );
  }

  /// setCameraCaptureState:completionHandler:
  void setCameraCaptureState(
    WKMediaCaptureState state, {
    objc.ObjCBlock<ffi.Void Function()>? completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.setCameraCaptureState:completionHandler:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    _objc_msgSend_dhyh3z(
      object$.ref.pointer,
      _sel_setCameraCaptureState_completionHandler_,
      state.value,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setConversationContext:
  set conversationContext(UIConversationContext value) {
    objc.checkOsVersionInternal(
      'WKWebView.setConversationContext:',
      iOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setConversationContext_,
      value.ref.pointer,
    );
  }

  /// setCustomUserAgent:
  set customUserAgent(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'WKWebView.setCustomUserAgent:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setCustomUserAgent_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setFindInteractionEnabled:
  set isFindInteractionEnabled(bool value) {
    objc.checkOsVersionInternal(
      'WKWebView.setFindInteractionEnabled:',
      iOS: (false, (16, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setFindInteractionEnabled_,
      value,
    );
  }

  /// setInspectable:
  set isInspectable(bool value) {
    objc.checkOsVersionInternal(
      'WKWebView.setInspectable:',
      iOS: (false, (16, 4, 0)),
      macOS: (false, (13, 3, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setInspectable_, value);
  }

  /// setInteractionState:
  set interactionState(objc.ObjCObject? value) {
    objc.checkOsVersionInternal(
      'WKWebView.setInteractionState:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setInteractionState_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setMediaType:
  set mediaType(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'WKWebView.setMediaType:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMediaType_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setMicrophoneCaptureState:completionHandler:
  void setMicrophoneCaptureState(
    WKMediaCaptureState state, {
    objc.ObjCBlock<ffi.Void Function()>? completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.setMicrophoneCaptureState:completionHandler:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    _objc_msgSend_dhyh3z(
      object$.ref.pointer,
      _sel_setMicrophoneCaptureState_completionHandler_,
      state.value,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setMinimumViewportInset:maximumViewportInset:
  void setMinimumViewportInset(
    UIEdgeInsets minimumViewportInset, {
    required UIEdgeInsets maximumViewportInset,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.setMinimumViewportInset:maximumViewportInset:',
      iOS: (false, (15, 5, 0)),
    );
    _objc_msgSend_j1wf65(
      object$.ref.pointer,
      _sel_setMinimumViewportInset_maximumViewportInset_,
      minimumViewportInset,
      maximumViewportInset,
    );
  }

  /// setNavigationDelegate:
  set navigationDelegate(WKNavigationDelegate? value) {
    objc.checkOsVersionInternal(
      'WKWebView.setNavigationDelegate:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setNavigationDelegate_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setObscuredContentInsets:
  set obscuredContentInsets(UIEdgeInsets value) {
    objc.checkOsVersionInternal(
      'WKWebView.setObscuredContentInsets:',
      iOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_1g8fos5(
      object$.ref.pointer,
      _sel_setObscuredContentInsets_,
      value,
    );
  }

  /// setPageZoom:
  set pageZoom(double value) {
    objc.checkOsVersionInternal(
      'WKWebView.setPageZoom:',
      iOS: (false, (14, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setPageZoom_, value);
  }

  /// setUIDelegate:
  set UIDelegate(WKUIDelegate? value) {
    objc.checkOsVersionInternal(
      'WKWebView.setUIDelegate:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setUIDelegate_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setUnderPageBackgroundColor:
  set underPageBackgroundColor(UIColor value) {
    objc.checkOsVersionInternal(
      'WKWebView.setUnderPageBackgroundColor:',
      iOS: (false, (15, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setUnderPageBackgroundColor_,
      value.ref.pointer,
    );
  }

  /// startDownloadUsingRequest:completionHandler:
  void startDownloadUsingRequest(
    NSURLRequest request, {
    required objc.ObjCBlock<ffi.Void Function(WKDownload)> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.startDownloadUsingRequest:completionHandler:',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    _objc_msgSend_o762yo(
      object$.ref.pointer,
      _sel_startDownloadUsingRequest_completionHandler_,
      request.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// stopLoading
  void stopLoading() {
    objc.checkOsVersionInternal(
      'WKWebView.stopLoading',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_stopLoading);
  }

  /// suspendAllMediaPlayback:
  void suspendAllMediaPlayback(
    objc.ObjCBlock<ffi.Void Function()>? completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'WKWebView.suspendAllMediaPlayback:',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_suspendAllMediaPlayback_,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// takeSnapshotWithConfiguration:completionHandler:
  void takeSnapshotWithConfiguration(
    WKSnapshotConfiguration? snapshotConfiguration, {
    required objc.ObjCBlock<ffi.Void Function(UIImage?, objc.NSError?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'WKWebView.takeSnapshotWithConfiguration:completionHandler:',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_o762yo(
      object$.ref.pointer,
      _sel_takeSnapshotWithConfiguration_completionHandler_,
      snapshotConfiguration?.ref.pointer ?? ffi.nullptr,
      completionHandler.ref.pointer,
    );
  }

  /// themeColor
  UIColor? get themeColor {
    objc.checkOsVersionInternal(
      'WKWebView.themeColor',
      iOS: (false, (15, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_themeColor);
    return $ret.address == 0
        ? null
        : UIColor.fromPointer($ret, retain: true, release: true);
  }

  /// title
  objc.NSString? get title {
    objc.checkOsVersionInternal(
      'WKWebView.title',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_title);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// underPageBackgroundColor
  UIColor get underPageBackgroundColor {
    objc.checkOsVersionInternal(
      'WKWebView.underPageBackgroundColor',
      iOS: (false, (15, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_underPageBackgroundColor,
    );
    return UIColor.fromPointer($ret, retain: true, release: true);
  }
}

enum WKCookiePolicy {
  WKCookiePolicyAllow(0),
  WKCookiePolicyDisallow(1);

  final int value;
  const WKCookiePolicy(this.value);

  static WKCookiePolicy fromValue(int value) => switch (value) {
    0 => WKCookiePolicyAllow,
    1 => WKCookiePolicyDisallow,
    _ => throw ArgumentError('Unknown value for WKCookiePolicy: $value'),
  };
}

enum WKContentMode {
  WKContentModeRecommended(0),
  WKContentModeMobile(1),
  WKContentModeDesktop(2);

  final int value;
  const WKContentMode(this.value);

  static WKContentMode fromValue(int value) => switch (value) {
    0 => WKContentModeRecommended,
    1 => WKContentModeMobile,
    2 => WKContentModeDesktop,
    _ => throw ArgumentError('Unknown value for WKContentMode: $value'),
  };
}

enum WKWebpagePreferencesUpgradeToHTTPSPolicy {
  WKWebpagePreferencesUpgradeToHTTPSPolicyKeepAsRequested(0),
  WKWebpagePreferencesUpgradeToHTTPSPolicyAutomaticFallbackToHTTP(1),
  WKWebpagePreferencesUpgradeToHTTPSPolicyUserMediatedFallbackToHTTP(2),
  WKWebpagePreferencesUpgradeToHTTPSPolicyErrorOnFailure(3);

  final int value;
  const WKWebpagePreferencesUpgradeToHTTPSPolicy(this.value);

  static WKWebpagePreferencesUpgradeToHTTPSPolicy fromValue(int value) =>
      switch (value) {
        0 => WKWebpagePreferencesUpgradeToHTTPSPolicyKeepAsRequested,
        1 => WKWebpagePreferencesUpgradeToHTTPSPolicyAutomaticFallbackToHTTP,
        2 => WKWebpagePreferencesUpgradeToHTTPSPolicyUserMediatedFallbackToHTTP,
        3 => WKWebpagePreferencesUpgradeToHTTPSPolicyErrorOnFailure,
        _ => throw ArgumentError(
          'Unknown value for WKWebpagePreferencesUpgradeToHTTPSPolicy: $value',
        ),
      };
}

enum WKNavigationType {
  WKNavigationTypeLinkActivated(0),
  WKNavigationTypeFormSubmitted(1),
  WKNavigationTypeBackForward(2),
  WKNavigationTypeReload(3),
  WKNavigationTypeFormResubmitted(4),
  WKNavigationTypeOther(-1);

  final int value;
  const WKNavigationType(this.value);

  static WKNavigationType fromValue(int value) => switch (value) {
    0 => WKNavigationTypeLinkActivated,
    1 => WKNavigationTypeFormSubmitted,
    2 => WKNavigationTypeBackForward,
    3 => WKNavigationTypeReload,
    4 => WKNavigationTypeFormResubmitted,
    -1 => WKNavigationTypeOther,
    _ => throw ArgumentError('Unknown value for WKNavigationType: $value'),
  };
}

enum WKInactiveSchedulingPolicy {
  WKInactiveSchedulingPolicySuspend(0),
  WKInactiveSchedulingPolicyThrottle(1),
  WKInactiveSchedulingPolicyNone(2);

  final int value;
  const WKInactiveSchedulingPolicy(this.value);

  static WKInactiveSchedulingPolicy fromValue(int value) => switch (value) {
    0 => WKInactiveSchedulingPolicySuspend,
    1 => WKInactiveSchedulingPolicyThrottle,
    2 => WKInactiveSchedulingPolicyNone,
    _ => throw ArgumentError(
      'Unknown value for WKInactiveSchedulingPolicy: $value',
    ),
  };
}

enum WKPermissionDecision {
  WKPermissionDecisionPrompt(0),
  WKPermissionDecisionGrant(1),
  WKPermissionDecisionDeny(2);

  final int value;
  const WKPermissionDecision(this.value);

  static WKPermissionDecision fromValue(int value) => switch (value) {
    0 => WKPermissionDecisionPrompt,
    1 => WKPermissionDecisionGrant,
    2 => WKPermissionDecisionDeny,
    _ => throw ArgumentError('Unknown value for WKPermissionDecision: $value'),
  };
}

enum WKMediaCaptureType {
  WKMediaCaptureTypeCamera(0),
  WKMediaCaptureTypeMicrophone(1),
  WKMediaCaptureTypeCameraAndMicrophone(2);

  final int value;
  const WKMediaCaptureType(this.value);

  static WKMediaCaptureType fromValue(int value) => switch (value) {
    0 => WKMediaCaptureTypeCamera,
    1 => WKMediaCaptureTypeMicrophone,
    2 => WKMediaCaptureTypeCameraAndMicrophone,
    _ => throw ArgumentError('Unknown value for WKMediaCaptureType: $value'),
  };
}

enum WKDialogResult {
  WKDialogResultShowDefault(1),
  WKDialogResultAskAgain(2),
  WKDialogResultHandled(3);

  final int value;
  const WKDialogResult(this.value);

  static WKDialogResult fromValue(int value) => switch (value) {
    1 => WKDialogResultShowDefault,
    2 => WKDialogResultAskAgain,
    3 => WKDialogResultHandled,
    _ => throw ArgumentError('Unknown value for WKDialogResult: $value'),
  };
}

enum WKUserScriptInjectionTime {
  WKUserScriptInjectionTimeAtDocumentStart(0),
  WKUserScriptInjectionTimeAtDocumentEnd(1);

  final int value;
  const WKUserScriptInjectionTime(this.value);

  static WKUserScriptInjectionTime fromValue(int value) => switch (value) {
    0 => WKUserScriptInjectionTimeAtDocumentStart,
    1 => WKUserScriptInjectionTimeAtDocumentEnd,
    _ => throw ArgumentError(
      'Unknown value for WKUserScriptInjectionTime: $value',
    ),
  };
}

sealed class WKWebExtensionMatchPatternOptions {
  static const WKWebExtensionMatchPatternOptionsNone = 0;
  static const WKWebExtensionMatchPatternOptionsIgnoreSchemes = 1;
  static const WKWebExtensionMatchPatternOptionsIgnorePaths = 2;
  static const WKWebExtensionMatchPatternOptionsMatchBidirectionally = 4;
}

sealed class WKWebExtensionTabChangedProperties {
  static const WKWebExtensionTabChangedPropertiesNone = 0;
  static const WKWebExtensionTabChangedPropertiesLoading = 2;
  static const WKWebExtensionTabChangedPropertiesMuted = 4;
  static const WKWebExtensionTabChangedPropertiesPinned = 8;
  static const WKWebExtensionTabChangedPropertiesPlayingAudio = 16;
  static const WKWebExtensionTabChangedPropertiesReaderMode = 32;
  static const WKWebExtensionTabChangedPropertiesSize = 64;
  static const WKWebExtensionTabChangedPropertiesTitle = 128;
  static const WKWebExtensionTabChangedPropertiesURL = 256;
  static const WKWebExtensionTabChangedPropertiesZoomFactor = 512;
}

enum WKWebExtensionContextPermissionStatus {
  WKWebExtensionContextPermissionStatusDeniedExplicitly(-3),
  WKWebExtensionContextPermissionStatusDeniedImplicitly(-2),
  WKWebExtensionContextPermissionStatusRequestedImplicitly(-1),
  WKWebExtensionContextPermissionStatusUnknown(0),
  WKWebExtensionContextPermissionStatusRequestedExplicitly(1),
  WKWebExtensionContextPermissionStatusGrantedImplicitly(2),
  WKWebExtensionContextPermissionStatusGrantedExplicitly(3);

  final int value;
  const WKWebExtensionContextPermissionStatus(this.value);

  static WKWebExtensionContextPermissionStatus fromValue(int value) =>
      switch (value) {
        -3 => WKWebExtensionContextPermissionStatusDeniedExplicitly,
        -2 => WKWebExtensionContextPermissionStatusDeniedImplicitly,
        -1 => WKWebExtensionContextPermissionStatusRequestedImplicitly,
        0 => WKWebExtensionContextPermissionStatusUnknown,
        1 => WKWebExtensionContextPermissionStatusRequestedExplicitly,
        2 => WKWebExtensionContextPermissionStatusGrantedImplicitly,
        3 => WKWebExtensionContextPermissionStatusGrantedExplicitly,
        _ => throw ArgumentError(
          'Unknown value for WKWebExtensionContextPermissionStatus: $value',
        ),
      };
}

enum WKWebExtensionWindowType {
  WKWebExtensionWindowTypeNormal(0),
  WKWebExtensionWindowTypePopup(1);

  final int value;
  const WKWebExtensionWindowType(this.value);

  static WKWebExtensionWindowType fromValue(int value) => switch (value) {
    0 => WKWebExtensionWindowTypeNormal,
    1 => WKWebExtensionWindowTypePopup,
    _ => throw ArgumentError(
      'Unknown value for WKWebExtensionWindowType: $value',
    ),
  };
}

enum WKWebExtensionWindowState {
  WKWebExtensionWindowStateNormal(0),
  WKWebExtensionWindowStateMinimized(1),
  WKWebExtensionWindowStateMaximized(2),
  WKWebExtensionWindowStateFullscreen(3);

  final int value;
  const WKWebExtensionWindowState(this.value);

  static WKWebExtensionWindowState fromValue(int value) => switch (value) {
    0 => WKWebExtensionWindowStateNormal,
    1 => WKWebExtensionWindowStateMinimized,
    2 => WKWebExtensionWindowStateMaximized,
    3 => WKWebExtensionWindowStateFullscreen,
    _ => throw ArgumentError(
      'Unknown value for WKWebExtensionWindowState: $value',
    ),
  };
}
