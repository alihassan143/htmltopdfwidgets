import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;

import '../htmltagstyles.dart';
import 'css_style.dart';
import 'image_builder_io.dart' if (dart.library.html) 'image_builder_web.dart'
    as image_builder;
import 'render_node.dart';

/// [PdfBuilder] converts a tree of [RenderNode]s into a list of [pw.Widget]s.
///
/// It traverses the render tree and creates corresponding PDF widgets (e.g.,
/// [pw.Container], [pw.Text], [pw.RichText], [pw.Table]) based on the
/// node type and its computed [CSSStyle].
class PdfBuilder {
  /// The root node of the render tree.
  final RenderNode root;

  /// Custom tag styles for checkbox customization.
  final HtmlTagStyle tagStyle;

  /// Fallback fonts for handling emojis and multiple languages.
  final List<pw.Font> fontFallback;

  /// Creates an instance of [PdfBuilder].
  ///
  /// [root] is the root [RenderNode] generated by [HtmlParser].
  /// [tagStyle] provides custom styling options including checkbox icons.
  /// [fontFallback] provides fonts for special characters and emojis.
  PdfBuilder({
    required this.root,
    this.tagStyle = const HtmlTagStyle(),
    this.fontFallback = const [],
  });

  /// Builds the PDF widgets from the render tree.
  Future<List<pw.Widget>> build() async {
    return await _buildBlock(root);
  }

  /// Builds widgets for a block-level node.
  ///
  /// This method handles:
  /// - Specific block tags (img, table, hr, blockquote, pre, etc.).
  /// - Block elements containing only inline content (rendered as [pw.RichText]).
  /// - Generic block elements with mixed content (recursively building children).
  Future<List<pw.Widget>> _buildBlock(RenderNode node) async {
    print('Building block: ${node.tagName} children:${node.children.length}');
    final widgets = <pw.Widget>[];

    if (node.display == Display.none) return widgets;

    // Handle specific tags that map to specific Widgets
    if (node.tagName == 'img') {
      return [await _buildImage(node)];
    } else if (node.tagName == 'table') {
      return [await _buildTable(node)];
    } else if (node.tagName == 'hr') {
      return [
        pw.Divider(
            color: node.style.border?.bottom.color ?? PdfColors.grey400,
            thickness: node.style.border?.bottom.width ?? 1.0)
      ];
    } else if (node.tagName == 'blockquote') {
      return [await _buildBlockquote(node)];
    } else if (node.tagName == 'pre') {
      return [_buildPreBlock(node)];
    } else if (node.tagName == 'br') {
      return [pw.SizedBox(height: 12)]; // Line break as vertical space
    }

    return await _buildBlockContent(node);
  }

  /// Builds the content of a block (children).
  Future<List<pw.Widget>> _buildBlockContent(RenderNode node) async {
    final widgets = <pw.Widget>[];

    // Check if this block contains only inline content (text, spans, b, i, etc.)
    // If so, render as RichText widgets (may be split into multiple for page spanning)
    if (_hasOnlyInlineContent(node)) {
      final richTextWidgets = _buildRichTextFromNode(node);
      if (richTextWidgets.isNotEmpty) {
        return richTextWidgets;
      }
      return [];
    }

    // Generic block processing - mixed content
    List<RenderNode> inlineGroup = [];
    int i = 0;

    while (i < node.children.length) {
      final child = node.children[i];
      if (child.display == Display.none) {
        i++;
        continue;
      }

      if (child.display == Display.inline ||
          child.tagName == '#text' ||
          (child.tagName == 'input' &&
              child.attributes['type'] == 'checkbox') ||
          child.tagName == 'label') {
        // Handle br tags specially in inline context
        if (child.tagName == 'br') {
          if (inlineGroup.isNotEmpty) {
            widgets.add(_buildRichText(inlineGroup, node.style));
            inlineGroup = [];
          }
          widgets.add(pw.SizedBox(height: 8));
        } else {
          inlineGroup.add(child);
        }
      } else {
        if (inlineGroup.isNotEmpty) {
          widgets.add(_buildRichText(inlineGroup, node.style));
          inlineGroup = [];
        }

        // Check if child is a list item inside a list
        if (child.tagName == 'li' &&
            (node.tagName == 'ul' || node.tagName == 'ol')) {
          widgets.add(await _buildListItem(
              child, node.tagName == 'ol', node.children.indexOf(child)));
        } else {
          widgets.addAll(await _buildBlockChild(child));
        }

        // Add spacing between block elements
        if (widgets.isNotEmpty && i < node.children.length - 1) {
          final nextNonEmpty = node.children.skip(i + 1).firstWhere(
                (n) =>
                    n.display != Display.none && n.tagName != '#text' ||
                    (n.text?.trim().isNotEmpty ?? false),
                orElse: () => RenderNode(tagName: '', style: const CSSStyle()),
              );
          if (nextNonEmpty.tagName.isNotEmpty) {
            // Add small spacing between block elements
            widgets.add(pw.SizedBox(height: 4));
          }
        }
      }
      i++;
    }

    if (inlineGroup.isNotEmpty) {
      widgets.add(_buildRichText(inlineGroup, node.style));
    }

    return widgets;
  }

  /// Checks if a node contains only inline content (no nested block elements).
  bool _hasOnlyInlineContent(RenderNode node) {
    for (var child in node.children) {
      if (child.display == Display.block && child.tagName != '#text') {
        // Check if it's a known block element
        if ([
          'div',
          'p',
          'h1',
          'h2',
          'h3',
          'h4',
          'h5',
          'h6',
          'ul',
          'ol',
          'li',
          'table',
          'blockquote',
          'pre',
          'img',
          'input',
          'header',
          'footer',
          'article',
          'section',
          'aside',
          'nav',
          'main',
          'figure',
          'figcaption'
        ].contains(child.tagName)) {
          return false;
        }
      }
    }
    return true;
  }

  /// Builds a list of [pw.RichText] widgets from a node that contains only inline content.
  ///
  /// Since RichText does NOT automatically span pages, we split large text content
  /// into smaller chunks. Each chunk becomes a separate RichText widget that fits
  /// on a page, allowing the overall content to span pages when placed in MultiPage.
  ///
  /// The chunking is based on span count to approximate page-friendly sizes.
  List<pw.Widget> _buildRichTextFromNode(RenderNode node) {
    final spans = <pw.InlineSpan>[];
    _collectInlineSpans(node, spans);

    if (spans.isEmpty) return [];

    // If we have a small number of spans, return as single RichText
    // Estimate: each TextSpan typically takes ~20-40 points in height
    // A page is ~700 points, so ~15-25 spans per page is safe.
    // We'll use a conservative chunk size of 8 spans to ensure no overflow.
    const int maxSpansPerChunk = 8;

    if (spans.length <= maxSpansPerChunk) {
      return [
        pw.RichText(
          overflow: pw.TextOverflow.span,
          text: pw.TextSpan(children: spans),
          textAlign: node.style.textAlign ?? pw.TextAlign.left,
        ),
      ];
    }

    // Split spans into smaller chunks to enable page spanning
    final widgets = <pw.Widget>[];
    for (int i = 0; i < spans.length; i += maxSpansPerChunk) {
      final chunkEnd = (i + maxSpansPerChunk < spans.length)
          ? i + maxSpansPerChunk
          : spans.length;
      final chunk = spans.sublist(i, chunkEnd);

      widgets.add(
        pw.RichText(
          overflow: pw.TextOverflow.span,
          text: pw.TextSpan(children: chunk),
          textAlign: node.style.textAlign ?? pw.TextAlign.left,
        ),
      );
    }

    return widgets;
  }

  Future<pw.Widget> _buildImage(RenderNode node) async {
    return await image_builder.buildImage(node);
  }

  Future<pw.Widget> _buildTable(RenderNode node) async {
    final rows = <pw.TableRow>[];
    bool isFirstRow = true;

    for (var child in node.children) {
      if (child.tagName == 'tr' ||
          child.tagName == 'tbody' ||
          child.tagName == 'thead' ||
          child.tagName == 'tfoot') {
        if (child.tagName == 'tr') {
          rows.add(await _buildTableRow(child,
              isHeaderRow:
                  isFirstRow && child.children.any((c) => c.tagName == 'th')));
          isFirstRow = false;
        } else {
          // Handle thead/tbody/tfoot children
          final isHead = child.tagName == 'thead';
          for (var grandChild in child.children) {
            if (grandChild.tagName == 'tr') {
              rows.add(await _buildTableRow(grandChild, isHeaderRow: isHead));
            }
          }
          if (isHead) isFirstRow = false;
        }
      }
    }

    // Determine border style
    final borderCollapse = node.style.borderCollapse ?? true;
    final borderColor = node.style.border?.top.color ?? PdfColors.grey600;
    final borderWidth = node.style.border?.top.width ?? 0.5;

    // Container prevents spanning. Use Padding/SizedBox for margin.
    return pw.Padding(
      padding: node.style.margin ?? const pw.EdgeInsets.symmetric(vertical: 8),
      child: pw.Table(
        border: borderCollapse
            ? pw.TableBorder.all(color: borderColor, width: borderWidth)
            : pw.TableBorder.symmetric(
                inside: pw.BorderSide(color: borderColor, width: borderWidth),
                outside: pw.BorderSide(color: borderColor, width: borderWidth),
              ),
        defaultVerticalAlignment: pw.TableCellVerticalAlignment.full,
        defaultColumnWidth: const pw.FlexColumnWidth(),
        children: rows,
      ),
    );
  }

  Future<pw.TableRow> _buildTableRow(RenderNode node,
      {bool isHeaderRow = false}) async {
    final cells = <pw.Widget>[];

    for (var child in node.children) {
      if (child.tagName == 'td' || child.tagName == 'th') {
        final isHeader = child.tagName == 'th' || isHeaderRow;
        final cellContent = _buildCellContent(child, isHeader);

        // Determine cell alignment
        pw.Alignment alignment = pw.Alignment.centerLeft;
        if (child.style.textAlign == pw.TextAlign.center) {
          alignment = pw.Alignment.center;
        } else if (child.style.textAlign == pw.TextAlign.right) {
          alignment = pw.Alignment.centerRight;
        }

        // Vertical alignment
        if (child.style.verticalAlign == VerticalAlign.top) {
          alignment = pw.Alignment(alignment.x, -1);
        } else if (child.style.verticalAlign == VerticalAlign.bottom) {
          alignment = pw.Alignment(alignment.x, 1);
        }

        cells.add(pw.Container(
          padding: child.style.padding ?? const pw.EdgeInsets.all(6),
          color: child.style.backgroundColor ??
              (isHeader ? PdfColors.grey200 : null),
          alignment: alignment,
          child: cellContent,
        ));
      }
    }

    return pw.TableRow(
      decoration: node.style.backgroundColor != null
          ? pw.BoxDecoration(color: node.style.backgroundColor)
          : null,
      children: cells,
    );
  }

  pw.Widget _buildCellContent(RenderNode node, bool isHeader) {
    // Collect inline content from cell
    final spans = <pw.InlineSpan>[];
    _collectInlineSpans(node, spans);

    if (spans.isEmpty) {
      return pw.Text('');
    }

    // Apply header styling
    if (isHeader) {
      return pw.RichText(
        overflow: pw.TextOverflow.span,
        text: pw.TextSpan(
          children: spans,
          style: pw.TextStyle(fontWeight: pw.FontWeight.bold),
        ),
        textAlign: pw.TextAlign.center,
      );
    }

    return pw.RichText(
      overflow: pw.TextOverflow.span,
      text: pw.TextSpan(children: spans),
    );
  }

  Future<pw.Widget> _buildListItem(
      RenderNode node, bool isOrdered, int index) async {
    // Collect inline content from list item
    final spans = <pw.InlineSpan>[];
    _collectInlineSpans(node, spans);

    pw.Widget bullet;
    if (isOrdered) {
      bullet = pw.Text('${index + 1}.');
    } else {
      // Draw a bullet circle
      bullet = pw.Container(
        width: 4,
        height: 4,
        decoration: const pw.BoxDecoration(
          color: PdfColors.black,
          shape: pw.BoxShape.circle,
        ),
      );
    }

    // If spans is empty, it means we have block content (e.g. <li><div>...</div></li>)
    // We must allow this content to span pages.
    // We cannot wrap it in Row(Bullet, Expanded(Column)).
    // Instead, we will try to render the bullet and the first block side-by-side using a Row,
    // and then the rest of the blocks below.
    // However, if the first block is HUGE, the Row will crash.
    // Ideally, we treat the bullet as a small widget in a Stack or absolutely positioned?
    // pdf package doesn't support Stack spanning.

    // Compromise: Use a Table? Tables span pages.
    // A table with 2 columns: Bullet, Content.

    pw.Widget? contentWidget;

    if (spans.isNotEmpty) {
      contentWidget = pw.RichText(
        overflow: pw.TextOverflow.span,
        text: pw.TextSpan(children: spans),
        textAlign: node.style.textAlign ?? pw.TextAlign.left,
      );
    } else {
      // Block content
      final children = await _buildBlockChild(node);
      if (children.isNotEmpty) {
        // We wrap block content in a generic SpanningWidget aka Column? No.
        // We can use a Wrap? No.
        // We must use a Table to align Bullet with Content AND allow spanning.
        // But children is List<Widget>. Table takes TableRow.
        // We can verify if Table supports arbitrary widgets spanning. Yes, inside methods.

        // Actually, simplest is to just flatten it and accept bullet alignment might be tricky?
        // Or use Table.

        final tableRows = <pw.TableRow>[];
        for (var i = 0; i < children.length; i++) {
          tableRows.add(pw.TableRow(children: [
            i == 0
                ? pw.Container(
                    alignment: pw.Alignment.topRight,
                    padding: const pw.EdgeInsets.only(right: 5),
                    child: bullet)
                : pw.SizedBox(),
            children[i]
          ]));
        }

        return pw.Table(columnWidths: {
          0: const pw.FixedColumnWidth(20),
          1: const pw.FlexColumnWidth(),
        }, children: tableRows);
      }
      return pw.SizedBox();
    }

    // For simple inline content, Row is technically fine unless text is > 1 page.
    // But text > 1 page wraps. Row DOES NOT WRAP/SPAN.
    // So even for text, we should use Table for robustness!

    return pw.Table(columnWidths: {
      0: const pw.FixedColumnWidth(20),
      1: const pw.FlexColumnWidth(),
    }, children: [
      pw.TableRow(
          verticalAlignment: pw.TableCellVerticalAlignment.middle,
          children: [
            pw.Container(
                alignment: pw.Alignment.topRight,
                padding: const pw.EdgeInsets.only(right: 5),
                child: bullet),
            contentWidget
          ])
    ]);
  }

  pw.Widget _buildCheckbox(RenderNode node) {
    final bool checked = node.attributes.containsKey('checked');

    // Priority 1: Use custom checkbox builder if provided
    if (tagStyle.checkboxBuilder != null) {
      return tagStyle.checkboxBuilder!(checked);
    }

    // Priority 2: Use custom SVG icons if provided
    // (Note: SVG rendering requires svg_to_pdf package which is not a dependency)
    // For now, we'll create a styled widget that can be customized

    final size = tagStyle.checkboxSize;
    final checkedColor = tagStyle.checkedIconColor ?? PdfColors.blue;
    final uncheckedColor = tagStyle.uncheckedIconColor ?? PdfColors.white;

    return pw.Container(
      width: size,
      height: size,
      decoration: pw.BoxDecoration(
        border: pw.Border.all(color: PdfColors.black, width: 1.5),
        color: checked ? checkedColor : uncheckedColor,
        borderRadius: const pw.BorderRadius.all(pw.Radius.circular(2)),
      ),
      child: checked
          ? pw.Center(
              child: pw.Text(
                'X',
                style: pw.TextStyle(
                  fontSize: size * 0.7,
                  color: PdfColors.white,
                  fontWeight: pw.FontWeight.bold,
                ),
              ),
            )
          : null,
    );
  }

  Future<pw.Widget> _buildBlockquote(RenderNode node) async {
    final content = await _buildBlockContent(node);

    // Blockquote usually has a side border.
    // Container(decoration + Column) prevents spanning.
    // We can use a Table with 2 columns: Border line, Content.
    // Table spans pages.

    final tableRows = <pw.TableRow>[];

    // We only put the border on the left column.
    // How to effectively make a continuous border?
    // Table border is per cell or grid.
    // If we use TableBorder(left: ...), it applies to table.
    // Let's try wrapping content in a Table.

    // A single cell table can span!

    // If we just want a left border, we can use Table with left border.

    // Wait, content is a List<Widget>.
    // To mix widgets into Table, we need Rows.
    // If we put all widgets in one cell, we are back to Column (no span).
    // So we must put EACH widget in a separate TableRow.

    for (var child in content) {
      tableRows.add(pw.TableRow(children: [child]));
    }

    // Use Padding instead of Container to allow spanning
    return pw.Padding(
      padding: (const pw.EdgeInsets.symmetric(vertical: 8, horizontal: 16)) +
          (const pw.EdgeInsets.only(left: 12)),
      child: pw.Table(
        border: const pw.TableBorder(
          left: pw.BorderSide(color: PdfColors.grey400, width: 3),
        ),
        children: tableRows,
      ),
    );
  }

  pw.Widget _buildPreBlock(RenderNode node) {
    // Collect all text from pre block
    String text = _collectText(node);

    return pw.Padding(
      padding: const pw.EdgeInsets.symmetric(vertical: 8) +
          const pw.EdgeInsets.all(8),
      child: pw.Text(
        text,
        style: const pw.TextStyle(
          fontSize: 10,

          // font: // monospace font should be here if available
        ),
      ),
    );
  }

  String _collectText(RenderNode node) {
    final buffer = StringBuffer();
    if (node.text != null) {
      buffer.write(node.text);
    }
    for (var child in node.children) {
      buffer.write(_collectText(child));
    }
    return buffer.toString();
  }

  Future<List<pw.Widget>> _buildBlockChild(RenderNode node) async {
    // This node is a block element.
    // We need to apply its styles (padding, margin, border, background)
    // and then process its children.

    // Recursive call to get children widgets
    final childrenWidgets = await _buildBlock(node);

    // Build decoration from node style
    final decoration = _buildBoxDecoration(node.style);
    final hasDecoration = decoration != null ||
        node.style.padding != null ||
        node.style.margin != null;

    // Empty blocks with decoration (like colored divs with explicit size)
    if (childrenWidgets.isEmpty) {
      if (hasDecoration &&
          (node.style.width != null || node.style.height != null)) {
        return [
          pw.Container(
            width: node.style.width,
            height: node.style.height,
            padding: node.style.padding,
            margin: node.style.margin,
            decoration: decoration,
          )
        ];
      }
      return [];
    }

    // Determine if this is a "small" block that can safely use Container wrapper
    // Headers (h1-h6), blockquotes, and single-content blocks can be wrapped
    final isSmallBlock = _isSmallBlock(node, childrenWidgets);

    if (isSmallBlock && hasDecoration) {
      // Small block - wrap everything in a decorated Container
      // This is safe for headers, titles, short paragraphs, etc.
      pw.Widget content;
      if (childrenWidgets.length == 1) {
        content = childrenWidgets.first;
      } else {
        // For small blocks with multiple children, use Column
        // This is acceptable since small blocks fit on a page
        content = pw.Column(
          crossAxisAlignment: node.style.textAlign == pw.TextAlign.center
              ? pw.CrossAxisAlignment.center
              : node.style.textAlign == pw.TextAlign.right
                  ? pw.CrossAxisAlignment.end
                  : pw.CrossAxisAlignment.start,
          children: childrenWidgets,
        );
      }

      // Determine container alignment based on text-align
      pw.Alignment? alignment;
      if (node.style.textAlign == pw.TextAlign.center) {
        alignment = pw.Alignment.center;
      } else if (node.style.textAlign == pw.TextAlign.right) {
        alignment = pw.Alignment.centerRight;
      }

      return [
        pw.Container(
          width: node.style.width,
          padding: node.style.padding,
          margin: node.style.margin,
          decoration: decoration,
          alignment: alignment,
          child: content,
        )
      ];
    }

    // Large structural blocks - apply decorations to individual children
    // This enables page spanning while preserving visual styling
    if (hasDecoration) {
      return _applyBlockDecorationToChildren(
        childrenWidgets,
        node.style,
        decoration,
      );
    }

    // No decoration - just return children with spacing
    final topSpace =
        (node.style.margin?.top ?? 0) + (node.style.padding?.top ?? 0);
    final bottomSpace =
        (node.style.margin?.bottom ?? 0) + (node.style.padding?.bottom ?? 0);

    final result = <pw.Widget>[];
    if (topSpace > 0) result.add(pw.SizedBox(height: topSpace));
    result.addAll(childrenWidgets);
    if (bottomSpace > 0) result.add(pw.SizedBox(height: bottomSpace));

    return result;
  }

  /// Determines if a block is "small" enough to safely wrap in a Container
  /// VERY conservative - only headers and simple blockquotes
  /// Paragraphs, divs, and other blocks may contain long content that exceeds page height
  bool _isSmallBlock(RenderNode node, List<pw.Widget> children) {
    // Only headers are truly guaranteed to be small
    if (['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].contains(node.tagName)) {
      return true;
    }

    // Blockquotes with a single short child
    if (node.tagName == 'blockquote' && children.length == 1) {
      return true;
    }

    // Pre blocks with single child
    if (node.tagName == 'pre' && children.length == 1) {
      return true;
    }

    // Everything else (including paragraphs) should be treated as potentially large
    // to enable page spanning
    return false;
  }

  /// For large structural blocks, apply background decoration using top/middle/bottom
  /// This creates a unified visual block while still allowing page spanning
  List<pw.Widget> _applyBlockDecorationToChildren(
    List<pw.Widget> children,
    CSSStyle style,
    pw.BoxDecoration? decoration,
  ) {
    final result = <pw.Widget>[];
    final leftPad = (style.padding?.left ?? 0) + (style.margin?.left ?? 0);
    final rightPad = (style.padding?.right ?? 0) + (style.margin?.right ?? 0);
    final topSpace = (style.margin?.top ?? 0) + (style.padding?.top ?? 0);
    final bottomSpace =
        (style.margin?.bottom ?? 0) + (style.padding?.bottom ?? 0);

    // Add top spacing with background and top border
    if (topSpace > 0 || decoration != null) {
      result.add(pw.Container(
        height: topSpace > 0 ? topSpace : null,
        padding: topSpace > 0 ? null : const pw.EdgeInsets.only(top: 8),
        decoration: decoration != null
            ? pw.BoxDecoration(
                color: decoration.color,
                border: decoration.border?.top != null
                    ? pw.Border(top: decoration.border!.top)
                    : null,
              )
            : null,
      ));
    }

    // Apply background and horizontal padding to each child
    for (final child in children) {
      if (decoration?.color != null || leftPad > 0 || rightPad > 0) {
        result.add(pw.Container(
          padding: pw.EdgeInsets.only(left: leftPad, right: rightPad),
          decoration: decoration?.color != null
              ? pw.BoxDecoration(color: decoration!.color)
              : null,
          child: child,
        ));
      } else {
        result.add(child);
      }
    }

    // Add bottom spacing with background and bottom border
    if (bottomSpace > 0 || decoration != null) {
      result.add(pw.Container(
        height: bottomSpace > 0 ? bottomSpace : null,
        padding: bottomSpace > 0 ? null : const pw.EdgeInsets.only(bottom: 8),
        decoration: decoration != null
            ? pw.BoxDecoration(
                color: decoration.color,
                border: decoration.border?.bottom != null
                    ? pw.Border(bottom: decoration.border!.bottom)
                    : null,
              )
            : null,
      ));
    }

    return result;
  }

  pw.Widget _buildRichText(List<RenderNode> nodes, CSSStyle parentStyle) {
    final spans = <pw.InlineSpan>[];

    for (var node in nodes) {
      _collectInlineSpans(node, spans);
    }

    // Return RichText directly without any wrapper widget.
    // RichText implements SpanningWidget and can automatically break
    // content across pages when used in MultiPage layouts.
    // Wrapping it in Container or Padding prevents this spanning capability.
    return pw.RichText(
      overflow: pw.TextOverflow.span,
      text: pw.TextSpan(children: spans),
      textAlign: parentStyle.textAlign ?? pw.TextAlign.left,
      textDirection: parentStyle.textDirection,
    );
  }

  void _collectInlineSpans(RenderNode node, List<pw.InlineSpan> spans) {
    if (node.display == Display.none) return;

    // Handle checkbox inputs as inline widgets
    if (node.tagName == 'input' && node.attributes['type'] == 'checkbox') {
      // Add space before checkbox if needed
      if (spans.isNotEmpty) {
        final lastSpan = spans.last;
        if (lastSpan is pw.TextSpan) {
          final lastText = lastSpan.text ?? '';
          if (lastText.isNotEmpty && !lastText.endsWith(' ')) {
            spans.add(const pw.TextSpan(text: ' '));
          }
        }
      }
      double baseline = -3;

      if (node.style.verticalAlign != null) {
        switch (node.style.verticalAlign!) {
          case VerticalAlign.top:
            baseline = 6;
            break;
          case VerticalAlign.bottom:
            baseline = -2;
            break;
          case VerticalAlign.baseline:
            baseline = 0;
            break;
          case VerticalAlign.middle:
            break;
        }
      }

      spans.add(pw.WidgetSpan(
        child: _buildCheckbox(node),
        baseline: baseline,
      ));
      return;
    }

    // If this is a text node, add its text with current style
    if (node.text != null && node.text!.isNotEmpty) {
      // Normalize whitespace like browsers do
      String text = node.text!;
      // Replace multiple whitespace with single space
      text = text.replaceAll(RegExp(r'\s+'), ' ');

      spans.add(pw.TextSpan(
        text: " $text",
        style: _mapTextStyle(node.style),
        annotation: node.tagName == 'a' && node.attributes.containsKey('href')
            ? pw.AnnotationUrl(node.attributes['href']!)
            : null,
      ));
      return;
    }

    // For non-text inline elements (span, b, i, a, etc.), add a space before
    // if there are already spans and the previous span doesn't end with space
    if (spans.isNotEmpty &&
        node.tagName != '#text' &&
        node.children.isNotEmpty) {
      final lastSpan = spans.last;
      if (lastSpan is pw.TextSpan) {
        final lastText = lastSpan.text ?? '';
        if (lastText.isNotEmpty && !lastText.endsWith(' ')) {
          // Add a space before this inline element
          spans.add(pw.TextSpan(text: ' ', style: _mapTextStyle(node.style)));
        }
      }
    }

    // For non-text inline elements, recurse into children
    // and apply this element's style to them
    for (var child in node.children) {
      if (child.text != null && child.text!.isNotEmpty) {
        // Text node with content - apply parent's style
        String text = child.text!;
        text = text.replaceAll(RegExp(r'\s+'), ' ');

        spans.add(pw.TextSpan(
          text: " $text",
          style: _mapTextStyle(node.style), // Use parent's computed style
          annotation: node.tagName == 'a' && node.attributes.containsKey('href')
              ? pw.AnnotationUrl(node.attributes['href']!)
              : null,
        ));
      } else {
        // Recurse for nested elements
        _collectInlineSpans(child, spans);
      }
    }
  }

  pw.BoxDecoration? _buildBoxDecoration(CSSStyle style) {
    if (style.backgroundColor == null && style.border == null) return null;

    return pw.BoxDecoration(
      color: style.backgroundColor,
      border: style.border,
    );
  }

  pw.TextStyle _mapTextStyle(CSSStyle style) {
    // If we have a fallback font, we can use it as the primary font if the style doesn't specify one.
    // This ensures we don't accidentally fallback to Helvetica (which lacks Unicode).
    // However, we must be careful not to override specific fonts.

    // Logic: If style has font, use it. Else if we have fallback, use first fallback.
    // Else null (default PDF font).

    // Note: The previous issue was forcing fallback.first ALWAYS.
    // Here we should only do it if we are relying on defaults?
    // Actually, PdfGoogleFonts usually provides the fallback list.
    // The safest way to avoid Helvetica is to set the default font in the Theme of the document,
    // NOT here. But we can hint it here.

    return pw.TextStyle(
      color: style.color,
      fontSize: style.fontSize,
      fontWeight: style.fontWeight,
      fontStyle: style.fontStyle,
      decoration: style.textDecoration,
      font: style.fontFamily != null ? null : null,
      fontFallback: fontFallback,
      lineSpacing:
          style.lineHeight, // Add line-height support if available in CSSStyle
      background: style.backgroundColor != null
          ? pw.BoxDecoration(color: style.backgroundColor)
          : null,
    );
  }
}
