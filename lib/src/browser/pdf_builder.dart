import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;

import '../htmltagstyles.dart';
import 'css_style.dart';
import 'image_builder_io.dart' if (dart.library.html) 'image_builder_web.dart'
    as image_builder;
import 'render_node.dart';

/// [PdfBuilder] converts a tree of [RenderNode]s into a list of [pw.Widget]s.
///
/// It traverses the render tree and creates corresponding PDF widgets (e.g.,
/// [pw.Container], [pw.Text], [pw.RichText], [pw.Table]) based on the
/// node type and its computed [CSSStyle].
class PdfBuilder {
  /// The root node of the render tree.
  final RenderNode root;

  /// Custom tag styles for checkbox customization.
  final HtmlTagStyle tagStyle;

  /// Fallback fonts for handling emojis and multiple languages.
  final List<pw.Font> fontFallback;

  /// Creates an instance of [PdfBuilder].
  ///
  /// [root] is the root [RenderNode] generated by [HtmlParser].
  /// [tagStyle] provides custom styling options including checkbox icons.
  /// [fontFallback] provides fonts for special characters and emojis.
  PdfBuilder({
    required this.root,
    this.tagStyle = const HtmlTagStyle(),
    this.fontFallback = const [],
  });

  /// Builds the PDF widgets from the render tree.
  Future<List<pw.Widget>> build() async {
    return await _buildBlock(root);
  }

  /// Builds widgets for a block-level node.
  ///
  /// This method handles:
  /// - Specific block tags (img, table, hr, blockquote, pre, etc.).
  /// - Block elements containing only inline content (rendered as [pw.RichText]).
  /// - Generic block elements with mixed content (recursively building children).
  Future<List<pw.Widget>> _buildBlock(RenderNode node) async {
    print('Building block: ${node.tagName} children:${node.children.length}');
    final widgets = <pw.Widget>[];

    if (node.display == Display.none) return widgets;

    // Handle specific tags that map to specific Widgets
    if (node.tagName == 'img') {
      return [await _buildImage(node)];
    } else if (node.tagName == 'table') {
      return [await _buildTable(node)];
    } else if (node.tagName == 'hr') {
      return [
        pw.Divider(
            color: node.style.border?.bottom.color ?? PdfColors.grey400,
            thickness: node.style.border?.bottom.width ?? 1.0)
      ];
    } else if (node.tagName == 'blockquote') {
      return [await _buildBlockquote(node)];
    } else if (node.tagName == 'pre') {
      return [_buildPreBlock(node)];
    } else if (node.tagName == 'br') {
      return [pw.SizedBox(height: 12)]; // Line break as vertical space
    }

    return await _buildBlockContent(node);
  }

  /// Builds the content of a block (children).
  Future<List<pw.Widget>> _buildBlockContent(RenderNode node) async {
    final widgets = <pw.Widget>[];

    // Check if this block contains only inline content (text, spans, b, i, etc.)
    // If so, render as RichText
    if (_hasOnlyInlineContent(node)) {
      final richText = _buildRichTextFromNode(node);
      if (richText != null) {
        return [richText];
      }
      return [];
    }

    // Generic block processing - mixed content
    List<RenderNode> inlineGroup = [];
    int i = 0;

    while (i < node.children.length) {
      final child = node.children[i];
      if (child.display == Display.none) {
        i++;
        continue;
      }

      if (child.display == Display.inline ||
          child.tagName == '#text' ||
          (child.tagName == 'input' &&
              child.attributes['type'] == 'checkbox') ||
          child.tagName == 'label') {
        // Handle br tags specially in inline context
        if (child.tagName == 'br') {
          if (inlineGroup.isNotEmpty) {
            widgets.add(_buildRichText(inlineGroup, node.style));
            inlineGroup = [];
          }
          widgets.add(pw.SizedBox(height: 8));
        } else {
          inlineGroup.add(child);
        }
      } else {
        if (inlineGroup.isNotEmpty) {
          widgets.add(_buildRichText(inlineGroup, node.style));
          inlineGroup = [];
        }

        // Check if child is a list item inside a list
        if (child.tagName == 'li' &&
            (node.tagName == 'ul' || node.tagName == 'ol')) {
          widgets.add(await _buildListItem(
              child, node.tagName == 'ol', node.children.indexOf(child)));
        } else {
          widgets.addAll(await _buildBlockChild(child));
        }

        // Add spacing between block elements
        if (widgets.isNotEmpty && i < node.children.length - 1) {
          final nextNonEmpty = node.children.skip(i + 1).firstWhere(
                (n) =>
                    n.display != Display.none && n.tagName != '#text' ||
                    (n.text?.trim().isNotEmpty ?? false),
                orElse: () => RenderNode(tagName: '', style: const CSSStyle()),
              );
          if (nextNonEmpty.tagName.isNotEmpty) {
            // Add small spacing between block elements
            widgets.add(pw.SizedBox(height: 4));
          }
        }
      }
      i++;
    }

    if (inlineGroup.isNotEmpty) {
      widgets.add(_buildRichText(inlineGroup, node.style));
    }

    return widgets;
  }

  /// Checks if a node contains only inline content (no nested block elements).
  bool _hasOnlyInlineContent(RenderNode node) {
    for (var child in node.children) {
      if (child.display == Display.block && child.tagName != '#text') {
        // Check if it's a known block element
        if ([
          'div',
          'p',
          'h1',
          'h2',
          'h3',
          'h4',
          'h5',
          'h6',
          'ul',
          'ol',
          'li',
          'table',
          'blockquote',
          'pre',
          'img',
          'input',
          'header',
          'footer',
          'article',
          'section',
          'aside',
          'nav',
          'main',
          'figure',
          'figcaption'
        ].contains(child.tagName)) {
          return false;
        }
      }
    }
    return true;
  }

  /// Builds a [pw.RichText] widget from a node that contains only inline content.
  pw.Widget? _buildRichTextFromNode(RenderNode node) {
    final spans = <pw.InlineSpan>[];
    _collectInlineSpans(node, spans);

    if (spans.isEmpty) return null;

    return pw.Padding(
      padding: (node.style.margin ?? const pw.EdgeInsets.only(bottom: 6)) +
          (node.style.padding ?? pw.EdgeInsets.zero),
      child: pw.RichText(
        text: pw.TextSpan(children: spans),
        textAlign: node.style.textAlign ?? pw.TextAlign.left,
      ),
    );
  }

  Future<pw.Widget> _buildImage(RenderNode node) async {
    return await image_builder.buildImage(node);
  }

  Future<pw.Widget> _buildTable(RenderNode node) async {
    final rows = <pw.TableRow>[];
    bool isFirstRow = true;

    for (var child in node.children) {
      if (child.tagName == 'tr' ||
          child.tagName == 'tbody' ||
          child.tagName == 'thead' ||
          child.tagName == 'tfoot') {
        if (child.tagName == 'tr') {
          rows.add(await _buildTableRow(child,
              isHeaderRow:
                  isFirstRow && child.children.any((c) => c.tagName == 'th')));
          isFirstRow = false;
        } else {
          // Handle thead/tbody/tfoot children
          final isHead = child.tagName == 'thead';
          for (var grandChild in child.children) {
            if (grandChild.tagName == 'tr') {
              rows.add(await _buildTableRow(grandChild, isHeaderRow: isHead));
            }
          }
          if (isHead) isFirstRow = false;
        }
      }
    }

    // Determine border style
    final borderCollapse = node.style.borderCollapse ?? true;
    final borderColor = node.style.border?.top.color ?? PdfColors.grey600;
    final borderWidth = node.style.border?.top.width ?? 0.5;

    // Container prevents spanning. Use Padding/SizedBox for margin.
    return pw.Padding(
      padding: node.style.margin ?? const pw.EdgeInsets.symmetric(vertical: 8),
      child: pw.Table(
        border: borderCollapse
            ? pw.TableBorder.all(color: borderColor, width: borderWidth)
            : pw.TableBorder.symmetric(
                inside: pw.BorderSide(color: borderColor, width: borderWidth),
                outside: pw.BorderSide(color: borderColor, width: borderWidth),
              ),
        defaultColumnWidth: const pw.IntrinsicColumnWidth(),
        columnWidths: node.style.width != null ? null : null,
        children: rows,
      ),
    );
  }

  Future<pw.TableRow> _buildTableRow(RenderNode node,
      {bool isHeaderRow = false}) async {
    final cells = <pw.Widget>[];

    for (var child in node.children) {
      if (child.tagName == 'td' || child.tagName == 'th') {
        final isHeader = child.tagName == 'th' || isHeaderRow;
        final cellContent = _buildCellContent(child, isHeader);

        // Determine cell alignment
        pw.Alignment alignment = pw.Alignment.centerLeft;
        if (child.style.textAlign == pw.TextAlign.center) {
          alignment = pw.Alignment.center;
        } else if (child.style.textAlign == pw.TextAlign.right) {
          alignment = pw.Alignment.centerRight;
        }

        // Vertical alignment
        if (child.style.verticalAlign == VerticalAlign.top) {
          alignment = pw.Alignment(alignment.x, -1);
        } else if (child.style.verticalAlign == VerticalAlign.bottom) {
          alignment = pw.Alignment(alignment.x, 1);
        }

        cells.add(pw.Container(
          padding: child.style.padding ?? const pw.EdgeInsets.all(6),
          color: child.style.backgroundColor ??
              (isHeader ? PdfColors.grey200 : null),
          alignment: alignment,
          child: cellContent,
        ));
      }
    }

    return pw.TableRow(
      decoration: node.style.backgroundColor != null
          ? pw.BoxDecoration(color: node.style.backgroundColor)
          : null,
      children: cells,
    );
  }

  pw.Widget _buildCellContent(RenderNode node, bool isHeader) {
    // Collect inline content from cell
    final spans = <pw.InlineSpan>[];
    _collectInlineSpans(node, spans);

    if (spans.isEmpty) {
      return pw.Text('');
    }

    // Apply header styling
    if (isHeader) {
      return pw.RichText(
        text: pw.TextSpan(
          children: spans,
          style: pw.TextStyle(fontWeight: pw.FontWeight.bold),
        ),
        textAlign: pw.TextAlign.center,
      );
    }

    return pw.RichText(
      text: pw.TextSpan(children: spans),
    );
  }

  Future<pw.Widget> _buildListItem(
      RenderNode node, bool isOrdered, int index) async {
    // Collect inline content from list item
    final spans = <pw.InlineSpan>[];
    _collectInlineSpans(node, spans);

    pw.Widget bullet;
    if (isOrdered) {
      bullet = pw.Text('${index + 1}.');
    } else {
      // Draw a bullet circle
      bullet = pw.Container(
        width: 4,
        height: 4,
        decoration: const pw.BoxDecoration(
          color: PdfColors.black,
          shape: pw.BoxShape.circle,
        ),
      );
    }

    // If spans is empty, it means we have block content (e.g. <li><div>...</div></li>)
    // We must allow this content to span pages.
    // We cannot wrap it in Row(Bullet, Expanded(Column)).
    // Instead, we will try to render the bullet and the first block side-by-side using a Row,
    // and then the rest of the blocks below.
    // However, if the first block is HUGE, the Row will crash.
    // Ideally, we treat the bullet as a small widget in a Stack or absolutely positioned?
    // pdf package doesn't support Stack spanning.

    // Compromise: Use a Table? Tables span pages.
    // A table with 2 columns: Bullet, Content.

    pw.Widget? contentWidget;

    if (spans.isNotEmpty) {
      contentWidget = pw.RichText(
        text: pw.TextSpan(children: spans),
        textAlign: node.style.textAlign ?? pw.TextAlign.left,
      );
    } else {
      // Block content
      final children = await _buildBlockChild(node);
      if (children.isNotEmpty) {
        // We wrap block content in a generic SpanningWidget aka Column? No.
        // We can use a Wrap? No.
        // We must use a Table to align Bullet with Content AND allow spanning.
        // But children is List<Widget>. Table takes TableRow.
        // We can verify if Table supports arbitrary widgets spanning. Yes, inside methods.

        // Actually, simplest is to just flatten it and accept bullet alignment might be tricky?
        // Or use Table.

        final tableRows = <pw.TableRow>[];
        for (var i = 0; i < children.length; i++) {
          tableRows.add(pw.TableRow(children: [
            i == 0
                ? pw.Container(
                    alignment: pw.Alignment.topRight,
                    padding: const pw.EdgeInsets.only(right: 5),
                    child: bullet)
                : pw.SizedBox(),
            children[i]
          ]));
        }

        return pw.Table(columnWidths: {
          0: const pw.FixedColumnWidth(20),
          1: const pw.FlexColumnWidth(),
        }, children: tableRows);
      }
      return pw.SizedBox();
    }

    // For simple inline content, Row is technically fine unless text is > 1 page.
    // But text > 1 page wraps. Row DOES NOT WRAP/SPAN.
    // So even for text, we should use Table for robustness!

    return pw.Table(columnWidths: {
      0: const pw.FixedColumnWidth(20),
      1: const pw.FlexColumnWidth(),
    }, children: [
      pw.TableRow(
          verticalAlignment: pw.TableCellVerticalAlignment.middle,
          children: [
            pw.Container(
                alignment: pw.Alignment.topRight,
                padding: const pw.EdgeInsets.only(right: 5),
                child: bullet),
            contentWidget
          ])
    ]);
  }

  pw.Widget _buildCheckbox(RenderNode node) {
    final bool checked = node.attributes.containsKey('checked');

    // Priority 1: Use custom checkbox builder if provided
    if (tagStyle.checkboxBuilder != null) {
      return tagStyle.checkboxBuilder!(checked);
    }

    // Priority 2: Use custom SVG icons if provided
    // (Note: SVG rendering requires svg_to_pdf package which is not a dependency)
    // For now, we'll create a styled widget that can be customized

    final size = tagStyle.checkboxSize;
    final checkedColor = tagStyle.checkedIconColor ?? PdfColors.blue;
    final uncheckedColor = tagStyle.uncheckedIconColor ?? PdfColors.white;

    return pw.Container(
      width: size,
      height: size,
      decoration: pw.BoxDecoration(
        border: pw.Border.all(color: PdfColors.black, width: 1.5),
        color: checked ? checkedColor : uncheckedColor,
        borderRadius: const pw.BorderRadius.all(pw.Radius.circular(2)),
      ),
      child: checked
          ? pw.Center(
              child: pw.Text(
                'X',
                style: pw.TextStyle(
                  fontSize: size * 0.7,
                  color: PdfColors.white,
                  fontWeight: pw.FontWeight.bold,
                ),
              ),
            )
          : null,
    );
  }

  Future<pw.Widget> _buildBlockquote(RenderNode node) async {
    final content = await _buildBlockContent(node);

    // Blockquote usually has a side border.
    // Container(decoration + Column) prevents spanning.
    // We can use a Table with 2 columns: Border line, Content.
    // Table spans pages.

    final tableRows = <pw.TableRow>[];

    // We only put the border on the left column.
    // How to effectively make a continuous border?
    // Table border is per cell or grid.
    // If we use TableBorder(left: ...), it applies to table.
    // Let's try wrapping content in a Table.

    // A single cell table can span!

    // If we just want a left border, we can use Table with left border.

    // Wait, content is a List<Widget>.
    // To mix widgets into Table, we need Rows.
    // If we put all widgets in one cell, we are back to Column (no span).
    // So we must put EACH widget in a separate TableRow.

    for (var child in content) {
      tableRows.add(pw.TableRow(children: [child]));
    }

    // Use Padding instead of Container to allow spanning
    return pw.Padding(
      padding: (const pw.EdgeInsets.symmetric(vertical: 8, horizontal: 16)) +
          (const pw.EdgeInsets.only(left: 12)),
      child: pw.Table(
        border: const pw.TableBorder(
          left: pw.BorderSide(color: PdfColors.grey400, width: 3),
        ),
        children: tableRows,
      ),
    );
  }

  pw.Widget _buildPreBlock(RenderNode node) {
    // Collect all text from pre block
    String text = _collectText(node);

    return pw.Padding(
      padding: const pw.EdgeInsets.symmetric(vertical: 8) +
          const pw.EdgeInsets.all(8),
      child: pw.Text(
        text,
        style: const pw.TextStyle(
          fontSize: 10,

          // font: // monospace font should be here if available
        ),
      ),
    );
  }

  String _collectText(RenderNode node) {
    final buffer = StringBuffer();
    if (node.text != null) {
      buffer.write(node.text);
    }
    for (var child in node.children) {
      buffer.write(_collectText(child));
    }
    return buffer.toString();
  }

  Future<List<pw.Widget>> _buildBlockChild(RenderNode node) async {
    // This node is a block element.
    // We need to apply its styles (padding, margin, border, background)
    // and then process its children.

    // Recursive call to get children widgets
    final childrenWidgets = await _buildBlock(node);

    // If it's a list item, we might want to handle it specifically or just as a block
    // For simplicity, treating as block with container.

    // Apply styling.
    // Note: pw.Container supports padding, margin, decoration (border, color).
    // However, pw.Container with non-null decoration might not span pages well if it's too large.
    // The prompt suggests "Virtual Fragmentation" and "Prefer using pw.Column".

    // If we have background or border, we must use Container/Decoration.
    // However, pw.Container with non-null decoration does NOT support spanning across pages.
    // If the content is large (e.g. section, article, div with multiple children),
    // keeping the decoration will cause "Widget won't fit" error.
    // For robustness, we discard the decoration if the node seems to be a structural wrapper
    // (has multiple block children) and relies on flow execution.

    // We only apply decoration if it's likely a small component (like a card or button)
    // Heuristic: if it has many children or specific semantic tags, avoid decoration.

    pw.Widget widget;
    if (childrenWidgets.length == 1) {
      widget = childrenWidgets.first;
    } else {
      widget = pw.Column(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: childrenWidgets,
      );
    }

    var decoration = _buildBoxDecoration(node.style);
    bool isStructural = false;
    // Aggressive flattening: Treat all generic block containers as structural
    // to prevent "Widget too big" errors.
    // We include 'div' with ANY children (>= 1).
    // This removes borders/backgrounds from divs, but ensures page spanning.
    // Universal flattening: Treat ANY block with children as structural.
    // This is the only way to guarantee "Any widget ... automatically split".
    // We sacrifice decorations (borders/backgrounds) on wrappers to prevent
    // "Widget won't fit" crashes.
    if (childrenWidgets.isNotEmpty) {
      isStructural = true;
    }

    // Special handling: Keep decoration for VERY simple elements if needed?
    // No, robustness first. If it has children, it might be huge. Flatten it.

    // If the node has NO children (e.g. <hr>, empty div with size),
    // isStructural is false, and it goes to Container logic below.
    // That's fine because without children it fits on a page or is just empty.

    if (isStructural) {
      // Force complete unwrap for structural blocks to guarantee spanning.
      // We drop decoration (background/border).
      // We preserve vertical margin/padding via SizedBox.
      // We SACRIFICE horizontal margin/padding/border to enable robust paging.
      // (Horizontal constraints usually don't cause page breaks, but wrappers do).

      final topSpace =
          (node.style.margin?.top ?? 0) + (node.style.padding?.top ?? 0);
      final bottomSpace =
          (node.style.margin?.bottom ?? 0) + (node.style.padding?.bottom ?? 0);

      final result = <pw.Widget>[];

      if (topSpace > 0) result.add(pw.SizedBox(height: topSpace));

      // Add all children directly to the result list
      result.addAll(childrenWidgets);

      if (bottomSpace > 0) result.add(pw.SizedBox(height: bottomSpace));

      return result;
    }

    // Non-structural / Small blocks (e.g. Buttons, Cards with fixed small content)
    // We try to keep decoration if possible.
    if (decoration != null) {
      return [
        pw.Container(
          width: node.style.width,
          height: node.style.height,
          padding: node.style.padding,
          margin: node.style.margin,
          decoration: decoration,
          child: widget,
        )
      ];
    } else {
      // Even if no decoration, if it's not structural, we might wraps it.
      // But wait, if it's NOT structural, it probably only has 1 child or is small.
      // Let's use Padding.

      if (node.style.padding != null || node.style.margin != null) {
        final p = node.style.padding ?? const pw.EdgeInsets.all(0);
        final m = node.style.margin ?? const pw.EdgeInsets.all(0);

        // Optimization: If only vertical spacing, use SizedBox to avoid nesting
        if (p.left == 0 && p.right == 0 && m.left == 0 && m.right == 0) {
          final top = p.top + m.top;
          final bottom = p.bottom + m.bottom;
          final res = <pw.Widget>[];
          if (top > 0) res.add(pw.SizedBox(height: top));
          res.add(widget);
          if (bottom > 0) res.add(pw.SizedBox(height: bottom));
          return res;
        }

        return [
          pw.Padding(
            padding: pw.EdgeInsets.fromLTRB(p.left + m.left, p.top + m.top,
                p.right + m.right, p.bottom + m.bottom),
            child: widget,
          )
        ];
      } else {
        return [widget];
      }
    }

    // Pass padding/margin even if decoration is dropped (Container handles it, though padding might not span perfectly)
    // Ideally we apply padding to the column children or use a specialized widget, but Container is okay for padding.
  }

  pw.Widget _buildRichText(List<RenderNode> nodes, CSSStyle parentStyle) {
    final spans = <pw.InlineSpan>[];

    for (var node in nodes) {
      _collectInlineSpans(node, spans);
    }

    // Wrap in a Container with margin for proper spacing
    return pw.Container(
      margin: const pw.EdgeInsets.only(bottom: 6),
      child: pw.RichText(
        text: pw.TextSpan(children: spans),
        textAlign: parentStyle.textAlign ?? pw.TextAlign.left,
        textDirection: parentStyle.textDirection,
      ),
    );
  }

  void _collectInlineSpans(RenderNode node, List<pw.InlineSpan> spans) {
    if (node.display == Display.none) return;

    // Handle checkbox inputs as inline widgets
    if (node.tagName == 'input' && node.attributes['type'] == 'checkbox') {
      // Add space before checkbox if needed
      if (spans.isNotEmpty) {
        final lastSpan = spans.last;
        if (lastSpan is pw.TextSpan) {
          final lastText = lastSpan.text ?? '';
          if (lastText.isNotEmpty && !lastText.endsWith(' ')) {
            spans.add(const pw.TextSpan(text: ' '));
          }
        }
      }
      double baseline = -3;

      if (node.style.verticalAlign != null) {
        switch (node.style.verticalAlign!) {
          case VerticalAlign.top:
            baseline = 6;
            break;
          case VerticalAlign.bottom:
            baseline = -2;
            break;
          case VerticalAlign.baseline:
            baseline = 0;
            break;
          case VerticalAlign.middle:
            break;
        }
      }

      spans.add(pw.WidgetSpan(
        child: _buildCheckbox(node),
        baseline: baseline,
      ));
      return;
    }

    // If this is a text node, add its text with current style
    if (node.text != null && node.text!.isNotEmpty) {
      // Normalize whitespace like browsers do
      String text = node.text!;
      // Replace multiple whitespace with single space
      text = text.replaceAll(RegExp(r'\s+'), ' ');

      spans.add(pw.TextSpan(
        text: " $text",
        style: _mapTextStyle(node.style),
        annotation: node.tagName == 'a' && node.attributes.containsKey('href')
            ? pw.AnnotationUrl(node.attributes['href']!)
            : null,
      ));
      return;
    }

    // For non-text inline elements (span, b, i, a, etc.), add a space before
    // if there are already spans and the previous span doesn't end with space
    if (spans.isNotEmpty &&
        node.tagName != '#text' &&
        node.children.isNotEmpty) {
      final lastSpan = spans.last;
      if (lastSpan is pw.TextSpan) {
        final lastText = lastSpan.text ?? '';
        if (lastText.isNotEmpty && !lastText.endsWith(' ')) {
          // Add a space before this inline element
          spans.add(pw.TextSpan(text: ' ', style: _mapTextStyle(node.style)));
        }
      }
    }

    // For non-text inline elements, recurse into children
    // and apply this element's style to them
    for (var child in node.children) {
      if (child.text != null && child.text!.isNotEmpty) {
        // Text node with content - apply parent's style
        String text = child.text!;
        text = text.replaceAll(RegExp(r'\s+'), ' ');

        spans.add(pw.TextSpan(
          text: " $text",
          style: _mapTextStyle(node.style), // Use parent's computed style
          annotation: node.tagName == 'a' && node.attributes.containsKey('href')
              ? pw.AnnotationUrl(node.attributes['href']!)
              : null,
        ));
      } else {
        // Recurse for nested elements
        _collectInlineSpans(child, spans);
      }
    }
  }

  pw.BoxDecoration? _buildBoxDecoration(CSSStyle style) {
    if (style.backgroundColor == null && style.border == null) return null;

    return pw.BoxDecoration(
      color: style.backgroundColor,
      border: style.border,
    );
  }

  pw.TextStyle _mapTextStyle(CSSStyle style) {
    // If we have a fallback font, we can use it as the primary font if the style doesn't specify one.
    // This ensures we don't accidentally fallback to Helvetica (which lacks Unicode).
    // However, we must be careful not to override specific fonts.

    // Logic: If style has font, use it. Else if we have fallback, use first fallback.
    // Else null (default PDF font).

    // Note: The previous issue was forcing fallback.first ALWAYS.
    // Here we should only do it if we are relying on defaults?
    // Actually, PdfGoogleFonts usually provides the fallback list.
    // The safest way to avoid Helvetica is to set the default font in the Theme of the document,
    // NOT here. But we can hint it here.

    return pw.TextStyle(
      color: style.color,
      fontSize: style.fontSize,
      fontWeight: style.fontWeight,
      fontStyle: style.fontStyle,
      decoration: style.textDecoration,
      font: style.fontFamily != null ? null : null,
      fontFallback: fontFallback,
      lineSpacing:
          style.lineHeight, // Add line-height support if available in CSSStyle
    );
  }
}
