import 'package:pdf/widgets.dart' as pw;
import 'package:pdf/pdf.dart';

import 'css_style.dart';
import 'render_node.dart';
import 'image_builder_io.dart'
    if (dart.library.html) 'image_builder_web.dart' as image_builder;

/// [PdfBuilder] converts a tree of [RenderNode]s into a list of [pw.Widget]s.
///
/// It traverses the render tree and creates corresponding PDF widgets (e.g.,
/// [pw.Container], [pw.Text], [pw.RichText], [pw.Table]) based on the
/// node type and its computed [CSSStyle].
class PdfBuilder {
  /// The root node of the render tree.
  final RenderNode root;

  /// Creates an instance of [PdfBuilder].
  ///
  /// [root] is the root [RenderNode] generated by [HtmlParser].
  PdfBuilder({required this.root});

  /// Builds the PDF widgets from the render tree.
  Future<List<pw.Widget>> build() async {
    return await _buildBlock(root);
  }

  /// Builds widgets for a block-level node.
  ///
  /// This method handles:
  /// - Specific block tags (img, table, hr, blockquote, pre, etc.).
  /// - Block elements containing only inline content (rendered as [pw.RichText]).
  /// - Generic block elements with mixed content (recursively building children).
  Future<List<pw.Widget>> _buildBlock(RenderNode node) async {
    final widgets = <pw.Widget>[];
    
    if (node.display == Display.none) return widgets;

    // Handle specific tags that map to specific Widgets
    if (node.tagName == 'img') {
      return [await _buildImage(node)];
    } else if (node.tagName == 'table') {
      return [await _buildTable(node)];
    } else if (node.tagName == 'hr') {
      return [pw.Divider(color: node.style.border?.bottom?.color ?? PdfColors.grey400, thickness: node.style.border?.bottom?.width ?? 1.0)];
    } else if (node.tagName == 'input' && node.attributes['type'] == 'checkbox') {
      return [_buildCheckbox(node)];
    } else if (node.tagName == 'blockquote') {
      return [await _buildBlockquote(node)];
    } else if (node.tagName == 'pre') {
      return [_buildPreBlock(node)];
    } else if (node.tagName == 'br') {
      return [pw.SizedBox(height: 12)]; // Line break as vertical space
    }

    return await _buildBlockContent(node);
  }

  /// Builds the content of a block (children).
  Future<List<pw.Widget>> _buildBlockContent(RenderNode node) async {
    final widgets = <pw.Widget>[];

    // Check if this block contains only inline content (text, spans, b, i, etc.)
    // If so, render as RichText
    if (_hasOnlyInlineContent(node)) {
      final richText = _buildRichTextFromNode(node);
      if (richText != null) {
        return [richText];
      }
      return [];
    }

    // Generic block processing - mixed content
    List<RenderNode> inlineGroup = [];

    for (var child in node.children) {
      if (child.display == Display.none) continue;

      if (child.display == Display.inline || child.tagName == '#text') {
        // Handle br tags specially in inline context
        if (child.tagName == 'br') {
          if (inlineGroup.isNotEmpty) {
            widgets.add(_buildRichText(inlineGroup, node.style));
            inlineGroup = [];
          }
          widgets.add(pw.SizedBox(height: 12));
        } else {
          inlineGroup.add(child);
        }
      } else {
        if (inlineGroup.isNotEmpty) {
          widgets.add(_buildRichText(inlineGroup, node.style));
          inlineGroup = [];
        }
        
        // Check if child is a list item inside a list
        if (child.tagName == 'li' && (node.tagName == 'ul' || node.tagName == 'ol')) {
           widgets.add(await _buildListItem(child, node.tagName == 'ol', node.children.indexOf(child)));
        } else {
           widgets.addAll(await _buildBlockChild(child));
        }
      }
    }

    if (inlineGroup.isNotEmpty) {
      widgets.add(_buildRichText(inlineGroup, node.style));
    }

    return widgets;
  }

  /// Checks if a node contains only inline content (no nested block elements).
  bool _hasOnlyInlineContent(RenderNode node) {
    for (var child in node.children) {
      if (child.display == Display.block && child.tagName != '#text') {
        // Check if it's a known block element
        if (['div', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'li', 'table', 'blockquote', 'pre'].contains(child.tagName)) {
          return false;
        }
      }
    }
    return true;
  }

  /// Builds a [pw.RichText] widget from a node that contains only inline content.
  pw.Widget? _buildRichTextFromNode(RenderNode node) {
    final spans = <pw.InlineSpan>[];
    _collectInlineSpans(node, spans);
    
    if (spans.isEmpty) return null;
    
    return pw.Container(
      width: double.infinity,
      margin: node.style.margin,
      padding: node.style.padding,
      child: pw.RichText(
        text: pw.TextSpan(children: spans),
        textAlign: node.style.textAlign ?? pw.TextAlign.left,
      ),
    );
  }

  Future<pw.Widget> _buildImage(RenderNode node) async {
    return await image_builder.buildImage(node);
  }

  Future<pw.Widget> _buildTable(RenderNode node) async {
    // Simple table implementation mapping tr/td to pw.Table
    final rows = <pw.TableRow>[];
    for (var child in node.children) {
      if (child.tagName == 'tr' || child.tagName == 'tbody' || child.tagName == 'thead') {
         if (child.tagName == 'tr') {
            rows.add(await _buildTableRow(child));
         } else {
            // Handle thead/tbody children
            for (var grandChild in child.children) {
               if (grandChild.tagName == 'tr') {
                  rows.add(await _buildTableRow(grandChild));
               }
            }
         }
      }
    }
    
    return pw.Table(
      border: node.style.border != null 
          ? pw.TableBorder.all(color: node.style.border!.top.color, width: node.style.border!.top.width) 
          : pw.TableBorder.all(color: PdfColors.black, width: 1),
      defaultColumnWidth: const pw.FlexColumnWidth(),
      children: rows,
    );
  }

  Future<pw.TableRow> _buildTableRow(RenderNode node) async {
    final cells = <pw.Widget>[];
    for (var child in node.children) {
      if (child.tagName == 'td' || child.tagName == 'th') {
        final isHeader = child.tagName == 'th';
        final cellContent = _buildCellContent(child, isHeader);
        cells.add(pw.Container(
          padding: child.style.padding ?? const pw.EdgeInsets.all(4),
          color: child.style.backgroundColor,
          child: cellContent,
        ));
      }
    }
    return pw.TableRow(children: cells);
  }

  pw.Widget _buildCellContent(RenderNode node, bool isHeader) {
    // Collect inline content from cell
    final spans = <pw.InlineSpan>[];
    _collectInlineSpans(node, spans);
    
    if (spans.isEmpty) {
      return pw.Text('');
    }
    
    // Apply header styling
    if (isHeader) {
      return pw.RichText(
        text: pw.TextSpan(
          children: spans,
          style: pw.TextStyle(fontWeight: pw.FontWeight.bold),
        ),
        textAlign: pw.TextAlign.center,
      );
    }
    
    return pw.RichText(
      text: pw.TextSpan(children: spans),
    );
  }


  Future<pw.Widget> _buildListItem(RenderNode node, bool isOrdered, int index) async {
    // Collect inline content from list item
    final spans = <pw.InlineSpan>[];
    _collectInlineSpans(node, spans);
    
    pw.Widget bullet;
    if (isOrdered) {
      bullet = pw.Text('${index + 1}.');
    } else {
      // Draw a bullet circle
      bullet = pw.Container(
        width: 4,
        height: 4,
        decoration: const pw.BoxDecoration(
          color: PdfColors.black,
          shape: pw.BoxShape.circle,
        ),
      );
    }

    pw.Widget listContent;
    if (spans.isNotEmpty) {
      listContent = pw.RichText(
        text: pw.TextSpan(children: spans),
        textAlign: node.style.textAlign ?? pw.TextAlign.left,
      );
    } else {
      // Fallback to block child if no inline content
      final content = await _buildBlockChild(node);
      listContent = pw.Column(crossAxisAlignment: pw.CrossAxisAlignment.start, children: content);
    }

    return pw.Row(
      crossAxisAlignment: pw.CrossAxisAlignment.start,
      children: [
        pw.Container(
          width: 20,
          height: 16, // Fixed height for alignment
          alignment: pw.Alignment.center,
          child: bullet,
        ),
        pw.Expanded(child: listContent),
      ],
    );
  }

  pw.Widget _buildCheckbox(RenderNode node) {
    final bool checked = node.attributes.containsKey('checked');
    return pw.Container(
      width: 13,
      height: 13,
      margin: const pw.EdgeInsets.only(right: 4, bottom: 2),
      decoration: pw.BoxDecoration(
        border: pw.Border.all(color: PdfColors.black, width: 1),
        color: checked ? PdfColors.blue : PdfColors.white,
        borderRadius: const pw.BorderRadius.all(pw.Radius.circular(2)),
      ),
      child: checked
          ? pw.Center(
              child: pw.Text(
                'âœ“',
                style: const pw.TextStyle(
                  fontSize: 10,
                  color: PdfColors.white,
                ),
              ),
            )
          : null,
    );
  }

  Future<pw.Widget> _buildBlockquote(RenderNode node) async {
    final content = await _buildBlockContent(node);
    return pw.Container(
      margin: const pw.EdgeInsets.symmetric(vertical: 8, horizontal: 16),
      padding: const pw.EdgeInsets.only(left: 12),
      decoration: const pw.BoxDecoration(
        border: pw.Border(
          left: pw.BorderSide(color: PdfColors.grey400, width: 3),
        ),
      ),
      child: pw.Column(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: content,
      ),
    );
  }

  pw.Widget _buildPreBlock(RenderNode node) {
    // Collect all text from pre block
    String text = _collectText(node);
    
    return pw.Container(
      width: double.infinity,
      margin: const pw.EdgeInsets.symmetric(vertical: 8),
      padding: const pw.EdgeInsets.all(8),
      decoration: const pw.BoxDecoration(
        color: PdfColors.grey200,
      ),
      child: pw.Text(
        text,
        style: const pw.TextStyle(
          fontSize: 10,
          // Monospace font would be applied here if available
        ),
      ),
    );
  }

  String _collectText(RenderNode node) {
    final buffer = StringBuffer();
    if (node.text != null) {
      buffer.write(node.text);
    }
    for (var child in node.children) {
      buffer.write(_collectText(child));
    }
    return buffer.toString();
  }


  Future<List<pw.Widget>> _buildBlockChild(RenderNode node) async {
    // This node is a block element. 
    // We need to apply its styles (padding, margin, border, background)
    // and then process its children.
    
    // Recursive call to get children widgets
    final childrenWidgets = await _buildBlock(node);

    // If it's a list item, we might want to handle it specifically or just as a block
    // For simplicity, treating as block with container.
    
    // Apply styling. 
    // Note: pw.Container supports padding, margin, decoration (border, color).
    // However, pw.Container with non-null decoration might not span pages well if it's too large.
    // The prompt suggests "Virtual Fragmentation" and "Prefer using pw.Column".
    
    // If we have background or border, we must use Container/Decoration.
    // If the content is large, this might clip. 
    // For now, we follow standard mapping but keep the warning in mind.
    // To strictly follow "Virtual Fragmentation", we would need to split the container manually, 
    // which is very complex. 
    // A simpler approach for "Virtual Fragmentation" is to apply background color to the *children* 
    // if possible, or accept that small blocks work fine. 
    
    // Let's use a Container for the block properties.
    
    pw.Widget widget;
    if (childrenWidgets.length == 1) {
      widget = childrenWidgets.first;
    } else {
      widget = pw.Column(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: childrenWidgets,
      );
    }

    return [
      pw.Container(
        width: node.style.width,
        height: node.style.height,
        padding: node.style.padding,
        margin: node.style.margin,
        decoration: _buildBoxDecoration(node.style),
        child: widget,
      )
    ];
  }

  pw.Widget _buildRichText(List<RenderNode> nodes, CSSStyle parentStyle) {
    final spans = <pw.InlineSpan>[];

    for (var node in nodes) {
      _collectInlineSpans(node, spans);
    }

    // If parent has text-align, we should apply it. 
    // But RenderNode style doesn't have textAlign yet (we missed it in CSSStyle).
    // Let's assume left for now or add it to CSSStyle later.
    
    return pw.RichText(
      text: pw.TextSpan(children: spans),
      textAlign: parentStyle.textAlign ?? pw.TextAlign.left,
    );
  }

  void _collectInlineSpans(RenderNode node, List<pw.InlineSpan> spans) {
    if (node.display == Display.none) return;

    // If this is a text node, add its text with current style
    if (node.text != null && node.text!.isNotEmpty) {
      // Normalize whitespace like browsers do
      String text = node.text!;
      // Replace multiple whitespace with single space, but keep some spacing
      text = text.replaceAll(RegExp(r'\s+'), ' ');
      
      spans.add(pw.TextSpan(
        text: text,
        style: _mapTextStyle(node.style),
        annotation: node.tagName == 'a' && node.attributes.containsKey('href') 
            ? pw.AnnotationUrl(node.attributes['href']!) 
            : null,
      ));
      return;
    }

    // For non-text inline elements, recurse into children
    // and apply this element's style to them
    for (var child in node.children) {
      if (child.text != null && child.text!.isNotEmpty) {
        // Text node with content - apply parent's style
        String text = child.text!;
        text = text.replaceAll(RegExp(r'\s+'), ' ');
        
        spans.add(pw.TextSpan(
          text: text,
          style: _mapTextStyle(node.style), // Use parent's computed style
          annotation: node.tagName == 'a' && node.attributes.containsKey('href') 
              ? pw.AnnotationUrl(node.attributes['href']!) 
              : null,
        ));
      } else {
        // Recurse for nested elements
        _collectInlineSpans(child, spans);
      }
    }
  }

  pw.BoxDecoration? _buildBoxDecoration(CSSStyle style) {
    if (style.backgroundColor == null && style.border == null) return null;
    
    return pw.BoxDecoration(
      color: style.backgroundColor,
      border: style.border,
    );
  }

  pw.TextStyle _mapTextStyle(CSSStyle style) {
    return pw.TextStyle(
      color: style.color,
      fontSize: style.fontSize,
      fontWeight: style.fontWeight,
      fontStyle: style.fontStyle,
      decoration: style.textDecoration,
      font: null, // Use default font for now
    );
  }
}
